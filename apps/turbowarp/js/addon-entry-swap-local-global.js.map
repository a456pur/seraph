{"version":3,"file":"js/addon-entry-swap-local-global.js","sources":["webpack://GUI/./src/addons/addons/swap-local-global/style.css","webpack://GUI/./src/addons/addons/swap-local-global/_runtime_entry.js","webpack://GUI/./src/addons/addons/swap-local-global/userscript.js"],"sourcesContent":["exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".sa-swap-local-global-hint {\\n  padding-bottom: 1rem;\\n}\\n.sa-swap-local-global-stage {\\n  /* resolves scratch class style conflict */\\n  display: block;\\n}\\n\", \"\"]);\n\n// exports\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./style.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"style.css\": _css,\n};\n","export default async function ({ addon, msg, console }) {\n  const ScratchBlocks = await addon.tab.traps.getBlockly();\n  const vm = addon.tab.traps.vm;\n\n  const getTargetName = (target) => {\n    if (target.isStage) {\n      // Stage always has an internal name of \"Stage\", but we want a translatable name\n      return ScratchBlocks.ScratchMsgs.translate(\"SENSING_OF_STAGE\", \"Stage\");\n    }\n    return target.getName();\n  };\n\n  const getTargetsThatUseVariable = (id) =>\n    vm.runtime.targets\n      .filter((target) => target.isOriginal)\n      .filter((target) =>\n        Object.values(target.blocks._blocks).find(\n          (block) =>\n            (block.fields.LIST && block.fields.LIST.id === id) ||\n            (block.fields.VARIABLE && block.fields.VARIABLE.id === id)\n        )\n      );\n\n  // https://github.com/LLK/scratch-vm/blob/7c6f1e44fb0a9b0d0279225cd4c62fbe59b6af54/src/engine/blocks.js#L388-L394\n  const getTargetsWithLocalVariableNamed = (name, type) =>\n    vm.runtime.targets.filter((target) => target.isOriginal && target.lookupVariableByNameAndType(name, type, true));\n\n  const getVmVariable = (id) => vm.editingTarget.lookupVariableById(id);\n  const isStageSelected = () => vm.editingTarget.isStage;\n\n  const deleteVariableWithoutDeletingBlocks = (workspace, variable) => {\n    // variable can be an ID or an actual Blockly variable object\n    if (typeof variable === \"string\") {\n      variable = workspace.getVariableById(variable);\n    }\n    workspace.variableMap_.deleteVariable(variable);\n  };\n\n  const syncBlockVariableNameWithActualVariableName = (workspace, id) => {\n    const variable = workspace.getVariableById(id);\n    for (const block of workspace.getAllBlocks()) {\n      block.updateVarName(variable);\n    }\n  };\n\n  let _undoRedoPreserveStateCallback = null;\n  const finishUndoRedoState = () => {\n    if (_undoRedoPreserveStateCallback) {\n      _undoRedoPreserveStateCallback();\n      _undoRedoPreserveStateCallback = null;\n    }\n  };\n\n  // https://github.com/LLK/scratch-blocks/blob/0d6012df1e18e66d82c1247f1f6d772a719982a7/core/variable_events.js#L194\n  const customUndoVarDelete = function (forward) {\n    const workspace = this.getEventWorkspace_();\n    if (forward) {\n      _undoRedoPreserveStateCallback = beginPreservingState(workspace, this.varId);\n      deleteVariableWithoutDeletingBlocks(workspace, this.varId);\n    } else {\n      workspace.createVariable(this.varName, this.varType, this.varId, this.isLocal, this.isCloud);\n      finishUndoRedoState();\n    }\n  };\n\n  // https://github.com/LLK/scratch-blocks/blob/0d6012df1e18e66d82c1247f1f6d772a719982a7/core/variable_events.js#L131\n  const customUndoVarCreate = function (forward) {\n    const workspace = this.getEventWorkspace_();\n    if (forward) {\n      workspace.createVariable(this.varName, this.varType, this.varId, this.isLocal, this.isCloud);\n      finishUndoRedoState();\n    } else {\n      _undoRedoPreserveStateCallback = beginPreservingState(workspace, this.varId);\n      deleteVariableWithoutDeletingBlocks(workspace, this.varId);\n    }\n  };\n\n  const flushBlocklyEventQueue = () => ScratchBlocks.Events.fireNow_();\n\n  const beginPreservingState = (workspace, id) => {\n    // oldMonitorState is an instance of https://github.com/LLK/scratch-vm/blob/develop/src/engine/monitor-record.js or undefined\n    const oldMonitorState = vm.runtime._monitorState.get(id);\n    const oldVmVariable = getVmVariable(id);\n    return () => {\n      flushBlocklyEventQueue();\n\n      const newVmVariable = getVmVariable(id);\n      if (newVmVariable) {\n        newVmVariable.value = oldVmVariable.value;\n      }\n\n      // Update the variable monitor (state is maintained separately)\n      if (oldMonitorState) {\n        if (oldMonitorState.visible) {\n          vm.runtime.monitorBlocks.changeBlock({\n            id,\n            element: \"checkbox\",\n            value: true,\n          });\n        }\n        const isLocal = !vm.runtime.getTargetForStage().variables[id];\n        let newMonitorState = oldMonitorState;\n        if (isLocal) {\n          const target = vm.editingTarget;\n          newMonitorState = newMonitorState.set(\"targetId\", target.id);\n          newMonitorState = newMonitorState.set(\"spriteName\", target.getName());\n        } else {\n          newMonitorState = newMonitorState.set(\"targetId\", null);\n          newMonitorState = newMonitorState.set(\"spriteName\", null);\n        }\n        if (newVmVariable.name !== oldVmVariable.name) {\n          const monitorBlocks = vm.runtime.monitorBlocks;\n          const block = monitorBlocks.getBlock(id);\n          if (block) {\n            newMonitorState = newMonitorState.set(\"params\", monitorBlocks._getBlockParams(block));\n          }\n        }\n        vm.runtime.requestAddMonitor(newMonitorState);\n      }\n\n      if (newVmVariable.name !== oldVmVariable.name) {\n        syncBlockVariableNameWithActualVariableName(workspace, id);\n      }\n    };\n  };\n\n  const convertVariable = (oldBlocklyVariable, newLocal, newCloud) => {\n    const CLOUD_PREFIX = \"â˜ \";\n\n    const name = oldBlocklyVariable.name;\n    const id = oldBlocklyVariable.getId();\n    const type = oldBlocklyVariable.type;\n    const isLocal = oldBlocklyVariable.isLocal;\n    const isCloud = oldBlocklyVariable.isCloud;\n    if (isLocal === newLocal && isCloud === newCloud) {\n      return;\n    }\n\n    // Cloud variables must always be global\n    if (newCloud && newLocal) {\n      alert(msg(\"cant-convert-cloud\"));\n      return;\n    }\n\n    const editingTarget = vm.editingTarget;\n    if (isLocal !== newLocal) {\n      if (newLocal) {\n        // Stage cannot have local variables\n        if (isStageSelected()) {\n          alert(msg(\"cant-convert-stage\"));\n          return;\n        }\n        // Variables used by unfocused sprites cannot be made local\n        // That includes cases where the variable is used by multiple sprites and where it's only used by an unfocused sprite\n        const targets = getTargetsThatUseVariable(id);\n        if (!targets.every((i) => i === editingTarget)) {\n          if (targets.length > 1) {\n            alert(\n              msg(\"cant-convert-to-local\", {\n                sprites: targets.map(getTargetName).join(\", \"),\n              })\n            );\n          } else {\n            alert(\n              msg(\"cant-convert-used-elsewhere\", {\n                sprite: getTargetName(targets[0]),\n              })\n            );\n          }\n          return;\n        }\n      } else {\n        // Global variables must not conflict with any local variables\n        const targets = getTargetsWithLocalVariableNamed(name, type).filter((target) => target !== editingTarget);\n        if (targets.length > 0) {\n          alert(\n            msg(\"cant-convert-conflict\", {\n              sprites: targets.map(getTargetName).join(\", \"),\n            })\n          );\n          return;\n        }\n      }\n    }\n\n    let newName = name;\n    if (isCloud !== newCloud) {\n      if (newCloud) {\n        newName = CLOUD_PREFIX + name;\n      } else if (name.startsWith(CLOUD_PREFIX)) {\n        newName = name.replace(CLOUD_PREFIX, \"\");\n      }\n    }\n\n    const workspace = oldBlocklyVariable.workspace;\n    const finishPreservingState = beginPreservingState(workspace, id);\n\n    ScratchBlocks.Events.setGroup(true);\n    try {\n      deleteVariableWithoutDeletingBlocks(workspace, oldBlocklyVariable);\n      workspace.createVariable(newName, type, id, newLocal, newCloud);\n    } finally {\n      ScratchBlocks.Events.setGroup(false);\n    }\n\n    // 2 items will be added to the queue: a variable create and delete\n    // We override their undo handlers to make undo/redo work properly\n    flushBlocklyEventQueue();\n    const stack = workspace.undoStack_;\n    const createEvent = stack[stack.length - 1];\n    const deleteEvent = stack[stack.length - 2];\n    if (\n      createEvent instanceof ScratchBlocks.Events.VarCreate &&\n      deleteEvent instanceof ScratchBlocks.Events.VarDelete\n    ) {\n      createEvent.run = customUndoVarCreate;\n      deleteEvent.run = customUndoVarDelete;\n    }\n\n    finishPreservingState();\n  };\n\n  const canUserUseCloudVariables = () => {\n    const blocksWrapper = document.querySelector('[class^=\"gui_blocks-wrapper_\"]');\n    let internalNode = blocksWrapper[addon.tab.traps.getInternalKey(blocksWrapper)];\n    while (true) {\n      if (!internalNode) {\n        return false;\n      }\n      const canUseCloud = internalNode.stateNode?.props?.canUseCloud;\n      if (typeof canUseCloud === \"boolean\") {\n        return canUseCloud;\n      }\n      internalNode = internalNode.child;\n    }\n  };\n\n  const addMoreOptionsToPrompt = (variable) => {\n    if (addon.self.disabled) {\n      return;\n    }\n\n    const promptBody = document.querySelector('[class^=\"prompt_body_\"]');\n    if (!promptBody) {\n      return;\n    }\n\n    const headerTitle = promptBody.parentElement.querySelector('[class^=\"modal_header-item_\"]');\n    if (headerTitle) {\n      if (variable.type === \"\") {\n        headerTitle.textContent = msg(\"edit-variable-header\");\n      } else {\n        headerTitle.textContent = msg(\"edit-list-header\");\n      }\n    }\n\n    const root = document.createElement(\"div\");\n    addon.tab.displayNoneWhileDisabled(root);\n\n    const createLabeledInput = (text, value) => {\n      const outer = document.createElement(\"label\");\n      const input = document.createElement(\"input\");\n      if (value === \"checkbox\") {\n        input.type = \"checkbox\";\n      } else {\n        input.name = \"variableScopeOption\";\n        input.type = \"radio\";\n        input.value = value;\n      }\n      outer.appendChild(input);\n      const label = document.createElement(\"span\");\n      label.textContent = text;\n      outer.appendChild(label);\n      return {\n        outer,\n        label,\n        input,\n      };\n    };\n    const promptDisabledClass = addon.tab.scratchClass(\"prompt_disabled-label\");\n\n    const noLocalsInStageSection = document.createElement(\"div\");\n    noLocalsInStageSection.className = addon.tab.scratchClass(\"prompt_info-message\", \"prompt_cloud-option\", {\n      others: \"sa-swap-local-global-stage\",\n    });\n    noLocalsInStageSection.appendChild(\n      Object.assign(document.createElement(\"span\"), {\n        textContent: addon.tab.scratchMessage(\"gui.gui.variablePromptAllSpritesMessage\"),\n      })\n    );\n\n    const scopeSection = document.createElement(\"div\");\n    scopeSection.className = addon.tab.scratchClass(\"prompt_options-row\", \"prompt_cloud-option\");\n    const forAllSprites = createLabeledInput(\n      addon.tab.scratchMessage(\"gui.gui.variableScopeOptionAllSprites\"),\n      \"global\"\n    );\n    const forThisSpriteOnly = createLabeledInput(\n      addon.tab.scratchMessage(\"gui.gui.variableScopeOptionSpriteOnly\"),\n      \"local\"\n    );\n    forAllSprites.input.checked = !variable.isLocal;\n    forThisSpriteOnly.input.checked = variable.isLocal;\n    scopeSection.appendChild(forAllSprites.outer);\n    scopeSection.appendChild(forThisSpriteOnly.outer);\n\n    const cloudSection = document.createElement(\"div\");\n    cloudSection.className = addon.tab.scratchClass(\"prompt_cloud-option\");\n    const cloudCheckbox = createLabeledInput(addon.tab.scratchMessage(\"gui.gui.cloudVariableOption\"), \"checkbox\");\n    cloudCheckbox.input.checked = variable.isCloud;\n    if (!vm.runtime.canAddCloudVariable() && !variable.isCloud) {\n      cloudCheckbox.input.disabled = true;\n      cloudSection.classList.add(promptDisabledClass);\n    }\n    cloudSection.appendChild(cloudCheckbox.outer);\n    const updateDisabledInputs = () => {\n      const thisSpriteOnlyDisabled = cloudCheckbox.input.checked;\n      forThisSpriteOnly.input.disabled = thisSpriteOnlyDisabled;\n      forThisSpriteOnly.label.classList.toggle(promptDisabledClass, thisSpriteOnlyDisabled);\n      if (thisSpriteOnlyDisabled) {\n        forAllSprites.input.click();\n      }\n    };\n    cloudCheckbox.input.addEventListener(\"change\", updateDisabledInputs);\n    updateDisabledInputs();\n\n    let isAnythingConfigurable = false;\n    if (isStageSelected()) {\n      root.appendChild(noLocalsInStageSection);\n    } else {\n      isAnythingConfigurable = true;\n      root.appendChild(scopeSection);\n    }\n    if (variable.type === \"\" && canUserUseCloudVariables()) {\n      isAnythingConfigurable = true;\n      root.appendChild(cloudSection);\n    }\n    if (isAnythingConfigurable) {\n      root.prepend(\n        Object.assign(document.createElement(\"div\"), {\n          textContent: msg(\"edit\"),\n          className: \"sa-swap-local-global-hint\",\n        })\n      );\n    }\n    promptBody.insertBefore(root, promptBody.lastChild);\n\n    return {\n      isLocal: () => forThisSpriteOnly.input.checked,\n      isCloud: () => cloudCheckbox.input.checked,\n    };\n  };\n\n  // https://github.com/LLK/scratch-blocks/blob/c5014f61e2e538e99601a9e0cb39e339e44c3910/core/variables.js#L470\n  const originalRenameVariable = ScratchBlocks.Variables.renameVariable;\n  ScratchBlocks.Variables.renameVariable = function (workspace, variable, opt_callback) {\n    const ret = originalRenameVariable.call(this, workspace, variable, (...args) => {\n      if (opt_callback) {\n        opt_callback(...args);\n      }\n      if (!addon.self.disabled && prompt) {\n        convertVariable(variable, prompt.isLocal(), prompt.isCloud());\n      }\n    });\n    const prompt = addMoreOptionsToPrompt(variable);\n    return ret;\n  };\n\n  addon.tab.createBlockContextMenu(\n    (items, block) => {\n      if (!addon.self.disabled && (block.getCategory() === \"data\" || block.getCategory() === \"data-lists\")) {\n        const variable = block.workspace.getVariableById(block.getVars()[0]);\n        if (variable) {\n          if (items.length > 0) {\n            if (items[0].text === ScratchBlocks.ScratchMsgs.translate(\"RENAME_VARIABLE\")) {\n              items[0].text = msg(\"edit-variable-option\");\n            } else if (items[0].text === ScratchBlocks.ScratchMsgs.translate(\"RENAME_LIST\")) {\n              items[0].text = msg(\"edit-list-option\");\n            }\n          }\n          items.push({\n            enabled: true,\n            separator: true,\n            text: msg(`to-${variable.isLocal ? \"global\" : \"local\"}`),\n            callback: () => convertVariable(variable, !variable.isLocal, variable.isCloud),\n          });\n        }\n      }\n      return items;\n    },\n    {\n      flyout: true,\n      blocks: true,\n    }\n  );\n}\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AAEA;AADA;AAIA;AACA;AAEA;AADA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AAEA;AACA;AACA;AADA;AAGA;AAEA;AADA;AAKA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAAA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAFA;AAKA;;;;A","sourceRoot":""}