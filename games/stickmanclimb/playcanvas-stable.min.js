/*

 PlayCanvas Engine v1.37.0 revision ef8e593
 Copyright 2011-2020 PlayCanvas Ltd. All rights reserved.
*/
(function(m, $c) {
    "object" === typeof exports && "undefined" !== typeof module ? $c(exports) : "function" === typeof define && define.amd ? define(["exports"], $c) : (m = "undefined" !== typeof globalThis ? globalThis : m || self, $c(m.pc = {}))
})(this, function(m) {
    function $c(a) {
        if (null === a) return "null";
        var b = typeof a;
        return "undefined" === b || "number" === b || "string" === b || "boolean" === b ? b : yn[Object.prototype.toString.call(a)]
    }

    function Hc(a, b) {
        var c;
        for (c in b) {
            var d = b[c];
            "object" == $c(d) ? a[c] = Hc({}, d) : "array" == $c(d) ? a[c] = Hc([], d) : a[c] =
                d
        }
        return a
    }

    function bi(a) {
        return void 0 !== a
    }

    function M() {
        this._callbacks = {};
        this._callbackActive = {}
    }

    function ci(a, b) {
        var c = a.length;
        b = b || 0;
        if (0 > b || b >= c) return null;
        var d = a.charCodeAt(b);
        return 1 < c && 55296 <= d && 56319 >= d && (a = a.charCodeAt(b + 1), 56320 <= a && 57343 >= a) ? {
            code: 1024 * (d - 55296) + a - 56320 + 65536,
            long: !0
        } : {
            code: d,
            long: !1
        }
    }

    function ad(a, b, c) {
        return a ? (a = ci(a)) ? (a = a.code, a >= b && a <= c) : !1 : !1
    }

    function L(a, b, c, d) {
        var e = a && a.length;
        3 === e || 4 === e ? (this.r = a[0], this.g = a[1], this.b = a[2], this.a = void 0 !== a[3] ? a[3] : 1) :
            (this.r = a || 0, this.g = b || 0, this.b = c || 0, this.a = void 0 !== d ? d : 1)
    }

    function di() {
        this._list = [];
        this._index = {}
    }

    function Bk(a) {
        this._index = {};
        this._key = a || null
    }

    function bd(a) {
        M.call(this);
        this._index = {};
        this._list = [];
        this._parent = a
    }

    function ei() {
        this._isRunning = !1;
        this._b = this._a = 0
    }

    function tg(a) {
        a = a.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/);
        this.scheme = a[2];
        this.authority = a[4];
        this.path = a[5];
        this.query = a[7];
        this.fragment = a[9];
        this.toString = function() {
            var b = "";
            this.scheme && (b +=
                this.scheme + ":");
            this.authority && (b += "//" + this.authority);
            b += this.path;
            this.query && (b += "?" + this.query);
            this.fragment && (b += "#" + this.fragment);
            return b
        };
        this.getQuery = function() {
            var b, c = {};
            if (this.query) {
                var d = decodeURIComponent(this.query).split("&");
                d.forEach(function(e, f, g) {
                    b = e.split("=");
                    c[b[0]] = b[1]
                }, this)
            }
            return c
        };
        this.setQuery = function(b) {
            var c = "",
                d;
            for (d in b) b.hasOwnProperty(d) && ("" !== c && (c += "&"), c += encodeURIComponent(d) + "=" + encodeURIComponent(b[d]));
            this.query = c
        }
    }

    function da() {}

    function fi(a,
        b) {
        this._curve = a;
        this._left = -Infinity;
        this._right = Infinity;
        this._m1 = this._m0 = this._p1 = this._p0 = this._recip = 0;
        this._reset(b || 0)
    }

    function hb(a) {
        this.keys = [];
        this.type = 1;
        this.tension = .5;
        this._eval = new fi(this);
        if (a)
            for (var b = 0; b < a.length - 1; b += 2) this.keys.push([a[b], a[b + 1]]);
        this.sort()
    }

    function Cb() {
        var a;
        this.curves = [];
        this._type = 1;
        if (1 < arguments.length)
            for (a = 0; a < arguments.length; a++) this.curves.push(new hb(arguments[a]));
        else if (0 === arguments.length) this.curves.push(new hb);
        else {
            var b = arguments[0];
            if ("number" === typeof b)
                for (a = 0; a < b; a++) this.curves.push(new hb);
            else
                for (a = 0; a < b.length; a++) this.curves.push(new hb(b[a]))
        }
    }

    function rb() {
        var a = new Float32Array(9);
        a[0] = a[4] = a[8] = 1;
        this.data = a
    }

    function P(a, b) {
        a && 2 === a.length ? (this.x = a[0], this.y = a[1]) : (this.x = a || 0, this.y = b || 0)
    }

    function z(a, b, c) {
        a && 3 === a.length ? (this.x = a[0], this.y = a[1], this.z = a[2]) : (this.x = a || 0, this.y = b || 0, this.z = c || 0)
    }

    function X(a, b, c, d) {
        a && 4 === a.length ? (this.x = a[0], this.y = a[1], this.z = a[2], this.w = a[3]) : (this.x = a || 0, this.y = b || 0, this.z =
            c || 0, this.w = d || 0)
    }

    function J() {
        var a = new Float32Array(16);
        a[0] = a[5] = a[10] = a[15] = 1;
        this.data = a
    }

    function Y(a, b, c, d) {
        a && 4 === a.length ? (this.x = a[0], this.y = a[1], this.z = a[2], this.w = a[3]) : (this.x = void 0 === a ? 0 : a, this.y = void 0 === b ? 0 : b, this.z = void 0 === c ? 0 : c, this.w = void 0 === d ? 1 : d)
    }

    function oa(a, b) {
        this.center = a || new z(0, 0, 0);
        this.halfExtents = b || new z(.5, .5, .5);
        this._min = new z;
        this._max = new z
    }

    function Ed(a, b) {
        this.center = a || new z(0, 0, 0);
        this.radius = void 0 === b ? .5 : b
    }

    function ug() {
        this.planes = [];
        for (var a = 0; 6 > a; a++) this.planes[a] = []
    }

    function cd(a, b) {
        this.origin = a || new z(0, 0, 0);
        this.direction = b || new z(0, 0, -1)
    }

    function gi(a, b) {
        this.halfExtents = b || new z(.5, .5, .5);
        a = a || Ck.setIdentity();
        this._modelTransform = a.clone().invert();
        this._worldTransform = a.clone();
        this._aabb = new oa(new z, this.halfExtents)
    }

    function hi(a, b) {
        this.normal = b || new z(0, 0, 1);
        this.point = a || new z(0, 0, 0)
    }

    function ab(a, b, c, d, e) {
        this.usage = d || 0;
        this.format = b;
        this.numVertices = c;
        this.id = zn++;
        this.numBytes = b.verticesByteSize ? b.verticesByteSize : b.size * c;
        a._vram.vb += this.numBytes;
        this.device = a;
        e ? this.setData(e) : this.storage = new ArrayBuffer(this.numBytes);
        this.device.buffers.push(this)
    }

    function se(a) {
        for (var b = 0, c = 0, d = a.length; c < d; c++) b = (b << 5) - b + a.charCodeAt(c), b |= 0;
        return b
    }

    function Na(a, b, c) {
        var d;
        this.elements = [];
        this.hasTangents = this.hasColor = this.hasUv1 = this.hasUv0 = !1;
        this._defaultInstancingFormat = null;
        this.verticesByteSize = 0;
        this.vertexCount = c;
        this.interleaved = !c;
        this.size = b.reduce(function(h, l) {
            return h + 4 * Math.ceil(l.components * sf[l.type] / 4)
        }, 0);
        var e = 0;
        a = 0;
        for (d = b.length; a <
            d; a++) {
            var f = b[a];
            var g = f.components * sf[f.type];
            c && (e = N.roundUp(e, g));
            var k = {
                name: f.semantic,
                offset: c ? e : f.hasOwnProperty("offset") ? f.offset : e,
                stride: c ? g : f.hasOwnProperty("stride") ? f.stride : this.size,
                dataType: f.type,
                numComponents: f.components,
                normalize: void 0 === f.normalize ? !1 : f.normalize,
                size: g
            };
            this.elements.push(k);
            e = c ? e + g * c : e + 4 * Math.ceil(g / 4);
            "TEXCOORD0" === f.semantic ? this.hasUv0 = !0 : "TEXCOORD1" === f.semantic ? this.hasUv1 = !0 : "COLOR" === f.semantic ? this.hasColor = !0 : "TANGENT" === f.semantic && (this.hasTangents = !0)
        }
        c && (this.verticesByteSize = e);
        this.update()
    }

    function tf(a, b, c) {
        this.index = 0;
        this.numComponents = b.numComponents;
        this.array = c.interleaved ? new Fd[b.dataType](a, b.offset) : new Fd[b.dataType](a, b.offset, c.vertexCount * b.numComponents);
        this.stride = b.stride / this.array.constructor.BYTES_PER_ELEMENT;
        switch (b.numComponents) {
            case 1:
                this.set = An;
                this.getToArray = Bn;
                this.setFromArray = Cn;
                break;
            case 2:
                this.set = Dn;
                this.getToArray = En;
                this.setFromArray = Fn;
                break;
            case 3:
                this.set = Gn;
                this.getToArray = Hn;
                this.setFromArray =
                    In;
                break;
            case 4:
                this.set = Jn, this.getToArray = Kn, this.setFromArray = Ln
        }
    }

    function An(a) {
        this.array[this.index] = a
    }

    function Dn(a, b) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b
    }

    function Gn(a, b, c) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b;
        this.array[this.index + 2] = c
    }

    function Jn(a, b, c, d) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b;
        this.array[this.index + 2] = c;
        this.array[this.index + 3] = d
    }

    function Cn(a, b, c) {
        this.array[a] = b[c]
    }

    function Fn(a, b, c) {
        this.array[a] = b[c];
        this.array[a + 1] = b[c + 1]
    }

    function In(a, b, c) {
        this.array[a] = b[c];
        this.array[a + 1] = b[c + 1];
        this.array[a + 2] = b[c + 2]
    }

    function Ln(a, b, c) {
        this.array[a] = b[c];
        this.array[a + 1] = b[c + 1];
        this.array[a + 2] = b[c + 2];
        this.array[a + 3] = b[c + 3]
    }

    function Bn(a, b, c) {
        b[c] = this.array[a]
    }

    function En(a, b, c) {
        b[c] = this.array[a];
        b[c + 1] = this.array[a + 1]
    }

    function Hn(a, b, c) {
        b[c] = this.array[a];
        b[c + 1] = this.array[a + 1];
        b[c + 2] = this.array[a + 2]
    }

    function Kn(a, b, c) {
        b[c] = this.array[a];
        b[c + 1] = this.array[a + 1];
        b[c + 2] = this.array[a + 2];
        b[c + 3] = this.array[a + 3]
    }

    function Pb(a) {
        this.vertexBuffer =
            a;
        this.vertexFormatSize = a.getFormat().size;
        this.buffer = this.vertexBuffer.lock();
        this.accessors = [];
        this.element = {};
        a = this.vertexBuffer.getFormat();
        for (var b = 0; b < a.elements.length; b++) {
            var c = a.elements[b];
            this.accessors[b] = new tf(this.buffer, c, a);
            this.element[c.name] = this.accessors[b]
        }
    }

    function La(a, b, c, d, e, f) {
        if (null === Gd) {
            var g = new Na(a, [{
                semantic: "POSITION",
                components: 2,
                type: 6
            }]);
            Gd = new ab(a, g, 4);
            g = new Pb(Gd);
            g.element.POSITION.set(-1, -1);
            g.next();
            g.element.POSITION.set(1, -1);
            g.next();
            g.element.POSITION.set(-1,
                1);
            g.next();
            g.element.POSITION.set(1, 1);
            g.end()
        }
        g = a.renderTarget;
        a.setRenderTarget(b);
        a.updateBegin();
        if (d) {
            var k = d.x;
            var h = d.y;
            var l = d.z;
            var n = d.w
        } else l = b ? b.width : a.width, n = b ? b.height : a.height, h = k = 0;
        if (e) {
            var p = e.x;
            var q = e.y;
            var r = e.z;
            var t = e.w
        } else p = k, q = h, r = l, t = n;
        e = a.vx;
        d = a.vy;
        b = a.vw;
        var u = a.vh;
        a.setViewport(k, h, l, n);
        l = a.sx;
        k = a.sy;
        h = a.sw;
        n = a.sh;
        a.setScissor(p, q, r, t);
        p = a.getDepthTest();
        q = a.getDepthWrite();
        r = a.getCullMode();
        t = a.writeRed;
        var x = a.writeGreen,
            v = a.writeBlue,
            w = a.writeAlpha;
        a.setDepthTest(!1);
        a.setDepthWrite(!1);
        a.setCullMode(0);
        a.setColorWrite(!0, !0, !0, !0);
        f || a.setBlending(!1);
        a.setVertexBuffer(Gd, 0);
        a.setShader(c);
        a.draw(Mn);
        a.setDepthTest(p);
        a.setDepthWrite(q);
        a.setCullMode(r);
        a.setColorWrite(t, x, v, w);
        a.updateEnd();
        a.setRenderTarget(g);
        a.updateBegin();
        a.setViewport(e, d, b, u);
        a.setScissor(l, k, h, n)
    }

    function te(a, b) {
        this.device = a;
        this.definition = b;
        this.attributes = [];
        this.uniforms = [];
        this.samplers = [];
        this.failed = this.ready = !1;
        this.device.createShader(this)
    }

    function vg(a, b) {
        b || (b = F);
        return 1 ===
            a || 2 === a ? b.gamma2_2PS ? b.gamma2_2PS : F.gamma2_2PS : 3 === a ? "#define HDR\n" + (b.gamma2_2PS ? b.gamma2_2PS : F.gamma2_2PS) : b.gamma1_0PS ? b.gamma1_0PS : F.gamma1_0PS
    }

    function wg(a, b) {
        b || (b = F);
        return 1 === a ? b.tonemappingFilmicPS ? b.tonemappingFilmicPS : F.tonemappingFilmicPS : 0 === a ? b.tonemappingLinearPS ? b.tonemappingLinearPS : F.tonemappingLinearPS : 2 === a ? b.tonemappingHejlPS ? b.tonemappingHejlPS : F.tonemappingHejlPS : 3 === a ? b.tonemappingAcesPS ? b.tonemappingAcesPS : F.tonemappingAcesPS : 4 === a ? b.tonemappingAces2PS ? b.tonemappingAces2PS :
            F.tonemappingAces2PS : b.tonemapingNonePS ? b.tonemapingNonePS : F.tonemappingNonePS
    }

    function ii(a, b) {
        b || (b = F);
        return "linear" === a ? b.fogLinearPS ? b.fogLinearPS : F.fogLinearPS : "exp" === a ? b.fogExpPS ? b.fogExpPS : F.fogExpPS : "exp2" === a ? b.fogExp2PS ? b.fogExp2PS : F.fogExp2PS : b.fogNonePS ? b.fogNonePS : F.fogNonePS
    }

    function ji(a, b) {
        b || (b = F);
        return a.supportsBoneTextures ? b.skinTexVS : "#define BONE_LIMIT " + a.getBoneLimit() + "\n" + b.skinConstVS
    }

    function Hd(a) {
        var b = "precision " + a.precision + " float;\n";
        a.webgl2 && (b += "#ifdef GL2\nprecision " +
            a.precision + " sampler2DShadow;\n#endif\n");
        return b
    }

    function Id(a) {
        return a.webgl2 ? "#version 300 es\n" : ""
    }

    function Dk() {
        return "void main(void) {gl_FragColor = vec4(0.0);}"
    }

    function ue() {
        return "void main(void)\n{\n"
    }

    function xg(a) {
        for (var b = {}, c = 0, d = a.indexOf("attribute"); 0 <= d && !(0 < d && "/" === a[d - 1]);) {
            var e = a.indexOf(";", d),
                f = a.lastIndexOf(" ", e);
            e = a.substr(f + 1, e - (f + 1));
            f = Nn[e];
            void 0 !== f ? b[e] = f : (b[e] = "ATTR" + c, c++);
            d = a.indexOf("attribute", d + 1)
        }
        return b
    }

    function Wa(a, b, c, d, e, f) {
        var g = a.programLib._cache,
            k = g[d];
        if (void 0 !== k) return k;
        c = Hd(a) + "\n" + (c || Dk());
        k = xg(b);
        a.webgl2 && (b = Id(a) + F.gles3VS + b, c = Id(a) + F.gles3PS + c);
        g[d] = new te(a, {
            attributes: k,
            vshader: b,
            fshader: (f ? f : "") + c,
            useTransformFeedback: e
        });
        return g[d]
    }

    function V(a, b) {
        this.device = a;
        this.name = null;
        this._height = this._width = 4;
        this._depth = 1;
        this._format = 7;
        this.type = "default";
        this.fixCubemapSeams = this._volume = this._cubemap = !1;
        this._flipY = !0;
        this._isRenderTarget = this._premultiplyAlpha = !1;
        this._mipmaps = !0;
        this._minFilter = 5;
        this._anisotropy = this._magFilter =
            1;
        this._addressW = this._addressV = this._addressU = 0;
        this._compareOnRead = !1;
        this._compareFunc = 1;
        void 0 !== b && (void 0 !== b.name && (this.name = b.name), this._width = void 0 !== b.width ? b.width : this._width, this._height = void 0 !== b.height ? b.height : this._height, this._format = void 0 !== b.format ? b.format : this._format, b.hasOwnProperty("type") ? this.type = b.type : b.hasOwnProperty("rgbm") ? this.type = b.rgbm ? "rgbm" : "default" : b.hasOwnProperty("swizzleGGGR") && (this.type = b.swizzleGGGR ? "swizzleGGGR" : "default"), this._mipmaps = void 0 !==
            b.mipmaps ? b.mipmaps : void 0 !== b.autoMipmap ? b.autoMipmap : this._mipmaps, this._levels = b.levels, this._cubemap = void 0 !== b.cubemap ? b.cubemap : this._cubemap, this.fixCubemapSeams = void 0 !== b.fixCubemapSeams ? b.fixCubemapSeams : this.fixCubemapSeams, this._minFilter = void 0 !== b.minFilter ? b.minFilter : this._minFilter, this._magFilter = void 0 !== b.magFilter ? b.magFilter : this._magFilter, this._anisotropy = void 0 !== b.anisotropy ? b.anisotropy : this._anisotropy, this._addressU = void 0 !== b.addressU ? b.addressU : this._addressU, this._addressV =
            void 0 !== b.addressV ? b.addressV : this._addressV, this._compareOnRead = void 0 !== b.compareOnRead ? b.compareOnRead : this._compareOnRead, this._compareFunc = void 0 !== b._compareFunc ? b._compareFunc : this._compareFunc, this._flipY = void 0 !== b.flipY ? b.flipY : this._flipY, this._premultiplyAlpha = void 0 !== b.premultiplyAlpha ? b.premultiplyAlpha : this._premultiplyAlpha, a.webgl2 && (this._depth = void 0 !== b.depth ? b.depth : this._depth, this._volume = void 0 !== b.volume ? b.volume : this._volume, this._addressW = void 0 !== b.addressW ? b.addressW :
                this._addressW));
        this._compressed = 8 === this._format || 9 === this._format || 10 === this._format || 21 <= this._format;
        this._invalid = !1;
        this._lockedLevel = -1;
        this._levels || (this._levels = this._cubemap ? [
            [null, null, null, null, null, null]
        ] : [null]);
        this.dirtyAll();
        this._gpuSize = 0
    }

    function dc(a, b, c, d, e) {
        this.usage = d || 0;
        this.format = b;
        this.numIndices = c;
        this.device = a;
        c = this.device.gl;
        if (0 === b) {
            var f = 1;
            this.glFormat = c.UNSIGNED_BYTE
        } else 1 === b ? (f = 2, this.glFormat = c.UNSIGNED_SHORT) : 2 === b && (f = 4, this.glFormat = c.UNSIGNED_INT);
        this.bytesPerIndex =
            f;
        this.numBytes = this.numIndices * f;
        e ? this.setData(e) : this.storage = new ArrayBuffer(this.numBytes);
        a._vram.ib += this.numBytes;
        this.device.buffers.push(this)
    }

    function dd() {
        this.initDefaults()
    }

    function On(a, b, c, d) {
        this.data = a;
        this.componentCount = b;
        this.dataType = c;
        this.dataTypeNormalize = d
    }

    function sb(a) {
        this._refCount = 0;
        this.id = Pn++;
        this.device = a || ea.getApplication().graphicsDevice;
        this.vertexBuffer = null;
        this.indexBuffer = [null];
        this.primitive = [{
            type: 0,
            base: 0,
            count: 0
        }];
        this._geometryData = this.morph = this.skin =
            null;
        this._aabb = new oa;
        this.boneAabb = null
    }

    function va(a, b, c) {
        this._key = [0, 0];
        this._shader = [null, null, null];
        this.isStatic = !1;
        this._staticSource = this._staticLightList = null;
        this.node = a;
        this._mesh = b;
        b.incReference();
        this.material = c;
        this._shaderDefs = 65536;
        this._shaderDefs |= b.vertexBuffer.format.hasUv0 ? 4 : 0;
        this._shaderDefs |= b.vertexBuffer.format.hasUv1 ? 8 : 0;
        this._shaderDefs |= b.vertexBuffer.format.hasColor ? 16 : 0;
        this._shaderDefs |= b.vertexBuffer.format.hasTangents ? 512 : 0;
        this._lightHash = 0;
        this.visible = !0;
        this.layer =
            15;
        this.renderStyle = 0;
        this.castShadow = !1;
        this._receiveShadow = !0;
        this._noDepthDrawGl1 = this._screenSpace = !1;
        this._updateAabb = this.pick = this.cull = !0;
        this._calculateSortDistance = this._updateAabbFunc = null;
        this.updateKey();
        this.instancingData = this._morphInstance = this._skinInstance = null;
        this.aabb = new oa;
        this._aabbVer = -1;
        this.visibleThisFrame = this.drawOrder = 0;
        this.isVisibleFunc = null;
        this.parameters = {};
        this.stencilBack = this.stencilFront = null;
        this.flipFaces = !1
    }

    function yg(a, b, c) {
        this._key = [];
        this._key[0] = (a &
            15) << 27 | (3 === b ? 1 : 0) << 26 | 33554432;
        this.command = c
    }

    function Qn(a) {
        this.count = a;
        this.vertexBuffer = null
    }

    function Db(a, b) {
        this.device = b || ea.getApplication().graphicsDevice;
        this._targets = a;
        this.device.supportsMorphTargetTexturesCore && (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable ? this._renderTextureFormat = Db.FORMAT_HALF_FLOAT : this.device.extTextureFloat && this.device.textureFloatRenderable && (this._renderTextureFormat = Db.FORMAT_FLOAT), this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable ?
            this._textureFormat = Db.FORMAT_HALF_FLOAT : this.device.extTextureFloat && (this._textureFormat = Db.FORMAT_FLOAT), void 0 !== this._renderTextureFormat && void 0 !== this._textureFormat && (this._useTextureMorph = !0));
        this._init();
        this._updateMorphFlags();
        this._calculateAabb()
    }

    function uf(a) {
        this.morph = a;
        this.device = a.device;
        this.meshInstance = null;
        this._weights = [];
        for (var b = 0; b < a._targets.length; b++) this.setWeight(b, a._targets[b].defaultWeight);
        this._activeTargets = [];
        if (a.useTextureMorph) {
            this.shaderCache = {};
            this.maxSubmitCount =
                this.device.maxTextures;
            this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
            b = function(c, d) {
                this[d] = a._createTexture(c, a._renderTextureFormat === Db.FORMAT_FLOAT ? 14 : 12);
                return new sa({
                    colorBuffer: this[d],
                    depth: !1
                })
            }.bind(this);
            a.morphPositions && (this.rtPositions = b("MorphRTPos", "texturePositions"));
            a.morphNormals && (this.rtNormals = b("MorphRTNrm", "textureNormals"));
            this._textureParams = new Float32Array([a.morphTextureWidth, a.morphTextureHeight, 1 / a.morphTextureWidth, 1 / a.morphTextureHeight]);
            for (b =
                0; b < this.maxSubmitCount; b++) this["morphBlendTex" + b] = this.device.scope.resolve("morphBlendTex" + b);
            this.morphFactor = this.device.scope.resolve("morphFactor[0]");
            this.zeroTextures = !1
        } else this.maxSubmitCount = 8, this._shaderMorphWeights = new Float32Array(this.maxSubmitCount), this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4), this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 16, 4), this._activeVertexBuffers = Array(this.maxSubmitCount)
    }

    function Ic(a) {
        this._dirty = !0;
        this._skinUpdateIndex = -1;
        this._updateBeforeCull = !0;
        a && this.initSkin(a)
    }

    function tb() {
        this.graph = null;
        this.meshInstances = [];
        this.skinInstances = [];
        this.morphInstances = [];
        this.cameras = [];
        this.lights = [];
        this._shadersVersion = 0;
        this._immutable = !1
    }

    function ki(a, b, c) {
        this.origMeshInstances = a;
        this._aabb = new oa;
        this.model = this.meshInstance = null;
        this.dynamic = b;
        this.batchGroupId = c;
        this.refCounter = 0
    }

    function bb(a, b, c, d, e) {
        this.dynamic = c;
        this.maxAabbSize = d;
        this.id = a;
        this.name = b;
        this.layers = void 0 === e ? [0] : e;
        this._sprite = this._ui = !1;
        this._obj = {
            model: [],
            element: [],
            sprite: []
        }
    }

    function Jd(a, b, c) {
        Ic.call(this);
        Ic.prototype.init.call(this, a, b.length);
        this.device = a;
        this.rootNode = c;
        this.bones = b
    }

    function Ia(a, b, c) {
        this.device = a;
        this.rootNode = b;
        this.scene = c;
        this._init = !1;
        this._batchGroups = {};
        this._batchGroupCounter = 0;
        this._batchList = [];
        this._dirtyGroups = []
    }

    function Ek(a, b) {
        if (a && !b || !a && b) return !1;
        a = a.data;
        b = b.data;
        if (a === b) return !0;
        if (a instanceof Float32Array && b instanceof Float32Array) {
            if (a.length !== b.length) return !1;
            for (var c = 0; c < a.length; c++)
                if (a[c] !== b[c]) return !1;
            return !0
        }
        return !1
    }

    function Rn(a, b) {
        for (var c in a)
            if (a.hasOwnProperty(c) && !Ek(a[c], b[c])) return !1;
        for (c in b)
            if (b.hasOwnProperty(c) && !Ek(b[c], a[c])) return !1;
        return !0
    }

    function Sn(a, b) {
        var c;
        for (c = 0; c < a.length; c++)
            if (0 > b.indexOf(a[c])) return !1;
        for (c = 0; c < b.length; c++)
            if (0 > a.indexOf(b[c])) return !1;
        return !0
    }

    function li(a) {
        a = a.node.worldTransform;
        a.getX(zg);
        a.getY(Fk);
        a.getZ(Gk);
        zg.cross(zg, Fk);
        return 0 <= zg.dot(Gk) ? 1 : -1
    }

    function pa() {
        this._aspectRatio =
            16 / 9;
        this._aspectRatioMode = 0;
        this._calculateTransform = this._calculateProjection = null;
        this._clearColor = new L(.75, .75, .75, 1);
        this._clearColorBuffer = !0;
        this._clearDepth = 1;
        this._clearDepthBuffer = !0;
        this._clearStencil = 0;
        this._clearStencilBuffer = !0;
        this._cullingMask = 4294967295;
        this._cullFaces = !0;
        this._farClip = 1E3;
        this._flipFaces = !1;
        this._fov = 45;
        this._frustumCulling = !0;
        this._horizontalFov = !1;
        this._layers = [0, 1, 2, 4, 3];
        this._nearClip = .1;
        this._node = null;
        this._orthoHeight = 10;
        this._projection = 0;
        this._rect = new X(0,
            0, 1, 1);
        this._renderTarget = null;
        this._scissorRect = new X(0, 0, 1, 1);
        this._vrDisplay = null;
        this._projMat = new J;
        this._projMatDirty = !0;
        this._projMatSkybox = new J;
        this._viewMat = new J;
        this._viewMatDirty = !0;
        this._viewProjMat = new J;
        this._viewProjMatDirty = !0;
        this.frustum = new ug
    }

    function Z(a) {
        M.call(this);
        this.name = "string" === typeof a ? a : "Untitled";
        this.tags = new bd(this);
        this._labels = {};
        this.localPosition = new z(0, 0, 0);
        this.localRotation = new Y(0, 0, 0, 1);
        this.localScale = new z(1, 1, 1);
        this.localEulerAngles = new z(0, 0,
            0);
        this.position = new z(0, 0, 0);
        this.rotation = new Y(0, 0, 0, 1);
        this.eulerAngles = new z(0, 0, 0);
        this._scale = null;
        this.localTransform = new J;
        this._dirtyLocal = !1;
        this._aabbVer = 0;
        this._frozen = !1;
        this.worldTransform = new J;
        this._dirtyWorld = !1;
        this.normalMatrix = new rb;
        this._dirtyNormal = !0;
        this._parent = this._forward = this._up = this._right = null;
        this._children = [];
        this._graphDepth = 0;
        this._enabled = !0;
        this.scaleCompensation = this._enabledInHierarchy = !1
    }

    function Tn(a, b) {
        return a.priority - b.priority
    }

    function Un(a, b) {
        return b.key -
            a.key
    }

    function Hk() {
        this.list = [];
        this.length = 0;
        this.done = !1
    }

    function Ik() {
        this.opaqueMeshInstances = [];
        this.transparentMeshInstances = [];
        this.shadowCasters = [];
        this.visibleOpaque = [];
        this.visibleTransparent = []
    }

    function ka(a) {
        a = a || {};
        void 0 !== a.id ? (this.id = a.id, mi = Math.max(this.id + 1, mi)) : this.id = mi++;
        this.name = a.name;
        this._refCounter = (this._enabled = void 0 === a.enabled ? !0 : a.enabled) ? 1 : 0;
        this.opaqueSortMode = void 0 === a.opaqueSortMode ? 2 : a.opaqueSortMode;
        this.transparentSortMode = void 0 === a.transparentSortMode ?
            3 : a.transparentSortMode;
        this.renderTarget = a.renderTarget;
        this.shaderPass = void 0 === a.shaderPass ? 0 : a.shaderPass;
        this.passThrough = void 0 === a.passThrough ? !1 : a.passThrough;
        this.overrideClear = void 0 === a.overrideClear ? !1 : a.overrideClear;
        this._clearColor = new L(0, 0, 0, 1);
        a.clearColor && this._clearColor.copy(a.clearColor);
        this._clearColorBuffer = void 0 === a.clearColorBuffer ? !1 : a.clearColorBuffer;
        this._clearDepthBuffer = void 0 === a.clearDepthBuffer ? !1 : a.clearDepthBuffer;
        this._clearStencilBuffer = void 0 === a.clearStencilBuffer ?
            !1 : a.clearStencilBuffer;
        this._clearOptions = {
            color: [this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a],
            depth: 1,
            stencil: 0,
            flags: (this._clearColorBuffer ? 1 : 0) | (this._clearDepthBuffer ? 2 : 0) | (this._clearStencilBuffer ? 4 : 0)
        };
        this.onPreCull = a.onPreCull;
        this.onPreRender = a.onPreRender;
        this.onPreRenderOpaque = a.onPreRenderOpaque;
        this.onPreRenderTransparent = a.onPreRenderTransparent;
        this.onPostCull = a.onPostCull;
        this.onPostRender = a.onPostRender;
        this.onPostRenderOpaque = a.onPostRenderOpaque;
        this.onPostRenderTransparent = a.onPostRenderTransparent;
        this.onDrawCall = a.onDrawCall;
        this.onEnable = a.onEnable;
        this.onDisable = a.onDisable;
        if (this._enabled && this.onEnable) this.onEnable();
        this.instances = (this.layerReference = a.layerReference) ? a.layerReference.instances : new Ik;
        this.cullingMask = a.cullingMask ? a.cullingMask : 4294967295;
        this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
        this.transparentMeshInstances = this.instances.transparentMeshInstances;
        this.shadowCasters = this.instances.shadowCasters;
        this.customCalculateSortValues = this.customSortCallback = null;
        this._lightComponents = [];
        this._lights = [];
        this._splitLights = [
            [],
            [],
            []
        ];
        this.cameras = [];
        this._dirtyCameras = this._dirtyLights = this._dirty = !1;
        this._staticLightHash = this._lightHash = this._cameraHash = 0;
        this._needsStaticPrepare = !0;
        this._staticPrepareDone = !1;
        this._shaderVersion = -1;
        this._version = 0;
        this._lightCube = null
    }

    function Vn(a, b) {
        if (0 !== b || a.webgl2) {
            if (3 === b) return a.extTextureFloatLinear ? 1 : 0;
            if (2 === b) return a.extTextureHalfFloatLinear ? 1 : 0
        } else return 0;
        return 1
    }

    function Jk(a, b, c, d) {
        var e = 3 === d ? 14 : 2 === d ? 12 : 4 === d || 0 === d && a.webgl2 ? 16 : 7,
            f = Vn(a, d);
        b = new V(a, {
            format: e,
            width: b,
            height: c,
            mipmaps: !1,
            minFilter: f,
            magFilter: f,
            addressU: 1,
            addressV: 1
        });
        b.name = "shadowmap";
        return 4 === d || 0 === d && a.webgl2 ? (b.compareOnRead = !0, b.compareFunc = 1, new sa({
            depthBuffer: b
        })) : new sa({
            colorBuffer: b,
            depth: !0
        })
    }

    function Kk(a, b) {
        a = new V(a, {
            format: 7,
            width: b,
            height: b,
            cubemap: !0,
            mipmaps: !1,
            minFilter: 0,
            magFilter: 0,
            addressU: 1,
            addressV: 1
        });
        a.name = "shadowcube";
        b = [];
        for (var c, d = 0; 6 > d; d++) c =
            new sa({
                colorBuffer: a,
                face: d,
                depth: !0
            }), b.push(c);
        return b
    }

    function Lk(a, b, c, d) {
        d || (d = 0);
        d = 1E4 * d + b;
        var e = Mk[c][d];
        e || (e = Jk(a, b, b, c ? c : 0), Mk[c][d] = e);
        return e
    }

    function Nk(a, b) {
        if (1 === b._type) {
            0 < b._shadowType && (b._shadowType = 0);
            if (b._cacheShadowMap) {
                var c = Ok[b._shadowResolution];
                c || (c = Kk(a, b._shadowResolution), Ok[b._shadowResolution] = c)
            } else c = Kk(a, b._shadowResolution);
            b._shadowCamera.renderTarget = c[0];
            b._shadowCubeMap = c
        } else c = b._cacheShadowMap ? Lk(a, b._shadowResolution, b._shadowType) : Jk(a, b._shadowResolution,
            b._shadowResolution, b._shadowType), b._shadowCamera.renderTarget = c;
        b._isCachedShadowMap = b._cacheShadowMap
    }

    function Ag(a) {
        a = this.device = a;
        this._layerCompositionUpdateTime = this._instancingTime = this._morphTime = this._skinTime = this._sortTime = this._cullTime = this._forwardTime = this._depthMapTime = this._shadowMapTime = this._shadowMapUpdates = this._materialSwitches = this._camerasRendered = this._skinDrawCalls = this._forwardDrawCalls = this._shadowDrawCalls = 0;
        this.library = a.getProgramLibrary();
        a = a.scope;
        this.projId = a.resolve("matrix_projection");
        this.projSkyboxId = a.resolve("matrix_projectionSkybox");
        this.viewId = a.resolve("matrix_view");
        this.viewId3 = a.resolve("matrix_view3");
        this.viewInvId = a.resolve("matrix_viewInverse");
        this.viewProjId = a.resolve("matrix_viewProjection");
        this.viewPos = new Float32Array(3);
        this.viewPosId = a.resolve("view_position");
        this.nearClipId = a.resolve("camera_near");
        this.farClipId = a.resolve("camera_far");
        this.cameraParamsId = a.resolve("camera_params");
        this.shadowMapLightRadiusId = a.resolve("light_radius");
        this.fogColorId =
            a.resolve("fog_color");
        this.fogStartId = a.resolve("fog_start");
        this.fogEndId = a.resolve("fog_end");
        this.fogDensityId = a.resolve("fog_density");
        this.modelMatrixId = a.resolve("matrix_model");
        this.normalMatrixId = a.resolve("matrix_normal");
        this.poseMatrixId = a.resolve("matrix_pose[0]");
        this.boneTextureId = a.resolve("texture_poseMap");
        this.boneTextureSizeId = a.resolve("texture_poseMapSize");
        this.morphWeightsA = a.resolve("morph_weights_a");
        this.morphWeightsB = a.resolve("morph_weights_b");
        this.morphPositionTex = a.resolve("morphPositionTex");
        this.morphNormalTex = a.resolve("morphNormalTex");
        this.morphTexParams = a.resolve("morph_tex_params");
        this.alphaTestId = a.resolve("alpha_ref");
        this.opacityMapId = a.resolve("texture_opacityMap");
        this.ambientId = a.resolve("light_globalAmbient");
        this.exposureId = a.resolve("exposure");
        this.skyboxIntensityId = a.resolve("skyboxIntensity");
        this.lightColorId = [];
        this.lightDir = [];
        this.lightDirId = [];
        this.lightShadowMapId = [];
        this.lightShadowMatrixId = [];
        this.lightShadowParamsId = [];
        this.lightShadowMatrixVsId = [];
        this.lightShadowParamsVsId = [];
        this.lightDirVs = [];
        this.lightDirVsId = [];
        this.lightRadiusId = [];
        this.lightPos = [];
        this.lightPosId = [];
        this.lightInAngleId = [];
        this.lightOutAngleId = [];
        this.lightPosVsId = [];
        this.lightCookieId = [];
        this.lightCookieIntId = [];
        this.lightCookieMatrixId = [];
        this.lightCookieOffsetId = [];
        this.depthMapId = a.resolve("uDepthMap");
        this.screenSizeId = a.resolve("uScreenSize");
        this._screenSize = new Float32Array(4);
        this.sourceId = a.resolve("source");
        this.pixelOffsetId = a.resolve("pixelOffset");
        this.weightId = a.resolve("weight[0]");
        this.blurVsmShaderCode = [F.blurVSMPS, "#define GAUSS\n" + F.blurVSMPS];
        this.blurPackedVsmShaderCode = ["#define PACKED\n" + this.blurVsmShaderCode[0], "#define PACKED\n" + this.blurVsmShaderCode[1]];
        this.blurVsmShader = [{}, {}];
        this.blurPackedVsmShader = [{}, {}];
        this.blurVsmWeights = {};
        this.twoSidedLightingNegScaleFactorId = a.resolve("twoSidedLightingNegScaleFactor");
        this.polygonOffsetId = a.resolve("polygonOffset");
        this.polygonOffset = new Float32Array(2);
        this.fogColor = new Float32Array(3);
        this.ambientColor = new Float32Array(3);
        this.cameraParams = new Float32Array(4)
    }

    function Bg(a, b) {
        a.data[0] = b.data[0];
        a.data[1] = b.data[1];
        a.data[2] = b.data[2];
        a.data[3] = b.data[4];
        a.data[4] = b.data[5];
        a.data[5] = b.data[6];
        a.data[6] = b.data[8];
        a.data[7] = b.data[9];
        a.data[8] = b.data[10]
    }

    function ed() {
        la.call(this);
        this.color = new L(1, 1, 1, 1);
        this.colorUniform = new Float32Array(4);
        this.colorMap = null;
        this.vertexColors = !1
    }

    function Cg(a) {
        this.lineVertexFormat = new Na(a, [{
            semantic: "POSITION",
            components: 3,
            type: 6
        }, {
            semantic: "COLOR",
            components: 4,
            type: 1,
            normalize: !0
        }]);
        this.lineBatches = [];
        this.layers = [];
        this.layerToBatch = {};
        this.cubeWorldPos = this.cubeLocalPos = this.quadMesh = null;
        this.identityGraphNode = new Z
    }

    function Pk() {
        this.numLinesAllocated = 128;
        this.mesh = this.vbRam = this.vb = null;
        this.linesUsed = 0;
        this.layer = this.meshInstance = this.material = null
    }

    function xa() {
        M.call(this);
        this.layerList = [];
        this.subLayerList = [];
        this.subLayerEnabled = [];
        this._opaqueOrder = {};
        this._transparentOrder = {};
        this._dirtyCameras = this._dirtyLights = this._dirtyBlend = this._dirty = !1;
        this._meshInstances = [];
        this._meshInstancesSet = new Set;
        this._lights = [];
        this._lightsMap = new Map;
        this._lightShadowCasters = [];
        this._lightShadowCastersSets = [];
        this._splitLights = [
            [],
            [],
            []
        ];
        this._globalLightCameras = [];
        this.cameras = [];
        this._globalLightCameraIds = [];
        this._renderedRt = [];
        this._renderedByCam = [];
        this._renderedLayer = [];
        this._renderList = [];
        this._renderListCamera = []
    }

    function Dg(a, b, c, d) {
        if (a.enabled) {
            var e;
            if (a.model && a.model.model && a.model.enabled && (d && d.push(a), a.model.lightmapped && b)) {
                var f = !0,
                    g = a.model.model.meshInstances;
                for (e = 0; e < g.length; e++)
                    if (!g[e].mesh.vertexBuffer.format.hasUv1) {
                        f = !1;
                        break
                    }
                if (f) {
                    var k = [];
                    for (e = 0; e < g.length; e++) {
                        var h = !1;
                        for (f = 0; f < g.length; f++) e !== f && g[e].mesh === g[f].mesh && (h = !0);
                        h ? (b.push(a), c.push([g[e]])) : k.push(g[e])
                    }
                    0 < k.length && (b.push(a), c.push(k))
                }
            }
            for (e = 0; e < a._children.length; e++) Dg(a._children[e], b, c, d)
        }
    }

    function ni(a, b, c, d, e) {
        this.device = a;
        this.root = b;
        this.scene = c;
        this.renderer = d;
        this.assets = e
    }

    function ve(a) {
        return a - Math.floor(a)
    }

    function oi(a, b) {
        return a - b * Math.floor(a / b)
    }

    function Eg(a) {
        var b =
            ve(a);
        a = ve(255 * a);
        return [b - a / 255, a - a / 255]
    }

    function pi(a) {
        this._emitter = a
    }

    function Qk(a, b) {
        b.data[0] = a.data[0];
        b.data[1] = a.data[1];
        b.data[2] = a.data[2];
        b.data[3] = a.data[4];
        b.data[4] = a.data[5];
        b.data[5] = a.data[6];
        b.data[6] = a.data[8];
        b.data[7] = a.data[9];
        b.data[8] = a.data[10]
    }

    function Fg(a, b) {
        this._emitter = a;
        this.frameRandomUniform = new Float32Array(3);
        this.emitterPosUniform = new Float32Array(3);
        this.emitterScaleUniform = new Float32Array([1, 1, 1]);
        this.worldBoundsMulUniform = new Float32Array(3);
        this.worldBoundsAddUniform =
            new Float32Array(3);
        this.inBoundsSizeUniform = new Float32Array(3);
        this.inBoundsCenterUniform = new Float32Array(3);
        this.constantParticleTexIN = b.scope.resolve("particleTexIN");
        this.constantParticleTexOUT = b.scope.resolve("particleTexOUT");
        this.constantEmitterPos = b.scope.resolve("emitterPos");
        this.constantEmitterScale = b.scope.resolve("emitterScale");
        this.constantSpawnBounds = b.scope.resolve("spawnBounds");
        this.constantSpawnPosInnerRatio = b.scope.resolve("spawnPosInnerRatio");
        this.constantSpawnBoundsSphere =
            b.scope.resolve("spawnBoundsSphere");
        this.constantSpawnBoundsSphereInnerRatio = b.scope.resolve("spawnBoundsSphereInnerRatio");
        this.constantInitialVelocity = b.scope.resolve("initialVelocity");
        this.constantFrameRandom = b.scope.resolve("frameRandom");
        this.constantDelta = b.scope.resolve("delta");
        this.constantRate = b.scope.resolve("rate");
        this.constantRateDiv = b.scope.resolve("rateDiv");
        this.constantLifetime = b.scope.resolve("lifetime");
        this.constantGraphSampleSize = b.scope.resolve("graphSampleSize");
        this.constantGraphNumSamples =
            b.scope.resolve("graphNumSamples");
        this.constantInternalTex0 = b.scope.resolve("internalTex0");
        this.constantInternalTex1 = b.scope.resolve("internalTex1");
        this.constantInternalTex2 = b.scope.resolve("internalTex2");
        this.constantInternalTex3 = b.scope.resolve("internalTex3");
        this.constantEmitterMatrix = b.scope.resolve("emitterMatrix");
        this.constantEmitterMatrixInv = b.scope.resolve("emitterMatrixInv");
        this.constantNumParticles = b.scope.resolve("numParticles");
        this.constantNumParticlesPot = b.scope.resolve("numParticlesPot");
        this.constantLocalVelocityDivMult = b.scope.resolve("localVelocityDivMult");
        this.constantVelocityDivMult = b.scope.resolve("velocityDivMult");
        this.constantRotSpeedDivMult = b.scope.resolve("rotSpeedDivMult");
        this.constantSeed = b.scope.resolve("seed");
        this.constantStartAngle = b.scope.resolve("startAngle");
        this.constantStartAngle2 = b.scope.resolve("startAngle2");
        this.constantOutBoundsMul = b.scope.resolve("outBoundsMul");
        this.constantOutBoundsAdd = b.scope.resolve("outBoundsAdd");
        this.constantInBoundsSize = b.scope.resolve("inBoundsSize");
        this.constantInBoundsCenter = b.scope.resolve("inBoundsCenter");
        this.constantMaxVel = b.scope.resolve("maxVel");
        this.constantFaceTangent = b.scope.resolve("faceTangent");
        this.constantFaceBinorm = b.scope.resolve("faceBinorm")
    }

    function U(a, b) {
        Rk[a] = void 0 !== Gg[a] && null !== Gg[a] ? Gg[a] : b
    }

    function Sk(a, b) {
        for (var c = a.length / 3, d = Array(4 * c), e = 0; e < c; e++) d[4 * e] = a[3 * e], d[4 * e + 1] = a[3 * e + 1], d[4 * e + 2] = a[3 * e + 2], d[4 * e + 3] = (255 * b[3 * e] << 16 | 255 * b[3 * e + 1] << 8 | 255 * b[3 * e + 2]) / 16777216;
        return d
    }

    function Kd(a, b) {
        var c, d, e = b.length,
            f =
            a.length / e;
        for (c = 0; c < f; c++)
            for (d = 0; d < e; d++) b[d] = Math.max(b[d], Math.abs(a[c * e + d]))
    }

    function Ld(a, b, c) {
        for (var d = new Float32Array(b.length), e = 0; e < b.length; e++) d[e] = b[e] - a[e];
        Kd(d, c);
        a = c.length;
        var f = d.length / a;
        for (b = 0; b < f; b++)
            for (e = 0; e < a; e++) d[b * a + e] /= 0 === c[e] ? 1 : c[e], d[b * a + e] *= .5, d[b * a + e] += .5;
        return d
    }

    function Tk(a, b) {
        var c = b.length / 3,
            d = a.length / 3,
            e, f = new z,
            g = new z,
            k = new z,
            h = new z,
            l = new z,
            n = new z,
            p = [];
        for (e = 0; e < a.length; e++) p[e] = 0;
        for (e = 0; e < c; e++) {
            var q = b[3 * e];
            var r = b[3 * e + 1];
            var t = b[3 * e + 2];
            f.set(a[3 *
                q], a[3 * q + 1], a[3 * q + 2]);
            g.set(a[3 * r], a[3 * r + 1], a[3 * r + 2]);
            k.set(a[3 * t], a[3 * t + 1], a[3 * t + 2]);
            h.sub2(g, f);
            l.sub2(k, f);
            n.cross(h, l).normalize();
            p[3 * q] += n.x;
            p[3 * q + 1] += n.y;
            p[3 * q + 2] += n.z;
            p[3 * r] += n.x;
            p[3 * r + 1] += n.y;
            p[3 * r + 2] += n.z;
            p[3 * t] += n.x;
            p[3 * t + 1] += n.y;
            p[3 * t + 2] += n.z
        }
        for (e = 0; e < d; e++) a = p[3 * e], b = p[3 * e + 1], c = p[3 * e + 2], a = 1 / Math.sqrt(a * a + b * b + c * c), p[3 * e] *= a, p[3 * e + 1] *= a, p[3 * e + 2] *= a;
        return p
    }

    function Uk(a, b, c, d) {
        var e = d.length / 3,
            f = a.length / 3,
            g = new z,
            k = new z,
            h = new z,
            l = new z,
            n = new z,
            p = new P,
            q = new P,
            r = new P,
            t, u = new Float32Array(3 *
                f),
            x = new Float32Array(3 * f),
            v = [];
        for (t = 0; t < e; t++) {
            var w = d[3 * t];
            var y = d[3 * t + 1];
            var A = d[3 * t + 2];
            h.set(a[3 * w], a[3 * w + 1], a[3 * w + 2]);
            l.set(a[3 * y], a[3 * y + 1], a[3 * y + 2]);
            n.set(a[3 * A], a[3 * A + 1], a[3 * A + 2]);
            p.set(c[2 * w], c[2 * w + 1]);
            q.set(c[2 * y], c[2 * y + 1]);
            r.set(c[2 * A], c[2 * A + 1]);
            var B = l.x - h.x;
            var E = n.x - h.x;
            var D = l.y - h.y;
            var C = n.y - h.y;
            var G = l.z - h.z;
            var K = n.z - h.z;
            var R = q.x - p.x;
            var I = r.x - p.x;
            var T = q.y - p.y;
            var S = r.y - p.y;
            var ba = R * S - I * T;
            0 == ba ? (g.set(0, 1, 0), k.set(1, 0, 0)) : (ba = 1 / ba, g.set((S * B - T * E) * ba, (S * D - T * C) * ba, (S * G - T * K) * ba),
                k.set((R * E - I * B) * ba, (R * C - I * D) * ba, (R * K - I * G) * ba));
            u[3 * w] += g.x;
            u[3 * w + 1] += g.y;
            u[3 * w + 2] += g.z;
            u[3 * y] += g.x;
            u[3 * y + 1] += g.y;
            u[3 * y + 2] += g.z;
            u[3 * A] += g.x;
            u[3 * A + 1] += g.y;
            u[3 * A + 2] += g.z;
            x[3 * w] += k.x;
            x[3 * w + 1] += k.y;
            x[3 * w + 2] += k.z;
            x[3 * y] += k.x;
            x[3 * y + 1] += k.y;
            x[3 * y + 2] += k.z;
            x[3 * A] += k.x;
            x[3 * A + 1] += k.y;
            x[3 * A + 2] += k.z
        }
        T = new z;
        S = new z;
        a = new z;
        c = new z;
        for (t = 0; t < f; t++) a.set(b[3 * t], b[3 * t + 1], b[3 * t + 2]), T.set(u[3 * t], u[3 * t + 1], u[3 * t + 2]), S.set(x[3 * t], x[3 * t + 1], x[3 * t + 2]), d = a.dot(T), c.copy(a).scale(d), c.sub2(T, c).normalize(), v[4 * t] = c.x, v[4 * t +
            1] = c.y, v[4 * t + 2] = c.z, c.cross(a, T), v[4 * t + 3] = 0 > c.dot(S) ? -1 : 1;
        return v
    }

    function Qb(a, b, c) {
        var d = c && void 0 !== c.normals ? c.normals : null,
            e = c && void 0 !== c.tangents ? c.tangents : null,
            f = c && void 0 !== c.colors ? c.colors : null,
            g = c && void 0 !== c.uvs ? c.uvs : null,
            k = c && void 0 !== c.uvs1 ? c.uvs1 : null,
            h = c && void 0 !== c.indices ? c.indices : null,
            l = c && void 0 !== c.blendIndices ? c.blendIndices : null,
            n = c && void 0 !== c.blendWeights ? c.blendWeights : null;
        c = [{
            semantic: "POSITION",
            components: 3,
            type: 6
        }];
        null !== d && c.push({
            semantic: "NORMAL",
            components: 3,
            type: 6
        });
        null !== e && c.push({
            semantic: "TANGENT",
            components: 4,
            type: 6
        });
        null !== f && c.push({
            semantic: "COLOR",
            components: 4,
            type: 1,
            normalize: !0
        });
        null !== g && c.push({
            semantic: "TEXCOORD0",
            components: 2,
            type: 6
        });
        null !== k && c.push({
            semantic: "TEXCOORD1",
            components: 2,
            type: 6
        });
        null !== l && c.push({
            semantic: "BLENDINDICES",
            components: 2,
            type: 1
        });
        null !== n && c.push({
            semantic: "BLENDWEIGHT",
            components: 2,
            type: 6
        });
        var p = new Na(a, c);
        c = b.length / 3;
        p = new ab(a, p, c);
        for (var q = new Pb(p), r = 0; r < c; r++) q.element.POSITION.set(b[3 * r], b[3 * r +
            1], b[3 * r + 2]), null !== d && q.element.NORMAL.set(d[3 * r], d[3 * r + 1], d[3 * r + 2]), null !== e && q.element.TANGENT.set(e[4 * r], e[4 * r + 1], e[4 * r + 2], e[4 * r + 3]), null !== f && q.element.COLOR.set(f[4 * r], f[4 * r + 1], f[4 * r + 2], f[4 * r + 3]), null !== g && q.element.TEXCOORD0.set(g[2 * r], g[2 * r + 1]), null !== k && q.element.TEXCOORD1.set(k[2 * r], k[2 * r + 1]), null !== l && q.element.BLENDINDICES.set(l[2 * r], l[2 * r + 1]), null !== n && q.element.BLENDWEIGHT.set(n[2 * r], n[2 * r + 1]), q.next();
        q.end();
        d = null;
        if (e = null !== h) d = new dc(a, 1, h.length), (new Uint16Array(d.lock())).set(h),
            d.unlock();
        f = new oa;
        f.compute(b);
        a = new sb(a);
        a.vertexBuffer = p;
        a.indexBuffer[0] = d;
        a.primitive[0].type = 4;
        a.primitive[0].base = 0;
        a.primitive[0].count = e ? h.length : c;
        a.primitive[0].indexed = e;
        a.aabb = f;
        return a
    }

    function Vk(a, b) {
        var c = b && void 0 !== b.tubeRadius ? b.tubeRadius : .2,
            d = b && void 0 !== b.ringRadius ? b.ringRadius : .3,
            e = b && void 0 !== b.segments ? b.segments : 30,
            f = b && void 0 !== b.sides ? b.sides : 20;
        b = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        var g, k, h = [],
            l = [],
            n = [],
            p = [];
        for (g = 0; g <= f; g++)
            for (k = 0; k <= e; k++) {
                var q =
                    Math.cos(2 * Math.PI * k / e) * (d + c * Math.cos(2 * Math.PI * g / f));
                var r = Math.sin(2 * Math.PI * g / f) * c;
                var t = Math.sin(2 * Math.PI * k / e) * (d + c * Math.cos(2 * Math.PI * g / f));
                var u = Math.cos(2 * Math.PI * k / e) * Math.cos(2 * Math.PI * g / f);
                var x = Math.sin(2 * Math.PI * g / f);
                var v = Math.sin(2 * Math.PI * k / e) * Math.cos(2 * Math.PI * g / f);
                var w = g / f;
                var y = 1 - k / e;
                h.push(q, r, t);
                l.push(u, x, v);
                n.push(w, y);
                g < f && k < e && (q = g * (e + 1) + k, r = (g + 1) * (e + 1) + k, t = g * (e + 1) + (k + 1), u = (g + 1) * (e + 1) + (k + 1), p.push(q, r, t), p.push(r, u, t))
            }
        c = {
            normals: l,
            uvs: n,
            indices: p
        };
        b && (c.tangents = b(h, l,
            n, p));
        return Qb(a, h, c)
    }

    function qi(a, b, c, d, e, f) {
        var g, k, h = new z,
            l = new z;
        var n = new z;
        var p = [],
            q = [],
            r = [],
            t = [],
            u = [];
        if (0 < c)
            for (g = 0; g <= d; g++)
                for (k = 0; k <= e; k++) {
                    var x = k / e * 2 * Math.PI - Math.PI;
                    var v = Math.sin(x);
                    x = Math.cos(x);
                    var w = new z(v * a, -c / 2, x * a);
                    var y = new z(v * b, c / 2, x * b);
                    h.lerp(w, y, g / d);
                    l.sub2(y, w).normalize();
                    v = new z(x, 0, -v);
                    n.cross(v, l).normalize();
                    p.push(h.x, h.y, h.z);
                    q.push(n.x, n.y, n.z);
                    y = k / e;
                    w = g / d;
                    r.push(y, w);
                    v = w;
                    w = y;
                    y = v;
                    y /= 3;
                    y = .875 * y + .0625;
                    w = .875 * w + .0625;
                    t.push(y, w);
                    g < d && k < e && (v = g * (e + 1) + k, x = g * (e + 1) +
                        (k + 1), y = (g + 1) * (e + 1) + k, w = (g + 1) * (e + 1) + (k + 1), u.push(v, x, y), u.push(x, w, y))
                }
        if (f) {
            a = Math.floor(e / 2);
            g = c / 2;
            for (c = 0; c <= a; c++)
                for (x = c * Math.PI * .5 / a, v = Math.sin(x), x = Math.cos(x), h = 0; h <= e; h++) f = 2 * h * Math.PI / e - Math.PI / 2, y = Math.sin(f), f = Math.cos(f), f *= v, k = x, n = y * v, y = 1 - h / e, w = 1 - c / a, p.push(f * b, k * b + g, n * b), q.push(f, k, n), r.push(y, w), y /= 3, w /= 3, y = .875 * y + .0625, w = .875 * w + .0625, y += 1 / 3, t.push(y, w);
            l = (d + 1) * (e + 1);
            for (c = 0; c < a; ++c)
                for (h = 0; h < e; ++h) v = c * (e + 1) + h, x = v + e + 1, u.push(l + v + 1, l + x, l + v), u.push(l + v + 1, l + x + 1, l + x);
            for (c = 0; c <= a; c++)
                for (x =
                    .5 * Math.PI + c * Math.PI * .5 / a, v = Math.sin(x), x = Math.cos(x), h = 0; h <= e; h++) f = 2 * h * Math.PI / e - Math.PI / 2, y = Math.sin(f), f = Math.cos(f), f *= v, k = x, n = y * v, y = 1 - h / e, w = 1 - c / a, p.push(f * b, k * b - g, n * b), q.push(f, k, n), r.push(y, w), y /= 3, w /= 3, y = .875 * y + .0625, w = .875 * w + .0625, y += 2 / 3, t.push(y, w);
            l = (d + 1) * (e + 1) + (e + 1) * (a + 1);
            for (c = 0; c < a; ++c)
                for (h = 0; h < e; ++h) v = c * (e + 1) + h, x = v + e + 1, u.push(l + v + 1, l + x, l + v), u.push(l + v + 1, l + x + 1, l + x)
        } else {
            l = (d + 1) * (e + 1);
            if (0 < a)
                for (g = 0; g < e; g++) x = g / e * 2 * Math.PI, f = Math.sin(x), k = -c / 2, n = Math.cos(x), y = 1 - (f + 1) / 2, w = (n + 1) / 2, p.push(f *
                    a, k, n * a), q.push(0, -1, 0), r.push(y, w), y /= 3, w /= 3, y = .875 * y + .0625, w = .875 * w + .0625, y += 1 / 3, t.push(y, w), 1 < g && u.push(l, l + g, l + g - 1);
            l += e;
            if (0 < b)
                for (g = 0; g < e; g++) x = g / e * 2 * Math.PI, f = Math.sin(x), k = c / 2, n = Math.cos(x), y = 1 - (f + 1) / 2, w = (n + 1) / 2, p.push(f * b, k, n * b), q.push(0, 1, 0), r.push(y, w), y /= 3, w /= 3, y = .875 * y + .0625, w = .875 * w + .0625, y += 2 / 3, t.push(y, w), 1 < g && u.push(l, l + g - 1, l + g)
        }
        return {
            positions: p,
            normals: q,
            uvs: r,
            uvs1: t,
            indices: u
        }
    }

    function ri(a, b) {
        var c = b && (b.radius || b.baseRadius);
        c = void 0 !== c ? c : .5;
        var d = b && void 0 !== b.calculateTangents ?
            b.calculateTangents : !1;
        b = qi(c, c, b && void 0 !== b.height ? b.height : 1, b && void 0 !== b.heightSegments ? b.heightSegments : 5, b && void 0 !== b.capSegments ? b.capSegments : 20, !1);
        d && (b.tangents = d(b.positions, b.normals, b.uvs, b.indices));
        return Qb(a, b.positions, b)
    }

    function si(a, b) {
        var c = b && void 0 !== b.radius ? b.radius : .3,
            d = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        b = qi(c, c, (b && void 0 !== b.height ? b.height : 1) - 2 * c, b && void 0 !== b.heightSegments ? b.heightSegments : 1, b && void 0 !== b.sides ? b.sides : 20, !0);
        d && (b.tangents =
            d(b.positions, b.normals, b.uvs, b.indices));
        return Qb(a, b.positions, b)
    }

    function ti(a, b) {
        var c = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        b = qi(b && void 0 !== b.baseRadius ? b.baseRadius : .5, b && void 0 !== b.peakRadius ? b.peakRadius : 0, b && void 0 !== b.height ? b.height : 1, b && void 0 !== b.heightSegments ? b.heightSegments : 5, b && void 0 !== b.capSegments ? b.capSegments : 18, !1);
        c && (b.tangents = c(b.positions, b.normals, b.uvs, b.indices));
        return Qb(a, b.positions, b)
    }

    function ui(a, b) {
        var c = b && void 0 !== b.radius ? b.radius : .5,
            d =
            b && void 0 !== b.latitudeBands ? b.latitudeBands : 16,
            e = b && void 0 !== b.longitudeBands ? b.longitudeBands : 16;
        b = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        var f, g = [],
            k = [],
            h = [],
            l = [];
        for (f = 0; f <= d; f++) {
            var n = f * Math.PI / d;
            var p = Math.sin(n);
            var q = Math.cos(n);
            for (n = 0; n <= e; n++) {
                var r = 2 * n * Math.PI / e - Math.PI / 2;
                var t = Math.sin(r);
                r = Math.cos(r);
                r *= p;
                var u = q;
                t *= p;
                var x = 1 - n / e;
                var v = 1 - f / d;
                g.push(r * c, u * c, t * c);
                k.push(r, u, t);
                h.push(x, v)
            }
        }
        for (f = 0; f < d; ++f)
            for (n = 0; n < e; ++n) c = f * (e + 1) + n, p = c + e + 1, l.push(c + 1, p, c), l.push(c + 1,
                p + 1, p);
        d = {
            normals: k,
            uvs: h,
            uvs1: h,
            indices: l
        };
        b && (d.tangents = b(g, k, h, l));
        return Qb(a, g, d)
    }

    function vi(a, b) {
        var c = b && void 0 !== b.halfExtents ? b.halfExtents : new P(.5, .5),
            d = b && void 0 !== b.widthSegments ? b.widthSegments : 5,
            e = b && void 0 !== b.lengthSegments ? b.lengthSegments : 5;
        b = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        var f, g, k = [],
            h = [],
            l = [],
            n = [],
            p = 0;
        for (f = 0; f <= d; f++)
            for (g = 0; g <= e; g++) {
                var q = -c.x + 2 * c.x * f / d;
                var r = -(-c.y + 2 * c.y * g / e);
                var t = f / d;
                var u = g / e;
                k.push(q, 0, r);
                h.push(0, 1, 0);
                l.push(t, u);
                f < d && g < e &&
                    (n.push(p + e + 1, p + 1, p), n.push(p + e + 1, p + e + 2, p + 1));
                p++
            }
        c = {
            normals: h,
            uvs: l,
            uvs1: l,
            indices: n
        };
        b && (c.tangents = b(k, h, l, n));
        return Qb(a, k, c)
    }

    function Hg(a, b) {
        var c = b && void 0 !== b.halfExtents ? b.halfExtents : new z(.5, .5, .5),
            d = b && void 0 !== b.widthSegments ? b.widthSegments : 1,
            e = b && void 0 !== b.lengthSegments ? b.lengthSegments : 1,
            f = b && void 0 !== b.heightSegments ? b.heightSegments : 1;
        b = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        var g = [new z(-c.x, -c.y, c.z), new z(c.x, -c.y, c.z), new z(c.x, c.y, c.z), new z(-c.x, c.y, c.z),
                new z(c.x, -c.y, -c.z), new z(-c.x, -c.y, -c.z), new z(-c.x, c.y, -c.z), new z(c.x, c.y, -c.z)
            ],
            k = [
                [0, 1, 3],
                [4, 5, 7],
                [3, 2, 6],
                [1, 0, 4],
                [1, 4, 2],
                [5, 0, 6]
            ],
            h = [
                [0, 0, 1],
                [0, 0, -1],
                [0, 1, 0],
                [0, -1, 0],
                [1, 0, 0],
                [-1, 0, 0]
            ],
            l = [],
            n = [],
            p = [],
            q = [],
            r = [],
            t = 0;
        c = function(u, x, v) {
            var w, y;
            for (w = 0; w <= x; w++)
                for (y = 0; y <= v; y++) {
                    var A = new z;
                    var B = new z;
                    var E = new z,
                        D = new z;
                    A.lerp(g[k[u][0]], g[k[u][1]], w / x);
                    B.lerp(g[k[u][0]], g[k[u][2]], y / v);
                    E.sub2(B, g[k[u][0]]);
                    D.add2(A, E);
                    A = w / x;
                    B = y / v;
                    l.push(D.x, D.y, D.z);
                    n.push(h[u][0], h[u][1], h[u][2]);
                    p.push(A, B);
                    A /= 3;
                    B /= 3;
                    A = .875 * A + .0625;
                    B = .875 * B + .0625;
                    A += u % 3 / 3;
                    B += Math.floor(u / 3) / 3;
                    q.push(A, B);
                    w < x && y < v && (r.push(t + v + 1, t + 1, t), r.push(t + v + 1, t + v + 2, t + 1));
                    t++
                }
        };
        c(0, d, f);
        c(1, d, f);
        c(2, d, e);
        c(3, d, e);
        c(4, e, f);
        c(5, e, f);
        d = {
            normals: n,
            uvs: p,
            uvs1: q,
            indices: r
        };
        b && (d.tangents = b(l, n, p, r));
        return Qb(a, l, d)
    }

    function ra() {
        M.call(this);
        this.root = null;
        this._gravity = new z(0, -9.8, 0);
        this._layers = null;
        this._fog = "none";
        this.fogColor = new L(0, 0, 0);
        this.fogStart = 1;
        this.fogEnd = 1E3;
        this.fogDensity = 0;
        this.ambientLight = new L(0, 0, 0);
        this._toneMapping =
            this._gammaCorrection = 0;
        this.exposure = 1;
        this._skyboxPrefiltered = [null, null, null, null, null, null];
        this._firstUpdateSkybox = !0;
        this.skyboxModel = this._skyboxCubeMap = null;
        this._skyboxIntensity = 1;
        this._skyboxMip = 0;
        this._skyboxRotation = new Y;
        this._skyboxRotationMat4 = this._skyboxRotationMat3 = null;
        this._skyboxIsRenderTarget = !1;
        this.lightmapSizeMultiplier = 1;
        this.lightmapMaxResolution = 2048;
        this.lightmapMode = 1;
        this._stats = {
            meshInstances: 0,
            lights: 0,
            dynamicLights: 0,
            bakedLights: 0,
            lastStaticPrepareFullTime: 0,
            lastStaticPrepareSearchTime: 0,
            lastStaticPrepareWriteTime: 0,
            lastStaticPrepareTriAabbTime: 0,
            lastStaticPrepareCombineTime: 0,
            updateShadersTime: 0
        };
        this.updateSkybox = this.updateShaders = !0;
        this._shaderVersion = 0;
        this._statsUpdated = !1;
        this._models = [];
        this.defaultMaterial = new ma;
        this.defaultMaterial.name = "Default Material";
        this.defaultMaterial.shadingModel = 1
    }

    function we() {
        return "undefined" !== typeof Audio
    }

    function fd() {
        return !("undefined" === typeof AudioContext && "undefined" === typeof webkitAudioContext)
    }

    function wi(a) {
        this.position = new z;
        this.velocity = new z;
        this.orientation = new J;
        fd() && (this.listener = a.context.listener)
    }

    function ec(a) {
        M.call(this);
        if (fd() || a.forceWebAudioApi) {
            if ("undefined" !== typeof AudioContext ? this.context = new AudioContext : "undefined" !== typeof webkitAudioContext && (this.context = new webkitAudioContext), this.context) {
                var b = this.context;
                this.resumeContext = function() {
                    this.context.resume();
                    window.removeEventListener("mousedown", this.resumeContext);
                    window.removeEventListener("touchend", this.resumeContext)
                }.bind(this);
                window.addEventListener("mousedown", this.resumeContext);
                window.addEventListener("touchend", this.resumeContext);
                if (Da.ios) {
                    var c = function() {
                        var d = b.createBuffer(1, 1, 44100),
                            e = b.createBufferSource();
                        e.buffer = d;
                        e.connect(b.destination);
                        e.start(0);
                        e.disconnect();
                        window.removeEventListener("touchend", c)
                    };
                    window.addEventListener("touchend", c)
                }
            }
        } else console.warn("No support for 3D audio found");
        we() || console.warn("No support for 2D audio found");
        this.listener = new wi(this);
        this._volume = 1;
        this.suspended = !1
    }

    function Ig(a, b, c, d) {
        this.time = a;
        this.position = b;
        this.rotation = c;
        this.scale = d
    }

    function Jg() {
        this._name = "";
        this._keys = []
    }

    function Rb() {
        this.name = "";
        this.duration = 0;
        this._nodes = [];
        this._nodeDict = {}
    }

    function vf(a) {
        2 === arguments.length && (a = arguments[1]);
        this.options = a;
        this.name = a.name;
        this.defaultWeight = a.defaultWeight || 0;
        this.aabb = a.aabb;
        this.aabb || (this.aabb = new oa, a.deltaPositions && this.aabb.compute(a.deltaPositions));
        this.deltaPositions = a.deltaPositions
    }

    function Kg(a, b, c) {
        this.device = a;
        this.inverseBindPose =
            b;
        this.boneNames = c
    }

    function wf() {}

    function fa(a, b) {
        Z.call(this, a);
        a instanceof ea && (b = a);
        this._batchHandle = null;
        this.c = {};
        this._app = b;
        if (!b && (this._app = ea.getApplication(), !this._app)) throw Error("Couldn't find current application");
        this._guid = null;
        this._template = this._destroying = !1
    }

    function Wk(a, b, c, d) {
        var e;
        if (b instanceof fa) {
            var f = b.c,
                g;
            for (g in f) {
                var k = f[g],
                    h = k.system.getPropertiesOfType("entity");
                var l = 0;
                for (e = h.length; l < e; l++) {
                    var n = h[l].name,
                        p = k[n];
                    a.findByGuid(p) && ((p = d[p].getGuid()) ? c.c[g][n] =
                        p : console.warn("Could not find corresponding entity id when resolving duplicated entity references"))
                }
            }
            f.script && !c._app.useLegacyScriptAttributeCloning && c.script.resolveDuplicatedEntityReferenceProperties(f.script, d);
            b = b.children.filter(function(q) {
                return q instanceof fa
            });
            c = c.children.filter(function(q) {
                return q instanceof fa
            });
            l = 0;
            for (e = b.length; l < e; l++) Wk(a, b[l], c[l], d)
        }
    }

    function xf(a, b) {
        this._components = a;
        this._data = b
    }

    function Xk() {
        this._left = Infinity;
        this._right = -Infinity;
        this._t = this._p1 = this._p0 =
            this._recip = this._len = 0;
        this._hermite = {
            valid: !1,
            p0: 0,
            m0: 0,
            p1: 0,
            m1: 0
        }
    }

    function Lg(a, b, c, d) {
        this._paths = a;
        this._input = b;
        this._output = c;
        this._interpolation = d
    }

    function Md(a, b, c, d, e) {
        this._name = a;
        this._duration = b;
        this._inputs = c;
        this._outputs = d;
        this._curves = e
    }

    function Yk(a) {
        this._name = a.name + "Snapshot";
        this._time = -1;
        this._cache = [];
        this._results = [];
        var b;
        for (b = 0; b < a._inputs.length; ++b) this._cache[b] = new Xk;
        var c = a._curves;
        a = a._outputs;
        for (b = 0; b < c.length; ++b) {
            for (var d = a[c[b]._output], e = [], f = 0; f < d._components; ++f) e[f] =
                0;
            this._results[b] = e
        }
    }

    function yf(a, b, c, d, e) {
        this._name = a.name;
        this._track = a;
        this._snapshot = new Yk(a);
        this._playing = d;
        this._time = b;
        this._speed = c;
        this._loop = e;
        this._blendWeight = 1;
        this._blendOrder = 0
    }

    function Jc(a, b, c) {
        this._func = a;
        this._type = b;
        this._components = c
    }

    function uc() {}

    function zf(a) {
        var b = {},
            c = function(d) {
                b[d.name] = {
                    node: d,
                    count: 0
                };
                for (var e = 0; e < d.children.length; ++e) c(d.children[e])
            };
        c(a);
        this.nodes = b;
        this.activeNodes = [];
        this.handlers = {
            localPosition: function(d) {
                var e = d.localPosition;
                return new Jc(function(f) {
                    e.set.apply(e,
                        f)
                }, "vector", 3)
            },
            localRotation: function(d) {
                var e = d.localRotation;
                return new Jc(function(f) {
                    e.set.apply(e, f)
                }, "quaternion", 4)
            },
            localScale: function(d) {
                var e = d.localScale;
                return new Jc(function(f) {
                    e.set.apply(e, f)
                }, "vector", 3)
            },
            weights: function(d) {
                for (var e = d; e && e.constructor !== fa;) e = e.parent;
                if (!(e && e.model && e.model.model && e.model.model.morphInstances)) return null;
                e = e.model.meshInstances;
                for (var f, g = 0; g < e.length; ++g)
                    if (e[g].node.name === d.name) {
                        f = e[g].morphInstance;
                        break
                    }
                return f ? new Jc(function(k) {
                    for (var h =
                            0; h < k.length; ++h) f.setWeight(h, k[h])
                }, "vector", f.morph._targets.length) : null
            },
            materialTexture: function(d, e) {
                for (var f = d; f && f.constructor !== fa;) f = f.parent;
                if (!f || !f.model || !f.model.model) return null;
                f = f.model.meshInstances;
                for (var g, k = 0; k < f.length; ++k)
                    if (f[k].node.name === d.name) {
                        g = f[k];
                        break
                    }
                if (!g) return null;
                d = function(h) {
                    (h = this.animComponent.system.app.assets.get(h[0])) && h.resource && "texture" === h.type && (g.material[e] = h.resource, g.material.update())
                }.bind(this);
                return new Jc(d, "vector", 1)
            }.bind(this)
        };
        this.propertyLocator = new wf
    }

    function Ja(a) {
        this._binder = a;
        this._clips = [];
        this._inputs = [];
        this._outputs = [];
        this._targets = {}
    }

    function xi() {}

    function Oa(a) {
        M.call(this);
        this.locale = Mg;
        this._translations = {};
        this._availableLangs = {};
        this._app = a;
        this._assets = [];
        this._parser = new xi
    }

    function yi(a) {
        this.asset = a
    }

    function aa(a, b, c, d, e) {
        M.call(this);
        this._id = Wn--;
        this.name = a || "";
        this.type = b;
        this.tags = new bd(this);
        this._preload = !1;
        this.variants = new yi(this);
        this._file = null;
        this._data = d || {};
        this.options = e || {};
        this._resources = [];
        this._i18n = {};
        this.loading = this.loaded = !1;
        this.registry = null;
        c && (this.file = c)
    }

    function gd() {}

    function zi() {
        this.maxRetries = 0
    }

    function Ai() {
        this.maxRetries = 0
    }

    function Af(a) {
        this._layers = [];
        this._parameters = {};
        var b;
        if (Array.isArray(a.layers)) this._layers = a.layers;
        else
            for (var c in a.layers) {
                var d = a.layers[c],
                    e = {
                        name: d.name,
                        states: [],
                        transitions: []
                    };
                for (b = 0; b < d.states.length; b++) e.states.push(a.states[d.states[b]]);
                for (b = 0; b < d.transitions.length; b++) {
                    var f = a.transitions[d.transitions[b]];
                    if (f.conditions &&
                        !Array.isArray(f.conditions)) {
                        for (var g = Object.keys(f.conditions), k = [], h = 0; h < g.length; h++) {
                            var l = f.conditions[g[h]];
                            l.parameterName && k.push(l)
                        }
                        f.conditions = k
                    }
                    Number.isInteger(f.from) && (f.from = a.states[f.from].name);
                    Number.isInteger(f.to) && (f.to = a.states[f.to].name);
                    e.transitions.push(f)
                }
                this._layers.push(e)
            }
        for (var n in a.parameters) b = a.parameters[n], this._parameters[b.name] = {
            type: b.type,
            value: b.value
        }
    }

    function Bi() {
        this.maxRetries = 0
    }

    function Ng(a) {
        a instanceof Audio ? this.audio = a : this.buffer = a
    }

    function Bf(a) {
        this.manager =
            a;
        this.maxRetries = 0
    }

    function Ci() {
        this.maxRetries = 0
    }

    function Cf(a) {
        this._blobUrls = {};
        for (var b = 0, c = a.length; b < c; b++) a[b].url && (this._blobUrls[a[b].name] = a[b].url)
    }

    function Zk(a) {
        function b(f) {
            this._fields = f
        }

        function c(f) {
            this._arrayBuffer = f || new ArrayBuffer(0);
            this._bufferView = new DataView(this._arrayBuffer);
            this._paxHeader = this._globalPaxHeader = null;
            this._bytesRead = 0
        }
        if ("undefined" !== typeof TextDecoder) {
            var d = new TextDecoder("utf-8");
            var e = new TextDecoder("windows-1252")
        } else console.warn("TextDecoder not supported - pc.Untar module will not work");
        b.parse = function(f, g, k) {
            for (var h = new Uint8Array(f, g, k), l = 0, n = []; l < k;) {
                var p;
                for (p = l; p < k && 32 != h[p]; p++);
                if (p >= k) throw Error("Invalid PAX header data format.");
                var q = parseInt(d.decode(new Uint8Array(f, g + l, p - l)), 10);
                p = d.decode(new Uint8Array(f, g + p + 1, q - (p - l) - 2)).split("=");
                if (2 !== p.length) throw Error("Invalid PAX header data format.");
                0 === p[1].length && (p[1] = null);
                n.push({
                    name: p[0],
                    value: p[1]
                });
                l += q
            }
            return new b(n)
        };
        b.prototype.applyHeader = function(f) {
            for (var g = 0; g < this._fields.length; g++) {
                var k = this._fields[g].name,
                    h = this._fields[g].value;
                "path" === k && (k = "name");
                null === h ? delete f[k] : f[k] = h
            }
        };
        a || ($k = c);
        c.prototype._hasNext = function() {
            return this._bytesRead + 4 < this._arrayBuffer.byteLength && 0 !== this._bufferView.getUint32(this._bytesRead)
        };
        c.prototype._readNextFile = function() {
            var f = new DataView(this._arrayBuffer, this._bytesRead, 512),
                g = e.decode(f);
            this._bytesRead += 512;
            f = g.substr(0, 100).replace(/\0/g, "");
            var k = g.substr(257, 6),
                h = parseInt(g.substr(124, 12), 8),
                l = g.substr(156, 1),
                n = this._bytesRead,
                p = null,
                q = !1;
            switch (l) {
                case "0":
                case "":
                    q = !0;
                    a || (p = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + h)]), p = URL.createObjectURL(p));
                    break;
                case "g":
                    this._globalPaxHeader = b.parse(this._arrayBuffer, this._bytesRead, h);
                    break;
                case "x":
                    this._paxHeader = b.parse(this._arrayBuffer, this._bytesRead, h)
            }
            this._bytesRead += h;
            l = h % 512;
            0 !== l && (this._bytesRead += 512 - l);
            if (!q) return null; - 1 !== k.indexOf("ustar") && (g = g.substr(345, 155).replace(/\0/g, ""), 0 < g.length && (f = g.trim() + f.trim()));
            f = {
                name: f,
                start: n,
                size: h,
                url: p
            };
            this._globalPaxHeader && this._globalPaxHeader.applyHeader(f);
            this._paxHeader && (this._paxHeader.applyHeader(f), this._paxHeader = null);
            return f
        };
        c.prototype.untar = function(f) {
            if (!d) return console.error("Cannot untar because TextDecoder interface is not available for this platform."), [];
            for (var g = []; this._hasNext();) {
                var k = this._readNextFile();
                k && (f && k.name && (k.name = f + k.name), g.push(k))
            }
            return g
        };
        a && (self.onmessage = function(f) {
            var g = f.data.id;
            try {
                var k = (new c(f.data.arrayBuffer)).untar(f.data.prefix);
                postMessage({
                    id: g,
                    files: k,
                    arrayBuffer: f.data.arrayBuffer
                }, [f.data.arrayBuffer])
            } catch (h) {
                postMessage({
                    id: g,
                    error: h.toString()
                })
            }
        })
    }

    function Df(a) {
        this._requestId = 0;
        this._pendingRequests = {};
        this._filenamePrefix = a;
        a = Worker;
        if (!Di) {
            var b = new Blob(["(" + Zk.toString() + ")(true)\n\n"], {
                type: "application/javascript"
            });
            Di = URL.createObjectURL(b)
        }
        this._worker = new a(Di);
        this._worker.addEventListener("message", this._onMessage.bind(this))
    }

    function Ei(a) {
        this._assets = a;
        this._worker = null;
        this.maxRetries = 0
    }

    function Fi(a) {
        this.data = a;
        this.model = null;
        this.materials = [];
        this.textures = [];
        this.animations = [];
        this.registry = null
    }

    function Gi(a, b) {
        this._device = a;
        this._defaultMaterial = b;
        this.maxRetries = 0
    }

    function Hi() {
        this.maxRetries = 0
    }

    function Ii(a, b, c) {
        this._device = a;
        this._registry = b;
        this._loader = c
    }

    function Ji() {}

    function Og(a, b) {
        this.type = b ? b.type || "msdf" : "msdf";
        this.em = 1;
        this.textures = a;
        this.intensity = 0;
        this._data = null;
        this.data = b
    }

    function Ki(a) {
        3 > a.version && (2 > a.version && (a.info.maps = a.info.maps || [{
            width: a.info.width,
            height: a.info.height
        }]), a.chars = Object.keys(a.chars || {}).reduce(function(b, c) {
            var d = a.chars[c];
            c = void 0 !==
                d.letter ? d.letter : vc.fromCodePoint(c);
            2 > a.version && (d.map = d.map || 0);
            b[c] = d;
            return b
        }, {}), a.version = 3);
        return a
    }

    function Li(a) {
        this._loader = a;
        this.maxRetries = 0
    }

    function Eb(a, b) {
        M.call(this);
        this._assets = [];
        this._registry = b;
        this._loaded = !1;
        this._total = this._count = 0;
        this._failed = [];
        this._waitingAssets = [];
        if (a.length && a[0] instanceof aa) this._assets = a;
        else
            for (var c = 0; c < a.length; c++) {
                var d = b.get(a[c]);
                d ? this._assets.push(d) : (this._waitForAsset(a[c]), this._total++)
            }
    }

    function Pg(a, b) {
        this._node = a;
        this._data =
            b
    }

    function Qg(a, b) {
        this._app = a;
        this._isTemplate = b
    }

    function Mi(a) {
        this._app = a;
        this.maxRetries = 0
    }

    function Ni() {
        this.maxRetries = 0
    }

    function Oi() {
        this.maxRetries = 0
    }

    function wc(a, b, c, d, e) {
        this.propertyName = a;
        this.parent = b;
        this._scope = e;
        this._registry = c;
        this.asset = this.url = this.id = null;
        this._onAssetLoad = d.load;
        this._onAssetAdd = d.add;
        this._onAssetRemove = d.remove
    }

    function Ef() {
        this.valid = this.removeInvalid = !0;
        this.enumValidators = {
            occludeSpecular: this._createEnumValidator([0, 1, 2]),
            cull: this._createEnumValidator([0,
                1, 2, 3
            ]),
            blendType: this._createEnumValidator([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
            shadingModel: this._createEnumValidator([0, 1])
        }
    }

    function xe() {
        this._validator = null
    }

    function Pi(a) {
        this._assets = a.assets;
        this._device = a.graphicsDevice;
        this._placeholderTextures = null;
        this._parser = new xe;
        this.maxRetries = 0
    }

    function al(a) {
        this._device = a;
        this._defaultMaterial = ea.getApplication().scene.defaultMaterial
    }

    function Xn() {
        this.index = 0;
        this.boneIndices = [0, 0, 0, 0]
    }

    function bl() {
        this.indexCount = this.indexStart = this.vertexCount = this.vertexStart =
            this.partition = 0;
        this.boneIndices = [];
        this.vertices = [];
        this.indices = [];
        this.indexMap = {}
    }

    function Yn(a) {
        var b = a.vertices,
            c = a.skins,
            d = a.meshes,
            e = a.meshInstances;
        for (a = 0; a < d.length; a++) d[a].vertices = b[d[a].vertices], void 0 !== d[a].skin && (d[a].skin = c[d[a].skin]);
        for (a = 0; a < e.length; a++) e[a].mesh = d[e[a].mesh]
    }

    function Zn(a) {
        var b = a.vertices,
            c = a.skins,
            d = a.meshes,
            e = a.meshInstances;
        for (a = 0; a < d.length; a++) d[a].vertices = b.indexOf(d[a].vertices), void 0 !== d[a].skin && (d[a].skin = c.indexOf(d[a].skin));
        for (a = 0; a < e.length; a++) e[a].mesh =
            d.indexOf(e[a].mesh)
    }

    function cl(a, b, c) {
        var d, e;
        Yn(a);
        var f = a.vertices,
            g = a.skins,
            k = a.meshes,
            h = a.meshInstances,
            l = function(C) {
                var G = new Xn;
                G.index = C;
                return G
            };
        for (d = g.length - 1; 0 <= d; d--)
            if (g[d].boneNames.length > c) {
                var n = g.splice(d, 1)[0],
                    p = [];
                for (e = 0; e < k.length; e++) k[e].skin === n && p.push(k[e]);
                for (e = 0; e < p.length; e++) {
                    var q = k.indexOf(p[e]); - 1 !== q && k.splice(q, 1)
                }
                if (0 === p.length) throw Error("partitionSkin: There should be at least one mesh that references a skin");
                var r = p[0].vertices;
                for (e = 1; e < p.length; e++)
                    if (p[e].vertices !==
                        r) throw Error("partitionSkin: All meshes that share a skin should also share the same vertex buffer");
                var t = [],
                    u = [];
                var x = [];
                var v = 0;
                for (e = 0; e < p.length; e++) {
                    var w = p[e];
                    for (var y = w.indices, A = w.base; A < w.base + w.count;) {
                        q = y[A++];
                        u[0] = l(q);
                        x[0] = q;
                        q = y[A++];
                        u[1] = l(q);
                        x[1] = q;
                        q = y[A++];
                        u[2] = l(q);
                        x[2] = q;
                        for (var B = !1, E = v; E < t.length; E++)
                            if (q = t[E], q.addPrimitive(u, x, r, c)) {
                                B = !0;
                                break
                            }
                        B || (q = new bl, q.originalMesh = w, q.addPrimitive(u, x, r, c), t.push(q))
                    }
                    v = t.length
                }
                w = [];
                p = [];
                for (e = 0; e < t.length; e++)
                    if (q = t[e], q.vertices.length &&
                        q.indices.length) {
                        u = w.length;
                        x = q.vertices.length;
                        v = p.length;
                        y = q.indices.length;
                        q.partition = e;
                        q.vertexStart = u;
                        q.vertexCount = x;
                        q.indexStart = v;
                        q.indexCount = y;
                        A = 0;
                        for (B = u; A < x;) w[B++] = q.vertices[A++];
                        A = 0;
                        for (B = v; A < y;) p[B++] = q.indices[A++] + u
                    }
                u = [];
                for (e = 0; e < t.length; e++) {
                    q = t[e];
                    v = [];
                    y = [];
                    for (x = 0; x < q.boneIndices.length; x++) v.push(n.inverseBindMatrices[q.boneIndices[x]]), y.push(n.boneNames[q.boneIndices[x]]);
                    q = {
                        inverseBindMatrices: v,
                        boneNames: y
                    };
                    u.push(q);
                    g.push(q)
                }
                var D;
                n = {};
                for (D in r) n[D] = {
                    components: r[D].components,
                    data: [],
                    type: r[D].type
                };
                for (D in r)
                    if ("blendIndices" === D)
                        for (q = n[D].data, e = 0; e < w.length; e++) x = w[e].boneIndices, q.push(x[0], x[1], x[2], x[3]);
                    else
                        for (e = r[D], v = e.data, y = e.components, e = 0; e < w.length; e++)
                            for (q = w[e].index, x = 0; x < y; x++) n[D].data.push(v[q * y + x]);
                f[f.indexOf(r)] = n;
                for (e = 0; e < t.length; e++)
                    for (q = t[e], w = {
                            aabb: {
                                min: [0, 0, 0],
                                max: [0, 0, 0]
                            },
                            vertices: n,
                            skin: u[e],
                            indices: p.splice(0, q.indexCount),
                            type: "triangles",
                            base: 0,
                            count: q.indexCount
                        }, k.push(w), x = h.length - 1; 0 <= x; x--) h[x].mesh === q.originalMesh && (h.push({
                        mesh: w,
                        node: h[x].node
                    }), b && b.push({
                        material: b[x].material,
                        path: b[x].path
                    }));
                for (e = 0; e < t.length; e++)
                    for (q = t[e], x = h.length - 1; 0 <= x; x--) h[x].mesh === q.originalMesh && (h.splice(x, 1), b && b.splice(x, 1))
            }
        Zn(a)
    }

    function dl(a) {
        this._device = a;
        this._defaultMaterial = ea.getApplication().scene.defaultMaterial
    }

    function Qi(a, b) {
        this._device = a;
        this._parsers = [];
        this._defaultMaterial = b;
        this.maxRetries = 0;
        this.addParser(new dl(this._device), function(c, d) {
            return ".json" === ca.getExtension(c)
        });
        this.addParser(new al(this._device), function(c,
            d) {
            return ".glb" === ca.getExtension(c)
        })
    }

    function Ri(a) {
        this._handlers = {};
        this._requests = {};
        this._cache = {};
        this._app = a
    }

    function Si(a) {
        this._app = a;
        this.maxRetries = 0
    }

    function Ti(a) {
        this._app = a;
        this.maxRetries = 0
    }

    function ub(a) {
        this._app = a;
        this._scripts = {};
        this._cache = {}
    }

    function Ui() {
        this.maxRetries = 0
    }

    function Sa(a, b) {
        M.call(this);
        this._device = a;
        this._pixelsPerUnit = b && void 0 !== b.pixelsPerUnit ? b.pixelsPerUnit : 1;
        this._renderMode = b && void 0 !== b.renderMode ? b.renderMode : 0;
        this._atlas = b && void 0 !== b.atlas ? b.atlas :
            null;
        this._frameKeys = b && void 0 !== b.frameKeys ? b.frameKeys : null;
        this._meshes = [];
        this._meshesDirty = this._updatingProperties = !1;
        this._atlas && this._frameKeys && this._createMeshes()
    }

    function Vi(a, b) {
        this._assets = a;
        this._device = b;
        this.maxRetries = 0
    }

    function Wi(a) {
        this.resource && (this.resource.atlas = a.resource)
    }

    function Xi(a) {
        this.registry.load(a)
    }

    function Rg(a, b) {
        this._app = a;
        this._data = b;
        this._templateRoot = null
    }

    function Yi(a) {
        this._app = a
    }

    function Zi() {
        this.maxRetries = 0
    }

    function xc() {
        M.call(this);
        this._frames =
            this._texture = null
    }

    function $i(a) {
        this._loader = a;
        this.maxRetries = 0
    }

    function $n() {
        var a = {
                astc: 10,
                dxt: 2,
                etc2: 0,
                etc1: 0,
                pvr: 8,
                atc: 11,
                none: 14
            },
            b = {
                astc: 10,
                dxt: 3,
                etc2: 1,
                etc1: 16,
                pvr: 9,
                atc: 12,
                none: 16
            },
            c = {
                0: 21,
                1: 23,
                2: 8,
                3: 10,
                8: 26,
                9: 27,
                10: 28,
                11: 29,
                12: 30,
                13: 7,
                14: 3,
                16: 5
            },
            d = "undefined" !== typeof performance,
            e = function(l, n, p, q, r) {
                var t = d ? performance.now() : 0,
                    u = new l.BasisFile(new Uint8Array(q));
                l = u.getImageWidth(0, 0);
                q = u.getImageHeight(0, 0);
                var x = u.getNumImages(),
                    v = u.getNumLevels(0),
                    w = !!u.getHasAlpha();
                if (!(l && q &&
                        x && v)) throw u.close(), u.delete(), Error("Invalid image dimensions url=" + n + " width=" + l + " height=" + q + " images=" + x + " levels=" + v);
                p = w ? b[p] : a[p];
                if (8 === p || 9 === p)
                    if (0 !== (l & l - 1) || l !== q) p = 8 === p ? 14 : 13;
                r && r.unswizzleGGGR && (p = 13);
                if (!u.startTranscoding()) throw u.close(), u.delete(), Error("Failed to start transcoding url=" + n);
                w = [];
                for (var y = 0; y < v; ++y) {
                    var A = u.getImageTranscodedSizeInBytes(0, y, p),
                        B = new Uint8Array(A);
                    if (!u.transcodeImage(B, 0, y, p, 1, 0)) throw u.close(), u.delete(), Error("Failed to transcode image url=" +
                        n);
                    if (14 === p || 16 === p) {
                        var E = new Uint16Array(A / 2);
                        for (x = 0; x < A / 2; ++x) E[x] = B[2 * x] + 256 * B[2 * x + 1];
                        B = E
                    }
                    w.push(B)
                }
                u.close();
                u.delete();
                if (r && r.unswizzleGGGR)
                    for (p = 14, x = 0; x < w.length; ++x) {
                        r = x;
                        u = w[x];
                        for (v = 0; v < u.length; v += 4) A = u[v + 3], y = u[v + 1], u[v + 0] = A, A = 2 / 255 * A - 1, y = 2 / 255 * y - 1, u[v + 2] = Math.max(0, Math.min(255, Math.floor(127.5 * (Math.sqrt(1 - Math.min(1, A * A + y * y)) + 1)))), u[v + 3] = 255;
                        v = new Uint16Array(u.length / 4);
                        for (y = 0; y < u.length; y += 4) v[y / 4] = (u[y + 0] & 248) << 8 | (u[y + 1] & 252) << 3 | u[y + 2] >> 3;
                        w[r] = v
                    }
                return {
                    format: c[p],
                    width: l + 3 &
                        -4,
                    height: q + 3 & -4,
                    levels: w,
                    cubemap: !1,
                    mipmaps: !0,
                    transcodeTime: d ? performance.now() - t : 0,
                    url: n
                }
            },
            f = null,
            g = [],
            k = function(l, n, p, q) {
                try {
                    var r = e(f, l, n, p, q);
                    r.levels = r.levels.map(function(t) {
                        return t.buffer
                    });
                    self.postMessage({
                        url: l,
                        data: r
                    }, r.levels)
                } catch (t) {
                    self.postMessage({
                        url: l.toString(),
                        err: t.toString()
                    })
                }
            },
            h = function(l) {
                var n = function(p, q) {
                    WebAssembly.instantiate(l, p).then(function(r) {
                        q(r)
                    });
                    return {}
                };
                self.BASIS(l ? {
                    instantiateWasm: n
                } : null).then(function(p) {
                    f = p;
                    f.initializeBasis();
                    for (p = 0; p < g.length; ++p) k(g[p].url,
                        g[p].format, g[p].data, g[p].options);
                    g = []
                })
            };
        self.onmessage = function(l) {
            l = l.data;
            switch (l.type) {
                case "init":
                    h(l.module);
                    break;
                case "transcode":
                    f ? k(l.url, l.format, l.data, l.options) : g.push(l)
            }
        }
    }

    function aj() {
        if (!bj) {
            var a = ea.getApplication().graphicsDevice;
            bj = a.extCompressedTextureASTC ? "astc" : a.extCompressedTextureS3TC ? "dxt" : a.extCompressedTextureETC ? "etc2" : a.extCompressedTextureETC1 ? "etc1" : a.extCompressedTexturePVRTC ? "pvr" : a.extCompressedTextureATC ? "atc" : "none"
        }
        return bj
    }

    function ao(a) {
        var b = a.data.url,
            c = a.data.err;
        a = a.data.data;
        var d = Ff[b];
        if (d) {
            var e;
            if (c)
                for (e = 0; e < d.length; ++e) d[e](c);
            else {
                a.levels = 3 === a.format || 5 === a.format ? a.levels.map(function(f) {
                    return new Uint16Array(f)
                }) : a.levels.map(function(f) {
                    return new Uint8Array(f)
                });
                for (e = 0; e < d.length; ++e) d[e](null, a);
                delete Ff[b]
            }
        } else console.error("internal logical error encountered in basis transcoder")
    }

    function el(a, b, c, d) {
        Ff.hasOwnProperty(a) ? Ff[a].push(c) : (Ff[a] = [c], Gf.postMessage({
            type: "transcode",
            url: a,
            format: aj(),
            data: b,
            options: d
        }, [b]))
    }

    function cj(a, b, c) {
        a = ["/* basis.js */", a, "/* mappings */\nvar PIXELFORMAT_ETC1 = 21;\nvar PIXELFORMAT_ETC2_RGBA = 23;\nvar PIXELFORMAT_DXT1 = 8;\nvar PIXELFORMAT_DXT5 = 10;\nvar PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;\nvar PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;\nvar PIXELFORMAT_ASTC_4x4 = 28;\nvar PIXELFORMAT_ATC_RGB = 29;\nvar PIXELFORMAT_ATC_RGBA = 30;\nvar PIXELFORMAT_R8_G8_B8_A8 = 7;\nvar PIXELFORMAT_R5_G6_B5 = 3;\nvar PIXELFORMAT_R4_G4_B4_A4 = 5;\n\n/* worker */", "(" + $n.toString() + ")()\n\n"].join("\n");
        a = new Blob([a], {
            type: "application/javascript"
        });
        a = URL.createObjectURL(a);
        Gf = new Worker(a);
        Gf.addEventListener("message", ao);
        Gf.postMessage({
            type: "init",
            module: b
        });
        c && c();
        for (b = 0; b < dj.length; ++b) c = dj[b], el(c.url, c.data, c.callback, c.options)
    }

    function ej(a, b, c, d) {
        fj && console.warn("basis module is being downloaded more than once");
        fj = !0;
        if (bo) {
            var e = null,
                f = null,
                g = function() {
                    e && f && cj(e, f, d)
                },
                k = function() {
                    wa.get(b, {
                        cache: !0,
                        responseType: "arraybuffer",
                        retry: !1
                    }, function(h, l) {
                        l && WebAssembly.compile(l).then(function(n) {
                            f =
                                n;
                            g()
                        })
                    })
                };
            WebAssembly.compileStreaming ? WebAssembly.compileStreaming(fetch(b)).then(function(h) {
                f = h;
                g()
            }).catch(function(h) {
                console.error(h);
                console.warn("compileStreaming() failed for " + b + ", falling back to arraybuffer download...");
                k()
            }) : k();
            wa.get(a, {
                cache: !0,
                responseType: "text",
                retry: !1
            }, function(h, l) {
                e = l;
                g()
            })
        } else wa.get(c, {
            cache: !0,
            responseType: "text",
            retry: !1
        }, function(h, l) {
            l && cj(l, null, d)
        })
    }

    function fl(a) {
        if (Hf) ej(Hf.glueUrl, Hf.wasmUrl, Hf.fallbackUrl, a);
        else {
            var b = ((window.config ? window.config.wasmModules :
                window.PRELOAD_MODULES) || []).find(function(d) {
                return "BASIS" === d.moduleName
            });
            if (b) {
                var c = window.ASSET_PREFIX ? window.ASSET_PREFIX : "";
                ej(c + b.glueUrl, c + b.wasmUrl, c + b.fallbackUrl, a)
            }
        }
    }

    function gl(a, b, c, d) {
        Gf ? el(a, b, c, d) : (dj.push({
            url: a,
            data: b,
            callback: c,
            options: d
        }), fj || fl())
    }

    function gj(a) {
        this.maxRetries = 0
    }

    function hj(a) {
        this.crossOrigin = a.prefix ? "anonymous" : null;
        this.maxRetries = 0;
        this.useImageBitmap = !1
    }

    function ij(a) {
        this.maxRetries = 0
    }

    function jj(a) {
        this.maxRetries = 0
    }

    function hl() {}

    function Sg(a, b,
        c) {
        this._device = a;
        this._assets = b;
        this._loader = c;
        this.imgParser = new hj(b);
        this.parsers = {
            dds: new jj(b),
            ktx: new ij(b),
            basis: new gj(b)
        }
    }

    function Nd(a) {
        M.call(this);
        this._loader = a;
        this._assets = [];
        this._cache = {};
        this._names = {};
        this._tags = new Bk("_id");
        this._urls = {};
        this.prefix = null
    }

    function kj(a) {
        this._assets = a;
        this._bundleAssets = {};
        this._assetsInBundles = {};
        this._urlsInBundles = {};
        this._fileRequests = {};
        this._assets.on("add", this._onAssetAdded, this);
        this._assets.on("remove", this._onAssetRemoved, this)
    }

    function fc(a) {
        M.call(this);
        this.app = a;
        this._scripts = {};
        this._list = []
    }

    function Od(a, b) {
        M.call(this);
        var c = this;
        this._app = a;
        this._device = a.graphicsDevice;
        this.id = b.displayId;
        this._frameData = null;
        window.VRFrameData && (this._frameData = new window.VRFrameData);
        this.display = b;
        this._camera = null;
        this.sitToStandInv = new J;
        this.leftView = new J;
        this.leftProj = new J;
        this.leftViewInv = new J;
        this.leftPos = new z;
        this.rightView = new J;
        this.rightProj = new J;
        this.rightViewInv = new J;
        this.rightPos = new z;
        this.combinedPos = new z;
        this.combinedView = new J;
        this.combinedProj =
            new J;
        this.combinedViewInv = new J;
        this.combinedAspect = this.combinedFov = 0;
        this.presenting = !1;
        c._presentChange = function(d) {
            if ((d.display ? d.display : d.detail && d.detail.display ? d.detail.display : d.detail && d.detail.vrdisplay ? d.detail.vrdisplay : c.display) === c.display) {
                c.presenting = c.display && c.display.isPresenting;
                if (c.presenting) {
                    d = c.display.getEyeParameters("left");
                    var e = c.display.getEyeParameters("right");
                    c._app.graphicsDevice.setResolution(2 * Math.max(d.renderWidth, e.renderWidth), Math.max(d.renderHeight,
                        e.renderHeight));
                    c._app._allowResize = !1
                } else c._app.setCanvasResolution("AUTO"), c._app._allowResize = !0;
                c.fire("beforepresentchange", c);
                c.fire("presentchange", c)
            }
        };
        window.addEventListener("vrdisplaypresentchange", c._presentChange, !1)
    }

    function hd(a) {
        M.call(this);
        var b = this;
        this.isSupported = hd.isSupported;
        this._index = {};
        this.displays = [];
        this.display = null;
        this._app = a;
        this._onDisplayConnect = this._onDisplayConnect.bind(this);
        this._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);
        b._attach();
        this._getDisplays(function(c,
            d) {
            if (c) b.fire("error", c);
            else {
                for (c = 0; c < d.length; c++) b._addDisplay(d[c]);
                b.fire("ready", b.displays)
            }
        })
    }

    function Kc(a, b, c) {
        M.call(this);
        this.manager = a;
        this._xrHitTestSource = b;
        this._transient = c
    }

    function Sb(a) {
        M.call(this);
        this.manager = a;
        this._supported = !(!window.XRSession || !window.XRSession.prototype.requestHitTestSource);
        this._session = null;
        this.sources = [];
        this._supported && (this.manager.on("start", this._onSessionStart, this), this.manager.on("end", this._onSessionEnd, this))
    }

    function If(a, b) {
        this._index =
            a;
        this._hand = b;
        this._hand._fingers.push(this);
        this._joints = [];
        this._tip = null
    }

    function Tb(a, b, c, d) {
        this._index = a;
        this._id = b;
        this._hand = c;
        this._hand._joints.push(this);
        this._hand._jointsById[b] = this;
        (this._finger = d || null) && this._finger._joints.push(this);
        if (this._wrist = b === XRHand.WRIST) this._hand._wrist = this;
        if (this._tip = this._finger && !!il[b]) this._hand._tips.push(this), this._finger && (this._finger._tip = this);
        this._radius = null;
        this._localTransform = new J;
        this._worldTransform = new J;
        this._localPosition =
            new z;
        this._localRotation = new Y;
        this._position = new z;
        this._rotation = new Y;
        this._dirtyLocal = !0
    }

    function gc(a) {
        M.call(this);
        var b = a._xrInputSource.hand;
        this._manager = a._manager;
        this._inputSource = a;
        this._tracking = !1;
        this._fingers = [];
        this._joints = [];
        this._jointsById = {};
        this._tips = [];
        this._wrist = null;
        b[XRHand.WRIST] && (this._wrist = new Tb(0, XRHand.WRIST, this, null));
        for (a = 0; a < Tg.length; a++)
            for (var c = new If(a, this), d = 0; d < Tg[a].length; d++) {
                var e = Tg[a][d];
                b[e] && new Tb(d, e, this, c)
            }
    }

    function ta(a, b) {
        M.call(this);
        this._id = ++co;
        this._manager = a;
        this._xrInputSource = b;
        this._ray = new cd;
        this._rayLocal = new cd;
        this._grip = !1;
        this._hand = null;
        b.hand && (this._hand = new gc(this));
        this._worldTransform = this._localTransform = null;
        this._position = new z;
        this._rotation = new Y;
        this._localRotation = this._localPosition = null;
        this._dirtyLocal = !0;
        this._selecting = !1;
        this._elementInput = !0;
        this._elementEntity = null;
        this._hitTestSources = []
    }

    function Fb(a) {
        M.call(this);
        var b = this;
        this.manager = a;
        this._session = null;
        this._inputSources = [];
        this._onInputSourcesChangeEvt =
            function(c) {
                b._onInputSourcesChange(c)
            };
        this.manager.on("start", this._onSessionStart, this);
        this.manager.on("end", this._onSessionEnd, this)
    }

    function ib(a) {
        M.call(this);
        this._manager = a;
        this._lightProbeRequested = this._available = this._supported = !1;
        this._lightProbe = null;
        this._intensity = 0;
        this._rotation = new Y;
        this._color = new L;
        this._sphericalHarmonics = new Float32Array(27);
        this._manager.on("start", this._onSessionStart, this);
        this._manager.on("end", this._onSessionEnd, this)
    }

    function Pa(a) {
        M.call(this);
        var b =
            this;
        this.app = a;
        this._supported = !!navigator.xr;
        this._available = {};
        this._available[jl] = !1;
        this._available[lj] = !1;
        this._available[Pd] = !1;
        this._referenceSpace = this._baseLayer = this._session = this._spaceType = this._type = null;
        this.input = new Fb(this);
        this.hitTest = new Sb(this);
        this.lightEstimation = new ib(this);
        this._camera = null;
        this.views = [];
        this.viewsPool = [];
        this._localPosition = new z;
        this._localRotation = new Y;
        this._depthNear = .1;
        this._depthFar = 1E3;
        this._height = this._width = 0;
        this._supported && (navigator.xr.addEventListener("devicechange",
            function() {
                b._deviceAvailabilityCheck()
            }), this._deviceAvailabilityCheck())
    }

    function O(a, b) {
        M.call(this);
        this.system = a;
        this.entity = b;
        this.system.schema && !this._accessorsBuilt && this.buildAccessors(this.system.schema);
        this.on("set", function(c, d, e) {
            this.fire("set_" + c, c, d, e)
        });
        this.on("set_enabled", this.onSetEnabled, this)
    }

    function H(a) {
        M.call(this);
        this.app = a;
        this.store = {};
        this.schema = []
    }

    function eo(a, b) {
        if (!a) return a;
        switch (b) {
            case "rgb":
                return a instanceof L ? a.clone() : new L(a[0], a[1], a[2]);
            case "rgba":
                return a instanceof
                L ? a.clone() : new L(a[0], a[1], a[2], a[3]);
            case "vec2":
                return a instanceof P ? a.clone() : new P(a[0], a[1]);
            case "vec3":
                return a instanceof z ? a.clone() : new z(a[0], a[1], a[2]);
            case "vec4":
                return a instanceof X ? a.clone() : new X(a[0], a[1], a[2], a[3]);
            case "boolean":
            case "number":
            case "string":
                return a;
            case "entity":
                return a;
            default:
                throw Error("Could not convert unhandled type: " + b);
        }
    }

    function kl() {
        this._written = !1;
        this._name = "";
        this._keyFrames = [];
        this._quat = new Y;
        this._pos = new z;
        this._scale = new z;
        this._targetNode =
            null
    }

    function Ta(a) {
        function b(d) {
            var e = new kl;
            e._name = d.name;
            c._interpolatedKeys.push(e);
            c._interpolatedKeyDict[d.name] = e;
            for (e = c._currKeyIndices[d.name] = 0; e < d._children.length; e++) b(d._children[e])
        }
        this._animation = null;
        this._time = 0;
        this.looping = !0;
        this._interpolatedKeys = [];
        this._interpolatedKeyDict = {};
        this._currKeyIndices = {};
        this.graph = null;
        var c = this;
        b(a)
    }

    function id(a, b) {
        O.call(this, a, b);
        this.animationsIndex = {};
        this.on("set_animations", this.onSetAnimations, this);
        this.on("set_assets", this.onSetAssets,
            this);
        this.on("set_loop", this.onSetLoop, this)
    }

    function fo() {
        this.assets = [];
        this.speed = 1;
        this.enabled = this.activate = this.loop = !0;
        this.animations = {};
        this.currAnim = this.prevAnim = this.model = null;
        this.blending = !1;
        this.blendSpeed = this.blend = 0;
        this.playing = !1;
        this.animEvaluator = this.toSkel = this.fromSkel = this.skeleton = null
    }

    function ye(a) {
        H.call(this, a);
        this.id = "animation";
        this.ComponentType = id;
        this.DataType = fo;
        this.schema = ll;
        this.on("beforeremove", this.onBeforeRemove, this);
        this.on("update", this.onUpdate,
            this);
        H.bind("update", this.onUpdate, this)
    }

    function Ua(a, b) {
        this.animComponent = a;
        b ? zf.call(this, b) : this.propertyLocator = new wf
    }

    function Ug(a, b, c) {
        this._name = a;
        this._controller = b;
        this._component = c
    }

    function Jf(a, b, c, d, e) {
        this._state = a;
        this._parent = b;
        this._name = c;
        this._point = Array.isArray(d) ? new pc.Vec2(d) : d;
        this._speed = e || 1;
        this._weight = 1;
        this._animTrack = null
    }

    function yc(a, b, c, d, e, f, g, k) {
        Jf.call(this, a, b, c, d);
        this._type = e;
        this._parameters = f;
        this._parameterValues = null;
        this._children = [];
        this._findParameter =
            k;
        for (b = 0; b < g.length; b++) c = g[b], c.children ? this._children.push(new yc(a, this, c.name, c.point, c.type, c.parameter ? [c.parameter] : c.parameters, c.children, k)) : this._children.push(new Jf(a, this, c.name, c.point, c.speed))
    }

    function go(a, b, c, d) {
        var e = Math.min(b, c);
        b = Math.max(b, c);
        return d ? a >= e && a <= b : a > e && a < b
    }

    function ml(a, b) {
        return Math.atan2(a.x * b.y - a.y * b.x, a.x * b.x + a.y * b.y)
    }

    function Vg(a, b, c) {
        return a <= b ? b : a >= c ? c : a
    }

    function mj(a, b, c, d, e) {
        this._controller = a;
        this._name = b;
        this._animations = {};
        this._animationList = [];
        this._speed = c || 1;
        this._loop = void 0 === d ? !0 : d;
        a = this._controller.findParameter.bind(this._controller);
        this._blendTree = e ? new yc(this, null, b, 1, e.type, e.parameter ? [e.parameter] : e.parameters, e.children, a) : new Jf(this, null, b, 1, c)
    }

    function nj(a, b, c, d, e, f, g, k, h) {
        this._controller = a;
        this._from = b;
        this._to = c;
        this._time = d;
        this._priority = e;
        this._conditions = f || [];
        this._exitTime = g || null;
        this._transitionOffset = k || null;
        this._interruptionSource = h || "NONE"
    }

    function Wg(a, b, c, d, e) {
        this._animEvaluator = a;
        this._states = {};
        this._stateNames = [];
        for (a = 0; a < b.length; a++) this._states[b[a].name] = new mj(this, b[a].name, b[a].speed, b[a].loop, b[a].blendTree), this._stateNames.push(b[a].name);
        this._transitions = c.map(function(f) {
            return new nj(this, f.from, f.to, f.time, f.priority, f.conditions, f.exitTime, f.transitionOffset, f.interruptionSource)
        }.bind(this));
        this._findTransitionsFromStateCache = {};
        this._findTransitionsBetweenStatesCache = {};
        this._parameters = d;
        this._previousStateName = null;
        this._activeStateName = "START";
        this._playing = !1;
        this._activate =
            e;
        this._totalTransitionTime = this._currTransitionTime = 1;
        this._isTransitioning = !1;
        this._transitionInterruptionSource = "NONE";
        this._transitionPreviousStates = [];
        this._timeInStateBefore = this._timeInState = 0
    }

    function jd(a, b) {
        O.call(this, a, b)
    }

    function ho() {
        this.stateGraphAsset = null;
        this.animationAssets = {};
        this.speed = 1;
        this.enabled = this.activate = !0;
        this.playing = !1;
        this.stateGraph = null;
        this.layers = [];
        this.layerIndices = {};
        this.parameters = {}
    }

    function ze(a) {
        H.call(this, a);
        this.id = "anim";
        this.ComponentType = jd;
        this.DataType =
            ho;
        this.schema = nl;
        this.on("beforeremove", this.onBeforeRemove, this);
        H.bind("animationUpdate", this.onAnimationUpdate, this)
    }

    function Qd(a, b) {
        O.call(this, a, b)
    }

    function io() {
        this.enabled = !0
    }

    function Ae(a, b) {
        H.call(this, a);
        this.id = "audiolistener";
        this.ComponentType = Qd;
        this.DataType = io;
        this.schema = ol;
        this.manager = b;
        this.current = null;
        H.bind("update", this.onUpdate, this)
    }

    function Rd(a, b) {
        O.call(this, a, b);
        this.on("set_assets", this.onSetAssets, this);
        this.on("set_loop", this.onSetLoop, this);
        this.on("set_volume",
            this.onSetVolume, this);
        this.on("set_pitch", this.onSetPitch, this);
        this.on("set_minDistance", this.onSetMinDistance, this);
        this.on("set_maxDistance", this.onSetMaxDistance, this);
        this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
        this.on("set_distanceModel", this.onSetDistanceModel, this);
        this.on("set_3d", this.onSet3d, this)
    }

    function jo() {
        this.enabled = !0;
        this.assets = [];
        this.activate = !0;
        this.pitch = this.volume = 1;
        this.loop = !1;
        this["3d"] = !0;
        this.minDistance = 1;
        this.maxDistance = 1E4;
        this.rollOffFactor = 1;
        this.distanceModel =
            Kf;
        this.paused = !0;
        this.sources = {};
        this.channel = this.currentSource = null
    }

    function Be(a, b) {
        H.call(this, a);
        this.id = "audiosource";
        this.ComponentType = Rd;
        this.DataType = jo;
        this.schema = pl;
        this.manager = b;
        this.initialized = !1;
        H.bind("initialize", this.onInitialize, this);
        H.bind("update", this.onUpdate, this);
        this.on("remove", this.onRemove, this)
    }

    function Lc(a, b, c) {
        if (a && a instanceof O) {
            if (!b || "string" !== typeof b) throw Error("The propertyName argument is required and must be a string");
            if (c && "object" !== typeof c) throw Error("If provided, the eventConfig argument must be an object");
        } else throw Error("The parentComponent argument is required and must be a Component");
        this._parentComponent = a;
        this._entityPropertyName = b;
        this._entity = null;
        this._app = a.system.app;
        this._configureEventListeners(c || {}, {
            "entity#destroy": this._onEntityDestroy
        });
        this._toggleLifecycleListeners("on")
    }

    function Sd(a, b) {
        O.call(this, a, b);
        this._visualState = Ma.DEFAULT;
        this._isHovering = !1;
        this._hoveringCounter = 0;
        this._isPressed = !1;
        this._defaultTint = new L(1, 1, 1, 1);
        this._defaultSpriteAsset = null;
        this._defaultSpriteFrame =
            0;
        this._imageReference = new Lc(this, "imageEntity", {
            "element#gain": this._onImageElementGain,
            "element#lose": this._onImageElementLose,
            "element#set:color": this._onSetColor,
            "element#set:opacity": this._onSetOpacity,
            "element#set:spriteAsset": this._onSetSpriteAsset,
            "element#set:spriteFrame": this._onSetSpriteFrame
        });
        this._toggleLifecycleListeners("on", a)
    }

    function ko() {
        this.active = this.enabled = !0;
        this.imageEntity = null;
        this.hitPadding = new X;
        this.transitionMode = Xg;
        this.hoverTint = new L(.75, .75, .75);
        this.pressedTint =
            new L(.5, .5, .5);
        this.inactiveTint = new L(.25, .25, .25);
        this.fadeDuration = 0;
        this.hoverSpriteAsset = null;
        this.hoverSpriteFrame = 0;
        this.pressedSpriteAsset = null;
        this.pressedSpriteFrame = 0;
        this.inactiveSpriteAsset = null;
        this.inactiveSpriteFrame = 0
    }

    function Ce(a) {
        H.call(this, a);
        this.id = "button";
        this.ComponentType = Sd;
        this.DataType = ko;
        this.schema = oj;
        this.on("beforeremove", this._onRemoveComponent, this);
        H.bind("update", this.onUpdate, this)
    }

    function Yg(a, b) {
        var c = this;
        this.app = a;
        this.camera = b;
        this.effects = [];
        this.enabled = !1;
        this.depthTarget = null;
        this.renderTargetScale = 1;
        this.resizeTimeout = null;
        this.resizeLast = 0;
        this._resizeTimeoutCallback = function() {
            c.resizeRenderTargets()
        };
        b.on("set_rect", this.onCameraRectChanged, this);
        this._origStencilColorBuffer = this._origDepthColorBuffer = this._origClearColorBuffer = this._origOverrideClear = !1
    }

    function lo() {
        this.enabled = !0
    }

    function mo() {
        this.enabled = !0;
        this.type = "box";
        this.halfExtents = new z(.5, .5, .5);
        this.radius = .5;
        this.axis = 1;
        this.height = 2;
        this.model = this.shape = this.asset = null;
        this.initialized = !1
    }

    function pj(a, b, c) {
        this.entity = b.entity;
        this.component = b;
        this.app = a;
        "undefined" === typeof Ammo || Mc || (Mc = new Ammo.btVector3, Lf = new Ammo.btQuaternion, De = new Ammo.btTransform);
        this.initialize(c)
    }

    function qj() {
        this.list = []
    }

    function Td(a) {
        this.func = void 0 === a.func ? 7 : a.func;
        this.ref = a.ref || 0;
        this.readMask = void 0 === a.readMask ? 255 : a.readMask;
        this.writeMask = void 0 === a.writeMask ? 255 : a.writeMask;
        this.fail = a.fail || 0;
        this.zfail = a.zfail || 0;
        this.zpass = a.zpass || 0
    }

    function yb(a, b, c) {
        this._entity =
            a;
        this._element = a.element;
        this.model = new tb;
        this.node = new Z;
        this.model.graph = this.node;
        this.mesh = b;
        this.meshInstance = new va(this.node, this.mesh, c);
        this.meshInstance.name = "ImageElement: " + a.name;
        this.meshInstance.castShadow = !1;
        this._meshDirty = this.meshInstance.receiveShadow = !1;
        this.model.meshInstances.push(this.meshInstance);
        this._entity.addChild(this.model.graph);
        this.model._entity = this._entity;
        this.unmaskMeshInstance = null
    }

    function cb(a) {
        this._element = a;
        this._entity = a.entity;
        this._system = a.system;
        this._sprite = this._spriteAsset = this._material = this._materialAsset = this._texture = this._textureAsset = null;
        this._spriteFrame = 0;
        this._pixelsPerUnit = null;
        this._rect = new X(0, 0, 1, 1);
        this._mask = !1;
        this._maskRef = 0;
        this._outerScale = new P;
        this._outerScaleUniform = new Float32Array(2);
        this._innerOffset = new X;
        this._innerOffsetUniform = new Float32Array(4);
        this._atlasRect = new X;
        this._atlasRectUniform = new Float32Array(4);
        this._defaultMesh = this._createMesh();
        this._renderable = new yb(this._entity, this._defaultMesh, this._material);
        this._color = new L(1, 1, 1, 1);
        this._colorUniform = new Float32Array([1, 1, 1]);
        this._renderable.setParameter("material_emissive", this._colorUniform);
        this._renderable.setParameter("material_opacity", 1);
        this._updateAabbFunc = this._updateAabb.bind(this);
        this._onScreenChange(this._element.screen);
        this._element.on("resize", this._onParentResizeOrPivotChange, this);
        this._element.on("set:pivot", this._onParentResizeOrPivotChange, this);
        this._element.on("screen:set:screenspace", this._onScreenSpaceChange, this);
        this._element.on("set:screen",
            this._onScreenChange, this);
        this._element.on("set:draworder", this._onDrawOrderChange, this);
        this._element.on("screen:set:resolution", this._onResolutionChange, this)
    }

    function Ha(a) {
        M.call(this);
        this._app = a;
        a.i18n.on("set:locale", this._onSetLocale, this);
        this._disableLocalization = this._autoLoad = !1;
        this._localizedAsset = this._defaultAsset = null
    }

    function ql(a) {
        this._symbols = a;
        this._last = this._index = 0;
        this._cur = 0 < this._symbols.length ? this._symbols[0] : null;
        this._buf = [];
        this._mode = "text";
        this._error = null
    }

    function rl(a,
        b) {
        for (var c in b)
            if (b.hasOwnProperty(c)) {
                var d = b[c];
                d instanceof Object ? (a.hasOwnProperty(c) || (a[c] = {}), rl(a[c], b[c])) : a[c] = d
            }
    }

    function no(a) {
        if (0 === a.length) return null;
        for (var b = {}, c = 0; c < a.length; ++c) {
            var d = a[c],
                e = {};
            e[d.name] = {
                value: d.value,
                attributes: d.attributes
            };
            rl(b, e)
        }
        return b
    }

    function oo(a, b) {
        function c(l) {
            k = k.filter(function(n) {
                return void 0 === l.find(function(p) {
                    return p === n
                })
            })
        }

        function d(l) {
            for (var n = 0; n < l.length; ++n) k.push(l[n])
        }
        var e;
        if (0 === a.length) return null;
        var f = {};
        for (e = 0; e < a.length; ++e) {
            var g =
                a[e];
            f.hasOwnProperty(g.start) ? null === f[g.start].open ? f[g.start].open = [g] : f[g.start].open.push(g) : f[g.start] = {
                open: [g],
                close: null
            };
            f.hasOwnProperty(g.end) ? null === f[g.end].close ? f[g.end].close = [g] : f[g.end].close.push(g) : f[g.end] = {
                open: null,
                close: [g]
            }
        }
        var k = [];
        g = Object.keys(f).sort(function(l, n) {
            return l - n
        });
        a = [];
        for (e = 0; e < g.length; ++e) {
            var h = f[g[e]];
            null !== h.close && c(h.close);
            null !== h.open && d(h.open);
            a.push({
                start: g[e],
                tags: no(k)
            })
        }
        f = [];
        g = null;
        for (e = 0; e < a.length; ++e) {
            for (h = a[e]; f.length < h.start;) f.push(g ?
                g.tags : null);
            g = h
        }
        for (; f.length < b;) f.push(null);
        return f
    }

    function po(a) {
        var b = new sl(a),
            c = [],
            d = [];
        if (!b.parse(c, d)) return console.warn(b.error()), {
            symbols: a,
            tags: null
        };
        if (b = d.find(function(e) {
                return null === e.end
            })) return console.warn("Markup error: found unclosed tag='" + b.name + "'"), {
            symbols: a,
            tags: null
        };
        a = oo(d, c.length);
        return {
            symbols: c,
            tags: a
        }
    }

    function tl() {}

    function qo() {
        this.quad = this.count = 0;
        this.lines = {};
        this.positions = [];
        this.normals = [];
        this.uvs = [];
        this.colors = [];
        this.indices = [];
        this.meshInstance =
            null
    }

    function na(a) {
        this._element = a;
        this._system = a.system;
        this._entity = a.entity;
        this._text = "";
        this._symbols = [];
        this._colorPalette = [];
        this._i18nKey = this._symbolColors = null;
        this._fontAsset = new Ha(this._system.app);
        this._fontAsset.disableLocalization = !0;
        this._fontAsset.on("load", this._onFontLoad, this);
        this._fontAsset.on("change", this._onFontChange, this);
        this._fontAsset.on("remove", this._onFontRemove, this);
        this._font = null;
        this._color = new L(1, 1, 1, 1);
        this._colorUniform = new Float32Array(3);
        this._spacing =
            1;
        this._fontSize = 32;
        this._fontMaxY = this._fontMinY = 0;
        this._maxFontSize = this._originalFontSize = 32;
        this._minFontSize = 8;
        this._autoFitHeight = this._autoFitWidth = !1;
        this._maxLines = -1;
        this._scaledLineHeight = this._lineHeight = 32;
        this._wrapLines = !1;
        this._drawOrder = 0;
        this._alignment = new P(.5, .5);
        this._autoHeight = this._autoWidth = !0;
        this.height = this.width = 0;
        this._node = new Z;
        this._model = new tb;
        this._model.graph = this._node;
        this._entity.addChild(this._node);
        this._meshInfo = [];
        this._material = null;
        this._aabbDirty = !0;
        this._aabb = new oa;
        this._noResize = !1;
        this._maskedMaterialSrc = this._currentMaterialType = null;
        this._rtl = this._unicodeConverter = this._rtlReorder = !1;
        this._outlineColor = new L(0, 0, 0, 1);
        this._outlineColorUniform = new Float32Array(4);
        this._outlineThicknessScale = .2;
        this._outlineThickness = 0;
        this._shadowColor = new L(0, 0, 0, 1);
        this._shadowColorUniform = new Float32Array(4);
        this._shadowOffsetScale = .005;
        this._shadowOffset = new P(0, 0);
        this._shadowOffsetUniform = new Float32Array(2);
        this._enableMarkup = !1;
        this._onScreenChange(this._element.screen);
        a.on("resize", this._onParentResize, this);
        a.on("set:screen", this._onScreenChange, this);
        a.on("screen:set:screenspace", this._onScreenSpaceChange, this);
        a.on("set:draworder", this._onDrawOrderChange, this);
        a.on("set:pivot", this._onPivotChange, this);
        this._system.app.i18n.on("set:locale", this._onLocaleSet, this);
        this._system.app.i18n.on("data:add", this._onLocalizationData, this);
        this._system.app.i18n.on("data:remove", this._onLocalizationData, this);
        this._rangeEnd = this._rangeStart = 0
    }

    function ia(a, b) {
        O.call(this,
            a, b);
        this._beingInitialized = !1;
        this._anchor = new X;
        this._localAnchor = new X;
        this._pivot = new P;
        this._height = this._calculatedHeight = this._width = this._calculatedWidth = 32;
        this._margin = new X(0, 0, -32, -32);
        this._modelTransform = new J;
        this._screenToWorld = new J;
        this._anchorTransform = new J;
        this._anchorDirty = !0;
        this._parentWorldTransform = new J;
        this._screenTransform = new J;
        this._screenCorners = [new z, new z, new z, new z];
        this._canvasCorners = [new P, new P, new P, new P];
        this._worldCorners = [new z, new z, new z, new z];
        this._worldCornersDirty =
            this._canvasCornersDirty = this._cornersDirty = !0;
        this.entity.on("insert", this._onInsert, this);
        this._patch();
        this.screen = null;
        this._type = ul;
        this._group = this._text = this._image = null;
        this._drawOrder = 0;
        this._useInput = !1;
        this._layers = [4];
        this._addedModels = [];
        this._batchGroupId = -1;
        this._offsetReadAt = 0;
        this._maskOffset = .5;
        this._maskedBy = null
    }

    function ro() {
        this.enabled = !0
    }

    function Ee(a) {
        H.call(this, a);
        this.id = "element";
        this.ComponentType = ia;
        this.DataType = ro;
        this.schema = vl;
        this._rtlReorder = this._unicodeConverter =
            null;
        this._defaultTexture = new V(a.graphicsDevice, {
            width: 1,
            height: 1,
            format: 7
        });
        this._defaultTexture.name = "element-system";
        a = this._defaultTexture.lock();
        var b = new Uint8Array(4);
        b[0] = 255;
        b[1] = 255;
        b[2] = 255;
        b[3] = 255;
        a.set(b);
        this._defaultTexture.unlock();
        this.defaultScreenSpaceBitmapTextMaterial = this.defaultScreenSpaceTextMaterial = this.defaultBitmapTextMaterial = this.defaultTextMaterial = this.defaultScreenSpaceImageMaskMaterial = this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImageMask9SlicedMaterial =
            this.defaultScreenSpaceImage9TiledMaterial = this.defaultScreenSpaceImage9SlicedMaterial = this.defaultScreenSpaceImageMaterial = this.defaultImage9TiledMaskMaterial = this.defaultImage9SlicedMaskMaterial = this.defaultImageMaskMaterial = this.defaultImage9TiledMaterial = this.defaultImage9SlicedMaterial = this.defaultImageMaterial = null;
        this.defaultImageMaterials = [];
        this.on("beforeremove", this.onRemoveComponent, this)
    }

    function Ud(a, b) {
        O.call(this, a, b);
        this._minHeight = this._minWidth = 0;
        this._maxHeight = this._maxWidth =
            null;
        this._fitHeightProportion = this._fitWidthProportion = 0;
        this._excludeFromLayout = !1
    }

    function Vd(a) {
        var b = "_" + a;
        Object.defineProperty(Ud.prototype, a, {
            get: function() {
                return this[b]
            },
            set: function(c) {
                this[b] !== c && (this[b] = c, this.fire("resize"))
            }
        })
    }

    function so() {
        this.enabled = !0
    }

    function rj() {}

    function wl(a) {
        function b(w) {
            w = w.entity.layoutchild;
            return !w || !w.enabled || !w.excludeFromLayout
        }

        function c(w, y, A) {
            switch (w) {
                case sj:
                    return zb.NONE;
                case 1:
                    return y < A ? zb.APPLY_STRETCHING : zb.NONE;
                case 2:
                    return y >= A ?
                        zb.APPLY_SHRINKING : zb.NONE;
                case 3:
                    return y < A ? zb.APPLY_STRETCHING : y >= A ? zb.APPLY_SHRINKING : zb.NONE;
                default:
                    throw Error("Unrecognized fitting mode: " + w);
            }
        }

        function d(w, y) {
            return l(w, y.size) + (w.length - 1) * u.spacing[y.axis]
        }

        function e(w, y, A) {
            var B = p(w, A.maxSize),
                E = n(w, A.fittingProportion),
                D = t(E, B);
            y = Gb[A.axis] - y;
            for (var C = 0; C < w.length; ++C) {
                var G = B[C],
                    K = g(G, y, E, D),
                    R = w[G][A.size] + K,
                    I = Math.min(R, w[G][A.maxSize]);
                w[G][A.size] = I;
                y -= K - Math.max(R - I, 0)
            }
        }

        function f(w, y, A) {
            var B = p(w, A.minSize, !0);
            var E = n(w, A.fittingProportion);
            if (1 === E.length) E = [1];
            else {
                for (var D = [], C = E.length, G = 0; G < C; ++G) D.push((1 - E[G]) / (C - 1));
                E = D
            }
            D = t(E, B);
            y -= Gb[A.axis];
            for (C = 0; C < w.length; ++C) {
                G = B[C];
                var K = g(G, y, E, D),
                    R = w[G][A.size] - K,
                    I = Math.max(R, w[G][A.minSize]);
                w[G][A.size] = I;
                y -= K - Math.max(I - R, 0)
            }
        }

        function g(w, y, A, B) {
            A = A[w];
            w = B[w];
            return 1E-5 > Math.abs(A) && 1E-5 > Math.abs(w) ? y : y * A / w
        }

        function k(w) {
            for (var y = [], A = 0; A < w.length; ++A) {
                var B = w[A],
                    E = Math.max(h(B, "minWidth"), 0),
                    D = Math.max(h(B, "minHeight"), 0),
                    C = Math.max(h(B, "maxWidth"), E),
                    G = Math.max(h(B, "maxHeight"),
                        D);
                var K = h(B, "width");
                K = Math.min(Math.max(K, E), C);
                var R = h(B, "height");
                R = Math.min(Math.max(R, D), G);
                var I = h(B, "fitWidthProportion");
                B = h(B, "fitHeightProportion");
                y.push({
                    minWidth: E,
                    minHeight: D,
                    maxWidth: C,
                    maxHeight: G,
                    width: K,
                    height: R,
                    fitWidthProportion: I,
                    fitHeightProportion: B
                })
            }
            return y
        }

        function h(w, y) {
            var A = w.entity.layoutchild;
            return A && A.enabled && void 0 !== A[y] && null !== A[y] ? A[y] : void 0 !== w[y] ? w[y] : to[y]
        }

        function l(w, y) {
            return w.reduce(function(A, B) {
                return A + B[y]
            }, 0)
        }

        function n(w, y) {
            var A = l(w, y),
                B = [],
                E = w.length,
                D;
            if (0 === A)
                for (D = 0; D < E; ++D) B.push(1 / E);
            else
                for (D = 0; D < E; ++D) B.push(w[D][y] / A);
            return B
        }

        function p(w, y, A) {
            w.forEach(q);
            return w.slice().sort(function(B, E) {
                return A ? E[y] - B[y] : B[y] - E[y]
            }).map(r)
        }

        function q(w, y) {
            w.index = y
        }

        function r(w) {
            return w.index
        }

        function t(w, y) {
            var A = [];
            A[y[w.length - 1]] = w[y[w.length - 1]];
            for (var B = w.length - 2; 0 <= B; --B) A[y[B]] = A[y[B + 1]] + w[y[B]];
            return A
        }
        var u, x = xl[a],
            v = xl[uo[a]];
        return function(w, y) {
            w = w.filter(b);
            u = y;
            Gb.x = u.containerSize.x - u.padding.x - u.padding.z;
            Gb.y = u.containerSize.y -
                u.padding.y - u.padding.w;
            y = w;
            for (var A = 0; A < y.length; ++A) {
                var B = y[A],
                    E = B.anchor;
                if (0 !== E.x || 0 !== E.y || 0 !== E.z || 0 !== E.w) B.anchor = X.ZERO
            }
            if (u.wrap) {
                y = [
                    []
                ];
                A = k(w);
                B = 0;
                E = 2 === u[x.fitting];
                for (var D = 0; D < w.length; ++D) {
                    0 < y[y.length - 1].length && (B += u.spacing[x.axis]);
                    var C = A[D][x.size];
                    B += C;
                    !E && B > Gb[x.axis] && 0 !== y[y.length - 1].length && (B = C, y.push([]));
                    y[y.length - 1].push(w[D]);
                    E && B > Gb[x.axis] && D !== w.length - 1 && (B = 0, y.push([]))
                }
                w = y
            } else w = [w];
            y = 0 === u.orientation && u.reverseX || 1 === u.orientation && u.reverseY;
            A = 0 === u.orientation &&
                u.reverseY || 1 === u.orientation && u.reverseX;
            if (y)
                for (B = 0; B < w.length; ++B) y && w[B].reverse();
            A && w.reverse();
            y = [];
            for (A = 0; A < w.length; ++A) B = k(w[A]), E = d(B, x), D = c(u[x.fitting], E, Gb[x.axis]), D === zb.APPLY_STRETCHING ? e(B, E, x) : D === zb.APPLY_SHRINKING && f(B, E, x), y.push(B);
            C = [];
            D = [];
            for (B = 0; B < w.length; ++B) {
                E = w[B];
                E.largestElement = null;
                E.largestSize = {
                    width: Number.NEGATIVE_INFINITY,
                    height: Number.NEGATIVE_INFINITY
                };
                for (A = 0; A < E.length; ++A) {
                    var G = y[B][A];
                    G[v.size] > E.largestSize[v.size] && (E.largestElement = E[A], E.largestSize =
                        G)
                }
                C.push(E.largestElement);
                D.push(E.largestSize)
            }
            A = d(D, v);
            B = c(u[v.fitting], A, Gb[v.axis]);
            B === zb.APPLY_STRETCHING ? e(D, A, v) : B === zb.APPLY_SHRINKING && f(D, A, v);
            for (B = 0; B < w.length; ++B)
                for (E = w[B], A = 0; A < E.length; ++A) D = y[B][A], C = 1 === w.length ? Gb[v.axis] : E.largestSize[v.size], G = c(u[v.fitting], D[v.size], C), G === zb.APPLY_STRETCHING ? D[v.size] = Math.min(C, D[v.maxSize]) : G === zb.APPLY_SHRINKING && (D[v.size] = Math.max(C, D[v.minSize]));
            a: {
                A = {};A[x.axis] = 0;A[v.axis] = 0;w[x.size] = Number.NEGATIVE_INFINITY;B = [];
                for (E = 0; E < w.length; ++E) {
                    D =
                        w[E];
                    if (0 === D.length) {
                        A = void 0;
                        break a
                    }
                    C = [];
                    G = y[E];
                    for (var K = 0; K < D.length; ++K) {
                        var R = D[K],
                            I = G[K];
                        A[v.axis] -= -I[v.size] * R.pivot[v.axis];
                        A[x.axis] -= -I[x.size] * R.pivot[x.axis];
                        C[K] = {};
                        C[K][x.axis] = A[x.axis];
                        C[K][v.axis] = A[v.axis];
                        A[v.axis] += -I[v.size] * R.pivot[v.axis];
                        A[x.axis] += I[x.size] * (1 - R.pivot[x.axis]) + u.spacing[x.axis]
                    }
                    D[x.size] = A[x.axis] - u.spacing[x.axis];
                    D[v.size] = D.largestSize[v.size];
                    w[x.size] = Math.max(w[x.size], D[x.size]);
                    A[x.axis] = 0;
                    A[v.axis] += D[v.size] + u.spacing[v.axis];
                    B.push(C)
                }
                w[v.size] =
                A[v.axis] - u.spacing[v.axis];A = B
            }
            B = A;
            E = u.alignment[x.axis];
            D = u.alignment[v.axis];
            C = u.padding[x.axis];
            G = u.padding[v.axis];
            for (K = 0; K < w.length; ++K) {
                R = w[K];
                I = y[K];
                for (var T = B[K], S = (Gb[x.axis] - R[x.size]) * E + C, ba = (Gb[v.axis] - w[v.size]) * D + G, ha = 0; ha < R.length; ++ha) {
                    var W = (R[v.size] - I[ha][v.size]) * u.alignment[v.axis];
                    T[ha][x.axis] += S;
                    T[ha][v.axis] += ba + W
                }
            }
            for (B = 0; B < w.length; ++B)
                for (E = w[B], D = y[B], C = A[B], G = 0; G < E.length; ++G) K = E[G], K[x.calculatedSize] = D[G][x.size], K[v.calculatedSize] = D[G][v.size], 0 === u.orientation ?
                    K.entity.setLocalPosition(C[G][x.axis], C[G][v.axis], K.entity.getLocalPosition().z) : K.entity.setLocalPosition(C[G][v.axis], C[G][x.axis], K.entity.getLocalPosition().z);
            y = w.width;
            w = w.height;
            return {
                bounds: new X((Gb.x - y) * u.alignment.x + u.padding.x, (Gb.y - w) * u.alignment.y + u.padding.y, y, w)
            }
        }
    }

    function kd(a, b) {
        O.call(this, a, b);
        this._orientation = 0;
        this._reverseX = !1;
        this._reverseY = !0;
        this._alignment = new P(0, 1);
        this._padding = new X;
        this._spacing = new P;
        this._heightFitting = this._widthFitting = sj;
        this._wrap = !1;
        this._layoutCalculator =
            new rj;
        this._listenForReflowEvents(this.entity, "on");
        this.entity.children.forEach(function(c) {
            this._listenForReflowEvents(c, "on")
        }.bind(this));
        this.entity.on("childinsert", this._onChildInsert, this);
        this.entity.on("childremove", this._onChildRemove, this);
        a.app.systems.element.on("add", this._onElementOrLayoutComponentAdd, this);
        a.app.systems.element.on("beforeremove", this._onElementOrLayoutComponentRemove, this);
        a.app.systems.layoutchild.on("add", this._onElementOrLayoutComponentAdd, this);
        a.app.systems.layoutchild.on("beforeremove",
            this._onElementOrLayoutComponentRemove, this)
    }

    function vo(a) {
        return a.element
    }

    function wo(a) {
        return a.enabled && a.element && a.element.enabled
    }

    function Nc(a) {
        var b = "_" + a;
        Object.defineProperty(kd.prototype, a, {
            get: function() {
                return this[b]
            },
            set: function(c) {
                this[b] !== c && (this[b] = c, this._scheduleReflow())
            }
        })
    }

    function xo() {
        this.enabled = !0
    }

    function Fe(a) {
        H.call(this, a);
        this.id = "layoutgroup";
        this.ComponentType = kd;
        this.DataType = xo;
        this.schema = yl;
        this._reflowQueue = [];
        this.on("beforeremove", this._onRemoveComponent,
            this);
        H.bind("postUpdate", this._onPostUpdate, this)
    }

    function ld(a, b) {
        O.call(this, a, b);
        this._cookieAssetId = this._cookieAsset = null;
        this._cookieAssetAdd = !1;
        this._cookieMatrix = null
    }

    function yo() {
        for (var a = tj, b = zo, c, d = 0; d < a.length; d++) c = b[d], this[a[d]] = c && c.clone ? c.clone() : c
    }

    function Ge(a) {
        H.call(this, a);
        this.id = "light";
        this.ComponentType = ld;
        this.DataType = yo;
        this.on("beforeremove", this._onRemoveComponent, this)
    }

    function Ga(a, b) {
        O.call(this, a, b);
        this._type = "asset";
        this._model = this._asset = null;
        this._mapping = {};
        this._receiveShadows = this._castShadows = !0;
        this._materialAsset = null;
        this._material = a.defaultMaterial;
        this._castShadowsLightmap = !0;
        this._lightmapped = !1;
        this._lightmapSizeMultiplier = 1;
        this._isStatic = !1;
        this._layers = [0];
        this._batchGroupId = -1;
        this._area = this._aabb = null;
        this._assetOld = 0;
        this._materialEvents = null;
        this._clonedModel = this._dirtyMaterialAsset = this._dirtyModelAsset = !1;
        b.on("remove", this.onRemoveChild, this);
        b.on("insert", this.onInsertChild, this)
    }

    function Ao() {
        this.enabled = !0
    }

    function He(a) {
        H.call(this,
            a);
        this.id = "model";
        this.ComponentType = Ga;
        this.DataType = Ao;
        this.schema = zl;
        this.sphere = this.plane = this.cylinder = this.cone = this.capsule = this.box = null;
        this.defaultMaterial = a.scene.defaultMaterial;
        this.on("beforeremove", this.onRemove, this)
    }

    function Bo() {
        this.rate = this.numParticles = 1;
        this.rate2 = null;
        this.startAngle = 0;
        this.startAngle2 = null;
        this.lifetime = 50;
        this.emitterExtents = new z;
        this.emitterExtentsInner = new z;
        this.initialVelocity = this.emitterShape = this.emitterRadiusInner = this.emitterRadius = 0;
        this.wrapBounds =
            new z;
        this.screenSpace = this.localSpace = !1;
        this.normalMapAsset = this.normalMap = this.colorMapAsset = this.colorMap = null;
        this.loop = !0;
        this.preWarm = !1;
        this.mode = this.sort = 0;
        this.scene = null;
        this.halfLambert = this.lighting = !1;
        this.intensity = 1;
        this.stretch = 0;
        this.alignToMotion = !1;
        this.depthSoftening = 0;
        this.mesh = this.meshAsset = null;
        this.noFog = this.depthWrite = !1;
        this.orientation = 0;
        this.particleNormal = new z(0, 1, 0);
        this.animTilesY = this.animTilesX = 1;
        this.animStartFrame = 0;
        this.animNumAnimations = this.animNumFrames =
            1;
        this.animIndex = 0;
        this.randomizeAnimIndex = !1;
        this.animSpeed = 1;
        this.animLoop = !0;
        this.radialSpeedGraph2 = this.radialSpeedGraph = this.rotationSpeedGraph2 = this.rotationSpeedGraph = this.velocityGraph2 = this.velocityGraph = this.localVelocityGraph2 = this.localVelocityGraph = this.alphaGraph2 = this.alphaGraph = this.colorGraph2 = this.colorGraph = this.scaleGraph2 = this.scaleGraph = null;
        this.blendType = 2;
        this.model = null;
        this.enabled = !0;
        this.paused = !1;
        this.autoPlay = !0;
        this.layers = [0]
    }

    function Ie(a) {
        H.call(this, a);
        this.id =
            "particlesystem";
        this.ComponentType = md;
        this.DataType = Bo;
        this.schema = Al;
        this.propertyTypes = {
            emitterExtents: "vec3",
            emitterExtentsInner: "vec3",
            particleNormal: "vec3",
            wrapBounds: "vec3",
            localVelocityGraph: "curveset",
            localVelocityGraph2: "curveset",
            velocityGraph: "curveset",
            velocityGraph2: "curveset",
            colorGraph: "curveset",
            colorGraph2: "curveset",
            alphaGraph: "curve",
            alphaGraph2: "curve",
            rotationSpeedGraph: "curve",
            rotationSpeedGraph2: "curve",
            radialSpeedGraph: "curve",
            radialSpeedGraph2: "curve",
            scaleGraph: "curve",
            scaleGraph2: "curve"
        };
        this.on("beforeremove", this.onBeforeRemove, this);
        H.bind("update", this.onUpdate, this)
    }

    function Zg(a, b) {
        this._constructor = a;
        this._pool = [];
        this._count = 0;
        this._resize(b)
    }

    function hc(a, b) {
        O.call(this, a, b);
        "undefined" === typeof Ammo || Ub || (Ub = new Ammo.btTransform, ya = new Ammo.btVector3, Mf = new Ammo.btVector3, uj = new Ammo.btQuaternion, vj = new Ammo.btVector3(0, 0, 0));
        this.on("set_mass", this.onSetMass, this);
        this.on("set_linearDamping", this.onSetLinearDamping, this);
        this.on("set_angularDamping",
            this.onSetAngularDamping, this);
        this.on("set_linearFactor", this.onSetLinearFactor, this);
        this.on("set_angularFactor", this.onSetAngularFactor, this);
        this.on("set_friction", this.onSetFriction, this);
        this.on("set_restitution", this.onSetRestitution, this);
        this.on("set_type", this.onSetType, this);
        this.on("set_group", this.onSetGroupOrMask, this);
        this.on("set_mask", this.onSetGroupOrMask, this);
        this.on("set_body", this.onSetBody, this);
        this._linearVelocity = new z(0, 0, 0);
        this._angularVelocity = new z(0, 0, 0)
    }

    function Co() {
        this.enabled = !0;
        this.mass = 1;
        this.angularDamping = this.linearDamping = 0;
        this.linearFactor = new z(1, 1, 1);
        this.angularFactor = new z(1, 1, 1);
        this.friction = .5;
        this.restitution = 0;
        this.type = Je;
        this.group = wj;
        this.mask = $g;
        this.body = null;
        this.simulationEnabled = !1
    }

    function xj(a, b, c) {
        this.entity = a;
        this.point = b;
        this.normal = c
    }

    function Bl(a, b, c) {
        0 === arguments.length ? (this.b = this.a = null, this.localPointA = new z, this.localPointB = new z, this.pointA = new z, this.pointB = new z, this.normal = new z) : (this.a = a, this.b = b, this.localPointA = c.localPoint,
            this.localPointB = c.localPointOther, this.pointA = c.point, this.pointB = c.pointOther, this.normal = c.normal)
    }

    function Cl(a, b, c, d, e) {
        0 === arguments.length ? (this.localPoint = new z, this.localPointOther = new z, this.point = new z, this.pointOther = new z, this.normal = new z) : (this.localPoint = a, this.localPointOther = b, this.point = c, this.pointOther = d, this.normal = e)
    }

    function Dl(a, b) {
        this.other = a;
        this.contacts = b
    }

    function Wd(a) {
        H.call(this, a);
        this.id = "rigidbody";
        this._stats = a.stats.frame;
        this.ComponentType = hc;
        this.DataType = Co;
        this.singleContactResultPool = this.contactResultPool = this.contactPointPool = null;
        this.schema = El;
        this.maxSubSteps = 10;
        this.fixedTimeStep = 1 / 60;
        this.gravity = new z(0, -9.81, 0);
        this._dynamic = [];
        this._kinematic = [];
        this._triggers = [];
        this._compounds = [];
        this.on("beforeremove", this.onBeforeRemove, this);
        this.on("remove", this.onRemove, this)
    }

    function Hb(a, b) {
        O.call(this, a, b);
        this._resolution = new P(640, 320);
        this._referenceResolution = new P(640, 320);
        this._scaleMode = Xd;
        this.scale = 1;
        this._scaleBlend = .5;
        this._priority =
            0;
        this.cull = this._screenSpace = !1;
        this._screenMatrix = new J;
        a.app.graphicsDevice.on("resizecanvas", this._onResize, this)
    }

    function Do() {
        this.enabled = !0
    }

    function Ke(a) {
        H.call(this, a);
        this.id = "screen";
        this.ComponentType = Hb;
        this.DataType = Do;
        this.schema = Fl;
        this.windowResolution = new P;
        this._drawOrderSyncQueue = new di;
        this.app.graphicsDevice.on("resizecanvas", this._onResize, this);
        H.bind("update", this._onUpdate, this);
        this.on("beforeremove", this.onRemoveComponent, this)
    }

    function Yd(a) {
        this.scriptType = a;
        this.index = {}
    }

    function db(a) {
        M.call(this);
        var b = this.constructor;
        this.app = a.app;
        this.entity = a.entity;
        this._enabled = "boolean" === typeof a.enabled ? a.enabled : !0;
        this._enabledOld = this.enabled;
        this.__destroyed = !1;
        this.__attributes = {};
        this.__attributesRaw = a.attributes || {};
        this.__scriptType = b;
        this.__executionOrder = -1
    }

    function Ib(a, b) {
        if (vb.legacy) return null;
        if (Ib.reservedScripts[a]) throw Error("script name: '" + a + "' is reserved, please change script name");
        var c = function(d) {
            db.call(this, d)
        };
        c.prototype = Object.create(db.prototype);
        c.prototype.constructor = c;
        c.extend = db.extend;
        c.attributes = new Yd(c);
        Gl(c, a, b);
        return c
    }

    function Gl(a, b, c) {
        if (!a.legacy) {
            if ("function" !== typeof a) throw Error("script class: '" + a + "' must be a constructor function (i.e. class).");
            if (!(a.prototype instanceof db)) throw Error("script class: '" + db.__getScriptName(a) + "' does not extend pc.ScriptType.");
            b = b || a.__name || db.__getScriptName(a);
            if (Ib.reservedScripts[b]) throw Error("script name: '" + b + "' is reserved, please change script name");
            a.__name = b;
            (c ? c.scripts :
                ea.getApplication().scripts).add(a);
            ub._push(a)
        }
    }

    function ic(a) {
        this._sortBy = a.sortBy;
        this.items = [];
        this.length = 0;
        this.loopIndex = -1;
        this._sortHandler = this._doSort.bind(this)
    }

    function Xa(a, b) {
        O.call(this, a, b);
        this._scripts = [];
        this._updateList = new ic({
            sortBy: "__executionOrder"
        });
        this._postUpdateList = new ic({
            sortBy: "__executionOrder"
        });
        this._scriptsIndex = {};
        this._destroyedScripts = [];
        this._destroyed = !1;
        this._scriptsData = null;
        this._enabled = this._oldState = !0;
        this._isLoopingThroughScripts = this._beingEnabled = !1;
        this._executionOrder = -1;
        this.on("set_enabled", this._onSetEnabled, this)
    }

    function Eo() {
        this.enabled = !0
    }

    function Le(a) {
        H.call(this, a);
        this.id = "script";
        this.ComponentType = Xa;
        this.DataType = Eo;
        this._components = new ic({
            sortBy: "_executionOrder"
        });
        this._enabledComponents = new ic({
            sortBy: "_executionOrder"
        });
        this.preloading = !0;
        this.on("beforeremove", this._onBeforeRemove, this);
        H.bind("initialize", this._onInitialize, this);
        H.bind("postInitialize", this._onPostInitialize, this);
        H.bind("update", this._onUpdate, this);
        H.bind("postUpdate", this._onPostUpdate, this)
    }

    function Zd(a, b) {
        O.call(this, a, b);
        this.on("set_scripts", this.onSetScripts, this)
    }

    function Fo() {
        this.scripts = [];
        this.enabled = !0;
        this.instances = {};
        this._instances = {};
        this.runInTools = !1;
        this.attributes = {};
        this.areScriptsLoaded = this.postInitialized = this.initialized = !1
    }

    function Oc(a, b) {
        M.call(this);
        if (!(a && a instanceof ia)) throw Error("Element was null or not an ElementComponent");
        if (b && "x" !== b && "y" !== b) throw Error("Unrecognized axis: " + b);
        this._element = a;
        this._app =
            a.system.app;
        this._axis = b || null;
        this._enabled = !0;
        this._dragScale = new z;
        this._dragStartMousePosition = new z;
        this._dragStartHandlePosition = new z;
        this._deltaMousePosition = new z;
        this._deltaHandlePosition = new z;
        this._isDragging = !1;
        this._toggleLifecycleListeners("on")
    }

    function nd(a, b) {
        O.call(this, a, b);
        this._viewportReference = new Lc(this, "viewportEntity", {
            "element#gain": this._onViewportElementGain,
            "element#resize": this._onSetContentOrViewportSize
        });
        this._contentReference = new Lc(this, "contentEntity", {
            "element#gain": this._onContentElementGain,
            "element#lose": this._onContentElementLose,
            "element#resize": this._onSetContentOrViewportSize
        });
        this._scrollbarUpdateFlags = {};
        this._scrollbarReferences = {};
        this._scrollbarReferences[0] = new Lc(this, "horizontalScrollbarEntity", {
            "scrollbar#set:value": this._onSetHorizontalScrollbarValue,
            "scrollbar#gain": this._onHorizontalScrollbarGain
        });
        this._scrollbarReferences[1] = new Lc(this, "verticalScrollbarEntity", {
            "scrollbar#set:value": this._onSetVerticalScrollbarValue,
            "scrollbar#gain": this._onVerticalScrollbarGain
        });
        this._prevContentSizes = {};
        this._prevContentSizes[0] = null;
        this._prevContentSizes[1] = null;
        this._scroll = new P;
        this._velocity = new z;
        this._dragStartPosition = new z;
        this._disabledContentInput = !1;
        this._disabledContentInputEntities = [];
        this._toggleLifecycleListeners("on", a);
        this._toggleElementListeners("on")
    }

    function Go() {
        this.enabled = !0
    }

    function $d(a, b) {
        O.call(this, a, b);
        this._app = a.app;
        this._handleReference = new Lc(this, "handleEntity", {
            "element#gain": this._onHandleElementGain,
            "element#lose": this._onHandleElementLose,
            "element#set:anchor": this._onSetHandleAlignment,
            "element#set:margin": this._onSetHandleAlignment,
            "element#set:pivot": this._onSetHandleAlignment
        });
        this._toggleLifecycleListeners("on")
    }

    function Ho() {
        this.enabled = !0
    }

    function Me(a) {
        H.call(this, a);
        this.id = "scrollbar";
        this.ComponentType = $d;
        this.DataType = Ho;
        this.schema = yj;
        this.on("beforeremove", this._onRemoveComponent, this)
    }

    function Qa(a, b, c) {
        M.call(this);
        this._component = a;
        this._assets = a.system.app.assets;
        this._manager = a.system.manager;
        this.name = b || "Untitled";
        c = c || {};
        this._volume = void 0 !== c.volume ? N.clamp(Number(c.volume) || 0, 0, 1) : 1;
        this._pitch = void 0 !== c.pitch ? Math.max(.01, Number(c.pitch) || 0) : 1;
        this._loop = !(void 0 === c.loop || !c.loop);
        this._duration = 0 < c.duration ? c.duration : null;
        this._startTime = Math.max(0, Number(c.startTime) || 0);
        this._overlap = !!c.overlap;
        this._autoPlay = !!c.autoPlay;
        this._lastNode = this._firstNode = null;
        this._asset = c.asset;
        this._asset instanceof aa && (this._asset = this._asset.id);
        this._onInstancePlayHandler = this._onInstancePlay.bind(this);
        this._onInstancePauseHandler =
            this._onInstancePause.bind(this);
        this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
        this._onInstanceStopHandler = this._onInstanceStop.bind(this);
        this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
        this.instances = []
    }

    function jc(a, b) {
        O.call(this, a, b);
        this._pitch = this._volume = 1;
        this._positional = !0;
        this._refDistance = 1;
        this._maxDistance = 1E4;
        this._rollOffFactor = 1;
        this._distanceModel = "linear";
        this._slots = {};
        this._playingBeforeDisable = {}
    }

    function ah(a, b) {
        Object.defineProperty(jc.prototype,
            a, {
                get: function() {
                    return this[b]
                },
                set: function(c) {
                    this[b] = c;
                    var d = this._slots,
                        e;
                    for (e in d) {
                        var f = d[e];
                        if (!f.overlap) {
                            f = f.instances;
                            for (var g = 0, k = f.length; g < k; g++) f[g][a] = c
                        }
                    }
                }
            })
    }

    function Hl(a, b) {
        Object.defineProperty(jc.prototype, a, {
            get: function() {
                return this[b]
            },
            set: function(c) {
                this[b] = c;
                var d = this._slots,
                    e;
                for (e in d) {
                    var f = d[e];
                    if (!f.overlap)
                        for (var g = f.instances, k = 0, h = g.length; k < h; k++) g[k][a] = f[a] * c
                }
            }
        })
    }

    function Io() {
        this.enabled = !0
    }

    function wb(a, b) {
        M.call(this);
        this._component = a;
        this._frame =
            0;
        this._spriteAsset = this._sprite = null;
        this.spriteAsset = b.spriteAsset;
        this.name = b.name;
        this.fps = b.fps || 0;
        this.loop = b.loop || !1;
        this._paused = this._playing = !1;
        this._time = 0
    }

    function Jo() {
        this.enabled = !0
    }

    function ae(a) {
        H.call(this, a);
        this.id = "sprite";
        this.ComponentType = Ba;
        this.DataType = Jo;
        this.schema = Il;
        this._default9SlicedMaterialTiledMode = this._default9SlicedMaterialSlicedMode = this._defaultMaterial = this._defaultTexture = null;
        H.bind("update", this.onUpdate, this);
        this.on("beforeremove", this.onBeforeRemove,
            this)
    }

    function od(a, b) {
        O.call(this, a, b);
        this._oldState = !0;
        this._size = new z;
        this.on("set_enabled", this._onSetEnabled, this)
    }

    function Ko() {
        this.enabled = !0
    }

    function Lo(a) {
        this.frame = {
            fps: 0,
            ms: 0,
            dt: 0,
            updateStart: 0,
            updateTime: 0,
            renderStart: 0,
            renderTime: 0,
            physicsStart: 0,
            physicsTime: 0,
            cullTime: 0,
            sortTime: 0,
            skinTime: 0,
            morphTime: 0,
            instancingTime: 0,
            triangles: 0,
            otherPrimitives: 0,
            shaders: 0,
            materials: 0,
            cameras: 0,
            shadowMapUpdates: 0,
            shadowMapTime: 0,
            depthMapTime: 0,
            forwardTime: 0,
            _timeToCountFrames: 0,
            _fpsAccum: 0
        };
        this.drawCalls = {
            forward: 0,
            depth: 0,
            shadow: 0,
            immediate: 0,
            misc: 0,
            total: 0,
            skinned: 0,
            instanced: 0,
            removedByInstancing: 0
        };
        this.misc = {
            renderTargetCreationTime: 0
        };
        this.particles = {
            updatesPerFrame: 0,
            _updatesPerFrame: 0,
            frameTime: 0,
            _frameTime: 0
        };
        this.vram = a._vram;
        this.shaders = a._shaderStats;
        Object.defineProperty(this.vram, "totalUsed", {
            get: function() {
                return this.tex + this.vb + this.ib
            }
        });
        Object.defineProperty(this.vram, "geom", {
            get: function() {
                return this.vb + this.ib
            }
        });
        Object.defineProperty(this, "scene", {
            get: function() {
                return ea._currentApplication.scene._stats
            }
        });
        Object.defineProperty(this, "lightmapper", {
            get: function() {
                return ea._currentApplication.lightmapper._stats
            }
        });
        Object.defineProperty(this, "batcher", {
            get: function() {
                return ea._currentApplication.batcher._stats
            }
        })
    }

    function Jl(a, b) {
        this.name = a;
        this.url = b
    }

    function kc(a) {
        this._app = a;
        this._list = [];
        this._index = {};
        this._urlIndex = {}
    }

    function ea(a, b) {
        M.call(this);
        b = b || {};
        console.log("Powered by PlayCanvas 1.37.0 ef8e593");
        ea._applications[a.id] = this;
        ea._currentApplication = this;
        m.app = this;
        this._time = 0;
        this.timeScale =
            1;
        this.maxDeltaTime = .1;
        this.frame = 0;
        this.autoRender = !0;
        this.renderNextFrame = !1;
        this.useLegacyScriptAttributeCloning = vb.legacy;
        this._librariesLoaded = !1;
        this._fillMode = bh;
        this._resolutionMode = zj;
        this._allowResize = !0;
        this.context = this;
        b.graphicsDeviceOptions || (b.graphicsDeviceOptions = {});
        b.graphicsDeviceOptions.xrCompatible = !0;
        this.graphicsDevice = new jb(a, b.graphicsDeviceOptions);
        this.stats = new Lo(this.graphicsDevice);
        this._soundManager = new ec(b);
        this.loader = new Ri(this);
        this._entityIndex = {};
        this.scene =
            new ra;
        this.root = new fa(this);
        this.root._enabledInHierarchy = !0;
        this._enableList = [];
        this._enableList.size = 0;
        this.assets = new Nd(this.loader);
        b.assetPrefix && (this.assets.prefix = b.assetPrefix);
        this.bundles = new kj(this.assets);
        this.enableBundles = "undefined" !== typeof TextDecoder;
        this.scriptsOrder = b.scriptsOrder || [];
        this.scripts = new fc(this);
        this.i18n = new Oa(this);
        this.scenes = new kc(this);
        var c = this;
        this.defaultLayerWorld = new ka({
            name: "World",
            id: 0
        });
        this.graphicsDevice.webgl2 ? (this.defaultLayerDepth = new ka({
            enabled: !1,
            name: "Depth",
            id: 1,
            onEnable: function() {
                if (!this.renderTarget) {
                    var d = new V(c.graphicsDevice, {
                        format: 17,
                        width: c.graphicsDevice.width,
                        height: c.graphicsDevice.height
                    });
                    d.name = "rt-depth2";
                    d.minFilter = 0;
                    d.magFilter = 0;
                    d.addressU = 1;
                    d.addressV = 1;
                    this.renderTarget = new sa({
                        colorBuffer: null,
                        depthBuffer: d,
                        autoResolve: !1
                    });
                    c.graphicsDevice.scope.resolve("uDepthMap").setValue(d)
                }
            },
            onDisable: function() {
                this.renderTarget && (this.renderTarget._depthBuffer.destroy(), this.renderTarget.destroy(), this.renderTarget = null)
            },
            onPreRenderOpaque: function(d) {
                var e = c.graphicsDevice.gl;
                this.srcFbo = e.getParameter(e.FRAMEBUFFER_BINDING);
                this.renderTarget && this.renderTarget.width === c.graphicsDevice.width && this.renderTarget.height === c.graphicsDevice.height || (this.onDisable(), this.onEnable());
                this.oldClear = this.cameras[d].camera._clearOptions;
                this.cameras[d].camera._clearOptions = this.depthClearOptions
            },
            onPostRenderOpaque: function(d) {
                this.renderTarget && (this.cameras[d].camera._clearOptions = this.oldClear, d = c.graphicsDevice.gl, c.graphicsDevice.setRenderTarget(this.renderTarget),
                    c.graphicsDevice.updateBegin(), d.bindFramebuffer(d.READ_FRAMEBUFFER, this.srcFbo), d.bindFramebuffer(d.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer), d.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, d.DEPTH_BUFFER_BIT, d.NEAREST))
            }
        }), this.defaultLayerDepth.depthClearOptions = {
            flags: 0
        }) : (this.defaultLayerDepth = new ka({
            enabled: !1,
            name: "Depth",
            id: 1,
            shaderPass: 2,
            onEnable: function() {
                if (!this.renderTarget) {
                    var d = new V(c.graphicsDevice, {
                        format: 7,
                        width: c.graphicsDevice.width,
                        height: c.graphicsDevice.height
                    });
                    d.name = "rt-depth1";
                    d.minFilter = 0;
                    d.magFilter = 0;
                    d.addressU = 1;
                    d.addressV = 1;
                    this.renderTarget = new sa(c.graphicsDevice, d, {
                        depth: !0,
                        stencil: c.graphicsDevice.supportsStencil
                    });
                    c.graphicsDevice.scope.resolve("uDepthMap").setValue(d)
                }
            },
            onDisable: function() {
                this.renderTarget && (this.renderTarget._colorBuffer.destroy(), this.renderTarget.destroy(), this.renderTarget = null)
            },
            onPostCull: function(d) {
                var e = this.instances.visibleOpaque[d],
                    f = e.list,
                    g = 0,
                    k = c.scene.layers.layerList,
                    h = c.scene.layers.subLayerEnabled,
                    l = c.scene.layers.subLayerList,
                    n = c.defaultLayerWorld.renderTarget;
                d = this.cameras[d];
                for (var p, q, r, t, u = 0; u < k.length; u++) {
                    p = k[u];
                    if (p === this) break;
                    if (p.renderTarget === n && p.enabled && h[u] && (q = p.cameras.indexOf(d), !(0 > q)))
                        for (q = (r = l[u]) ? p.instances.visibleTransparent[q] : p.instances.visibleOpaque[q], r = q.length, q = q.list, p = 0; p < r; p++) t = q[p], t.material && t.material.depthWrite && !t._noDepthDrawGl1 && (f[g] = t, g++)
                }
                e.length = g
            },
            onPreRenderOpaque: function(d) {
                this.renderTarget &&
                    this.renderTarget.width === c.graphicsDevice.width && this.renderTarget.height === c.graphicsDevice.height || (this.onDisable(), this.onEnable());
                this.oldClear = this.cameras[d].camera._clearOptions;
                this.cameras[d].camera._clearOptions = this.rgbaDepthClearOptions
            },
            onDrawCall: function() {
                c.graphicsDevice.setColorWrite(!0, !0, !0, !0)
            },
            onPostRenderOpaque: function(d) {
                this.renderTarget && (this.cameras[d].camera._clearOptions = this.oldClear)
            }
        }), this.defaultLayerDepth.rgbaDepthClearOptions = {
            color: [254 / 255, 254 / 255, 254 / 255,
                254 / 255
            ],
            depth: 1,
            flags: 3
        });
        this.defaultLayerSkybox = new ka({
            enabled: !1,
            name: "Skybox",
            id: 2,
            opaqueSortMode: 0
        });
        this.defaultLayerUi = new ka({
            enabled: !0,
            name: "UI",
            id: 4,
            transparentSortMode: 1,
            passThrough: !1
        });
        this.defaultLayerImmediate = new ka({
            enabled: !0,
            name: "Immediate",
            id: 3,
            opaqueSortMode: 0,
            passThrough: !0
        });
        this.defaultLayerComposition = new xa;
        this.defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerUi);
        this.scene.layers = this.defaultLayerComposition;
        this._immediateLayer = this.defaultLayerImmediate;
        this.scene.on("set:layers", function(d, e) {
            d = e.layerList;
            for (var f = 0; f < d.length; f++) switch (e = d[f], e.id) {
                case 1:
                    e.onEnable = c.defaultLayerDepth.onEnable;
                    e.onDisable = c.defaultLayerDepth.onDisable;
                    e.onPreRenderOpaque = c.defaultLayerDepth.onPreRenderOpaque;
                    e.onPostRenderOpaque = c.defaultLayerDepth.onPostRenderOpaque;
                    e.depthClearOptions = c.defaultLayerDepth.depthClearOptions;
                    e.rgbaDepthClearOptions = c.defaultLayerDepth.rgbaDepthClearOptions;
                    e.shaderPass = c.defaultLayerDepth.shaderPass;
                    e.onPostCull = c.defaultLayerDepth.onPostCull;
                    e.onDrawCall = c.defaultLayerDepth.onDrawCall;
                    break;
                case 4:
                    e.passThrough = c.defaultLayerUi.passThrough;
                    break;
                case 3:
                    e.passThrough = c.defaultLayerImmediate.passThrough
            }
        });
        this.renderer = new Ag(this.graphicsDevice);
        this.renderer.scene = this.scene;
        this.lightmapper = new ni(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);
        this.once("prerender", this._firstBake, this);
        this.batcher = new Ia(this.graphicsDevice, this.root, this.scene);
        this.once("prerender", this._firstBatch, this);
        this.keyboard = b.keyboard || null;
        this.mouse = b.mouse || null;
        this.touch = b.touch || null;
        this.gamepads = b.gamepads || null;
        if (this.elementInput = b.elementInput || null) this.elementInput.app = this;
        this.vr =
            null;
        this.xr = new Pa(this);
        this.elementInput && this.elementInput.attachSelectEvents();
        this._inTools = !1;
        this._skyboxLast = 0;
        this._scriptPrefix = b.scriptPrefix || "";
        this.enableBundles && this.loader.addHandler("bundle", new Ei(this.assets));
        this.loader.addHandler("animation", new zi);
        this.loader.addHandler("animclip", new Ai);
        this.loader.addHandler("animstategraph", new Bi);
        this.loader.addHandler("model", new Qi(this.graphicsDevice, this.scene.defaultMaterial));
        this.loader.addHandler("material", new Pi(this));
        this.loader.addHandler("texture",
            new Sg(this.graphicsDevice, this.assets, this.loader));
        this.loader.addHandler("text", new Zi);
        this.loader.addHandler("json", new Oi);
        this.loader.addHandler("audio", new Bf(this._soundManager));
        this.loader.addHandler("script", new ub(this));
        this.loader.addHandler("scene", new Si(this));
        this.loader.addHandler("cubemap", new Ii(this.graphicsDevice, this.assets, this.loader));
        this.loader.addHandler("html", new Ni);
        this.loader.addHandler("css", new Hi);
        this.loader.addHandler("shader", new Ui);
        this.loader.addHandler("hierarchy",
            new Mi(this));
        this.loader.addHandler("scenesettings", new Ti(this));
        this.loader.addHandler("folder", new Ji);
        this.loader.addHandler("font", new Li(this.loader));
        this.loader.addHandler("binary", new Ci);
        this.loader.addHandler("textureatlas", new $i(this.loader));
        this.loader.addHandler("sprite", new Vi(this.assets, this.graphicsDevice));
        this.loader.addHandler("template", new Yi(this));
        this.loader.addHandler("container", new Gi(this.graphicsDevice, this.scene.defaultMaterial));
        this.systems = new qj;
        this.systems.add(new Wd(this));
        this.systems.add(new Ne(this));
        this.systems.add(new ye(this));
        this.systems.add(new ze(this));
        this.systems.add(new He(this));
        this.systems.add(new Oe(this));
        this.systems.add(new Ge(this));
        vb.legacy ? this.systems.add(new Pe(this)) : this.systems.add(new Le(this));
        this.systems.add(new Be(this, this._soundManager));
        this.systems.add(new pd(this, this._soundManager));
        this.systems.add(new Ae(this, this._soundManager));
        this.systems.add(new Ie(this));
        this.systems.add(new Ke(this));
        this.systems.add(new Ee(this));
        this.systems.add(new Ce(this));
        this.systems.add(new Qe(this));
        this.systems.add(new Me(this));
        this.systems.add(new ae(this));
        this.systems.add(new Fe(this));
        this.systems.add(new Re(this));
        this.systems.add(new Se(this));
        this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
        "undefined" !== typeof document && (void 0 !== document.hidden ? (this._hiddenAttr = "hidden", document.addEventListener("visibilitychange", this._visibilityChangeHandler, !1)) : void 0 !== document.mozHidden ? (this._hiddenAttr = "mozHidden",
            document.addEventListener("mozvisibilitychange", this._visibilityChangeHandler, !1)) : void 0 !== document.msHidden ? (this._hiddenAttr = "msHidden", document.addEventListener("msvisibilitychange", this._visibilityChangeHandler, !1)) : void 0 !== document.webkitHidden && (this._hiddenAttr = "webkitHidden", document.addEventListener("webkitvisibilitychange", this._visibilityChangeHandler, !1)));
        this.meshInstanceArray = [];
        this.tick = Mo(this)
    }

    function la() {
        this.name = "Untitled";
        this.id = No++;
        this._shader = null;
        this.variants = {};
        this.parameters = {};
        this.alphaTest = 0;
        this.blend = this.alphaToCoverage = !1;
        this.blendSrc = 1;
        this.blendEquation = this.blendDst = 0;
        this.separateAlphaBlend = !1;
        this.blendSrcAlpha = 1;
        this.blendAlphaEquation = this.blendDstAlpha = 0;
        this.cull = 1;
        this.depthWrite = this.depthTest = !0;
        this.stencilBack = this.stencilFront = null;
        this.slopeDepthBias = this.depthBias = 0;
        this.alphaWrite = this.blueWrite = this.greenWrite = this.redWrite = !0;
        this.meshInstances = [];
        this._shaderVersion = 0;
        this._scene = null;
        this._dirtyBlend = !1;
        this.dirty = !0
    }

    function Vb() {
        this._mapXForms =
            null
    }

    function ma() {
        la.call(this);
        this._assetReferences = {};
        this._validator = null;
        this.shaderOptBuilder = new Vb;
        this.reset()
    }

    function Jb(a) {
        this._device = a;
        this._cache = {};
        this._generators = {};
        this._precached = this._isClearingCache = !1;
        this._programsCollection = [];
        this._defaultStdMatOption = {};
        this._defaultStdMatOptionMin = {};
        var b = new ma;
        b.shaderOptBuilder.updateRef(this._defaultStdMatOption, a, {}, b, null, [], 0, null, null);
        b.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, a, {}, b, null, [], 3, null, null)
    }

    function Aj() {
        this.revision = this.globalId = 0
    }

    function Kl() {
        Ll++;
        this.version = new Aj;
        this.version.globalId = Ll
    }

    function ch(a) {
        this.name = a;
        this.value = null;
        this.versionObject = new Kl
    }

    function dh(a) {
        this.name = a;
        this.variables = {};
        this.namespaces = {}
    }

    function Bj(a, b, c, d) {
        this.locationId = d;
        this.scopeId = a.scope.resolve(b);
        this.version = new Aj;
        if ("[0]" === b.substr(b.length - 3)) switch (c) {
            case 2:
                c = 17;
                break;
            case 3:
                c = 21;
                break;
            case 4:
                c = 22;
                break;
            case 5:
                c = 23
        }
        this.dataType = c;
        this.value = [null, null, null, null];
        this.array = []
    }

    function Ml(a, b) {
        var c = !0,
            d = a.createTexture();
        a.bindTexture(a.TEXTURE_2D, d);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
        a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, 2, 2, 0, a.RGBA, b, null);
        b = a.createFramebuffer();
        a.bindFramebuffer(a.FRAMEBUFFER, b);
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D,
            d, 0);
        a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE && (c = !1);
        a.bindTexture(a.TEXTURE_2D, null);
        a.deleteTexture(d);
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        a.deleteFramebuffer(b);
        return c
    }

    function eh(a, b, c) {
        var d = b._colorBuffer;
        if (7 == d.format) {
            var e = new Uint8Array(d.width * d.height * 4),
                f = a.gl;
            a.setFramebuffer(b._glFrameBuffer);
            f.readPixels(0, 0, d.width, d.height, f.RGBA, f.UNSIGNED_BYTE, e);
            d._levels || (d._levels = []);
            d._levels[0] || (d._levels[0] = []);
            d._levels[0][c] = e
        }
    }

    function fh(a, b) {
        return Math.atan2(a *
            b, Math.sqrt(a * a + b * b + 1))
    }

    function Nl(a, b) {
        var c, d = a.width;
        if (7 != a.format) console.error("ERROR: SH: cubemap must be RGBA8");
        else {
            if (a._levels[0]) {
                if (!a._levels[0][0].length)
                    if (a._levels[0][0] instanceof HTMLImageElement) {
                        var e = ea.getApplication().graphicsDevice;
                        var f = e.gl;
                        var g = Wa(e, F.fullscreenQuadVS, F.fullscreenQuadPS, "fsQuadSimple"),
                            k = e.scope.resolve("source");
                        for (c = 0; 6 > c; c++) {
                            var h = a._levels[0][c],
                                l = new V(e, {
                                    cubemap: !1,
                                    type: "default",
                                    format: a.format,
                                    width: d,
                                    height: d,
                                    mipmaps: !1
                                });
                            l.name = "prefiltered-cube";
                            l._levels[0] = h;
                            l.upload();
                            h = new V(e, {
                                cubemap: !1,
                                type: "default",
                                format: a.format,
                                width: d,
                                height: d,
                                mipmaps: !1
                            });
                            h.name = "prefiltered-cube";
                            h = new sa(e, h, {
                                depth: !1
                            });
                            k.setValue(l);
                            La(e, h, g);
                            var n = new Uint8Array(d * d * 4);
                            f.bindFramebuffer(f.FRAMEBUFFER, h._glFrameBuffer);
                            f.readPixels(0, 0, l.width, l.height, f.RGBA, f.UNSIGNED_BYTE, n);
                            a._levels[0][c] = n
                        }
                    } else {
                        console.error("ERROR: SH: cubemap must be composed of arrays or images");
                        return
                    }
                g = [];
                for (f = 0; f < d; f++)
                    for (e = 0; e < d; e++) g[f * d + e] = (new z(e / (d - 1) * 2 - 1, f / (d - 1) * 2 -
                        1, 1)).normalize();
                k = new Float32Array(27);
                for (c = h = 0; 6 > c; c++)
                    for (f = 0; f < d; f++)
                        for (e = 0; e < d; e++) {
                            l = f * d + e;
                            n = e;
                            var p = f;
                            var q = d;
                            var r = (2 * (n + .5) / q - 1) * (1 - 1 / q);
                            var t = (2 * (p + .5) / q - 1) * (1 - 1 / q);
                            var u = 1 / q;
                            var x = r - u;
                            var v = t - u;
                            r += u;
                            t += u;
                            x = fh(x, v) - fh(x, t) - fh(r, v) + fh(r, t);
                            if (0 === n && 0 === p || n === q - 1 && 0 === p || 0 === n && p === q - 1 || n === q - 1 && p === q - 1) x /= 3;
                            else if (0 === n || 0 === p || n === q - 1 || p === q - 1) x *= .5;
                            n = x;
                            p = 4 * n / 17;
                            q = 8 * n / 17;
                            x = 15 * n / 17;
                            v = 5 * n / 68;
                            t = 15 * n / 68;
                            u = g[l];
                            if (0 == c) {
                                var w = u.z;
                                var y = -u.y;
                                var A = -u.x
                            } else 1 == c ? (w = -u.z, y = -u.y, A = u.x) : 2 ==
                                c ? (w = u.x, y = u.z, A = u.y) : 3 == c ? (w = u.x, y = -u.z, A = -u.y) : 4 == c ? (w = u.x, y = -u.y, A = u.z) : 5 == c && (w = -u.x, y = -u.y, A = -u.z);
                            b || (w = -w);
                            r = a._levels[0][c][4 * l + 3] / 255;
                            for (u = 0; 3 > u; u++) {
                                var B = a._levels[0][c][4 * l + u] / 255;
                                "rgbm" === a.type ? (B *= 8 * r, B *= B) : B = Math.pow(B, 2.2);
                                k[0 + u] += B * p;
                                k[3 + u] += B * q * w;
                                k[6 + u] += B * q * y;
                                k[9 + u] += B * q * A;
                                k[12 + u] += B * x * w * A;
                                k[15 + u] += B * x * A * y;
                                k[18 + u] += B * x * y * w;
                                k[21 + u] += B * v * (3 * A * A - 1);
                                k[24 + u] += B * t * (w * w - y * y);
                                h += n
                            }
                        }
                for (u = 0; u < k.length; u++) k[u] *= 4 * Math.PI / h;
                return k
            }
            console.error("ERROR: SH: cubemap must be synced to CPU")
        }
    }

    function Cj(a) {
        this.device = a;
        this.depthMap = this.shader = null;
        this.vertexBuffer = Ol(a);
        this.needsDepthBuffer = !1
    }

    function Ol(a) {
        var b = new Na(a, [{
            semantic: "POSITION",
            components: 2,
            type: 6
        }]);
        a = new ab(a, b, 4);
        b = new Pb(a);
        b.element.POSITION.set(-1, -1);
        b.next();
        b.element.POSITION.set(1, -1);
        b.next();
        b.element.POSITION.set(-1, 1);
        b.next();
        b.element.POSITION.set(1, 1);
        b.end();
        return a
    }

    function Pl(a, b, c, d, e) {
        var f = a.getRenderTarget();
        a.setRenderTarget(b);
        a.updateBegin();
        var g = null !== b ? b.width : a.width,
            k = null !== b ? b.height :
            a.height,
            h = 0,
            l = 0;
        e && (h = e.x * g, l = e.y * k, g *= e.z, k *= e.w);
        e = a.vx;
        b = a.vy;
        var n = a.vw,
            p = a.vh;
        a.setViewport(h, l, g, k);
        var q = a.sx,
            r = a.sy,
            t = a.sw,
            u = a.sh;
        a.setScissor(h, l, g, k);
        g = a.getBlending();
        k = a.getDepthTest();
        h = a.getDepthWrite();
        l = a.getCullMode();
        var x = a.writeRed,
            v = a.writeGreen,
            w = a.writeBlue,
            y = a.writeAlpha;
        a.setBlending(!1);
        a.setDepthTest(!1);
        a.setDepthWrite(!1);
        a.setCullMode(0);
        a.setColorWrite(!0, !0, !0, !0);
        a.setVertexBuffer(c, 0);
        a.setShader(d);
        a.draw(Oo);
        a.setBlending(g);
        a.setDepthTest(k);
        a.setDepthWrite(h);
        a.setCullMode(l);
        a.setColorWrite(x, v, w, y);
        a.updateEnd();
        a.setRenderTarget(f);
        a.updateBegin();
        a.setViewport(e, b, n, p);
        a.setScissor(q, r, t, u)
    }

    function Nf(a, b) {
        b = b || 3;
        this.device = a.device;
        var c = this.device.gl;
        this._inputBuffer = a;
        3 === b && a.usage !== b && (c.bindBuffer(c.ARRAY_BUFFER, a.bufferId), c.bufferData(c.ARRAY_BUFFER, a.storage, c.DYNAMIC_COPY));
        this._outputBuffer = new ab(a.device, a.format, a.numVertices, b, a.storage)
    }

    function be() {
        la.call(this)
    }

    function qd(a, b, c) {
        a instanceof jb && (a = ea.getApplication());
        this.app =
            a;
        var d = this.device = a.graphicsDevice;
        this.library = d.getProgramLibrary();
        this.pickColor = new Float32Array(4);
        this.pickColor[3] = 1;
        this.mapping = [];
        this.scene = null;
        this.drawCalls = [];
        this.layerComp = this.layer = null;
        this.clearOptions = {
            color: [1, 1, 1, 1],
            depth: 1,
            flags: 3
        };
        var e = this;
        this._clearDepthOptions = {
            depth: 1,
            flags: 2
        };
        this.clearDepthCommand = new yg(0, 0, function() {
            d.clear(e._clearDepthOptions)
        });
        this.resize(b, c);
        this._ignoreOpacityFor = null
    }

    function Ql() {}

    function Dj(a, b) {
        b ? (this.key = b.keyCode, this.element =
            b.target, this.event = b) : this.event = this.element = this.key = null
    }

    function Ej(a) {
        gh.key = a.keyCode;
        gh.element = a.target;
        gh.event = a;
        return gh
    }

    function hh(a) {
        return "string" === typeof a ? a.toUpperCase().charCodeAt(0) : a
    }

    function kb(a, b) {
        M.call(this);
        b = b || {};
        this._element = null;
        this._keyDownHandler = this._handleKeyDown.bind(this);
        this._keyUpHandler = this._handleKeyUp.bind(this);
        this._keyPressHandler = this._handleKeyPress.bind(this);
        this._keymap = {};
        this._lastmap = {};
        a && this.attach(a);
        this.preventDefault = b.preventDefault ||
            !1;
        this.stopPropagation = b.stopPropagation || !1
    }

    function rd(a, b) {
        var c = {
            x: 0,
            y: 0
        };
        if (b) {
            if (b instanceof rd) throw Error("Expected MouseEvent");
            c = a._getTargetCoords(b)
        } else b = {};
        if (c) this.x = c.x, this.y = c.y;
        else if (Kb.isPointerLocked()) this.y = this.x = 0;
        else return;
        this.wheelDelta = 0;
        "wheel" === b.type && (0 < b.deltaY ? this.wheelDelta = 1 : 0 > b.deltaY && (this.wheelDelta = -1));
        Kb.isPointerLocked() ? (this.dx = b.movementX || b.webkitMovementX || b.mozMovementX || 0, this.dy = b.movementY || b.webkitMovementY || b.mozMovementY || 0) : (this.dx =
            this.x - a._lastX, this.dy = this.y - a._lastY);
        this.button = "mousedown" === b.type || "mouseup" === b.type ? b.button : -1;
        this.buttons = a._buttons.slice(0);
        this.element = b.target;
        this.ctrlKey = b.ctrlKey || !1;
        this.altKey = b.altKey || !1;
        this.shiftKey = b.shiftKey || !1;
        this.metaKey = b.metaKey || !1;
        this.event = b
    }

    function Kb(a) {
        M.call(this);
        this._lastY = this._lastX = 0;
        this._buttons = [!1, !1, !1];
        this._lastbuttons = [!1, !1, !1];
        this._upHandler = this._handleUp.bind(this);
        this._downHandler = this._handleDown.bind(this);
        this._moveHandler = this._handleMove.bind(this);
        this._wheelHandler = this._handleWheel.bind(this);
        this._contextMenuHandler = function(b) {
            b.preventDefault()
        };
        this._target = null;
        this._attached = !1;
        this.attach(a)
    }

    function lb(a, b) {
        b = b || {};
        this._keyboard = b.keyboard || null;
        this._mouse = b.mouse || null;
        this._gamepads = b.gamepads || null;
        this._element = null;
        this._actions = {};
        this._axes = {};
        this._axesValues = {};
        a && this.attach(a)
    }

    function Po(a, b, c) {
        Te.sub2(b, a);
        ih.sub2(c[0], a);
        Fj.sub2(c[1], a);
        Rl.sub2(c[2], a);
        jh.cross(Rl, Te);
        if (0 <= ih.dot(jh)) {
            if (0 > -Fj.dot(jh)) return !1;
            a =
                ih;
            if (0 > Sl.cross(Te, Fj).dot(a)) return !1
        } else {
            Gj.sub2(c[3], a);
            if (0 > Gj.dot(jh)) return !1;
            a = Gj;
            if (0 > Sl.cross(Te, ih).dot(a)) return !1
        }
        return 1E-8 > Te.sub2(c[0], c[2]).lengthSq() || 1E-8 > Te.sub2(c[1], c[3]).lengthSq() ? !1 : !0
    }

    function sd(a, b, c) {
        this.event = a;
        this.element = b;
        this.camera = c;
        this._stopPropagation = !1
    }

    function td(a, b, c, d, e, f, g) {
        sd.call(this, a, b, c);
        this.x = d;
        this.y = e;
        this.ctrlKey = a.ctrlKey || !1;
        this.altKey = a.altKey || !1;
        this.shiftKey = a.shiftKey || !1;
        this.metaKey = a.metaKey || !1;
        this.button = a.button;
        Kb.isPointerLocked() ?
            (this.dx = a.movementX || a.webkitMovementX || a.mozMovementX || 0, this.dy = a.movementY || a.webkitMovementY || a.mozMovementY || 0) : (this.dx = d - f, this.dy = e - g);
        this.wheelDelta = 0;
        "wheel" === a.type && (0 < a.deltaY ? this.wheelDelta = 1 : 0 > a.deltaY && (this.wheelDelta = -1))
    }

    function Pc(a, b, c, d, e, f) {
        sd.call(this, a, b, c);
        this.touches = a.touches;
        this.changedTouches = a.changedTouches;
        this.x = d;
        this.y = e;
        this.touch = f
    }

    function lc(a, b, c, d) {
        sd.call(this, a, b, c);
        this.inputSource = d
    }

    function Of(a, b) {
        this._app = null;
        this._attached = !1;
        this._target =
            null;
        this._enabled = !0;
        this._lastY = this._lastX = 0;
        this._upHandler = this._handleUp.bind(this);
        this._downHandler = this._handleDown.bind(this);
        this._moveHandler = this._handleMove.bind(this);
        this._wheelHandler = this._handleWheel.bind(this);
        this._touchstartHandler = this._handleTouchStart.bind(this);
        this._touchcancelHandler = this._touchendHandler = this._handleTouchEnd.bind(this);
        this._touchmoveHandler = this._handleTouchMove.bind(this);
        this._sortHandler = this._sortElements.bind(this);
        this._elements = [];
        this._pressedElement =
            this._hoveredElement = null;
        this._touchedElements = {};
        this._touchesForWhichTouchLeaveHasFired = {};
        this._selectedElements = {};
        this._selectedPressedElements = {};
        this._useMouse = !b || !1 !== b.useMouse;
        this._useTouch = !b || !1 !== b.useTouch;
        this._useXr = !b || !1 !== b.useXr;
        this._selectEventsAttached = !1;
        Da.touch && (this._clickedEntities = {});
        this.attach(a)
    }

    function Hj() {
        this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;
        this.current = [];
        this.previous = [];
        this.deadZone = .25
    }

    function kh(a) {
        var b = Ij(a);
        this.id = a.identifier;
        this.x = b.x;
        this.y = b.y;
        this.target = a.target;
        this.touch = a
    }

    function ce(a, b) {
        this.element = b.target;
        this.event = b;
        this.touches = [];
        this.changedTouches = [];
        if (b) {
            var c = b.touches.length;
            for (a = 0; a < c; a++) this.touches.push(new kh(b.touches[a]));
            c = b.changedTouches.length;
            for (a = 0; a < c; a++) this.changedTouches.push(new kh(b.changedTouches[a]))
        }
    }

    function Ue(a) {
        M.call(this);
        this._element = null;
        this._startHandler = this._handleTouchStart.bind(this);
        this._endHandler = this._handleTouchEnd.bind(this);
        this._moveHandler =
            this._handleTouchMove.bind(this);
        this._cancelHandler = this._handleTouchCancel.bind(this);
        this.attach(a)
    }

    function Ij(a) {
        for (var b = 0, c = 0, d = a.target; !(d instanceof HTMLElement);) d = d.parentNode;
        do b += d.offsetLeft - d.scrollLeft, c += d.offsetTop - d.scrollTop, d = d.offsetParent; while (d);
        return {
            x: a.pageX - b,
            y: a.pageY - c
        }
    }

    function xb(a, b) {
        M.call(this);
        this.type = "bitmap";
        this.app = a;
        this.intensity = 0;
        b = b || {};
        this.fontWeight = b.fontWeight || "normal";
        this.glyphSize = this.fontSize = parseInt(b.fontSize, 10);
        this.fontName = b.fontName ||
            "Arial";
        this.color = b.color || new L(1, 1, 1);
        this.padding = b.padding || 0;
        a = 4096 < b.width ? 4096 : b.width || 512;
        var c = 4096 < b.height ? 4096 : b.height || 512;
        b = document.createElement("canvas");
        b.height = c;
        b.width = a;
        a = new V(this.app.graphicsDevice, {
            format: 7,
            autoMipmap: !0
        });
        a.name = "font";
        a.setSource(b);
        a.minFilter = 5;
        a.magFilter = 1;
        a.addressU = 1;
        a.addressV = 1;
        this.textures = [a];
        this.chars = "";
        this.data = {}
    }

    function Tl() {}

    function lh(a, b, c) {
        b = new V(b, {
            format: c,
            width: b.width,
            height: b.height
        });
        b.name = "posteffect-pass";
        b.minFilter =
            0;
        b.magFilter = 0;
        b.addressU = 1;
        b.addressV = 1;
        Ka[a]._colorBuffer = b
    }

    function Ul(a) {
        a = a.match(Qo) || [];
        for (var b, c, d = [], e = 0; e < a.length; e++) b = a[e].search(Ro), c = a[e].search(So), b = a[e].substr(b, c - b), "uColorBuffer" !== b && d.push(b);
        return d
    }

    function Vl(a, b) {
        this.app = a;
        this.srcRenderTarget = b.srcRenderTarget;
        this.hdr = b.hdr;
        this.blending = b.blending;
        this.shader = b.shader;
        this.setup = b.setup;
        var c = this,
            d = a.graphicsDevice;
        this.layer = new ka({
            opaqueSortMode: 0,
            transparentSortMode: 0,
            passThrough: !0,
            name: b.name,
            onPostRender: function() {
                c.srcRenderTarget ?
                    (Ab.x = c.srcRenderTarget.width, Ab.y = c.srcRenderTarget.height, Ab.z = 1 / c.srcRenderTarget.width, Ab.w = 1 / c.srcRenderTarget.height) : (Ab.x = d.width, Ab.y = d.height, Ab.z = 1 / d.width, Ab.w = 1 / d.height);
                Pf[0] = Ab.x;
                Pf[1] = Ab.y;
                Pf[2] = Ab.z;
                Pf[3] = Ab.w;
                Wl.setValue(Pf);
                if (this._postEffectCombined && 0 > this._postEffectCombined) c.setup && c.setup(d, c, Ab, null, this.renderTarget);
                else {
                    var f = this._postEffectCombinedSrc ? this._postEffectCombinedSrc : c.srcRenderTarget ? c.srcRenderTarget : Ka[this._backbufferRtId];
                    1 < f._samples && f.resolve(!0, !1);
                    var g = f._colorBuffer;
                    g.magFilter = (this._postEffectCombinedShader ? this._postEffectCombinedBilinear : this.postEffectBilinear) ? 1 : 0;
                    Jj.setValue(g);
                    c.setup && c.setup(d, c, Ab, f, this.renderTarget);
                    (f = this._postEffectCombinedShader ? this._postEffectCombinedShader : this.shader) && La(d, this.renderTarget, f, null, null, c.blending);
                    if (!c.srcRenderTarget)
                        for (f = a.scene.layers.layerList, g = 0; g < f.length && f[g] !== c.layer; g++)
                            if (f[g].renderTarget === Ka[0] || f[g].renderTarget === Ka[1]) f[g].renderTarget = null
                }
            }
        });
        this.layer._generateCameraHash();
        this.layer.isPostEffect = !0;
        this.layer.unmodifiedUvs = b.unmodifiedUvs;
        this.layer.postEffectBilinear = b.bilinear;
        this.layer.postEffect = this;
        this.layer.shader = b.shader;
        this.layer.renderTarget = b.destRenderTarget;
        if (!Jj) {
            Jj = d.scope.resolve("uColorBuffer");
            Wl = d.scope.resolve("uScreenSize");
            b = d.supportsMsaa ? 4 : 1;
            for (var e = 0; 2 > e; e++) Ka[e] = new sa({
                depth: !0,
                stencil: d.supportsStencil,
                samples: b,
                autoResolve: !1
            }), Ka[e].name = "backbuffer" + e;
            a.on("prerender", function() {
                var f = a.scene.layers.layerList,
                    g, k = 0,
                    h = 0;
                Kj = Lj =
                    Qf = !1;
                var l = 7;
                if (a.scene.layers._dirty) {
                    var n = 0;
                    for (g = 0; g < f.length; g++) {
                        var p = !1;
                        var q;
                        if ((q = f[g].isPostEffect) && !(q = 0 === n) && (q = f[g].unmodifiedUvs && f[g].shader)) {
                            a: {
                                var r, t, u;
                                var x = f;
                                var v = mc;
                                var w = n,
                                    y = Ul(f[g].shader.definition.fshader);
                                if (0 !== y.length)
                                    for (u = 0; u < w; u++)
                                        for (t = 0; t < y.length; t++) {
                                            q = y[t];
                                            var A = Ul(x[v[u]].shader.definition.fshader);
                                            for (r = 0; r < A.length; r++)
                                                if (A[r] === q) {
                                                    q = !0;
                                                    break a
                                                }
                                        }
                                q = !1
                            }
                            q = !q
                        }
                        q ? (mc[n] = g, n++, g === f.length - 1 && (p = !0)) : 0 < n && (p = !0);
                        if (p) {
                            if (1 < n) {
                                q = "post_";
                                for (p = 0; p < n; p++) A = f[mc[p]],
                                    q += A.name ? A.name : A.id, p < n - 1 && (q += "_");
                                A = d.programLib._cache[q];
                                if (!A) {
                                    r = "vec4 shaderOutput;\n";
                                    t = "void main() {\n";
                                    u = [];
                                    for (p = 0; p < n; p++) {
                                        A = f[mc[p]].shader.definition.fshader + "\n";
                                        A = A.replace(To, "//").replace(Uo, "//").replace(Vo, "//").replace(Wo, "shaderOutput");
                                        0 < p && (A = A.replace(Xo, "//").replace(Yo, "//").replace(Zo, "shaderOutput;//"));
                                        A = A.replace($o, "void main" + p);
                                        var B;
                                        y = A;
                                        v = u;
                                        var E = y.length;
                                        var D = 0,
                                            C = B = 0;
                                        w = "";
                                        for (x = 0; x < E; x++) {
                                            var G = y.charAt(x);
                                            "{" === G ? (0 === B && (D = x), B++) : "}" === G && (1 === B && (G = x, w +=
                                                y.substr(C, D - C + 1), C = G), B--)
                                        }
                                        w += y.substr(C, y.length - C + 1);
                                        D = null;
                                        C = w.match(ap) || [];
                                        for (x = 0; x < C.length; x++)
                                            for (y = C[x].split(","), E = 0; E < y.length; E++) B = y[E].replace(bp, "").trim(), 0 <= v.indexOf(B) ? (D || (D = []), D.push(B)) : v.push(B);
                                        w = w.match(cp) || [];
                                        for (x = 0; x < w.length; x++)
                                            for (y = w[x].split(","), E = 0; E < y.length; E++) B = y[E].replace(dp, "").trim(), B = v.indexOf(B), 0 <= B && v.splice(B, 1);
                                        if (x = D)
                                            for (v = 0; v < x.length; v++) A = A.replace(new RegExp("\\b" + x[v] + "\\b", "g"), x[v] + "NNNN" + p);
                                        r += A;
                                        t += "main" + p + "();\n"
                                    }
                                    t += "gl_FragColor = shaderOutput;\n}\n";
                                    A = Wa(d, F.fullscreenQuadVS, r + t, q)
                                }
                                for (p = 0; p < n; p++) f[mc[p]]._postEffectCombined = p === n - 1 ? 1 : -1;
                                f[mc[n - 1]]._postEffectCombinedShader = A;
                                f[mc[n - 1]]._postEffectCombinedBilinear = f[mc[0]].postEffectBilinear;
                                f[mc[n - 1]]._postEffectCombinedSrc = f[mc[0]].postEffect.srcRenderTarget
                            }
                            mc[0] = g;
                            n = 1
                        }
                    }
                }
                for (g = 0; g < f.length; g++) {
                    if (f[g].isPostEffect && (!f[g].postEffect.srcRenderTarget && !f[g]._postEffectCombined || !f[g].postEffect._postEffectCombinedSrc && 0 <= f[g]._postEffectCombined)) {
                        for (p = g - 1; p >= k; p--) f[p].renderTarget || (f[p].renderTarget =
                            Ka[h]);
                        f[g]._backbufferRtId = h;
                        k = g;
                        Qf = !0;
                        1 === h && (Lj = !0);
                        f[g].postEffect.hdr && (l = d.webgl2 && d.textureFloatRenderable ? 18 : d.extTextureHalfFloatLinear && d.textureHalfFloatRenderable ? 12 : 7);
                        f[g].postEffect.shader && !f[g].renderTarget && (h = 1 - h)
                    } else f[g].isPostEffect || f[g].renderTarget || !Qf || (f[g].renderTarget = Ka[h]);
                    f[g].isPostEffect && !f[g].renderTarget && (Kj = !0)
                }
                if (Qf)
                    if (!Ka[0].colorBuffer) lh(0, d, l);
                    else if (Ka[0].width !== d.width || Ka[0].height !== d.height || Ka[0]._colorBuffer._format !== l) Ka[0].colorBuffer.destroy(),
                    Ka[0].destroy(), lh(0, d, l);
                if (Lj)
                    if (!Ka[1].colorBuffer) lh(1, d, l);
                    else if (Ka[1].width !== d.width || Ka[1].height !== d.height || Ka[1]._colorBuffer._format !== l) Ka[1].colorBuffer.destroy(), Ka[1].destroy(), lh(1, d, l)
            }, this);
            a.on("postrender", function() {
                var f = a.graphicsDevice;
                if (Qf && !Kj) {
                    for (var g = a.scene.layers.layerList, k, h = g.length - 1; 0 <= h && (k = g[h].renderTarget, k !== Ka[0] && k !== Ka[1]); h--);
                    k && (1 < k._samples && k.resolve(!0, !1), f.copyRenderTarget(k, null, !0, !1))
                }
            }, this)
        }
    }

    function Mj(a) {
        this.name = "UnsupportedBrowserError";
        this.message = a || ""
    }

    function Nj(a) {
        this.name = "ContextCreationError";
        this.message = a || ""
    }
    Array.prototype.find || Object.defineProperty(Array.prototype, "find", {
        value: function(a, b) {
            if (null == this) throw TypeError('"this" is null or not defined');
            var c = Object(this),
                d = c.length >>> 0;
            if ("function" !== typeof a) throw TypeError("predicate must be a function");
            for (var e = 0; e < d;) {
                var f = c[e];
                if (a.call(b, f, e, c)) return f;
                e++
            }
        },
        configurable: !0,
        writable: !0
    });
    Math.log2 = Math.log2 || function(a) {
        return Math.log(a) * Math.LOG2E
    };
    Math.sign || (Math.sign = function(a) {
        return (0 < a) - (0 > a) || +a
    });
    "function" != typeof Object.assign && Object.defineProperty(Object, "assign", {
        value: function(a, b) {
            if (null == a) throw new TypeError("Cannot convert undefined or null to object");
            for (var c = Object(a), d = 1; d < arguments.length; d++) {
                var e = arguments[d];
                if (null != e)
                    for (var f in e) Object.prototype.hasOwnProperty.call(e, f) && (c[f] = e[f])
            }
            return c
        },
        writable: !0,
        configurable: !0
    });
    (function() {
        if ("undefined" !== typeof navigator && "undefined" !== typeof document) {
            navigator.pointer =
                navigator.pointer || navigator.webkitPointer || navigator.mozPointer;
            var a = function() {
                    var c = document.createEvent("CustomEvent");
                    c.initCustomEvent("pointerlockchange", !0, !1, null);
                    document.dispatchEvent(c)
                },
                b = function() {
                    var c = document.createEvent("CustomEvent");
                    c.initCustomEvent("pointerlockerror", !0, !1, null);
                    document.dispatchEvent(c)
                };
            document.addEventListener("webkitpointerlockchange", a, !1);
            document.addEventListener("webkitpointerlocklost", a, !1);
            document.addEventListener("mozpointerlockchange", a, !1);
            document.addEventListener("mozpointerlocklost", a, !1);
            document.addEventListener("webkitpointerlockerror", b, !1);
            document.addEventListener("mozpointerlockerror", b, !1);
            Element.prototype.requestPointerLock = Element.prototype.mozRequestPointerLock ? function() {
                this.mozRequestPointerLock()
            } : Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
            !Element.prototype.requestPointerLock && navigator.pointer && (Element.prototype.requestPointerLock = function() {
                document.pointerLockElement =
                    this;
                navigator.pointer.lock(this, a, b)
            });
            document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
            document.exitPointerLock || (document.exitPointerLock = function() {
                navigator.pointer && (document.pointerLockElement = null, navigator.pointer.unlock())
            })
        }
    })();
    (function() {
        if ("undefined" !== typeof window) {
            for (var a = 0, b = ["ms", "moz", "webkit", "o"], c = 0; c < b.length && !window.requestAnimationFrame; ++c) window.requestAnimationFrame = window[b[c] + "RequestAnimationFrame"],
                window.cancelAnimationFrame = window[b[c] + "CancelAnimationFrame"] || window[b[c] + "CancelRequestAnimationFrame"];
            window.requestAnimationFrame || (window.requestAnimationFrame = function(d, e) {
                var f = (new Date).getTime(),
                    g = Math.max(0, 16 - (f - a));
                e = window.setTimeout(function() {
                    d(f + g)
                }, g);
                a = f + g;
                return e
            });
            window.cancelAnimationFrame || (window.cancelAnimationFrame = function(d) {
                clearTimeout(d)
            })
        }
    })();
    String.prototype.endsWith || (String.prototype.endsWith = function(a, b) {
        if (void 0 === b || b > this.length) b = this.length;
        return this.substring(b -
            a.length, b) === a
    });
    String.prototype.includes || (String.prototype.includes = function(a, b) {
        "number" !== typeof b && (b = 0);
        return b + a.length > this.length ? !1 : -1 !== this.indexOf(a, b)
    });
    String.prototype.startsWith || (String.prototype.startsWith = function(a, b) {
        return this.substr(!b || 0 > b ? 0 : +b, a.length) === a
    });
    (function() {
        function a(e) {
            var f = e.getError;
            e.getError = function() {
                do {
                    var g = f.apply(e);
                    g != e.NO_ERROR && (b[g] = !0)
                } while (g != e.NO_ERROR);
                for (g in b)
                    if (b[g]) return delete b[g], parseInt(g);
                return e.NO_ERROR
            }
        }
        var b = {},
            c =
            function g(f) {
                var k = f.gl;
                this.ext = f;
                this.isAlive = !0;
                this.hasBeenBound = !1;
                this.elementArrayBuffer = null;
                this.attribs = Array(f.maxVertexAttribs);
                for (f = 0; f < this.attribs.length; f++) {
                    var h = new g.VertexAttrib(k);
                    this.attribs[f] = h
                }
                this.maxAttrib = 0
            };
        c.VertexAttrib = function(f) {
            this.enabled = !1;
            this.buffer = null;
            this.size = 4;
            this.type = f.FLOAT;
            this.normalized = !1;
            this.stride = 16;
            this.offset = 0;
            this.cached = "";
            this.recache()
        };
        c.VertexAttrib.prototype.recache = function() {
            this.cached = [this.size, this.type, this.normalized,
                this.stride, this.offset
            ].join(":")
        };
        var d = function(f) {
            var g = this;
            this.gl = f;
            a(f);
            var k = this.original = {
                getParameter: f.getParameter,
                enableVertexAttribArray: f.enableVertexAttribArray,
                disableVertexAttribArray: f.disableVertexAttribArray,
                bindBuffer: f.bindBuffer,
                getVertexAttrib: f.getVertexAttrib,
                vertexAttribPointer: f.vertexAttribPointer
            };
            f.getParameter = function(h) {
                return h == g.VERTEX_ARRAY_BINDING_OES ? g.currentVertexArrayObject == g.defaultVertexArrayObject ? null : g.currentVertexArrayObject : k.getParameter.apply(this,
                    arguments)
            };
            f.enableVertexAttribArray = function(h) {
                var l = g.currentVertexArrayObject;
                l.maxAttrib = Math.max(l.maxAttrib, h);
                l.attribs[h].enabled = !0;
                return k.enableVertexAttribArray.apply(this, arguments)
            };
            f.disableVertexAttribArray = function(h) {
                var l = g.currentVertexArrayObject;
                l.maxAttrib = Math.max(l.maxAttrib, h);
                l.attribs[h].enabled = !1;
                return k.disableVertexAttribArray.apply(this, arguments)
            };
            f.bindBuffer = function(h, l) {
                switch (h) {
                    case f.ARRAY_BUFFER:
                        g.currentArrayBuffer = l;
                        break;
                    case f.ELEMENT_ARRAY_BUFFER:
                        g.currentVertexArrayObject.elementArrayBuffer =
                            l
                }
                return k.bindBuffer.apply(this, arguments)
            };
            f.getVertexAttrib = function(h, l) {
                var n = g.currentVertexArrayObject.attribs[h];
                switch (l) {
                    case f.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                        return n.buffer;
                    case f.VERTEX_ATTRIB_ARRAY_ENABLED:
                        return n.enabled;
                    case f.VERTEX_ATTRIB_ARRAY_SIZE:
                        return n.size;
                    case f.VERTEX_ATTRIB_ARRAY_STRIDE:
                        return n.stride;
                    case f.VERTEX_ATTRIB_ARRAY_TYPE:
                        return n.type;
                    case f.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                        return n.normalized;
                    default:
                        return k.getVertexAttrib.apply(this, arguments)
                }
            };
            f.vertexAttribPointer =
                function(h, l, n, p, q, r) {
                    var t = g.currentVertexArrayObject;
                    t.maxAttrib = Math.max(t.maxAttrib, h);
                    t = t.attribs[h];
                    t.buffer = g.currentArrayBuffer;
                    t.size = l;
                    t.type = n;
                    t.normalized = p;
                    t.stride = q;
                    t.offset = r;
                    t.recache();
                    return k.vertexAttribPointer.apply(this, arguments)
                };
            f.instrumentExtension && f.instrumentExtension(this, "OES_vertex_array_object");
            f.canvas.addEventListener("webglcontextrestored", function() {
                window.console && window.console.log && window.console.log("OESVertexArrayObject emulation library context restored");
                g.reset_()
            }, !0);
            this.reset_()
        };
        d.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
        d.prototype.reset_ = function() {
            if (void 0 !== this.vertexArrayObjects)
                for (var f = 0; f < this.vertexArrayObjects.length; ++f) this.vertexArrayObjects.isAlive = !1;
            f = this.gl;
            this.maxVertexAttribs = f.getParameter(f.MAX_VERTEX_ATTRIBS);
            this.defaultVertexArrayObject = new c(this);
            this.currentArrayBuffer = this.currentVertexArrayObject = null;
            this.vertexArrayObjects = [this.defaultVertexArrayObject];
            this.bindVertexArrayOES(null)
        };
        d.prototype.createVertexArrayOES =
            function() {
                var f = new c(this);
                this.vertexArrayObjects.push(f);
                return f
            };
        d.prototype.deleteVertexArrayOES = function(f) {
            f.isAlive = !1;
            this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(f), 1);
            this.currentVertexArrayObject == f && this.bindVertexArrayOES(null)
        };
        d.prototype.isVertexArrayOES = function(f) {
            return f && f instanceof c && f.hasBeenBound && f.ext == this ? !0 : !1
        };
        d.prototype.bindVertexArrayOES = function(f) {
            var g = this.gl;
            if (f && !f.isAlive) b[g.INVALID_OPERATION] = !0, window.console && window.console.error &&
                window.console.error("bindVertexArrayOES: attempt to bind deleted arrayObject");
            else {
                var k = this.original,
                    h = this.currentVertexArrayObject;
                this.currentVertexArrayObject = f || this.defaultVertexArrayObject;
                this.currentVertexArrayObject.hasBeenBound = !0;
                f = this.currentVertexArrayObject;
                if (h != f) {
                    h && f.elementArrayBuffer == h.elementArrayBuffer || k.bindBuffer.call(g, g.ELEMENT_ARRAY_BUFFER, f.elementArrayBuffer);
                    for (var l = this.currentArrayBuffer, n = Math.max(h ? h.maxAttrib : 0, f.maxAttrib), p = 0; p <= n; p++) {
                        var q = f.attribs[p],
                            r = h ? h.attribs[p] : null;
                        h && q.enabled == r.enabled || (q.enabled ? k.enableVertexAttribArray.call(g, p) : k.disableVertexAttribArray.call(g, p));
                        if (q.enabled) {
                            var t = !1;
                            h && q.buffer == r.buffer || (l != q.buffer && (k.bindBuffer.call(g, g.ARRAY_BUFFER, q.buffer), l = q.buffer), t = !0);
                            (t || q.cached != r.cached) && k.vertexAttribPointer.call(g, p, q.size, q.type, q.normalized, q.stride, q.offset)
                        }
                    }
                    this.currentArrayBuffer != l && k.bindBuffer.call(g, g.ARRAY_BUFFER, this.currentArrayBuffer)
                }
            }
        };
        window.setupVertexArrayObject = function(f) {
            if (f.getSupportedExtensions) {
                if (-1 !=
                    f.getSupportedExtensions().indexOf("OES_vertex_array_object")) return
            } else if (f.getExtension && f.getExtension("OES_vertex_array_object")) return;
            if (f.getSupportedExtensions) {
                var g = f.getSupportedExtensions;
                f.getSupportedExtensions = function() {
                    var h = g.call(this) || [];
                    h.push("OES_vertex_array_object");
                    return h
                }
            }
            var k = f.getExtension;
            f.getExtension = function(h) {
                return "OES_vertex_array_object" == h ? (f.__OESVertexArrayObject || (f.__OESVertexArrayObject = new d(f)), f.__OESVertexArrayObject) : k ? k.call(this, h) : null
            }
        }
    })();
    var yn = function() {
            for (var a = {}, b = "Array Object Function Date RegExp Float32Array".split(" "), c = 0; c < b.length; c++) a["[object " + b[c] + "]"] = b[c].toLowerCase();
            return a
        }(),
        ep = function() {
            var a = null,
                b = null,
                c = null,
                d = null;
            return {
                display: function(e) {
                    a || (a = document.createElement("table"), b = document.createElement("tr"), c = document.createElement("td"), d = document.createElement("td"), a.style.cssText = "position:absolute;font-family:sans-serif;font-size:12px;color:#cccccc", a.style.top = "0px", a.style.left = "0px", a.style.border =
                        "thin solid #cccccc", document.body.appendChild(a));
                    a.innerHTML = "";
                    for (var f in e) {
                        var g = b.cloneNode(),
                            k = c.cloneNode(),
                            h = d.cloneNode();
                        k.textContent = f;
                        h.textContent = e[f];
                        g.appendChild(k);
                        g.appendChild(h);
                        a.appendChild(g)
                    }
                }
            }
        }();
    Object.assign(M.prototype, {
        _addCallback: function(a, b, c, d) {
            a && "string" === typeof a && b && (this._callbacks[a] || (this._callbacks[a] = []), this._callbackActive[a] && this._callbackActive[a] === this._callbacks[a] && (this._callbackActive[a] = this._callbackActive[a].slice()), this._callbacks[a].push({
                callback: b,
                scope: c || this,
                once: d || !1
            }))
        },
        on: function(a, b, c) {
            this._addCallback(a, b, c, !1);
            return this
        },
        off: function(a, b, c) {
            if (a) this._callbackActive[a] && this._callbackActive[a] === this._callbacks[a] && (this._callbackActive[a] = this._callbackActive[a].slice());
            else
                for (var d in this._callbackActive) this._callbacks[d] && this._callbacks[d] === this._callbackActive[d] && (this._callbackActive[d] = this._callbackActive[d].slice());
            if (a)
                if (b) {
                    a = this._callbacks[a];
                    if (!a) return this;
                    d = a.length;
                    for (var e = 0; e < d; e++) a[e].callback ===
                        b && (c && a[e].scope !== c || (a[e--] = a[--d]));
                    a.length = d
                } else this._callbacks[a] && (this._callbacks[a] = []);
            else this._callbacks = {};
            return this
        },
        fire: function(a, b, c, d, e, f, g, k, h) {
            if (!a || !this._callbacks[a]) return this;
            if (this._callbackActive[a]) {
                this._callbackActive[a] === this._callbacks[a] && (this._callbackActive[a] = this._callbackActive[a].slice());
                var l = this._callbacks[a].slice()
            } else this._callbackActive[a] = this._callbacks[a];
            for (var n = 0;
                (l || this._callbackActive[a]) && n < (l || this._callbackActive[a]).length; n++) {
                var p =
                    (l || this._callbackActive[a])[n];
                p.callback.call(p.scope, b, c, d, e, f, g, k, h);
                p.once && (p = this._callbacks[a].indexOf(p), -1 !== p && (this._callbackActive[a] === this._callbacks[a] && (this._callbackActive[a] = this._callbackActive[a].slice()), this._callbacks[a].splice(p, 1)))
            }
            l || (this._callbackActive[a] = null);
            return this
        },
        once: function(a, b, c) {
            this._addCallback(a, b, c, !0);
            return this
        },
        hasEvent: function(a) {
            return this._callbacks[a] && 0 !== this._callbacks[a].length || !1
        }
    });
    var Rf = {
            attach: function(a) {
                var b = Rf;
                a._addCallback =
                    b._addCallback;
                a.on = b.on;
                a.off = b.off;
                a.fire = b.fire;
                a.once = b.once;
                a.hasEvent = b.hasEvent;
                a._callbacks = {};
                a._callbackActive = {};
                return a
            },
            _addCallback: M.prototype._addCallback,
            on: M.prototype.on,
            off: M.prototype.off,
            fire: M.prototype.fire,
            once: M.prototype.once,
            hasEvent: M.prototype.hasEvent
        },
        Xl = {
            create: function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
                    var b = 16 * Math.random() | 0;
                    return ("x" == a ? b : b & 3 | 8).toString(16)
                })
            }
        },
        ca = {
            delimiter: "/",
            join: function() {
                var a, b = arguments.length,
                    c = arguments[0];
                for (a = 0; a < b - 1; ++a) {
                    var d = arguments[a],
                        e = arguments[a + 1];
                    if (!bi(d) || !bi(e)) throw Error("undefined argument to pc.path.join");
                    c = e[0] === ca.delimiter ? e : d && e && d[d.length - 1] !== ca.delimiter && e[0] !== ca.delimiter ? c + (ca.delimiter + e) : c + e
                }
                return c
            },
            normalize: function(a) {
                var b = a.startsWith(ca.delimiter),
                    c = a.endsWith(ca.delimiter);
                a = a.split("/");
                for (var d = [], e = 0; e < a.length; e++) "" !== a[e] && "." !== a[e] && (".." === a[e] && 0 < d.length ? d = d.slice(0, d.length - 2) : (0 < e && d.push(ca.delimiter), d.push(a[e])));
                a = d.join("");
                b || a[0] !== ca.delimiter || (a = a.slice(1));
                c && a[a.length - 1] !== ca.delimiter && (a += ca.delimiter);
                return a
            },
            split: function(a) {
                a = a.split(ca.delimiter);
                var b = a.slice(a.length - 1)[0];
                return [a.slice(0, a.length - 1).join(ca.delimiter), b]
            },
            getBasename: function(a) {
                return ca.split(a)[1]
            },
            getDirectory: function(a) {
                a = a.split(ca.delimiter);
                return a.slice(0, a.length - 1).join(ca.delimiter)
            },
            getExtension: function(a) {
                var b = a.split("?")[0].split(".").pop();
                return b !== a ? "." + b : ""
            },
            isRelativePath: function(a) {
                return "/" !== a.charAt(0) &&
                    null === a.match(/:\/\//)
            },
            extractPath: function(a) {
                var b = "",
                    c = a.split("/");
                if (1 < c.length)
                    if (ca.isRelativePath(a))
                        if ("." === c[0])
                            for (a = 0; a < c.length - 1; ++a) b += 0 === a ? c[a] : "/" + c[a];
                        else if (".." === c[0])
                    for (a = 0; a < c.length - 1; ++a) b += 0 === a ? c[a] : "/" + c[a];
                else
                    for (b = ".", a = 0; a < c.length - 1; ++a) b += "/" + c[a];
                else
                    for (a = 0; a < c.length - 1; ++a) b += 0 === a ? c[a] : "/" + c[a];
                return b
            }
        },
        Da = {
            desktop: !1,
            mobile: !1,
            ios: !1,
            android: !1,
            windows: !1,
            xbox: !1,
            gamepads: !1,
            touch: !1,
            workers: !1,
            passiveEvents: !1
        };
    if ("undefined" !== typeof navigator) {
        var Sf =
            navigator.userAgent;
        /(windows|mac os|linux|cros)/i.test(Sf) && (Da.desktop = !0);
        /xbox/i.test(Sf) && (Da.xbox = !0);
        /(windows phone|iemobile|wpdesktop)/i.test(Sf) ? (Da.desktop = !1, Da.mobile = !0, Da.windows = !0) : /android/i.test(Sf) ? (Da.desktop = !1, Da.mobile = !0, Da.android = !0) : /ip([ao]d|hone)/i.test(Sf) && (Da.desktop = !1, Da.mobile = !0, Da.ios = !0);
        "undefined" !== typeof window && (Da.touch = "ontouchstart" in window || "maxTouchPoints" in navigator && 0 < navigator.maxTouchPoints);
        Da.gamepads = "getGamepads" in navigator;
        Da.workers = "undefined" !==
            typeof Worker;
        try {
            var Yl = Object.defineProperty({}, "passive", {
                get: function() {
                    Da.passiveEvents = !0;
                    return !1
                }
            });
            window.addEventListener("testpassive", null, Yl);
            window.removeEventListener("testpassive", null, Yl)
        } catch (a) {}
    }
    var vc = {
            ASCII_LOWERCASE: "abcdefghijklmnopqrstuvwxyz",
            ASCII_UPPERCASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
            ASCII_LETTERS: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
            format: function(a) {
                for (var b = 1; b < arguments.length; b++) a = a.replace("{" + (b - 1) + "}", arguments[b]);
                return a
            },
            toBool: function(a,
                b) {
                if ("true" === a) return !0;
                if (b) {
                    if ("false" === a) return !1;
                    throw new TypeError("Not a boolean string");
                }
                return !1
            },
            getCodePoint: function(a, b) {
                return (a = ci(a, b)) && a.code
            },
            getCodePoints: function(a) {
                if ("string" !== typeof a) throw new TypeError("Not a string");
                for (var b = 0, c = [], d; d = ci(a, b);) c.push(d.code), b += d.long ? 2 : 1;
                return c
            },
            getSymbols: function(a) {
                if ("string" !== typeof a) throw new TypeError("Not a string");
                for (var b = 0, c = a.length, d = [], e = 0, f; b < c;) {
                    f = e;
                    var g = a,
                        k = b + e;
                    k === g.length - 1 ? e = 1 : ad(g[k], 55296, 56319) ? (e =
                        g.substring(k, k + 2), g = g.substring(k + 2, k + 4), e = ad(g, 127995, 127999) || ad(e, 127462, 127487) && ad(g, 127462, 127487) ? 4 : ad(g, 65024, 65039) ? 3 : 2) : e = ad(g[k + 1], 65024, 65039) ? 2 : 1;
                    e = f + e;
                    f = a[b + e];
                    ad(f, 8400, 8447) && (f = a[b + e++]);
                    ad(f, 65024, 65039) && (f = a[b + e++]);
                    f && 8205 === f.charCodeAt(0) ? e++ : (f = a.substring(b, b + e), d.push(f), b += e, e = 0)
                }
                return d
            },
            fromCodePoint: function() {
                for (var a = [], b, c, d = 0; d < arguments.length; ++d) b = Number(arguments[d]), c = b - 65536, b = 65535 < b ? [(c >> 10) + 55296, c % 1024 + 56320] : [b], a.push(String.fromCharCode.apply(null,
                    b));
                return a.join("")
            }
        },
        N = {
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            clamp: function(a, b, c) {
                return a >= c ? c : a <= b ? b : a
            },
            intToBytes24: function(a) {
                return [a >> 16 & 255, a >> 8 & 255, a & 255]
            },
            intToBytes32: function(a) {
                return [a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, a & 255]
            },
            bytesToInt24: function(a, b, c) {
                a.length && (c = a[2], b = a[1], a = a[0]);
                return a << 16 | b << 8 | c
            },
            bytesToInt32: function(a, b, c, d) {
                a.length && (d = a[3], c = a[2], b = a[1], a = a[0]);
                return (a << 24 | b << 16 | c << 8 | d) >>> 32
            },
            lerp: function(a, b, c) {
                return a + (b - a) * N.clamp(c, 0, 1)
            },
            lerpAngle: function(a,
                b, c) {
                180 < b - a && (b -= 360); - 180 > b - a && (b += 360);
                return N.lerp(a, b, N.clamp(c, 0, 1))
            },
            powerOfTwo: function(a) {
                return 0 !== a && !(a & a - 1)
            },
            nextPowerOfTwo: function(a) {
                a--;
                a |= a >> 1;
                a |= a >> 2;
                a |= a >> 4;
                a |= a >> 8;
                a |= a >> 16;
                a++;
                return a
            },
            random: function(a, b) {
                return Math.random() * (b - a) + a
            },
            smoothstep: function(a, b, c) {
                if (c <= a) return 0;
                if (c >= b) return 1;
                c = (c - a) / (b - a);
                return c * c * (3 - 2 * c)
            },
            smootherstep: function(a, b, c) {
                if (c <= a) return 0;
                if (c >= b) return 1;
                c = (c - a) / (b - a);
                return c * c * c * (c * (6 * c - 15) + 10)
            },
            roundUp: function(a, b) {
                return 0 === b ? a : Math.ceil(a /
                    b) * b
            },
            float2Half: function() {
                var a = new Float32Array(1),
                    b = new Int32Array(a.buffer);
                return function(c) {
                    a[0] = c;
                    c = b[0];
                    var d = c >> 16 & 32768,
                        e = c >> 12 & 2047,
                        f = c >> 23 & 255;
                    return 103 > f ? d : 142 < f ? d | 31744 | ((255 == f ? 0 : 1) && c & 8388607) : 113 > f ? (e |= 2048, d | (e >> 114 - f) + (e >> 113 - f & 1)) : d = (d | f - 112 << 10 | e >> 1) + (e & 1)
                }
            }()
        };
    Object.assign(L.prototype, {
        clone: function() {
            return new L(this.r, this.g, this.b, this.a)
        },
        copy: function(a) {
            this.r = a.r;
            this.g = a.g;
            this.b = a.b;
            this.a = a.a;
            return this
        },
        equals: function(a) {
            return this.r === a.r && this.g === a.g &&
                this.b === a.b && this.a === a.a
        },
        set: function(a, b, c, d) {
            this.r = a;
            this.g = b;
            this.b = c;
            this.a = void 0 === d ? 1 : d;
            return this
        },
        lerp: function(a, b, c) {
            this.r = a.r + c * (b.r - a.r);
            this.g = a.g + c * (b.g - a.g);
            this.b = a.b + c * (b.b - a.b);
            this.a = a.a + c * (b.a - a.a);
            return this
        },
        fromString: function(a) {
            var b = parseInt(a.replace("#", "0x"), 16);
            7 < a.length ? a = N.intToBytes32(b) : (a = N.intToBytes24(b), a[3] = 255);
            this.set(a[0] / 255, a[1] / 255, a[2] / 255, a[3] / 255);
            return this
        },
        toString: function(a) {
            var b = "#" + (16777216 + (Math.round(255 * this.r) << 16) + (Math.round(255 *
                this.g) << 8) + Math.round(255 * this.b)).toString(16).slice(1);
            !0 === a && (a = Math.round(255 * this.a).toString(16), b = this.a < 16 / 255 ? b + ("0" + a) : b + a);
            return b
        }
    });
    Object.defineProperties(L, {
        BLACK: {
            value: new L(0, 0, 0, 1)
        },
        WHITE: {
            value: new L(1, 1, 1, 1)
        },
        YELLOW: {
            value: new L(1, 1, 0, 1)
        },
        RED: {
            value: new L(1, 0, 0, 1)
        },
        MAGENTA: {
            value: new L(1, 0, 1, 1)
        },
        GREEN: {
            value: new L(0, 1, 0, 1)
        },
        GRAY: {
            value: new L(.5, .5, .5, 1)
        },
        CYAN: {
            value: new L(0, 1, 1, 1)
        },
        BLUE: {
            value: new L(0, 0, 1, 1)
        }
    });
    Object.freeze(L.BLACK);
    Object.freeze(L.WHITE);
    Object.freeze(L.YELLOW);
    Object.freeze(L.RED);
    Object.freeze(L.MAGENTA);
    Object.freeze(L.GREEN);
    Object.freeze(L.GRAY);
    Object.freeze(L.CYAN);
    Object.freeze(L.BLUE);
    Object.assign(di.prototype, {
        push: function(a, b) {
            if (this._index[a]) throw Error("Key already in index " + a);
            b = this._list.push(b) - 1;
            this._index[a] = b
        },
        has: function(a) {
            return void 0 !== this._index[a]
        },
        get: function(a) {
            a = this._index[a];
            return void 0 !== a ? this._list[a] : null
        },
        remove: function(a) {
            var b = this._index[a];
            if (void 0 !== b) {
                this._list.splice(b, 1);
                delete this._index[a];
                for (a in this._index) {
                    var c =
                        this._index[a];
                    c > b && (this._index[a] = c - 1)
                }
                return !0
            }
            return !1
        },
        list: function() {
            return this._list
        },
        clear: function() {
            this._list.length = 0;
            for (var a in this._index) delete this._index[a]
        }
    });
    Object.assign(Bk.prototype, {
        addItem: function(a) {
            for (var b = a.tags._list, c = 0; c < b.length; c++) this.add(b[c], a)
        },
        removeItem: function(a) {
            for (var b = a.tags._list, c = 0; c < b.length; c++) this.remove(b[c], a)
        },
        add: function(a, b) {
            this._index[a] && -1 !== this._index[a].list.indexOf(b) || (this._index[a] || (this._index[a] = {
                    list: []
                }, this._key &&
                (this._index[a].keys = {})), this._index[a].list.push(b), this._key && (this._index[a].keys[b[this._key]] = b))
        },
        remove: function(a, b) {
            if (this._index[a] && (!this._key || this._index[a].keys[b[this._key]])) {
                var c = this._index[a].list.indexOf(b); - 1 !== c && (this._index[a].list.splice(c, 1), this._key && delete this._index[a].keys[b[this._key]], 0 === this._index[a].list.length && delete this._index[a])
            }
        },
        find: function(a) {
            var b = this,
                c = {},
                d = [],
                e, f, g = function(n, p) {
                    return b._index[n].list.length - b._index[p].list.length
                };
            for (e =
                0; e < a.length; e++) {
                var k = a[e];
                if (k instanceof Array) {
                    if (0 === k.length) continue;
                    if (1 === k.length) k = k[0];
                    else {
                        var h = !1;
                        for (f = 0; f < k.length; f++)
                            if (!this._index[k[f]]) {
                                h = !0;
                                break
                            }
                        if (h) continue;
                        k = k.slice(0).sort(g);
                        var l = k.slice(1);
                        1 === l.length && (l = l[0]);
                        for (f = 0; f < this._index[k[0]].list.length; f++) h = this._index[k[0]].list[f], (this._key ? !c[h[this._key]] : -1 === d.indexOf(h)) && h.tags.has(l) && (this._key && (c[h[this._key]] = !0), d.push(h));
                        continue
                    }
                }
                if (k && "string" === typeof k && this._index[k])
                    for (f = 0; f < this._index[k].list.length; f++) h =
                        this._index[k].list[f], this._key ? c[h[this._key]] || (c[h[this._key]] = !0, d.push(h)) : -1 === d.indexOf(h) && d.push(h)
            }
            return d
        }
    });
    bd.prototype = Object.create(M.prototype);
    bd.prototype.constructor = bd;
    Object.assign(bd.prototype, {
        add: function() {
            var a = !1,
                b = this._processArguments(arguments, !0);
            if (!b.length) return a;
            for (var c = 0; c < b.length; c++) this._index[b[c]] || (a = !0, this._index[b[c]] = !0, this._list.push(b[c]), this.fire("add", b[c], this._parent));
            a && this.fire("change", this._parent);
            return a
        },
        remove: function() {
            var a = !1;
            if (!this._list.length) return a;
            var b = this._processArguments(arguments, !0);
            if (!b.length) return a;
            for (var c = 0; c < b.length; c++) this._index[b[c]] && (a = !0, delete this._index[b[c]], this._list.splice(this._list.indexOf(b[c]), 1), this.fire("remove", b[c], this._parent));
            a && this.fire("change", this._parent);
            return a
        },
        clear: function() {
            if (this._list.length) {
                var a = this._list.slice(0);
                this._list = [];
                this._index = {};
                for (var b = 0; b < a.length; b++) this.fire("remove", a[b], this._parent);
                this.fire("change", this._parent)
            }
        },
        has: function() {
            return this._list.length ? this._has(this._processArguments(arguments)) : !1
        },
        _has: function(a) {
            if (!this._list.length || !a.length) return !1;
            for (var b = 0; b < a.length; b++)
                if (1 === a[b].length) {
                    if (this._index[a[b][0]]) return !0
                } else {
                    for (var c = !0, d = 0; d < a[b].length; d++)
                        if (!this._index[a[b][d]]) {
                            c = !1;
                            break
                        }
                    if (c) return !0
                }
            return !1
        },
        list: function() {
            return this._list.slice(0)
        },
        _processArguments: function(a, b) {
            var c = [],
                d = [];
            if (!a || !a.length) return c;
            for (var e = 0; e < a.length; e++)
                if (a[e] instanceof Array) {
                    b || (d = []);
                    for (var f = 0; f < a[e].length; f++) "string" === typeof a[e][f] && (b ? c.push(a[e][f]) : d.push(a[e][f]));
                    !b && d.length && c.push(d)
                } else "string" === typeof a[e] && (b ? c.push(a[e]) : c.push([a[e]]));
            return c
        }
    });
    Object.defineProperty(bd.prototype, "size", {
        get: function() {
            return this._list.length
        }
    });
    var Lb = "undefined" !== typeof window && window.performance && window.performance.now && window.performance.timing ? function() {
        return window.performance.now()
    } : Date.now;
    Object.assign(ei.prototype, {
        start: function() {
            this._isRunning = !0;
            this._a = Lb()
        },
        stop: function() {
            this._isRunning = !1;
            this._b = Lb()
        },
        getMilliseconds: function() {
            return this._b - this._a
        }
    });
    da.ContentType = {
        FORM_URLENCODED: "application/x-www-form-urlencoded",
        GIF: "image/gif",
        JPEG: "image/jpeg",
        DDS: "image/dds",
        JSON: "application/json",
        PNG: "image/png",
        TEXT: "text/plain",
        XML: "application/xml",
        WAV: "audio/x-wav",
        OGG: "audio/ogg",
        MP3: "audio/mpeg",
        MP4: "audio/mp4",
        AAC: "audio/aac",
        BIN: "application/octet-stream",
        BASIS: "image/basis",
        GLB: "model/gltf-binary"
    };
    da.ResponseType = {
        TEXT: "text",
        ARRAY_BUFFER: "arraybuffer",
        BLOB: "blob",
        DOCUMENT: "document",
        JSON: "json"
    };
    da.binaryExtensions = ".model .wav .ogg .mp3 .mp4 .m4a .aac .dds .basis .glb".split(" ");
    da.retryDelay = 100;
    Object.assign(da.prototype, {
        ContentType: da.ContentType,
        ResponseType: da.ResponseType,
        binaryExtensions: da.binaryExtensions,
        get: function(a, b, c) {
            "function" === typeof b && (c = b, b = {});
            return this.request("GET", a, b, c)
        },
        post: function(a, b, c, d) {
            "function" === typeof c && (d = c, c = {});
            c.postdata = b;
            return this.request("POST", a, c, d)
        },
        put: function(a,
            b, c, d) {
            "function" === typeof c && (d = c, c = {});
            c.postdata = b;
            return this.request("PUT", a, c, d)
        },
        del: function(a, b, c) {
            "function" === typeof b && (c = b, b = {});
            return this.request("DELETE", a, b, c)
        },
        request: function(a, b, c, d) {
            var e = !1;
            "function" === typeof c && (d = c, c = {});
            c.retry && (c = Object.assign({
                retries: 0,
                maxRetries: 5
            }, c));
            c.callback = d;
            null == c.async && (c.async = !0);
            null == c.headers && (c.headers = {});
            if (null != c.postdata)
                if (c.postdata instanceof Document) var f = c.postdata;
                else if (c.postdata instanceof FormData) f = c.postdata;
            else if (c.postdata instanceof Object) switch (f = c.headers["Content-Type"], void 0 === f && (c.headers["Content-Type"] = da.ContentType.FORM_URLENCODED, f = c.headers["Content-Type"]), f) {
                case da.ContentType.FORM_URLENCODED:
                    f = "";
                    d = !0;
                    for (g in c.postdata) c.postdata.hasOwnProperty(g) && (d ? d = !1 : f += "&", f += escape(g) + "=" + escape(c.postdata[g]));
                    break;
                default:
                case da.ContentType.JSON:
                    null == f && (c.headers["Content-Type"] = da.ContentType.JSON), f = JSON.stringify(c.postdata)
            } else f = c.postdata;
            if (!1 === c.cache) {
                d = Lb();
                var g = new tg(b);
                g.query = g.query ? g.query +
                    "&ts=" + d : "ts=" + d;
                b = g.toString()
            }
            c.query && (g = new tg(b), d = Hc(g.getQuery(), c.query), g.setQuery(d), b = g.toString());
            var k = new XMLHttpRequest;
            k.open(a, b, c.async);
            k.withCredentials = void 0 !== c.withCredentials ? c.withCredentials : !1;
            k.responseType = c.responseType || this._guessResponseType(b);
            for (var h in c.headers) c.headers.hasOwnProperty(h) && k.setRequestHeader(h, c.headers[h]);
            k.onreadystatechange = function() {
                this._onReadyStateChange(a, b, c, k)
            }.bind(this);
            k.onerror = function() {
                this._onError(a, b, c, k);
                e = !0
            }.bind(this);
            try {
                k.send(f)
            } catch (l) {
                e || c.error(k.status, k, l)
            }
            return k
        },
        _guessResponseType: function(a) {
            a = new tg(a);
            a = ca.getExtension(a.path);
            return 0 <= da.binaryExtensions.indexOf(a) ? da.ResponseType.ARRAY_BUFFER : ".xml" === a ? da.ResponseType.DOCUMENT : da.ResponseType.TEXT
        },
        _isBinaryContentType: function(a) {
            return 0 <= [da.ContentType.MP4, da.ContentType.WAV, da.ContentType.OGG, da.ContentType.MP3, da.ContentType.BIN, da.ContentType.DDS, da.ContentType.BASIS, da.ContentType.GLB].indexOf(a) ? !0 : !1
        },
        _onReadyStateChange: function(a,
            b, c, d) {
            if (4 === d.readyState) switch (d.status) {
                case 200:
                case 201:
                case 206:
                case 304:
                    this._onSuccess(a, b, c, d);
                    break;
                default:
                    this._onError(a, b, c, d)
            }
        },
        _onSuccess: function(a, b, c, d) {
            if (a = d.getResponseHeader("Content-Type")) {
                var e = a.split(";");
                e = e[0].trim()
            }
            try {
                if (e === this.ContentType.JSON || b.split("?")[0].endsWith(".json")) var f = JSON.parse(d.responseText);
                else this._isBinaryContentType(e) ? f = d.response : (e && console.warn("responseType: " + d.responseType + " being served with Content-Type: " + e), f = d.responseType ===
                    da.ResponseType.ARRAY_BUFFER ? d.response : d.responseType === da.ResponseType.BLOB || d.responseType === da.ResponseType.JSON ? d.response : d.responseType === da.ResponseType.DOCUMENT || e === this.ContentType.XML ? d.responseXML : d.responseText);
                c.callback(null, f)
            } catch (g) {
                c.callback(g)
            }
        },
        _onError: function(a, b, c, d) {
            if (!c.retrying)
                if (c.retry && c.retries < c.maxRetries) {
                    c.retries++;
                    c.retrying = !0;
                    var e = N.clamp(Math.pow(2, c.retries) * da.retryDelay, 0, c.maxRetryDelay || 5E3);
                    console.log(a + ": " + b + " - Error " + d.status + ". Retrying in " +
                        e + " ms");
                    setTimeout(function() {
                        c.retrying = !1;
                        this.request(a, b, c, c.callback)
                    }.bind(this), e)
                } else c.callback(0 === d.status ? "Network error" : d.status, null)
        }
    });
    var wa = new da;
    Object.assign(fi.prototype, {
        evaluate: function(a, b) {
            (b || a < this._left || a >= this._right) && this._reset(a);
            b = this._curve.type;
            5 === b ? a = this._p0 : (a = 0 === this._recip ? 0 : (a - this._left) * this._recip, a = 0 === b ? N.lerp(this._p0, this._p1, a) : 1 === b ? N.lerp(this._p0, this._p1, a * a * (3 - 2 * a)) : this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, a));
            return a
        },
        _reset: function(a) {
            var b = this._curve.keys,
                c = b.length;
            if (c)
                if (a < b[0][0]) this._left = -Infinity, this._right = b[0][0], this._recip = 0, this._p0 = this._p1 = b[0][1], this._m0 = this._m1 = 0;
                else if (a >= b[c - 1][0]) this._left = b[c - 1][0], this._right = Infinity, this._recip = 0, this._p0 = this._p1 = b[c - 1][1], this._m0 = this._m1 = 0;
            else {
                for (c = 0; a >= b[c + 1][0];) c++;
                this._left = b[c][0];
                this._right = b[c + 1][0];
                a = 1 / (this._right - this._left);
                this._recip = isFinite(a) ? a : 0;
                this._p0 = b[c][1];
                this._p1 = b[c + 1][1];
                this._isHermite() && this._calcTangents(b,
                    c)
            } else this._left = -Infinity, this._right = Infinity, this._p0 = this._p1 = this._m0 = this._m1 = this._recip = 0
        },
        _isHermite: function() {
            return 2 === this._curve.type || 3 === this._curve.type || 4 === this._curve.type
        },
        _calcTangents: function(a, b) {
            var c = a[b],
                d = a[b + 1];
            var e = 0 === b ? [a[0][0] + (a[0][0] - a[1][0]), a[0][1] + (a[0][1] - a[1][1])] : a[b - 1];
            a = b == a.length - 2 ? [a[b + 1][0] + (a[b + 1][0] - a[b][0]), a[b + 1][1] + (a[b + 1][1] - a[b][1])] : a[b + 2];
            if (4 === this._curve.type) {
                b = 2 * (d[0] - c[0]) / (d[0] - e[0]);
                var f = 2 * (d[0] - c[0]) / (a[0] - c[0]);
                this._m0 = this._curve.tension *
                    (isFinite(b) ? b : 0) * (d[1] - e[1]);
                this._m1 = this._curve.tension * (isFinite(f) ? f : 0) * (a[1] - c[1])
            } else f = (d[0] - c[0]) / (c[0] - e[0]), b = (d[0] - c[0]) / (a[0] - d[0]), e = c[1] + (e[1] - c[1]) * (isFinite(f) ? f : 0), a = d[1] + (a[1] - d[1]) * (isFinite(b) ? b : 0), b = 2 === this._curve.type ? .5 : this._curve.tension, this._m0 = b * (d[1] - e), this._m1 = b * (a - c[1])
        },
        _evaluateHermite: function(a, b, c, d, e) {
            var f = e * e,
                g = e + e,
                k = 1 - e;
            k *= k;
            return a * (1 + g) * k + c * e * k + b * f * (3 - g) + d * f * (e - 1)
        }
    });
    Object.assign(hb.prototype, {
        add: function(a, b) {
            for (var c = this.keys, d = c.length, e = 0; e < d &&
                !(c[e][0] > a); e++);
            a = [a, b];
            this.keys.splice(e, 0, a);
            return a
        },
        get: function(a) {
            return this.keys[a]
        },
        sort: function() {
            this.keys.sort(function(a, b) {
                return a[0] - b[0]
            })
        },
        value: function(a) {
            return this._eval.evaluate(a, !0)
        },
        closest: function(a) {
            for (var b = this.keys, c = b.length, d = 2, e = null, f = 0; f < c; f++) {
                var g = Math.abs(a - b[f][0]);
                if (d >= g) d = g, e = b[f];
                else break
            }
            return e
        },
        clone: function() {
            var a = new hb;
            a.keys = Hc(a.keys, this.keys);
            a.type = this.type;
            a.tension = this.tension;
            return a
        },
        quantize: function(a) {
            a = Math.max(a, 2);
            var b =
                new Float32Array(a),
                c = 1 / (a - 1);
            b[0] = this._eval.evaluate(0, !0);
            for (var d = 1; d < a; d++) b[d] = this._eval.evaluate(c * d);
            return b
        },
        quantizeClamped: function(a, b, c) {
            a = this.quantize(a);
            for (var d = 0; d < a.length; ++d) a[d] = Math.min(c, Math.max(b, a[d]));
            return a
        }
    });
    Object.defineProperty(hb.prototype, "length", {
        get: function() {
            return this.keys.length
        }
    });
    Object.assign(Cb.prototype, {
        get: function(a) {
            return this.curves[a]
        },
        value: function(a, b) {
            var c = this.curves.length;
            b = b || [];
            b.length = c;
            for (var d = 0; d < c; d++) b[d] = this.curves[d].value(a);
            return b
        },
        clone: function() {
            var a = new Cb;
            a.curves = [];
            for (var b = 0; b < this.curves.length; b++) a.curves.push(this.curves[b].clone());
            a._type = this._type;
            return a
        },
        quantize: function(a) {
            a = Math.max(a, 2);
            for (var b = this.curves.length, c = new Float32Array(a * b), d = 1 / (a - 1), e = 0; e < b; e++)
                for (var f = new fi(this.curves[e]), g = 0; g < a; g++) c[g * b + e] = f.evaluate(d * g);
            return c
        },
        quantizeClamped: function(a, b, c) {
            a = this.quantize(a);
            for (var d = 0; d < a.length; ++d) a[d] = Math.min(c, Math.max(b, a[d]));
            return a
        }
    });
    Object.defineProperty(Cb.prototype,
        "length", {
            get: function() {
                return this.curves.length
            }
        });
    Object.defineProperty(Cb.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            this._type = a;
            for (var b = 0; b < this.curves.length; b++) this.curves[b].type = a
        }
    });
    Object.assign(rb.prototype, {
        clone: function() {
            return (new rb).copy(this)
        },
        copy: function(a) {
            a = a.data;
            var b = this.data;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            return this
        },
        set: function(a) {
            var b = this.data;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            return this
        },
        equals: function(a) {
            var b = this.data;
            a = a.data;
            return b[0] === a[0] && b[1] === a[1] && b[2] === a[2] && b[3] === a[3] && b[4] === a[4] && b[5] === a[5] && b[6] === a[6] && b[7] === a[7] && b[8] === a[8]
        },
        isIdentity: function() {
            var a = this.data;
            return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 1 === a[4] && 0 === a[5] && 0 === a[6] && 0 === a[7] && 1 === a[8]
        },
        setIdentity: function() {
            var a = this.data;
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 1;
            a[5] = 0;
            a[6] = 0;
            a[7] = 0;
            a[8] = 1;
            return this
        },
        toString: function() {
            for (var a =
                    "[", b = 0; 9 > b; b++) a += this.data[b], a += 8 !== b ? ", " : "";
            return a + "]"
        },
        transpose: function() {
            var a = this.data;
            var b = a[1];
            a[1] = a[3];
            a[3] = b;
            b = a[2];
            a[2] = a[6];
            a[6] = b;
            b = a[5];
            a[5] = a[7];
            a[7] = b;
            return this
        }
    });
    Object.defineProperties(rb, {
        ZERO: {
            value: (new rb).set([0, 0, 0, 0, 0, 0, 0, 0, 0])
        },
        IDENTITY: {
            value: new rb
        }
    });
    Object.freeze(rb.ZERO);
    Object.freeze(rb.IDENTITY);
    Object.assign(P.prototype, {
        add: function(a) {
            this.x += a.x;
            this.y += a.y;
            return this
        },
        add2: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this
        },
        clone: function() {
            return (new P).copy(this)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            return this
        },
        distance: function(a) {
            var b = this.x - a.x;
            a = this.y - a.y;
            return Math.sqrt(b * b + a * a)
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y
        },
        equals: function(a) {
            return this.x === a.x && this.y === a.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        lerp: function(a, b, c) {
            this.x = a.x + c * (b.x - a.x);
            this.y = a.y + c * (b.y - a.y);
            return this
        },
        mul: function(a) {
            this.x *= a.x;
            this.y *= a.y;
            return this
        },
        mul2: function(a, b) {
            this.x =
                a.x * b.x;
            this.y = a.y * b.y;
            return this
        },
        normalize: function() {
            var a = this.x * this.x + this.y * this.y;
            0 < a && (a = 1 / Math.sqrt(a), this.x *= a, this.y *= a);
            return this
        },
        scale: function(a) {
            this.x *= a;
            this.y *= a;
            return this
        },
        set: function(a, b) {
            this.x = a;
            this.y = b;
            return this
        },
        sub: function(a) {
            this.x -= a.x;
            this.y -= a.y;
            return this
        },
        sub2: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this
        },
        toString: function() {
            return "[" + this.x + ", " + this.y + "]"
        }
    });
    Object.defineProperties(P, {
        ZERO: {
            value: new P(0, 0)
        },
        ONE: {
            value: new P(1, 1)
        },
        UP: {
            value: new P(0,
                1)
        },
        DOWN: {
            value: new P(0, -1)
        },
        RIGHT: {
            value: new P(1, 0)
        },
        LEFT: {
            value: new P(-1, 0)
        }
    });
    Object.freeze(P.ZERO);
    Object.freeze(P.ONE);
    Object.freeze(P.UP);
    Object.freeze(P.DOWN);
    Object.freeze(P.RIGHT);
    Object.freeze(P.LEFT);
    Object.assign(z.prototype, {
        add: function(a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            return this
        },
        add2: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this
        },
        clone: function() {
            return (new z).copy(this)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this
        },
        cross: function(a,
            b) {
            var c = a.x,
                d = a.y;
            a = a.z;
            var e = b.x,
                f = b.y;
            b = b.z;
            this.x = d * b - f * a;
            this.y = a * e - b * c;
            this.z = c * f - e * d;
            return this
        },
        distance: function(a) {
            var b = this.x - a.x,
                c = this.y - a.y;
            a = this.z - a.z;
            return Math.sqrt(b * b + c * c + a * a)
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z
        },
        equals: function(a) {
            return this.x === a.x && this.y === a.y && this.z === a.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        lerp: function(a, b, c) {
            this.x =
                a.x + c * (b.x - a.x);
            this.y = a.y + c * (b.y - a.y);
            this.z = a.z + c * (b.z - a.z);
            return this
        },
        mul: function(a) {
            this.x *= a.x;
            this.y *= a.y;
            this.z *= a.z;
            return this
        },
        mul2: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this
        },
        normalize: function() {
            var a = this.x * this.x + this.y * this.y + this.z * this.z;
            0 < a && (a = 1 / Math.sqrt(a), this.x *= a, this.y *= a, this.z *= a);
            return this
        },
        project: function(a) {
            var b = (this.x * a.x + this.y * a.y + this.z * a.z) / (a.x * a.x + a.y * a.y + a.z * a.z);
            this.x = a.x * b;
            this.y = a.y * b;
            this.z = a.z * b;
            return this
        },
        scale: function(a) {
            this.x *=
                a;
            this.y *= a;
            this.z *= a;
            return this
        },
        set: function(a, b, c) {
            this.x = a;
            this.y = b;
            this.z = c;
            return this
        },
        sub: function(a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            return this
        },
        sub2: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this
        },
        toString: function() {
            return "[" + this.x + ", " + this.y + ", " + this.z + "]"
        }
    });
    Object.defineProperties(z, {
        ZERO: {
            value: new z(0, 0, 0)
        },
        ONE: {
            value: new z(1, 1, 1)
        },
        UP: {
            value: new z(0, 1, 0)
        },
        DOWN: {
            value: new z(0, -1, 0)
        },
        RIGHT: {
            value: new z(1, 0, 0)
        },
        LEFT: {
            value: new z(-1, 0, 0)
        },
        FORWARD: {
            value: new z(0,
                0, -1)
        },
        BACK: {
            value: new z(0, 0, 1)
        }
    });
    Object.freeze(z.ZERO);
    Object.freeze(z.ONE);
    Object.freeze(z.UP);
    Object.freeze(z.DOWN);
    Object.freeze(z.RIGHT);
    Object.freeze(z.LEFT);
    Object.freeze(z.FORWARD);
    Object.freeze(z.BACK);
    Object.assign(X.prototype, {
        add: function(a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            this.w += a.w;
            return this
        },
        add2: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this
        },
        clone: function() {
            return (new X).copy(this)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            this.w = a.w;
            return this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
        },
        equals: function(a) {
            return this.x === a.x && this.y === a.y && this.z === a.z && this.w === a.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        lerp: function(a, b, c) {
            this.x = a.x + c * (b.x - a.x);
            this.y = a.y + c * (b.y - a.y);
            this.z = a.z + c * (b.z - a.z);
            this.w = a.w + c * (b.w - a.w);
            return this
        },
        mul: function(a) {
            this.x *=
                a.x;
            this.y *= a.y;
            this.z *= a.z;
            this.w *= a.w;
            return this
        },
        mul2: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            this.w = a.w * b.w;
            return this
        },
        normalize: function() {
            var a = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            0 < a && (a = 1 / Math.sqrt(a), this.x *= a, this.y *= a, this.z *= a, this.w *= a);
            return this
        },
        scale: function(a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            this.w *= a;
            return this
        },
        set: function(a, b, c, d) {
            this.x = a;
            this.y = b;
            this.z = c;
            this.w = d;
            return this
        },
        sub: function(a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            this.w -=
                a.w;
            return this
        },
        sub2: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this
        },
        toString: function() {
            return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]"
        }
    });
    Object.defineProperties(X, {
        ZERO: {
            value: new X(0, 0, 0, 0)
        },
        ONE: {
            value: new X(1, 1, 1, 1)
        }
    });
    Object.freeze(X.ZERO);
    Object.freeze(X.ONE);
    var Tf = new P;
    J._getPerspectiveHalfSize = function(a, b, c, d, e) {
        e ? (a.x = d * Math.tan(b * Math.PI / 360), a.y = a.x / c) : (a.y = d * Math.tan(b * Math.PI / 360), a.x = a.y * c)
    };
    Object.assign(J.prototype, {
        add2: function(a,
            b) {
            a = a.data;
            b = b.data;
            var c = this.data;
            c[0] = a[0] + b[0];
            c[1] = a[1] + b[1];
            c[2] = a[2] + b[2];
            c[3] = a[3] + b[3];
            c[4] = a[4] + b[4];
            c[5] = a[5] + b[5];
            c[6] = a[6] + b[6];
            c[7] = a[7] + b[7];
            c[8] = a[8] + b[8];
            c[9] = a[9] + b[9];
            c[10] = a[10] + b[10];
            c[11] = a[11] + b[11];
            c[12] = a[12] + b[12];
            c[13] = a[13] + b[13];
            c[14] = a[14] + b[14];
            c[15] = a[15] + b[15];
            return this
        },
        add: function(a) {
            return this.add2(this, a)
        },
        clone: function() {
            return (new J).copy(this)
        },
        copy: function(a) {
            a = a.data;
            var b = this.data;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            b[9] = a[9];
            b[10] = a[10];
            b[11] = a[11];
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            b[15] = a[15];
            return this
        },
        equals: function(a) {
            var b = this.data;
            a = a.data;
            return b[0] === a[0] && b[1] === a[1] && b[2] === a[2] && b[3] === a[3] && b[4] === a[4] && b[5] === a[5] && b[6] === a[6] && b[7] === a[7] && b[8] === a[8] && b[9] === a[9] && b[10] === a[10] && b[11] === a[11] && b[12] === a[12] && b[13] === a[13] && b[14] === a[14] && b[15] === a[15]
        },
        isIdentity: function() {
            var a = this.data;
            return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 0 === a[4] && 1 === a[5] && 0 === a[6] &&
                0 === a[7] && 0 === a[8] && 0 === a[9] && 1 === a[10] && 0 === a[11] && 0 === a[12] && 0 === a[13] && 0 === a[14] && 1 === a[15]
        },
        mul2: function(a, b) {
            var c = a.data;
            var d = b.data,
                e = this.data;
            b = c[0];
            a = c[1];
            var f = c[2];
            var g = c[3];
            var k = c[4];
            var h = c[5];
            var l = c[6];
            var n = c[7];
            var p = c[8];
            var q = c[9];
            var r = c[10];
            var t = c[11];
            var u = c[12];
            var x = c[13];
            var v = c[14];
            c = c[15];
            var w = d[0];
            var y = d[1];
            var A = d[2];
            var B = d[3];
            e[0] = b * w + k * y + p * A + u * B;
            e[1] = a * w + h * y + q * A + x * B;
            e[2] = f * w + l * y + r * A + v * B;
            e[3] = g * w + n * y + t * A + c * B;
            w = d[4];
            y = d[5];
            A = d[6];
            B = d[7];
            e[4] = b * w + k * y + p * A + u * B;
            e[5] =
                a * w + h * y + q * A + x * B;
            e[6] = f * w + l * y + r * A + v * B;
            e[7] = g * w + n * y + t * A + c * B;
            w = d[8];
            y = d[9];
            A = d[10];
            B = d[11];
            e[8] = b * w + k * y + p * A + u * B;
            e[9] = a * w + h * y + q * A + x * B;
            e[10] = f * w + l * y + r * A + v * B;
            e[11] = g * w + n * y + t * A + c * B;
            w = d[12];
            y = d[13];
            A = d[14];
            B = d[15];
            e[12] = b * w + k * y + p * A + u * B;
            e[13] = a * w + h * y + q * A + x * B;
            e[14] = f * w + l * y + r * A + v * B;
            e[15] = g * w + n * y + t * A + c * B;
            return this
        },
        mulAffine2: function(a, b) {
            var c = a.data;
            var d = b.data,
                e = this.data;
            b = c[0];
            a = c[1];
            var f = c[2];
            var g = c[4];
            var k = c[5];
            var h = c[6];
            var l = c[8];
            var n = c[9];
            var p = c[10];
            var q = c[12];
            var r = c[13];
            c = c[14];
            var t = d[0];
            var u = d[1];
            var x = d[2];
            e[0] = b * t + g * u + l * x;
            e[1] = a * t + k * u + n * x;
            e[2] = f * t + h * u + p * x;
            e[3] = 0;
            t = d[4];
            u = d[5];
            x = d[6];
            e[4] = b * t + g * u + l * x;
            e[5] = a * t + k * u + n * x;
            e[6] = f * t + h * u + p * x;
            e[7] = 0;
            t = d[8];
            u = d[9];
            x = d[10];
            e[8] = b * t + g * u + l * x;
            e[9] = a * t + k * u + n * x;
            e[10] = f * t + h * u + p * x;
            e[11] = 0;
            t = d[12];
            u = d[13];
            x = d[14];
            e[12] = b * t + g * u + l * x + q;
            e[13] = a * t + k * u + n * x + r;
            e[14] = f * t + h * u + p * x + c;
            e[15] = 1;
            return this
        },
        mul: function(a) {
            return this.mul2(this, a)
        },
        transformPoint: function(a, b) {
            var c = this.data;
            var d = a.x;
            var e = a.y;
            a = a.z;
            b = void 0 === b ? new z : b;
            b.x = d * c[0] + e * c[4] + a * c[8] +
                c[12];
            b.y = d * c[1] + e * c[5] + a * c[9] + c[13];
            b.z = d * c[2] + e * c[6] + a * c[10] + c[14];
            return b
        },
        transformVector: function(a, b) {
            var c = this.data;
            var d = a.x;
            var e = a.y;
            a = a.z;
            b = void 0 === b ? new z : b;
            b.x = d * c[0] + e * c[4] + a * c[8];
            b.y = d * c[1] + e * c[5] + a * c[9];
            b.z = d * c[2] + e * c[6] + a * c[10];
            return b
        },
        transformVec4: function(a, b) {
            var c = this.data;
            var d = a.x;
            var e = a.y;
            var f = a.z;
            a = a.w;
            b = void 0 === b ? new X : b;
            b.x = d * c[0] + e * c[4] + f * c[8] + a * c[12];
            b.y = d * c[1] + e * c[5] + f * c[9] + a * c[13];
            b.z = d * c[2] + e * c[6] + f * c[10] + a * c[14];
            b.w = d * c[3] + e * c[7] + f * c[11] + a * c[15];
            return b
        },
        setLookAt: function() {
            var a = new z;
            var b = new z;
            var c = new z;
            return function(d, e, f) {
                c.sub2(d, e).normalize();
                b.copy(f).normalize();
                a.cross(b, c).normalize();
                b.cross(c, a);
                e = this.data;
                e[0] = a.x;
                e[1] = a.y;
                e[2] = a.z;
                e[3] = 0;
                e[4] = b.x;
                e[5] = b.y;
                e[6] = b.z;
                e[7] = 0;
                e[8] = c.x;
                e[9] = c.y;
                e[10] = c.z;
                e[11] = 0;
                e[12] = d.x;
                e[13] = d.y;
                e[14] = d.z;
                e[15] = 1;
                return this
            }
        }(),
        setFrustum: function(a, b, c, d, e, f) {
            var g = 2 * e;
            var k = b - a;
            var h = d - c;
            var l = f - e;
            var n = this.data;
            n[0] = g / k;
            n[1] = 0;
            n[2] = 0;
            n[3] = 0;
            n[4] = 0;
            n[5] = g / h;
            n[6] = 0;
            n[7] = 0;
            n[8] = (b + a) / k;
            n[9] =
                (d + c) / h;
            n[10] = (-f - e) / l;
            n[11] = -1;
            n[12] = 0;
            n[13] = 0;
            n[14] = -g * f / l;
            n[15] = 0;
            return this
        },
        setPerspective: function(a, b, c, d, e) {
            J._getPerspectiveHalfSize(Tf, a, b, c, e);
            return this.setFrustum(-Tf.x, Tf.x, -Tf.y, Tf.y, c, d)
        },
        setOrtho: function(a, b, c, d, e, f) {
            var g = this.data;
            g[0] = 2 / (b - a);
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = 2 / (d - c);
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[10] = -2 / (f - e);
            g[11] = 0;
            g[12] = -(b + a) / (b - a);
            g[13] = -(d + c) / (d - c);
            g[14] = -(f + e) / (f - e);
            g[15] = 1;
            return this
        },
        setFromAxisAngle: function(a, b) {
            b *= N.DEG_TO_RAD;
            var c = a.x;
            var d = a.y;
            a = a.z;
            var e = Math.cos(b);
            b = Math.sin(b);
            var f = 1 - e;
            var g = f * c;
            var k = f * d;
            var h = this.data;
            h[0] = g * c + e;
            h[1] = g * d + b * a;
            h[2] = g * a - b * d;
            h[3] = 0;
            h[4] = g * d - b * a;
            h[5] = k * d + e;
            h[6] = k * a + b * c;
            h[7] = 0;
            h[8] = g * a + b * d;
            h[9] = k * a - c * b;
            h[10] = f * a * a + e;
            h[11] = 0;
            h[12] = 0;
            h[13] = 0;
            h[14] = 0;
            h[15] = 1;
            return this
        },
        setTranslate: function(a, b, c) {
            var d = this.data;
            d[0] = 1;
            d[1] = 0;
            d[2] = 0;
            d[3] = 0;
            d[4] = 0;
            d[5] = 1;
            d[6] = 0;
            d[7] = 0;
            d[8] = 0;
            d[9] = 0;
            d[10] = 1;
            d[11] = 0;
            d[12] = a;
            d[13] = b;
            d[14] = c;
            d[15] = 1;
            return this
        },
        setScale: function(a, b, c) {
            var d = this.data;
            d[0] = a;
            d[1] = 0;
            d[2] =
                0;
            d[3] = 0;
            d[4] = 0;
            d[5] = b;
            d[6] = 0;
            d[7] = 0;
            d[8] = 0;
            d[9] = 0;
            d[10] = c;
            d[11] = 0;
            d[12] = 0;
            d[13] = 0;
            d[14] = 0;
            d[15] = 1;
            return this
        },
        invert: function() {
            var a = this.data;
            var b = a[0];
            var c = a[1];
            var d = a[2];
            var e = a[3];
            var f = a[4];
            var g = a[5];
            var k = a[6];
            var h = a[7];
            var l = a[8];
            var n = a[9];
            var p = a[10];
            var q = a[11];
            var r = a[12];
            var t = a[13];
            var u = a[14];
            var x = a[15];
            var v = b * g - c * f;
            var w = b * k - d * f;
            var y = b * h - e * f;
            var A = c * k - d * g;
            var B = c * h - e * g;
            var E = d * h - e * k;
            var D = l * t - n * r;
            var C = l * u - p * r;
            var G = l * x - q * r;
            var K = n * u - p * t;
            var R = n * x - q * t;
            var I = p * x - q * u;
            var T =
                v * I - w * R + y * K + A * G - B * C + E * D;
            0 === T ? this.setIdentity() : (T = 1 / T, a[0] = (g * I - k * R + h * K) * T, a[1] = (-c * I + d * R - e * K) * T, a[2] = (t * E - u * B + x * A) * T, a[3] = (-n * E + p * B - q * A) * T, a[4] = (-f * I + k * G - h * C) * T, a[5] = (b * I - d * G + e * C) * T, a[6] = (-r * E + u * y - x * w) * T, a[7] = (l * E - p * y + q * w) * T, a[8] = (f * R - g * G + h * D) * T, a[9] = (-b * R + c * G - e * D) * T, a[10] = (r * B - t * y + x * v) * T, a[11] = (-l * B + n * y - q * v) * T, a[12] = (-f * K + g * C - k * D) * T, a[13] = (b * K - c * C + d * D) * T, a[14] = (-r * A + t * w - u * v) * T, a[15] = (l * A - n * w + p * v) * T);
            return this
        },
        set: function(a) {
            var b = this.data;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            b[9] = a[9];
            b[10] = a[10];
            b[11] = a[11];
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            b[15] = a[15];
            return this
        },
        setIdentity: function() {
            var a = this.data;
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = 1;
            a[6] = 0;
            a[7] = 0;
            a[8] = 0;
            a[9] = 0;
            a[10] = 1;
            a[11] = 0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return this
        },
        setTRS: function(a, b, c) {
            var d = b.x;
            var e = b.y;
            var f = b.z;
            var g = b.w;
            b = c.x;
            var k = c.y;
            c = c.z;
            var h = d + d;
            var l = e + e;
            var n = f + f;
            var p = d * h;
            var q = d * l;
            d *= n;
            var r = e * l;
            e *= n;
            f *= n;
            h *= g;
            l *= g;
            g *= n;
            n = this.data;
            n[0] = (1 - (r +
                f)) * b;
            n[1] = (q + g) * b;
            n[2] = (d - l) * b;
            n[3] = 0;
            n[4] = (q - g) * k;
            n[5] = (1 - (p + f)) * k;
            n[6] = (e + h) * k;
            n[7] = 0;
            n[8] = (d + l) * c;
            n[9] = (e - h) * c;
            n[10] = (1 - (p + r)) * c;
            n[11] = 0;
            n[12] = a.x;
            n[13] = a.y;
            n[14] = a.z;
            n[15] = 1;
            return this
        },
        transpose: function() {
            var a = this.data;
            var b = a[1];
            a[1] = a[4];
            a[4] = b;
            b = a[2];
            a[2] = a[8];
            a[8] = b;
            b = a[3];
            a[3] = a[12];
            a[12] = b;
            b = a[6];
            a[6] = a[9];
            a[9] = b;
            b = a[7];
            a[7] = a[13];
            a[13] = b;
            b = a[11];
            a[11] = a[14];
            a[14] = b;
            return this
        },
        invertTo3x3: function(a) {
            var b = this.data;
            a = a.data;
            var c = b[0],
                d = b[1],
                e = b[2],
                f = b[4],
                g = b[5],
                k = b[6],
                h = b[8],
                l =
                b[9],
                n = b[10];
            b = n * g - k * l;
            var p = -n * f + k * h;
            var q = l * f - g * h;
            var r = c * b + d * p + e * q;
            if (0 === r) return this;
            r = 1 / r;
            a[0] = r * b;
            a[1] = r * (-n * d + e * l);
            a[2] = r * (k * d - e * g);
            a[3] = r * p;
            a[4] = r * (n * c - e * h);
            a[5] = r * (-k * c + e * f);
            a[6] = r * q;
            a[7] = r * (-l * c + d * h);
            a[8] = r * (g * c - d * f);
            return this
        },
        getTranslation: function(a) {
            a = void 0 === a ? new z : a;
            return a.set(this.data[12], this.data[13], this.data[14])
        },
        getX: function(a) {
            a = void 0 === a ? new z : a;
            return a.set(this.data[0], this.data[1], this.data[2])
        },
        getY: function(a) {
            a = void 0 === a ? new z : a;
            return a.set(this.data[4],
                this.data[5], this.data[6])
        },
        getZ: function(a) {
            a = void 0 === a ? new z : a;
            return a.set(this.data[8], this.data[9], this.data[10])
        },
        getScale: function() {
            var a = new z;
            var b = new z;
            var c = new z;
            return function(d) {
                d = void 0 === d ? new z : d;
                this.getX(a);
                this.getY(b);
                this.getZ(c);
                d.set(a.length(), b.length(), c.length());
                return d
            }
        }(),
        setFromEulerAngles: function(a, b, c) {
            a *= N.DEG_TO_RAD;
            b *= N.DEG_TO_RAD;
            c *= N.DEG_TO_RAD;
            var d = Math.sin(-a);
            a = Math.cos(-a);
            var e = Math.sin(-b);
            b = Math.cos(-b);
            var f = Math.sin(-c);
            c = Math.cos(-c);
            var g = this.data;
            g[0] = b * c;
            g[1] = -b * f;
            g[2] = e;
            g[3] = 0;
            g[4] = a * f + c * d * e;
            g[5] = a * c - d * e * f;
            g[6] = -b * d;
            g[7] = 0;
            g[8] = d * f - a * c * e;
            g[9] = c * d + a * e * f;
            g[10] = a * b;
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return this
        },
        getEulerAngles: function() {
            var a = new z;
            return function(b) {
                b = void 0 === b ? new z : b;
                this.getScale(a);
                var c = a.x;
                var d = a.y;
                var e = a.z;
                var f = this.data;
                var g = Math.asin(-f[2] / c);
                var k = .5 * Math.PI;
                g < k ? g > -k ? (d = Math.atan2(f[6] / d, f[10] / e), c = Math.atan2(f[1] / c, f[0] / c)) : (c = 0, d = -Math.atan2(f[4] / d, f[5] / d)) : (c = 0, d = Math.atan2(f[4] / d, f[5] / d));
                return b.set(d,
                    g, c).scale(N.RAD_TO_DEG)
            }
        }(),
        toString: function() {
            var a;
            var b = "[";
            for (a = 0; 16 > a; a += 1) b += this.data[a], b += 15 !== a ? ", " : "";
            return b + "]"
        }
    });
    Object.defineProperties(J, {
        ZERO: {
            value: (new J).set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
        },
        IDENTITY: {
            value: new J
        }
    });
    Object.freeze(J.ZERO);
    Object.freeze(J.IDENTITY);
    Object.assign(Y.prototype, {
        clone: function() {
            return new Y(this.x, this.y, this.z, this.w)
        },
        conjugate: function() {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            return this
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            this.w =
                a.w;
            return this
        },
        equals: function(a) {
            return this.x === a.x && this.y === a.y && this.z === a.z && this.w === a.w
        },
        getAxisAngle: function(a) {
            var b = 2 * Math.acos(this.w),
                c = Math.sin(b / 2);
            if (0 !== c) {
                if (a.x = this.x / c, a.y = this.y / c, a.z = this.z / c, 0 > a.x || 0 > a.y || 0 > a.z) a.x *= -1, a.y *= -1, a.z *= -1, b *= -1
            } else a.x = 1, a.y = 0, a.z = 0;
            return b * N.RAD_TO_DEG
        },
        getEulerAngles: function(a) {
            a = void 0 === a ? new z : a;
            var b = this.x;
            var c = this.y;
            var d = this.z;
            var e = this.w;
            var f = 2 * (e * c - b * d);
            if (-.99999 >= f) {
                var g = 2 * Math.atan2(b, e);
                f = -Math.PI / 2;
                b = 0
            } else .99999 <= f ?
                (g = 2 * Math.atan2(b, e), f = Math.PI / 2, b = 0) : (g = Math.atan2(2 * (e * b + c * d), 1 - 2 * (b * b + c * c)), f = Math.asin(f), b = Math.atan2(2 * (e * d + b * c), 1 - 2 * (c * c + d * d)));
            return a.set(g, f, b).scale(N.RAD_TO_DEG)
        },
        invert: function() {
            return this.conjugate().normalize()
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        mul: function(a) {
            var b = this.x;
            var c = this.y;
            var d = this.z;
            var e = this.w;
            var f = a.x;
            var g = a.y;
            var k =
                a.z;
            a = a.w;
            this.x = e * f + b * a + c * k - d * g;
            this.y = e * g + c * a + d * f - b * k;
            this.z = e * k + d * a + b * g - c * f;
            this.w = e * a - b * f - c * g - d * k;
            return this
        },
        mul2: function(a, b) {
            var c = a.x;
            var d = a.y;
            var e = a.z;
            a = a.w;
            var f = b.x;
            var g = b.y;
            var k = b.z;
            b = b.w;
            this.x = a * f + c * b + d * k - e * g;
            this.y = a * g + d * b + e * f - c * k;
            this.z = a * k + e * b + c * g - d * f;
            this.w = a * b - c * f - d * g - e * k;
            return this
        },
        normalize: function() {
            var a = this.length();
            0 === a ? (this.x = this.y = this.z = 0, this.w = 1) : (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a);
            return this
        },
        set: function(a, b, c, d) {
            this.x = a;
            this.y = b;
            this.z = c;
            this.w = d;
            return this
        },
        setFromAxisAngle: function(a, b) {
            b *= .5 * N.DEG_TO_RAD;
            var c = Math.sin(b);
            b = Math.cos(b);
            this.x = c * a.x;
            this.y = c * a.y;
            this.z = c * a.z;
            this.w = b;
            return this
        },
        setFromEulerAngles: function(a, b, c) {
            var d = .5 * N.DEG_TO_RAD;
            a *= d;
            b *= d;
            c *= d;
            d = Math.sin(a);
            a = Math.cos(a);
            var e = Math.sin(b);
            b = Math.cos(b);
            var f = Math.sin(c);
            c = Math.cos(c);
            this.x = d * b * c - a * e * f;
            this.y = a * e * c + d * b * f;
            this.z = a * b * f - d * e * c;
            this.w = a * b * c + d * e * f;
            return this
        },
        setFromMat4: function(a) {
            a = a.data;
            var b = a[0];
            var c = a[1];
            var d = a[2];
            var e = a[4];
            var f =
                a[5];
            var g = a[6];
            var k = a[8];
            var h = a[9];
            a = a[10];
            var l = b * b + c * c + d * d;
            if (0 === l) return this;
            l = 1 / Math.sqrt(l);
            var n = e * e + f * f + g * g;
            if (0 === n) return this;
            n = 1 / Math.sqrt(n);
            var p = k * k + h * h + a * a;
            if (0 === p) return this;
            p = 1 / Math.sqrt(p);
            b *= l;
            c *= l;
            d *= l;
            e *= n;
            f *= n;
            g *= n;
            k *= p;
            h *= p;
            a *= p;
            l = b + f + a;
            0 <= l ? (b = Math.sqrt(l + 1), this.w = .5 * b, b = .5 / b, this.x = (g - h) * b, this.y = (k - d) * b, this.z = (c - e) * b) : b > f ? b > a ? (b = Math.sqrt(b - (f + a) + 1), this.x = .5 * b, b = .5 / b, this.w = (g - h) * b, this.y = (c + e) * b, this.z = (d + k) * b) : (b = Math.sqrt(a - (b + f) + 1), this.z = .5 * b, b = .5 / b, this.w =
                (c - e) * b, this.x = (k + d) * b, this.y = (h + g) * b) : f > a ? (b = Math.sqrt(f - (a + b) + 1), this.y = .5 * b, b = .5 / b, this.w = (k - d) * b, this.z = (g + h) * b, this.x = (e + c) * b) : (b = Math.sqrt(a - (b + f) + 1), this.z = .5 * b, b = .5 / b, this.w = (c - e) * b, this.x = (k + d) * b, this.y = (h + g) * b);
            return this
        },
        slerp: function(a, b, c) {
            var d = a.x;
            var e = a.y;
            var f = a.z;
            a = a.w;
            var g = b.x;
            var k = b.y;
            var h = b.z;
            b = b.w;
            var l = a * b + d * g + e * k + f * h;
            0 > l && (b = -b, g = -g, k = -k, h = -h, l = -l);
            if (1 <= Math.abs(l)) return this.w = a, this.x = d, this.y = e, this.z = f, this;
            var n = Math.acos(l),
                p = Math.sqrt(1 - l * l);
            if (.001 > Math.abs(p)) return this.w =
                .5 * a + .5 * b, this.x = .5 * d + .5 * g, this.y = .5 * e + .5 * k, this.z = .5 * f + .5 * h, this;
            l = Math.sin((1 - c) * n) / p;
            c = Math.sin(c * n) / p;
            this.w = a * l + b * c;
            this.x = d * l + g * c;
            this.y = e * l + k * c;
            this.z = f * l + h * c;
            return this
        },
        transformVector: function(a, b) {
            void 0 === b && (b = new z);
            var c = a.x,
                d = a.y,
                e = a.z;
            a = this.x;
            var f = this.y,
                g = this.z,
                k = this.w,
                h = k * c + f * e - g * d,
                l = k * d + g * c - a * e,
                n = k * e + a * d - f * c;
            c = -a * c - f * d - g * e;
            b.x = h * k + c * -a + l * -g - n * -f;
            b.y = l * k + c * -f + n * -a - h * -g;
            b.z = n * k + c * -g + h * -f - l * -a;
            return b
        },
        toString: function() {
            return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w +
                "]"
        }
    });
    Object.defineProperties(Y, {
        ZERO: {
            value: new Y(0, 0, 0, 0)
        },
        IDENTITY: {
            value: new Y(0, 0, 0, 1)
        }
    });
    Object.freeze(Y.ZERO);
    Object.freeze(Y.IDENTITY);
    var zc = new z,
        Wb = new z,
        Uf = new z,
        Vf = new z,
        de = new z;
    Object.assign(oa.prototype, {
        add: function(a) {
            var b = this.center,
                c = b.x,
                d = b.y,
                e = b.z,
                f = this.halfExtents,
                g = f.x,
                k = f.y,
                h = f.z,
                l = c - g;
            c += g;
            g = d - k;
            d += k;
            k = e - h;
            e += h;
            h = a.center;
            var n = h.x,
                p = h.y;
            h = h.z;
            a = a.halfExtents;
            var q = a.x,
                r = a.y,
                t = a.z;
            a = n - q;
            n += q;
            q = p - r;
            p += r;
            r = h - t;
            h += t;
            a < l && (l = a);
            n > c && (c = n);
            q < g && (g = q);
            p > d && (d = p);
            r < k && (k = r);
            h > e && (e = h);
            b.x = .5 * (l + c);
            b.y = .5 * (g + d);
            b.z = .5 * (k + e);
            f.x = .5 * (c - l);
            f.y = .5 * (d - g);
            f.z = .5 * (e - k)
        },
        copy: function(a) {
            this.center.copy(a.center);
            this.halfExtents.copy(a.halfExtents);
            this.type = a.type
        },
        clone: function() {
            return new oa(this.center.clone(), this.halfExtents.clone())
        },
        intersects: function(a) {
            var b = this.getMax(),
                c = this.getMin(),
                d = a.getMax();
            a = a.getMin();
            return c.x <= d.x && b.x >= a.x && c.y <= d.y && b.y >= a.y && c.z <= d.z && b.z >= a.z
        },
        _intersectsRay: function(a, b) {
            var c = zc.copy(this.getMin()).sub(a.origin),
                d = Wb.copy(this.getMax()).sub(a.origin),
                e = a.direction;
            0 === e.x ? (c.x = 0 > c.x ? -Number.MAX_VALUE : Number.MAX_VALUE, d.x = 0 > d.x ? -Number.MAX_VALUE : Number.MAX_VALUE) : (c.x /= e.x, d.x /= e.x);
            0 === e.y ? (c.y = 0 > c.y ? -Number.MAX_VALUE : Number.MAX_VALUE, d.y = 0 > d.y ? -Number.MAX_VALUE : Number.MAX_VALUE) : (c.y /= e.y, d.y /= e.y);
            0 === e.z ? (c.z = 0 > c.z ? -Number.MAX_VALUE : Number.MAX_VALUE, d.z = 0 > d.z ? -Number.MAX_VALUE : Number.MAX_VALUE) : (c.z /= e.z, d.z /= e.z);
            e = Uf.set(Math.min(c.x, d.x), Math.min(c.y, d.y), Math.min(c.z, d.z));
            c = Vf.set(Math.max(c.x, d.x), Math.max(c.y, d.y), Math.max(c.z, d.z));
            d = Math.max(Math.max(e.x, e.y), e.z);
            (c = Math.min(Math.min(c.x, c.y), c.z) >= d && 0 <= d) && b.copy(a.direction).scale(d).add(a.origin);
            return c
        },
        _fastIntersectsRay: function(a) {
            var b = a.direction;
            zc.sub2(a.origin, this.center);
            Vf.set(Math.abs(zc.x), Math.abs(zc.y), Math.abs(zc.z));
            Uf.mul2(zc, b);
            if (Vf.x > this.halfExtents.x && 0 <= Uf.x || Vf.y > this.halfExtents.y && 0 <= Uf.y || Vf.z > this.halfExtents.z && 0 <= Uf.z) return !1;
            de.set(Math.abs(b.x), Math.abs(b.y), Math.abs(b.z));
            Wb.cross(b, zc);
            Wb.set(Math.abs(Wb.x), Math.abs(Wb.y), Math.abs(Wb.z));
            return Wb.x > this.halfExtents.y * de.z + this.halfExtents.z * de.y || Wb.y > this.halfExtents.x * de.z + this.halfExtents.z * de.x || Wb.z > this.halfExtents.x * de.y + this.halfExtents.y * de.x ? !1 : !0
        },
        intersectsRay: function(a, b) {
            return b ? this._intersectsRay(a, b) : this._fastIntersectsRay(a)
        },
        setMinMax: function(a, b) {
            this.center.add2(b, a).scale(.5);
            this.halfExtents.sub2(b, a).scale(.5)
        },
        getMin: function() {
            return this._min.copy(this.center).sub(this.halfExtents)
        },
        getMax: function() {
            return this._max.copy(this.center).add(this.halfExtents)
        },
        containsPoint: function(a) {
            var b = this.getMin(),
                c = this.getMax();
            return a.x < b.x || a.x > c.x || a.y < b.y || a.y > c.y || a.z < b.z || a.z > c.z ? !1 : !0
        },
        setFromTransformedAabb: function(a, b) {
            var c = a.center;
            a = a.halfExtents;
            b = b.data;
            var d = b[0],
                e = b[4],
                f = b[8],
                g = b[1],
                k = b[5],
                h = b[9],
                l = b[2],
                n = b[6],
                p = b[10];
            this.center.set(b[12] + d * c.x + e * c.y + f * c.z, b[13] + g * c.x + k * c.y + h * c.z, b[14] + l * c.x + n * c.y + p * c.z);
            this.halfExtents.set(Math.abs(d) * a.x + Math.abs(e) * a.y + Math.abs(f) * a.z, Math.abs(g) * a.x + Math.abs(k) * a.y + Math.abs(h) * a.z, Math.abs(l) * a.x + Math.abs(n) *
                a.y + Math.abs(p) * a.z)
        },
        compute: function(a, b) {
            b = void 0 === b ? a.length / 3 : b;
            if (0 < b) {
                for (var c = zc.set(a[0], a[1], a[2]), d = Wb.set(a[0], a[1], a[2]), e = 1; e < b; e++) {
                    var f = a[3 * e],
                        g = a[3 * e + 1],
                        k = a[3 * e + 2];
                    f < c.x && (c.x = f);
                    g < c.y && (c.y = g);
                    k < c.z && (c.z = k);
                    f > d.x && (d.x = f);
                    g > d.y && (d.y = g);
                    k > d.z && (d.z = k)
                }
                this.setMinMax(c, d)
            }
        },
        intersectsBoundingSphere: function(a) {
            return this._distanceToBoundingSphereSq(a) <= a.radius * a.radius ? !0 : !1
        },
        _distanceToBoundingSphereSq: function(a) {
            for (var b = this.getMin(), c = this.getMax(), d = 0, e = ["x", "y", "z"],
                    f = 0; 3 > f; ++f) {
                var g = 0,
                    k = a.center[e[f]],
                    h = b[e[f]],
                    l = c[e[f]];
                k < h && (h -= k, g += h * h);
                k > l && (h = k - l, g += h * h);
                d += g
            }
            return d
        },
        _expand: function(a, b) {
            zc.add2(this.getMin(), a);
            Wb.add2(this.getMax(), b);
            this.setMinMax(zc, Wb)
        }
    });
    var ud = new z,
        mh = new z,
        Ve = new z,
        Zl = new z;
    Object.assign(Ed.prototype, {
        containsPoint: function(a) {
            a = ud.sub2(a, this.center).lengthSq();
            var b = this.radius;
            return a < b * b
        },
        compute: function(a) {
            var b, c = a.length / 3;
            for (b = 0; b < c; b++) ud.set(a[3 * b], a[3 * b + 1], a[3 * b + 2]), Ve.addSelf(ud), 0 === b % 100 && (Ve.scale(1 / c), mh.add(Ve),
                Ve.set(0, 0, 0));
            Ve.scale(1 / c);
            mh.add(Ve);
            this.center.copy(mh);
            var d = 0;
            for (b = 0; b < c; b++) ud.set(a[3 * b], a[3 * b + 1], a[3 * b + 2]), Zl.sub2(ud, this.center), d = Math.max(Zl.lengthSq(), d);
            this.radius = Math.sqrt(d)
        },
        intersectsRay: function(a, b) {
            var c = ud.copy(a.origin).sub(this.center),
                d = c.dot(mh.copy(a.direction).normalize());
            c = c.dot(c) - this.radius * this.radius;
            if (0 < c && 0 < d) return null;
            c = d * d - c;
            if (0 > c) return !1;
            d = Math.abs(-d - Math.sqrt(c));
            b && b.copy(a.direction).scale(d).add(a.origin);
            return !0
        },
        intersectsBoundingSphere: function(a) {
            ud.sub2(a.center,
                this.center);
            a = a.radius + this.radius;
            return ud.lengthSq() <= a * a ? !0 : !1
        }
    });
    Object.assign(ug.prototype, {
        setFromMat4: function(a) {
            a = a.data;
            var b = this.planes;
            var c = b[0];
            c[0] = a[3] - a[0];
            c[1] = a[7] - a[4];
            c[2] = a[11] - a[8];
            c[3] = a[15] - a[12];
            var d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[1];
            c[0] = a[3] + a[0];
            c[1] = a[7] + a[4];
            c[2] = a[11] + a[8];
            c[3] = a[15] + a[12];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[2];
            c[0] = a[3] + a[1];
            c[1] = a[7] + a[5];
            c[2] = a[11] + a[9];
            c[3] = a[15] + a[13];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[3];
            c[0] = a[3] - a[1];
            c[1] = a[7] - a[5];
            c[2] = a[11] - a[9];
            c[3] = a[15] - a[13];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[4];
            c[0] = a[3] - a[2];
            c[1] = a[7] - a[6];
            c[2] = a[11] - a[10];
            c[3] = a[15] - a[14];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[5];
            c[0] = a[3] + a[2];
            c[1] = a[7] + a[6];
            c[2] = a[11] + a[10];
            c[3] = a[15] + a[14];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /=
                d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d
        },
        containsPoint: function(a) {
            var b;
            for (b = 0; 6 > b; b++) {
                var c = this.planes[b];
                if (0 >= c[0] * a.x + c[1] * a.y + c[2] * a.z + c[3]) return !1
            }
            return !0
        },
        containsSphere: function(a) {
            var b = 0,
                c = a.radius;
            var d = a.center;
            a = d.x;
            var e = d.y,
                f = d.z,
                g = this.planes;
            for (d = 0; 6 > d; d++) {
                var k = g[d];
                k = k[0] * a + k[1] * e + k[2] * f + k[3];
                if (k <= -c) return 0;
                k > c && b++
            }
            return 6 === b ? 2 : 1
        }
    });
    cd.prototype.set = function(a, b) {
        this.origin.copy(a);
        this.direction.copy(b);
        return this
    };
    var nh = new cd,
        $l = new z,
        Oj = new Ed,
        Ck = new J;
    Object.assign(gi.prototype, {
        intersectsRay: function(a, b) {
            this._modelTransform.transformPoint(a.origin, nh.origin);
            this._modelTransform.transformVector(a.direction, nh.direction);
            return b ? (a = this._aabb._intersectsRay(nh, b), Ck.copy(this._modelTransform).invert().transformPoint(b, b), a) : this._aabb._fastIntersectsRay(nh)
        },
        containsPoint: function(a) {
            this._modelTransform.transformPoint(a, $l);
            return this._aabb.containsPoint($l)
        },
        intersectsBoundingSphere: function(a) {
            this._modelTransform.transformPoint(a.center, Oj.center);
            Oj.radius = a.radius;
            return this._aabb.intersectsBoundingSphere(Oj) ? !0 : !1
        }
    });
    Object.defineProperty(gi.prototype, "worldTransform", {
        get: function() {
            return this._worldTransform
        },
        set: function(a) {
            this._worldTransform.copy(a);
            this._modelTransform.copy(a).invert()
        }
    });
    var fp = new z;
    Object.assign(hi.prototype, {
        intersectsLine: function(a, b, c) {
            var d = -this.normal.dot(this.point),
                e = this.normal.dot(a) + d;
            d = this.normal.dot(b) + d;
            e /= e - d;
            (d = 0 <= e && 1 >= e) && c && c.lerp(a, b, e);
            return d
        },
        intersectsRay: function(a, b) {
            var c = fp.sub2(this.point, a.origin);
            c = this.normal.dot(c) / this.normal.dot(a.direction);
            var d = 0 <= c;
            d && b && b.copy(a.direction).scale(c).add(a.origin);
            return d
        }
    });
    var Fd = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array],
        sf = [1, 1, 2, 2, 4, 4, 4],
        am = [Uint8Array, Uint16Array, Uint32Array],
        Pj = {
            POSITION: 0,
            NORMAL: 1,
            BLENDWEIGHT: 2,
            BLENDINDICES: 3,
            COLOR: 4,
            TEXCOORD0: 5,
            TEXCOORD1: 6,
            TEXCOORD2: 7,
            TEXCOORD3: 8,
            TEXCOORD4: 9,
            TEXCOORD5: 10,
            TEXCOORD6: 11,
            TEXCOORD7: 12,
            TANGENT: 13,
            ATTR0: 0,
            ATTR1: 1,
            ATTR2: 2,
            ATTR3: 3,
            ATTR4: 4,
            ATTR5: 5,
            ATTR6: 6,
            ATTR7: 7,
            ATTR8: 8,
            ATTR9: 9,
            ATTR10: 10,
            ATTR11: 11,
            ATTR12: 12,
            ATTR13: 13,
            ATTR14: 14,
            ATTR15: 15
        },
        zn = 0;
    Object.assign(ab.prototype, {
        destroy: function() {
            var a = this.device,
                b = a.buffers.indexOf(this); - 1 !== b && a.buffers.splice(b, 1);
            this.bufferId && (b = a.gl, a.boundVao = null, b.bindVertexArray(null), b.deleteBuffer(this.bufferId), a._vram.vb -= this.storage.byteLength, this.bufferId = null)
        },
        getFormat: function() {
            return this.format
        },
        getUsage: function() {
            return this.usage
        },
        getNumVertices: function() {
            return this.numVertices
        },
        lock: function() {
            return this.storage
        },
        unlock: function() {
            var a = this.device.gl;
            this.bufferId || (this.bufferId = a.createBuffer());
            switch (this.usage) {
                case 0:
                    var b = a.STATIC_DRAW;
                    break;
                case 1:
                    b = a.DYNAMIC_DRAW;
                    break;
                case 2:
                    b = a.STREAM_DRAW;
                    break;
                case 3:
                    b = this.device.webgl2 ? a.DYNAMIC_COPY : a.STATIC_DRAW
            }
            a.bindBuffer(a.ARRAY_BUFFER, this.bufferId);
            a.bufferData(a.ARRAY_BUFFER, this.storage, b)
        },
        setData: function(a) {
            if (a.byteLength !== this.numBytes) return console.error("VertexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + a.byteLength), !1;
            this.storage = a;
            this.unlock();
            return !0
        }
    });
    Na.init = function(a) {
        this._defaultInstancingFormat = new Na(a, [{
            semantic: "TEXCOORD2",
            components: 4,
            type: 6
        }, {
            semantic: "TEXCOORD3",
            components: 4,
            type: 6
        }, {
            semantic: "TEXCOORD4",
            components: 4,
            type: 6
        }, {
            semantic: "TEXCOORD5",
            components: 4,
            type: 6
        }])
    };
    Object.defineProperty(Na, "defaultInstancingFormat", {
        get: function() {
            return function() {
                return this._defaultInstancingFormat
            }
        }()
    });
    Object.assign(Na.prototype, {
        update: function() {
            this._evaluateHash()
        },
        _evaluateHash: function() {
            var a = [],
                b = [],
                c, d = this.elements.length;
            for (c = 0; c < d; c++) {
                var e = this.elements[c];
                var f = e.name;
                f += e.dataType;
                f += e.numComponents;
                f += e.normalize;
                a.push(f);
                f += e.offset;
                f += e.stride;
                f += e.size;
                b.push(f)
            }
            a.sort();
            this.batchingHash = se(a.join());
            this.renderingingHash = se(b.join())
        }
    });
    tf.prototype.get = function(a) {
        return this.array[this.index + a]
    };
    tf.prototype.set = function(a, b, c, d) {};
    tf.prototype.setFromArray = function(a, b, c) {};
    tf.prototype.getToArray = function(a, b, c) {};
    Object.assign(Pb.prototype, {
        next: function(a) {
            void 0 ===
                a && (a = 1);
            for (var b = 0, c = this.accessors, d = this.accessors.length; b < d;) {
                var e = c[b++];
                e.index += a * e.stride
            }
        },
        end: function() {
            this.vertexBuffer.unlock()
        },
        writeData: function(a, b, c) {
            if (a = this.element[a]) {
                c > this.vertexBuffer.numVertices && (c = this.vertexBuffer.numVertices);
                var d, e = a.numComponents;
                if (this.vertexBuffer.getFormat().interleaved) {
                    var f = 0;
                    for (d = 0; d < c; d++) a.setFromArray(f, b, d * e), f += a.stride
                } else if (b.length > c * e)
                    if (c *= e, ArrayBuffer.isView(b)) b = b.subarray(0, c), a.array.set(b);
                    else
                        for (d = 0; d < c; d++) a.array[d] =
                            b[d];
                else a.array.set(b)
            }
        },
        readData: function(a, b) {
            a = this.element[a];
            var c = 0;
            if (a) {
                c = this.vertexBuffer.numVertices;
                var d, e = a.numComponents;
                if (this.vertexBuffer.getFormat().interleaved) {
                    Array.isArray(b) && (b.length = 0);
                    var f = a.index = 0;
                    for (d = 0; d < c; d++) a.getToArray(f, b, d * e), f += a.stride
                } else if (ArrayBuffer.isView(b)) b.set(a.array);
                else
                    for (b.length = 0, e *= c, d = 0; d < e; d++) b[d] = a.array[d]
            }
            return c
        }
    });
    var Gd = null,
        Mn = {
            type: 5,
            base: 0,
            count: 4,
            indexed: !1
        };
    Object.assign(te.prototype, {
        destroy: function() {
            this.device.destroyShader(this)
        }
    });
    var F = {
            alphaTestPS: "uniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n",
            ambientConstantPS: "void addAmbient() {\n\tdDiffuseLight += light_globalAmbient;\n}\n",
            ambientPrefilteredCubePS: "#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nvoid addAmbient() {\n\tvec3 fixedReflDir = fixSeamsStatic(cubeMapRotate(dNormalW), 1.0 - 1.0 / 4.0);\n#ifndef RIGHT_HANDED_CUBEMAP\n\tfixedReflDir.x *= -1.0;\n#endif\n\tdDiffuseLight += processEnvironment($DECODE(textureCube(texture_prefilteredCubeMap4, fixedReflDir)).rgb);\n}\n",
            ambientPrefilteredCubeLodPS: "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nvoid addAmbient() {\n\tvec3 fixedReflDir = fixSeamsStatic(cubeMapRotate(dNormalW), 1.0 - 1.0 / 4.0);\n#ifndef RIGHT_HANDED_CUBEMAP\n\tfixedReflDir.x *= -1.0;\n#endif\n\tdDiffuseLight += processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, 5.0) ).rgb);\n}\n",
            ambientSHPS: "uniform vec3 ambientSH[9];\nvoid addAmbient() {\n\tvec3 n = cubeMapRotate(dNormalW);\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n",
            aoPS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\nvoid applyAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\tdAo *= texture2D(texture_aoMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight *= dAo;\n}\n",
            aoSpecOccPS: "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",
            aoSpecOccConstPS: "void occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",
            aoSpecOccConstSimplePS: "void occludeSpecular() {\n\tfloat specOcc = dAo;\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",
            aoSpecOccSimplePS: "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",
            bakeDirLmEndPS: "\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n",
            bakeLmEndPS: "\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n",
            basePS: "uniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n",
            baseVS: "attribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\nvec3 dLightPosW;\nvec3 dLightDirNormW;\nvec3 dNormalW;\n",
            baseNineSlicedPS: "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n",
            baseNineSlicedVS: "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n",
            baseNineSlicedTiledPS: "#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n",
            biasConstPS: "#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n",
            blurVSMPS: "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n",
            clearCoatPS: "#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatMap;\n#endif\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2D(texture_clearCoatMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n",
            clearCoatGlossPS: "#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGlossiness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tccGlossiness += 0.0000001;\n}\n",
            clearCoatNormalPS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatNormalMap;\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n\t#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2D(texture_clearCoatNormalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness));\n\tccNormalW = dTBN * normalMap;\n\t#else\n\tccNormalW = normalize(dVertexNormalW);\n\t#endif\n\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n}\n",
            combineClearCoatPS: "vec3 combineColorCC() {\n\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\n}\n",
            combineDiffusePS: "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight;\n}\n",
            combineDiffuseSpecularPS: "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n",
            combineDiffuseSpecularNoConservePS: "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n",
            combineDiffuseSpecularNoReflPS: "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n",
            combineDiffuseSpecularNoReflSeparateAmbientPS: "uniform vec3 material_ambient;\nvec3 combineColor() {\n\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n",
            combineDiffuseSpecularOldPS: "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n",
            cookiePS: "vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n",
            cubeMapProjectBoxPS: "uniform vec3 envBoxMin, envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tnrdir = cubeMapRotate(nrdir);\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn posonbox - envBoxPos;\n}\n",
            cubeMapProjectNonePS: "vec3 cubeMapProject(vec3 dir) {\n\treturn cubeMapRotate(dir);\n}\n",
            cubeMapRotatePS: "#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n\treturn refDir * cubeMapRotationMatrix;\n#else\n\treturn refDir;\n#endif\n}\n",
            detailModesPS: "vec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n",
            diffusePS: "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV).$CH));\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n",
            diffuseDetailMapPS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\nvec3 addAlbedoDetail(vec3 albedo) {\n\t#ifdef MAPTEXTURE\n\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV).$CH);\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n\t#else\n\treturn albedo;\n\t#endif\n}\n",
            dilatePS: "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2D(source, vUv0);\n\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n\tgl_FragColor = c;\n}\n",
            dpAtlasQuadPS: "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec4 params;\nvoid main(void) {\n\tvec2 uv = vUv0;\n\tuv = uv * 2.0 - vec2(1.0);\n\tuv *= params.xy;\n\tuv = uv * 0.5 + 0.5;\n\tgl_FragColor = texture2D(source, uv);\n}\n",
            emissivePS: "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n\tvec3 emission = vec3(1.0);\n\t#ifdef MAPFLOAT\n\temission *= material_emissiveIntensity;\n\t#endif\n\t#ifdef MAPCOLOR\n\temission *= material_emissive;\n\t#endif\n\t#ifdef MAPTEXTURE\n\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n\treturn emission;\n}\n",
            endPS: "\t#ifdef CLEARCOAT\n\tgl_FragColor.rgb = combineColorCC();\n\t#else\n\tgl_FragColor.rgb = combineColor();\n\t#endif\n\tgl_FragColor.rgb += getEmission();\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n",
            envConstPS: "vec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n",
            envMultiplyPS: "uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n",
            extensionPS: "\n",
            extensionVS: "\n",
            falloffInvSquaredPS: "float getFalloffInvSquared(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n",
            falloffLinearPS: "float getFalloffLinear(float lightRadius) {\n\tfloat d = length(dLightDirW);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n",
            fixCubemapSeamsNonePS: "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\treturn vec3(0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, vec3 scale) {\n\treturn vec;\n}\n",
            fixCubemapSeamsStretchPS: "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat M = max(avec.x, max(avec.y, avec.z));\n\treturn vec3(avec.x != M ? 1.0 : 0.0,\n\t\t\t\tavec.y != M ? 1.0 : 0.0,\n\t\t\t\tavec.z != M ? 1.0 : 0.0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec * (seam * -scale + vec3(1.0));\n}\n",
            fogExpPS: "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",
            fogExp2PS: "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",
            fogLinearPS: "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\tfogFactor = gammaCorrectInput(fogFactor);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",
            fogNonePS: "float dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n",
            fresnelSchlickPS: "\nuniform float material_fresnelFactor;\nvoid getFresnel() {\n\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n\tfloat fresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= dGlossiness * dGlossiness;\n\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n\t#ifdef CLEARCOAT\n\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\n\tfresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= ccGlossiness * ccGlossiness;\n\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\n\t#endif\n}\n",
            fullscreenQuadPS: "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n",
            fullscreenQuadVS: "attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n",
            gamma1_0PS: "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn texture2D(tex, uv);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn texture2D(tex, uv, bias);\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\treturn textureCube(tex, uvw);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\n",
            gamma2_2PS: "vec3 gammaCorrectInput(vec3 color) {\n\treturn pow(color, vec3(2.2));\n}\nfloat gammaCorrectInput(float color) {\n\treturn pow(color, 2.2);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\tvec4 rgba = texture2D(tex, uv);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\tvec4 rgba = texture2D(tex, uv, bias);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\tvec4 rgba = textureCube(tex, uvw);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\t#ifdef HDR\n\treturn color;\n\t#else\n\tcolor += vec3(0.0000001);\n\treturn pow(color, vec3(0.45));\n\t#endif\n}\n",
            genParaboloidPS: "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nvoid main(void) {\n\tvec2 uv = vUv0;\n\tfloat side = uv.x < 0.5? 1.0 : -1.0;\n\tvec2 tc;\n\ttc.x = fract(uv.x * 2.0) * 2.0 - 1.0;\n\ttc.y = uv.y * 2.0 - 1.0;\n\tconst float scale = 1.1;\n\ttc *= scale;\n\tvec3 dir;\n\tdir.y = (dot(tc, tc) - 1.0) * side;\n\tdir.xz = tc * -2.0;\n\tdir.x *= -side * params.y;\n\tdir = fixSeams(dir, params.x);\n\tvec4 color = textureCube(source, dir, -100.0);\n\tgl_FragColor = color;\n}\n",
            gles3PS: "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n",
            gles3VS: "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n",
            glossPS: "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdGlossiness += 0.0000001;\n}\n",
            instancingVS: "attribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n",
            lightDiffuseLambertPS: "float getLightDiffuse() {\n\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n",
            lightDirPointPS: "void getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n",
            lightmapDirPS: "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid addLightMap() {\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\tvec4 dir = texture2D(texture_dirLightMap, $UV);\n\tif (dot(dir.xyz,vec3(1.0)) < 0.00001) {\n\t\tdDiffuseLight += color;\n\t\treturn;\n\t}\n\tdLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\n\tfloat nlight = (flight / max(vlight,0.01)) * 0.5;\n\tdDiffuseLight += color * nlight * 2.0;\n}\nvoid addDirLightMap() {\n\tvec4 dir = texture2D(texture_dirLightMap, $UV);\n\tif (dot(dir.xyz,vec3(1.0)) < 0.00001) return;\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\tdLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n\tdSpecularLight += vec3(getLightSpecular()) * color;\n}\n",
            lightmapSinglePS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\nvoid addLightMap() {\n\tvec3 lm = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tlm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tlm *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight += lm;\n}\n",
            lightmapSingleVertPS: "void addLightMap() {\n\tdDiffuseLight += saturate(vVertexColor.$CH);\n}\n",
            lightSpecularAnisoGGXPS: "\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\n\tfloat NoH = dot(tNormalW, h);\n\tfloat ToH = dot(dTBN[0], h);\n\tfloat BoH = dot(dTBN[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(dTBN[0], dViewDirW);\n\tfloat BoV = dot(dTBN[1], dViewDirW);\n\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\n\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\n\tfloat NoV = dot(tNormalW, dViewDirW);\n\tfloat NoL = dot(tNormalW, -dLightDirNormW);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n",
            lightSpecularBlinnPS: "\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\n\tfloat nh = max( dot( h, tNormalW ), 0.0 );\n\tfloat specPow = exp2(tGlossiness * 11.0);\n\tspecPow = antiAliasGlossiness(specPow);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n",
            lightSpecularPhongPS: "float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\n\tfloat specPow = tGlossiness;\n\tspecPow = antiAliasGlossiness(specPow);\n\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dReflDirW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\n}\n",
            metalnessPS: "void processMetalness(float metalness) {\n\tconst float dielectricF0 = 0.04;\n\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n\tdAlbedo *= 1.0 - metalness;\n}\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\nvoid getSpecularity() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2D(texture_metalnessMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tprocessMetalness(metalness);\n}\n",
            msdfPS: "uniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\t#ifdef USE_FWIDTH\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, 0.5);\n\t#else\n\tfloat font_size = 16.0;\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, 0.5);\n\t#endif\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\treturn tcolor;\n}\n",
            normalVS: "#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\tvec3 tempNormal = vertex_normal;\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\ttempNormal += morphNormal;\n\t#endif\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n",
            normalDetailMapPS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n\t#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV));\n\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\n\treturn blendNormals(normalMap, normalDetailMap);\n\t#else\n\treturn normalMap;\n\t#endif\n}\n",
            normalInstancedVS: "vec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n",
            normalMapPS: "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n",
            normalMapFastPS: "uniform sampler2D texture_normalMap;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n",
            normalSkinnedVS: "vec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n",
            normalVertexPS: "void getNormal() {\n\tdNormalW = normalize(dVertexNormalW);\n}\n",
            normalXYPS: "vec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n",
            normalXYZPS: "vec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n",
            opacityPS: "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2D(texture_opacityMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n",
            outputAlphaPS: "gl_FragColor.a = dAlpha;\n",
            outputAlphaOpaquePS: "gl_FragColor.a = 1.0;\n",
            outputAlphaPremulPS: "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n",
            outputCubemapPS: "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec4 color) {\n\tcolor.rgb = pow(color.rgb, vec3(0.5));\n\tcolor.rgb *= 1.0 / 8.0;\n\tcolor.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\n\tcolor.a = ceil(color.a * 255.0) / 255.0;\n\tcolor.rgb /= color.a;\n\treturn color;\n}\nvoid main(void) {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\tgl_FragColor = textureCube(source, vec);\n\tif (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\n}\n",
            outputTex2DPS: "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n",
            packDepthPS: "\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n",
            packDepthMaskPS: "vec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres.x = 0.0;\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n",
            parallaxPS: "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2D(texture_heightMap, $UV).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n",
            particlePS: "varying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\nvoid main(void) {\n\tvec4 tex  = texture2DSRGB(colorMap, texCoordsAlphaLife.xy);\n\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a  = tex.a * ramp.a;\n",
            particleVS: "vec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n",
            particleAnimFrameClampVS: "\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n",
            particleAnimFrameLoopVS: "\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n",
            particleAnimTexVS: "\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n",
            particleInputFloatPS: "void readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n",
            particleInputRgba8PS: "\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n",
            particleOutputFloatPS: "void writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n",
            particleOutputRgba8PS: "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n",
            particleUpdaterAABBPS: "uniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n",
            particleUpdaterEndPS: "\twriteOutput();\n}\n",
            particleUpdaterInitPS: "varying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n",
            particleUpdaterNoRespawnPS: "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n",
            particleUpdaterOnStopPS: "\tvisMode = outLife < 0.0? -1.0: visMode;\n",
            particleUpdaterRespawnPS: "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n",
            particleUpdaterSpherePS: "uniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n",
            particleUpdaterStartPS: "float saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t  tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n",
            particle_billboardVS: "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n",
            particle_blendAddPS: "\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n",
            particle_blendMultiplyPS: "\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n",
            particle_blendNormalPS: "\tif (a < 0.01) discard;\n",
            particle_cpuVS: "attribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n",
            particle_cpu_endVS: "\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n",
            particle_customFaceVS: "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n",
            particle_endPS: "\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n",
            particle_endVS: "\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n",
            particle_halflambertPS: "\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n",
            particle_initVS: "attribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n",
            particle_lambertPS: "\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n",
            particle_lightingPS: "\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n",
            particle_localShiftVS: "\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n",
            particle_meshVS: "\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n",
            particle_normalVS: "\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n",
            particle_normalMapPS: "\tvec3 normalMap = normalize(texture2D(normalMap, texCoordsAlphaLife.xy).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n",
            particle_pointAlongVS: "\tinAngle = atan(velocityV.x, velocityV.y);\n",
            particle_softPS: "\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n",
            particle_softVS: "\tvDepth = getLinearDepth(localPos);\n",
            particle_stretchVS: "\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n",
            particle_TBNVS: "\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n",
            particle_wrapVS: "\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n",
            precisionTestPS: "void main(void) {\n\tgl_FragColor = vec4(2147483648.0);\n}\n",
            precisionTest2PS: "uniform sampler2D source;\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n",
            prefilterCubemapPS: "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nfloat rnd(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nconst float PI = 3.14159265358979;\nvec3 hemisphereSample_cos(vec2 uv, mat3 vecSpace, vec3 cubeDir, float gloss) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = sqrt(1.0 - uv.x);\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\treturn normalize(mix(vecSpace * sampleDir, cubeDir, params.y));\n}\nvec3 hemisphereSample_phong(vec2 uv, mat3 vecSpace, vec3 cubeDir, float specPow) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\treturn vecSpace * sampleDir;\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\nvoid main(void) {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tif (params.w==1.0 || params.w==3.0) {\n\t\tst = 2.0 * floor(gl_FragCoord.xy) / (params.z - 1.0) - 1.0;\n\t}\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\tmat3 vecSpace = matrixFromVector(normalize(vec));\n\tvec3 color = vec3(0.0);\n\tconst int samples = $NUMSAMPLES;\n\tvec3 vect;\n\tfor(int i=0; i<samples; i++) {\n\t\tfloat sini = sin(float(i));\n\t\tfloat cosi = cos(float(i));\n\t\tfloat rand = rnd(vec2(sini, cosi));\n\t\tvect = hemisphereSample_$METHOD(vec2(float(i) / float(samples), rand), vecSpace, vec, params.y);\n\t\tcolor += $textureCube(source, vect).rgb;\n\t}\n\tcolor /= float(samples);\n\tgl_FragColor = params.w < 2.0? vec4(color, 1.0) : encodeRGBM(color);\n}\n",
            reflDirPS: "void getReflDir() {\n\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n",
            reflDirAnisoPS: "void getReflDir() {\n\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-dViewDirW, bentNormal);\n}\n",
            reflectionCCPS: "#ifdef CLEARCOAT\nuniform float material_clearCoatReflectivity;\nvoid addReflectionCC() {\n\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\n}\n#endif\n",
            reflectionCubePS: "uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n#ifndef RIGHT_HANDED_CUBEMAP\n\tlookupVec.x *= -1.0;\n#endif\n\treturn $textureCubeSAMPLE(texture_cubeMap, lookupVec).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
            reflectionDpAtlasPS: "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec2 getDpAtlasUv(vec2 uv, float mip) {\n\tvec4 rect;\n\tfloat sx = saturate(mip - 2.0);\n\trect.x = sx * 0.5;\n\tfloat t = mip - rect.x * 6.0;\n\tfloat i = 1.0 - rect.x;\n\trect.y = min(t * 0.5, 0.75) * i + rect.x;\n\tfloat st = saturate(t);\n\trect.z = (1.0 - st * 0.5) * i;\n\trect.w = rect.z * 0.5;\n\tfloat rcRectZ = 1.0 / rect.z;\n\tfloat scaleFactor = 0.00390625 * rcRectZ;\n\tvec2 scale = vec2(scaleFactor, scaleFactor * 2.0);\n\tuv = uv * (vec2(1.0) - scale) + scale * 0.5;\n\tuv = uv * rect.zw + rect.xy;\n\treturn uv;\n}\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDir = normalize(cubeMapProject(tReflDirW));\n\tbool up = reflDir.y > 0.0;\n\tfloat scale = 0.90909090909090909090909090909091;\n\tvec3 reflDirWarp = reflDir.xzx * vec3(-0.25, 0.5, 0.25);\n\tfloat reflDirVer = abs(reflDir.y) + 1.0;\n\treflDirWarp /= reflDirVer;\n\treflDirWarp *= scale;\n\treflDirWarp = vec3(0.75, 0.5, 0.25) - reflDirWarp;\n\tvec2 tc = up? reflDirWarp.xy : reflDirWarp.zy;\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tfloat mip = floor(bias);\n\tvec3 tex1 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n\tmip = min(mip + 1.0, 5.0);\n\tvec3 tex2 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n\ttex1 = mix(tex1, tex2, fract(bias));\n\ttex1 = processEnvironment(tex1);\n\treturn tex1;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
            reflectionPrefilteredCubePS: "uniform samplerCube texture_prefilteredCubeMap128;\nuniform samplerCube texture_prefilteredCubeMap64;\nuniform samplerCube texture_prefilteredCubeMap32;\nuniform samplerCube texture_prefilteredCubeMap16;\nuniform samplerCube texture_prefilteredCubeMap8;\n#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 refl = cubeMapProject(tReflDirW);\n#ifndef RIGHT_HANDED_CUBEMAP\n\trefl.x *= -1.0;\n#endif\n\tvec3 seam = calcSeam(refl);\n\tvec4 c0 = textureCube(texture_prefilteredCubeMap128, applySeam(refl, seam, 1.0 / 128.0));\n\tvec4 c1 = textureCube(texture_prefilteredCubeMap64, applySeam(refl, seam, 2.0 / 128.0));\n\tvec4 c2 = textureCube(texture_prefilteredCubeMap32, applySeam(refl, seam, 4.0 / 128.0));\n\tvec4 c3 = textureCube(texture_prefilteredCubeMap16, applySeam(refl, seam, 8.0 / 128.0));\n\tvec4 c4 = textureCube(texture_prefilteredCubeMap8, applySeam(refl, seam, 16.0 / 128.0));\n\tvec4 c5 = textureCube(texture_prefilteredCubeMap4, applySeam(refl, seam, 32.0 / 128.0));\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tvec4 cubes0;\n\tvec4 cubes1;\n\tif (bias < 1.0) {\n\t\tcubes0 = c0;\n\t\tcubes1 = c1;\n\t} else if (bias < 2.0) {\n\t\tcubes0 = c1;\n\t\tcubes1 = c2;\n\t} else if (bias < 3.0) {\n\t\tcubes0 = c2;\n\t\tcubes1 = c3;\n\t} else if (bias < 4.0) {\n\t\tcubes0 = c3;\n\t\tcubes1 = c4;\n\t} else {\n\t\tcubes0 = c4;\n\t\tcubes1 = c5;\n\t}\n\tvec4 cubeFinal = mix(cubes0, cubes1, fract(bias));\n\treturn processEnvironment($DECODE(cubeFinal).rgb);\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
            reflectionPrefilteredCubeLodPS: "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tvec3 fixedReflDir = fixSeams(cubeMapProject(tReflDirW), bias);\n#ifndef RIGHT_HANDED_CUBEMAP\n\tfixedReflDir.x *= -1.0;\n#endif\n\tvec3 refl = processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, bias) ).rgb);\n\treturn refl;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
            reflectionSpherePS: "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
            reflectionSphereLowPS: "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = vNormalV;\n\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n\treturn $texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
            refractionPS: "uniform float material_refraction, material_refractionIndex;\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n\tfloat vn = dot(viewVec, Normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n\treturn refrVec;\n}\nvoid addRefraction() {\n\tvec3 tmp = dReflDirW;\n\tvec4 tmp2 = dReflection;\n\tdReflection = vec4(0.0);\n\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n\taddReflection();\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n\tdReflDirW = tmp;\n\tdReflection = tmp2;\n}\n",
            reprojectPS: "\nvarying vec2 vUv0;\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\nuniform vec4 params;\nfloat targetFace() { return params.x; }\nfloat specularPower() { return params.y; }\nfloat sourceCubeSeamScale() { return params.z; }\nfloat targetCubeSeamScale() { return params.w; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 decodeLinear(vec4 source) {\n\treturn source.rgb;\n}\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec3 decodeGamma(vec4 source) {\n\treturn pow(source.xyz, vec3(2.2));\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec3 decodeRGBE(vec4 source) {\n\tif (source.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\n\t}\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\nvec3 modifySeams(vec3 dir, float amount) {\n\tif (amount != 1.0) {\n\t\tvec3 adir = abs(dir);\n\t\tfloat M = max(max(adir.x, adir.y), adir.z);\n\t\tif (adir.x == M) {\n\t\t\tdir.y *= amount;\n\t\t\tdir.z *= amount;\n\t\t}\n\t\telse if (adir.y == M) {\n\t\t\tdir.x *= amount;\n\t\t\tdir.z *= amount;\n\t\t} else {\n\t\t\tdir.x *= amount;\n\t\t\tdir.y *= amount;\n\t\t}\n\t}\n\treturn dir;\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(atan(dir.z, dir.x) * -1.0, asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * cos(-uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * sin(-uv.x));\n}\nvec4 sampleEquirect(vec2 sph) {\n\treturn texture2D(sourceTex, sph / vec2(PI * 2.0, PI) + 0.5);\n}\nvec4 sampleEquirect(vec3 dir) {\n\treturn sampleEquirect(toSpherical(dir));\n}\nvec4 sampleCubemap(vec3 dir) {\n\treturn textureCube(sourceCube, modifySeams(dir, sourceCubeSeamScale()));\n}\nvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vUv0 * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = targetFace();\n\tvec3 vec;\n\tif (face == 0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face == 1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face == 2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face == 3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face == 4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(modifySeams(vec, 1.0 / targetCubeSeamScale()));\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n\tvec3 a = normalize(cross(n, vec3(0, 1, 0)));\n\tvec3 b = cross(n, a);\n\treturn mat3(a, b, n);\n}\nfloat rnd(int i) {\n\tfloat sini = sin(float(i));\n\tfloat cosi = cos(float(i));\n\treturn fract(sin(dot(vec2(sini, cosi), vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nvec3 hemisphereSamplePhong(vec2 uv, float specPow) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\treturn vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec2 sph = toSpherical(TARGET_FUNC());\n\t\tvec2 sphu = dFdx(sph);\n\t\tvec2 sphv = dFdy(sph);\n\t\tconst float num = sqrt(float(NUM_SAMPLES));\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u=0.0; u<num; ++u) {\n\t\t\tfor (float v=0.0; v<num; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\n\t\t\t\t\t\t\t\t\t\t\t\t  sphu * (u / num - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t  sphv * (v / num - 0.5)));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (num * num));\n\t}\n}\nvec4 prefilter() {\n\tvec3 vec = TARGET_FUNC();\n\tmat3 vecSpace = matrixFromVectorSlow(vec);\n\tvec3 result = vec3(0.0);\n\tfor (int i=0; i<NUM_SAMPLES; ++i) {\n\t\tvec2 uv = vec2(float(i) / float(NUM_SAMPLES), rnd(i));\n\t\tvec3 dir = vecSpace * hemisphereSamplePhong(uv, specularPower());\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(dir));\n\t}\n\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\nvoid main(void) {\n\tgl_FragColor = PROCESS_FUNC();\n}\n",
            rgbmPS: "vec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n\treturn decodeRGBM(textureCube(tex, uvw));\n}\n",
            screenDepthPS: "uniform sampler2D uDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tz = z * 2.0 - 1.0;\n\treturn 1.0 / (camera_params.z * z + camera_params.w);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n\t#else\n\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n",
            shadowCommonPS: "void normalOffsetPointShadow(vec4 shadowParams) {\n\tfloat distScale = length(dLightDirW);\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - dLightPosW;\n\tdLightDirW = dir;\n}\n",
            shadowCoordPS: "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xy /= projPos.w;\n\tdShadowCoord.xy = projPos.xy;\n\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n",
            shadowCoordVS: "void getLightDirPoint(vec3 lightPosW) {\n\tvec3 lightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(lightDirW);\n\tdLightPosW = lightPosW;\n}\nvoid _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tvMainShadowUv = projPos;\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tvMainShadowUv = projPos;\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n",
            shadowCoordPerspZbufferPS: "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n",
            shadowEVSMPS: "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n",
            shadowEVSMnPS: "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n",
            shadowStandardPS: "vec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#ifdef GL2\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowCoord = dShadowCoord;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\tvec3 shadowCoord = dShadowCoord;\n\tfloat xoffset = 1.0 / shadowParams.x;\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n",
            shadowStandardGL2PS: "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = gammaCorrectInput(sum);\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n",
            shadowStandardGL2VSPS: "float getShadowPCF5x5VS(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\n",
            shadowStandardVSPS: "#ifdef GL2\n#define SHADOW_SAMPLERVS sampler2DShadow\n#else\n#define SHADOW_SAMPLERVS sampler2D\n#endif\nfloat getShadowPCF3x3VS(SHADOW_SAMPLERVS shadowMap, vec3 shadowParams) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\n",
            shadowVSM8PS: "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n",
            shadowVSMVSPS: "float getShadowVSM$VS(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z += shadowParams.z;\n\tdShadowCoord.xyz /= vMainShadowUv.w;\n\tdShadowCoord.z = min(dShadowCoord.z, 1.0);\n\treturn $VSM(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n",
            shadowVSM_commonPS: "float linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n",
            skinBatchConstVS: "attribute float vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nmat4 getBoneMatrix(const in float i) {\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n",
            skinBatchTexVS: "attribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n",
            skinConstVS: "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n",
            skinTexVS: "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n",
            skyboxPS: "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tgl_FragColor = textureCube(texture_cubeMap, fixSeams(vViewDir));\n}\n",
            skyboxVS: "attribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nvarying vec3 vViewDir;\nvoid main(void) {\n\tmat4 view = matrix_view;\n\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\tgl_Position.z = gl_Position.w - 0.00001;\n\tvViewDir = aPosition;\n}\n",
            skyboxHDRPS: "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\n#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvoid main(void) {\n#ifdef CUBEMAP_ROTATION\n\tvec3 dir=vViewDir * cubeMapRotationMatrix;\n#else\n\tvec3 dir=vViewDir;\n#endif\n#ifndef RIGHT_HANDED_CUBEMAP\n\tdir.x *= -1.0;\n#endif\n\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)).rgb);\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n",
            skyboxPrefilteredCubePS: "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvec3 fixSeamsStretch(vec3 vec, float mipmapIndex, float cubemapSize) {\n\tfloat scale = 1.0 - exp2(mipmapIndex) / cubemapSize;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvoid main(void) {\n\tvec3 color = textureCubeRGBM(texture_cubeMap, fixSeamsStretch(vViewDir, 0.0, 128.0));\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n",
            specularPS: "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdSpecularity *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdSpecularity *= texture2D(texture_specularMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n",
            specularAaNonePS: "float antiAliasGlossiness(float power) {\n\treturn power;\n}\n",
            specularAaToksvigPS: "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * mix(1.0, toksvig, material_bumpiness);\n}\n",
            specularAaToksvigFastPS: "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * toksvig;\n}\n",
            spotPS: "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n",
            startPS: "void main(void) {\n\tdDiffuseLight = vec3(0);\n\tdSpecularLight = vec3(0);\n\tdReflection = vec4(0);\n\tdSpecularity = vec3(0);\n\t#ifdef CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec4(0);\n\t#endif\n",
            startVS: "void main(void) {\n\tgl_Position = getPosition();\n",
            startNineSlicedPS: "\tnineSlicedUv = vUv0;\n",
            startNineSlicedTiledPS: "\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 clampedUv = mix(innerOffset.xy*0.5, vec2(1.0) - innerOffset.zw*0.5, fract(vTiledUv));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n",
            storeEVSMPS: "float exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n",
            tangentBinormalVS: "vec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\nvec3 getObjectSpaceUp() {\n\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n",
            TBNPS: "void getTBN() {\n\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n",
            TBNderivativePS: "\nvoid getTBN() {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, dVertexNormalW );\n\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat invmax = 1.0 / sqrt( max( dot(T,T), dot(B,B) ) );\n\tdTBN = mat3( T * invmax, B * invmax, dVertexNormalW );\n}\n",
            TBNfastPS: "void getTBN() {\n\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n",
            TBNObjectSpacePS: "void getTBN() {\n\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n\tvec3 T = cross(dVertexNormalW, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\t\tif (dVertexNormalW.x==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,1,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.y==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,0,1));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.z==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(1,0,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n",
            tonemappingAcesPS: "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n",
            tonemappingAces2PS: "uniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,  1.10813, -0.00605,\n\t-0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n",
            tonemappingFilmicPS: "const float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n",
            tonemappingHejlPS: "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n",
            tonemappingLinearPS: "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n",
            tonemappingNonePS: "vec3 toneMap(vec3 color) {\n\treturn color;\n}\n",
            transformVS: "#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\nvec2 getTextureMorphCoords() {\n\tfloat vertexId = morph_vertex_id;\n\tvec2 textureSize = morph_tex_params.xy;\n\tvec2 invTextureSize = morph_tex_params.zw;\n\tfloat morphGridV = floor(vertexId * invTextureSize.x);\n\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\n\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\t#ifdef NINESLICED\n\tlocalPos.xz *= outerScale;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\tlocalPos.xz *= -0.5;\n\tlocalPos = localPos.xzy;\n\t#endif\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\tlocalPos += morphPos;\n\t#endif\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n",
            transformDeclVS: "attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n",
            uv0VS: "#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n",
            uv1VS: "vec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n",
            viewDirPS: "void getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n",
            viewNormalVS: "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n"
        },
        Nn = {
            vertex_position: "POSITION",
            vertex_normal: "NORMAL",
            vertex_tangent: "TANGENT",
            vertex_texCoord0: "TEXCOORD0",
            vertex_texCoord1: "TEXCOORD1",
            vertex_texCoord2: "TEXCOORD2",
            vertex_texCoord3: "TEXCOORD3",
            vertex_texCoord4: "TEXCOORD4",
            vertex_texCoord5: "TEXCOORD5",
            vertex_texCoord6: "TEXCOORD6",
            vertex_texCoord7: "TEXCOORD7",
            vertex_color: "COLOR",
            vertex_boneIndices: "BLENDINDICES",
            vertex_boneWeights: "BLENDWEIGHT"
        };
    F.collectAttribs = xg;
    F.createShader = function(a, b, c, d) {
        b = F[b];
        c = Hd(a) + "\n" + F[c];
        var e = xg(b);
        a.webgl2 && (b = Id(a) + F.gles3VS + b, c = Id(a) + F.gles3PS + c);
        return new te(a, {
            attributes: e,
            vshader: b,
            fshader: c,
            useTransformFeedback: d
        })
    };
    F.createShaderFromCode = Wa;
    var Qj = function(a, b, c) {
            return "\n#ifdef MAPFLOAT\n" + a +
                "\n#else\n" + F[b] + "\n#endif\n"
        },
        Rj = function(a, b, c) {
            return "\n#ifdef MAPCOLOR\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
        },
        ee = function(a, b, c) {
            return "\n#ifdef MAPTEXTURE\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
        },
        Sj = function(a, b, c) {
            return "#undef MAPTEXTURECOLOR\n#ifdef MAPTEXTURE\n#ifdef MAPCOLOR\n#define MAPTEXTURECOLOR\n#endif\n#endif\n#ifdef MAPTEXTURECOLOR\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
        },
        oh = function(a, b, c) {
            return "#undef MAPTEXTUREFLOAT\n#ifdef MAPTEXTURE\n#ifdef MAPFLOAT\n#define MAPTEXTUREFLOAT\n#endif\n#endif\n#ifdef MAPTEXTUREFLOAT\n" +
                a + "\n#else\n" + F[b] + "\n#endif\n"
        },
        fe = function(a, b, c) {
            return "\n#ifdef MAPVERTEX\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
        },
        Tj = function(a, b, c) {
            return "#undef MAPVERTEXCOLOR\n#ifdef MAPVERTEX\n#ifdef MAPCOLOR\n#define MAPVERTEXCOLOR\n#endif\n#endif\n#ifdef MAPVERTEXCOLOR\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
        },
        ph = function(a, b, c) {
            return "#undef MAPVERTEXFLOAT\n#ifdef MAPVERTEX\n#ifdef MAPFLOAT\n#define MAPVERTEXFLOAT\n#endif\n#endif\n#ifdef MAPVERTEXFLOAT\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
        },
        Ac = [],
        Uj = {
            _oldChunkToNew: {
                aoTexPS: {
                    n: "aoPS",
                    f: ee
                },
                aoVertPS: {
                    n: "aoPS",
                    f: fe
                },
                diffuseConstPS: {
                    n: "diffusePS",
                    f: Rj
                },
                diffuseTexPS: {
                    n: "diffusePS",
                    f: ee
                },
                diffuseTexConstPS: {
                    n: "diffusePS",
                    f: Sj
                },
                diffuseVertPS: {
                    n: "diffusePS",
                    f: fe
                },
                diffuseVertConstPS: {
                    n: "diffusePS",
                    f: Tj
                },
                emissiveConstPS: {
                    n: "emissivePS",
                    f: Rj
                },
                emissiveTexPS: {
                    n: "emissivePS",
                    f: ee
                },
                emissiveTexConstPS: {
                    n: "emissivePS",
                    f: Sj
                },
                emissiveTexConstFloatPS: {
                    n: "emissivePS",
                    f: oh
                },
                emissiveVertPS: {
                    n: "emissivePS",
                    f: fe
                },
                emissiveVertConstPS: {
                    n: "emissivePS",
                    f: Tj
                },
                emissiveVertConstFloatPS: {
                    n: "emissivePS",
                    f: ph
                },
                glossConstPS: {
                    n: "glossPS",
                    f: Qj
                },
                glossTexPS: {
                    n: "glossPS",
                    f: ee
                },
                glossTexConstPS: {
                    n: "glossPS",
                    f: oh
                },
                glossVertPS: {
                    n: "glossPS",
                    f: fe
                },
                glossVertConstPS: {
                    n: "glossPS",
                    f: ph
                },
                metalnessConstPS: {
                    n: "metalnessPS",
                    f: Qj
                },
                metalnessTexPS: {
                    n: "metalnessPS",
                    f: ee
                },
                metalnessTexConstPS: {
                    n: "metalnessPS",
                    f: oh
                },
                metalnessVertPS: {
                    n: "metalnessPS",
                    f: fe
                },
                metalnessVertConstPS: {
                    n: "metalnessPS",
                    f: ph
                },
                opacityConstPS: {
                    n: "opacityPS",
                    f: Qj
                },
                opacityTexPS: {
                    n: "opacityPS",
                    f: ee
                },
                opacityTexConstPS: {
                    n: "opacityPS",
                    f: oh
                },
                opacityVertPS: {
                    n: "opacityPS",
                    f: fe
                },
                opacityVertConstPS: {
                    n: "opacityPS",
                    f: ph
                },
                specularConstPS: {
                    n: "specularPS",
                    f: Rj
                },
                specularTexPS: {
                    n: "specularPS",
                    f: ee
                },
                specularTexConstPS: {
                    n: "specularPS",
                    f: Sj
                },
                specularVertPS: {
                    n: "specularPS",
                    f: fe
                },
                specularVertConstPS: {
                    n: "specularPS",
                    f: Tj
                },
                transformBatchSkinnedVS: {
                    n: "transformVS",
                    f: function(a, b, c) {
                        return "\n#ifdef DYNAMICBATCH\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                    }
                },
                transformInstancedVS: {
                    n: "transformVS",
                    f: function(a, b, c) {
                        return "\n#ifdef INSTANCING\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                    }
                },
                transformPixelSnapVS: {
                    n: "transformVS",
                    f: function(a, b, c) {
                        return "\n#ifdef PIXELSNAP\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                    }
                },
                transformScreenSpaceVS: {
                    n: "transformVS",
                    f: function(a, b, c) {
                        return "\n#ifdef SCREENSPACE\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                    }
                },
                transformScreenSpaceBatchSkinned: {
                    n: "transformVS",
                    f: function(a, b, c) {
                        return "#undef SCREENSPACEBATCH\n#ifdef SCREENSPACE\n#ifdef BATCH\n#define SCREENSPACEBATCH\n#endif\n#endif\n#ifdef SCREENSPACEBATCH\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                    }
                },
                transformSkinned: {
                    n: "transformVS",
                    f: function(a, b, c) {
                        return "\n#ifdef SKIN\n" +
                            a + "\n#else\n" + F[b] + "\n#endif\n"
                    }
                },
                transformUv1: {
                    n: "transformVS",
                    f: function(a, b, c) {
                        return "\n#ifdef UV1LAYOUT\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                    }
                }
            },
            optionsContext: {},
            optionsContextMin: {},
            generateKey: function(a) {
                var b = function(f) {
                    var g = [],
                        k;
                    for (k in f) f.hasOwnProperty(k) && "chunks" !== k && "lights" !== k && g.push(k);
                    return g.sort()
                };
                if (a === this.optionsContextMin) {
                    this.propsMin || (this.propsMin = b(a));
                    var c = this.propsMin
                } else a === this.optionsContext ? (this.props || (this.props = b(a)), c = this.props) : c = b(a);
                b = "standard";
                var d;
                for (d = 0; d < c.length; d++) a[c[d]] && (b += c[d] + a[c[d]]);
                if (a.chunks) {
                    c = [];
                    for (var e in a.chunks) a.chunks.hasOwnProperty(e) && c.push(e + a.chunks[e]);
                    c.sort();
                    b += c
                }
                if (a.lights)
                    for (d = 0; d < a.lights.length; d++) b += a.lights[d].key;
                return se(b)
            },
            _correctChannel: function(a, b) {
                if (0 < Ac[a]) {
                    if (Ac[a] < b.length) return b.substring(0, Ac[a]);
                    if (Ac[a] > b.length) {
                        var c = b.charAt(b.length - 1);
                        a = Ac[a] - b.length;
                        for (var d = 0; d < a; d++) b += c;
                        return b
                    }
                    return b
                }
            },
            _setMapTransform: function(a, b, c, d) {
                a[0] += "uniform vec4 texture_" + b + "MapTransform;\n";
                var e = c + 100 * d;
                a[3][e] || (a[1] += "varying vec2 vUV" + d + "_" + c + ";\n", a[2] += "   vUV" + d + "_" + c + " = uv" + d + " * texture_" + b + "MapTransform.xy + texture_" + b + "MapTransform.zw;\n", a[3][e] = !0);
                return a
            },
            _getUvSourceExpression: function(a, b, c) {
                var d = c[a];
                b = c[b];
                var e = 0 === c.pass || 1 === c.pass;
                e && 1 === c.nineSlicedMode ? d = "nineSlicedUv" : e && 2 === c.nineSlicedMode ? d = "nineSlicedUv, -1000.0" : (d = 0 === d ? "vUv" + b : "vUV" + b + "_" + d, c.heightMap && "heightMapTransform" !== a && (d += " + dUvOffset"));
                return d
            },
            _addMapDef: function(a, b) {
                var c = "\n#undef " +
                    a + "\n";
                b && (c += " #define " + a + "\n");
                return c
            },
            _addMapDefs: function(a, b, c, d) {
                a = "" + this._addMapDef("MAPFLOAT", a);
                a += this._addMapDef("MAPCOLOR", b);
                a += this._addMapDef("MAPVERTEX", c);
                return a += this._addMapDef("MAPTEXTURE", d)
            },
            _addMap: function(a, b, c, d, e) {
                var f = a + "Map",
                    g = f + "Uv",
                    k = f + "Transform",
                    h = f + "Channel",
                    l = a + "VertexColorChannel",
                    n = c[a + "Tint"],
                    p = c[a + "VertexColor"];
                f = c[f];
                a = c[a + "Mode"];
                b = d[b];
                f && (g = this._getUvSourceExpression(k, g, c), b = b.replace(/\$UV/g, g).replace(/\$CH/g, c[h]), void 0 !== e && (b = b.replace(/\$texture2DSAMPLE/g,
                    0 === e ? "texture2DSRGB" : 1 === e ? "texture2DRGBM" : "texture2D")));
                p && (b = b.replace(/\$VC/g, c[l]));
                a && (b = b.replace(/\$DETAILMODE/g, a));
                b = this._addMapDefs(1 === n, 3 === n, p, f) + b;
                return b.replace(/\$/g, "")
            },
            _nonPointShadowMapProjection: function(a, b, c) {
                return !b._normalOffsetBias || b._isVsm ? 2 === b._type ? b._isPcf && (a.webgl2 || a.extStandardDerivatives) ? "\t   getShadowCoordPerspZbuffer" + c : "\t   getShadowCoordPersp" + c : "\t   getShadowCoordOrtho" + c : 2 === b._type ? b._isPcf && (a.webgl2 || a.extStandardDerivatives) ? "\t   getShadowCoordPerspZbufferNormalOffset" +
                    c : "\t   getShadowCoordPerspNormalOffset" + c : "\t   getShadowCoordOrthoNormalOffset" + c
            },
            _addVaryingIfNeeded: function(a, b, c) {
                return 0 <= a.indexOf(c) ? "varying " + b + " " + c + ";\n" : ""
            },
            _vsAddTransformCode: function(a, b, c, d) {
                return a += c.transformVS
            },
            _vsAddBaseCode: function(a, b, c, d) {
                a += c.baseVS;
                if (1 === d.nineSlicedMode || 2 === d.nineSlicedMode) a += c.baseNineSlicedVS;
                return a
            },
            _fsAddBaseCode: function(a, b, c, d) {
                a += c.basePS;
                1 === d.nineSlicedMode ? a += c.baseNineSlicedPS : 2 === d.nineSlicedMode && (a += c.baseNineSlicedTiledPS);
                return a
            },
            _fsAddStartCode: function(a, b, c, d) {
                a += c.startPS;
                1 === d.nineSlicedMode ? a += c.startNineSlicedPS : 2 === d.nineSlicedMode && (a += c.startNineSlicedTiledPS);
                return a
            },
            createShaderDefinition: function(a, b) {
                var c = 0 < b.lights.length;
                b.dirLightMap && (c = !0, b.useSpecular = !0);
                0 === b.shadingModel ? (b.fresnelModel = 0, b.specularAntialias = !1, b.prefilteredCubemap = !1, b.dpAtlas = !1, b.ambientSH = !1) : b.fresnelModel = 0 === b.fresnelModel ? 2 : b.fresnelModel;
                var d = (b.cubeMap || b.prefilteredCubemap && b.useSpecular) && !b.sphereMap && !b.dpAtlas,
                    e = b.sphereMap ||
                    d || b.dpAtlas,
                    f = b.useTexCubeLod;
                b.cubeMap && (b.sphereMap = null);
                b.dpAtlas && (b.prefilteredCubemap = null);
                b.useSpecular || (b.specularMap = b.glossMap = null);
                var g = c || e || b.ambientSH || b.prefilteredCubemap || b.heightMap || b.enableGGXSpecular,
                    k = 3 <= b.pass && 17 >= b.pass;
                this.options = b;
                var h = "",
                    l = "",
                    n = "",
                    p = F,
                    q = {
                        vertex_position: "POSITION"
                    };
                if (b.chunks) {
                    var r = {};
                    for (A in p)
                        if (p.hasOwnProperty(A))
                            if (b.chunks[A]) {
                                var t = b.chunks[A];
                                0 <= t.indexOf("vertex_normal") && (q.vertex_normal = "NORMAL");
                                0 <= t.indexOf("vertex_tangent") && (q.vertex_tangent =
                                    "TANGENT");
                                0 <= t.indexOf("vertex_texCoord0") && (q.vertex_texCoord0 = "TEXCOORD0");
                                0 <= t.indexOf("vertex_texCoord1") && (q.vertex_texCoord1 = "TEXCOORD1");
                                0 <= t.indexOf("vertex_color") && (q.vertex_color = "COLOR");
                                0 <= t.indexOf("vertex_boneWeights") && (q.vertex_boneWeights = "BLENDWEIGHT");
                                0 <= t.indexOf("vertex_boneIndices") && (q.vertex_boneIndices = "BLENDINDICES");
                                r[A] = t
                            } else r[A] = p[A];
                    for (A in b.chunks)(p = this._oldChunkToNew[A]) && (r[p.n] = p.f(b.chunks[A], p.n, A));
                    p = r
                }
                h = this._vsAddBaseCode(h, a, p, b);
                r = -1;
                if (!b.noShadow &&
                    !b.twoSidedLighting) {
                    for (t = 0; t < b.lights.length; t++) {
                        var u = b.lights[t]._type;
                        if (b.lights[t].castShadows && 0 === u) {
                            h += "uniform mat4 light" + t + "_shadowMatrixVS;\n";
                            h += "uniform vec3 light" + t + "_shadowParamsVS;\n";
                            h += "uniform vec3 light" + t + (0 === u ? "_directionVS" : "_positionVS") + ";\n";
                            r = t;
                            break
                        }
                    }
                    0 <= r && (h += p.shadowCoordVS)
                }
                l += "   vPositionW\t= getWorldPosition();\n";
                2 === b.pass && (h += "varying float vDepth;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n\n#endif\n",
                    l += "\tvDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n");
                b.useInstancing && (q.instance_line1 = "TEXCOORD2", q.instance_line2 = "TEXCOORD3", q.instance_line3 = "TEXCOORD4", q.instance_line4 = "TEXCOORD5", h += p.instancingVS);
                g && (q.vertex_normal = "NORMAL", l += "   vNormalW\t= dNormalW = getNormal();\n", b.sphereMap && 16 >= a.fragmentUniformsCount && (h += p.viewNormalVS, l += "   vNormalV\t= getViewNormal();\n"), (b.heightMap || b.normalMap || b.enableGGXSpecular) && b.hasTangents ? (q.vertex_tangent = "TANGENT", h +=
                    p.tangentBinormalVS, l += "   vTangentW   = getTangent();\n   vBinormalW  = getBinormal();\n") : b.enableGGXSpecular && (h += p.tangentBinormalVS, l += "   vObjectSpaceUpW  = getObjectSpaceUp();\n"), 0 <= r && (u = b.lights[r]._type, l = (0 === u ? l + ("   dLightDirNormW = light" + r + "_directionVS;\n") : l + ("   getLightDirPoint(light" + r + "_positionVS);\n")) + this._nonPointShadowMapProjection(a, b.lights[r], "(light" + r + "_shadowMatrixVS, light" + r + "_shadowParamsVS);\n")));
                u = [];
                var x = [];
                for (A in Ac) {
                    t = A + "Map";
                    if (b[A + "VertexColor"]) {
                        var v =
                            A + "VertexColorChannel";
                        b[v] = this._correctChannel(A, b[v])
                    }
                    if (b[t]) {
                        v = t + "Channel";
                        var w = t + "Transform";
                        var y = t + "Uv";
                        b[y] = Math.min(b[y], 1);
                        b[v] = this._correctChannel(A, b[v]);
                        y = b[y];
                        u[y] = !0;
                        x[y] = x[y] || b[t] && !b[w]
                    }
                }
                b.forceUv1 && (u[1] = !0, x[1] = void 0 !== x[1] ? x[1] : !0);
                for (t = 0; 2 > t; t++) u[t] && (q["vertex_texCoord" + t] = "TEXCOORD" + t, h += p["uv" + t + "VS"], l += "   vec2 uv" + t + " = getUv" + t + "();\n"), x[t] && (l += "   vUv" + t + " = uv" + t + ";\n");
                u = [h, n, l, []];
                for (A in Ac) t = A + "Map", b[t] && (w = t + "Transform", b[w] && (y = t + "Uv", this._setMapTransform(u,
                    A, b[w], b[y])));
                h = u[0];
                n = u[1];
                l = u[2];
                b.vertexColors && (q.vertex_color = "COLOR", l += "   vVertexColor = vertex_color;\n");
                if (b.useMorphPosition || b.useMorphNormal) b.useMorphTextureBased ? (h += "#define MORPHING_TEXTURE_BASED\n", b.useMorphPosition && (h += "#define MORPHING_TEXTURE_BASED_POSITION\n"), b.useMorphNormal && (h += "#define MORPHING_TEXTURE_BASED_NORMAL\n"), q.morph_vertex_id = "ATTR15", h += "attribute float morph_vertex_id;\n") : (h += "#define MORPHING\n", b.useMorphPosition ? (q.morph_pos0 = "ATTR8", q.morph_pos1 = "ATTR9",
                    q.morph_pos2 = "ATTR10", q.morph_pos3 = "ATTR11", h += "#define MORPHING_POS03\nattribute vec3 morph_pos0;\nattribute vec3 morph_pos1;\nattribute vec3 morph_pos2;\nattribute vec3 morph_pos3;\n") : b.useMorphNormal && (q.morph_nrm0 = "ATTR8", q.morph_nrm1 = "ATTR9", q.morph_nrm2 = "ATTR10", q.morph_nrm3 = "ATTR11", h += "#define MORPHING_NRM03\nattribute vec3 morph_nrm0;\nattribute vec3 morph_nrm1;\nattribute vec3 morph_nrm2;\nattribute vec3 morph_nrm3;\n"), b.useMorphNormal ? (q.morph_nrm4 = "ATTR12", q.morph_nrm5 = "ATTR13", q.morph_nrm6 =
                    "ATTR14", q.morph_nrm7 = "ATTR15", h += "#define MORPHING_NRM47\nattribute vec3 morph_nrm4;\nattribute vec3 morph_nrm5;\nattribute vec3 morph_nrm6;\nattribute vec3 morph_nrm7;\n") : (q.morph_pos4 = "ATTR12", q.morph_pos5 = "ATTR13", q.morph_pos6 = "ATTR14", q.morph_pos7 = "ATTR15", h += "#define MORPHING_POS47\nattribute vec3 morph_pos4;\nattribute vec3 morph_pos5;\nattribute vec3 morph_pos6;\nattribute vec3 morph_pos7;\n"));
                b.skin ? (q.vertex_boneWeights = "BLENDWEIGHT", q.vertex_boneIndices = "BLENDINDICES", h += ji(a, p), h += "#define SKIN\n") :
                    b.useInstancing && (h += "#define INSTANCING\n");
                b.screenSpace && (h += "#define SCREENSPACE\n");
                b.pixelSnap && (h += "#define PIXELSNAP\n");
                h = this._vsAddTransformCode(h, a, p, b);
                g && (h += p.normalVS);
                h = h + "\n" + p.startVS;
                var A = h = h + l + "}";
                t = n;
                n = "" + this._addVaryingIfNeeded(h, "vec4", "vMainShadowUv");
                n += this._addVaryingIfNeeded(h, "vec4", "vVertexColor");
                n += this._addVaryingIfNeeded(h, "vec3", "vPositionW");
                n += this._addVaryingIfNeeded(h, "vec3", "vNormalV");
                n += this._addVaryingIfNeeded(h, "vec3", "vNormalW");
                n += this._addVaryingIfNeeded(h,
                    "vec3", "vTangentW");
                n += this._addVaryingIfNeeded(h, "vec3", "vBinormalW");
                n += this._addVaryingIfNeeded(h, "vec3", "vObjectSpaceUpW");
                n += this._addVaryingIfNeeded(h, "vec2", "vUv0");
                n += this._addVaryingIfNeeded(h, "vec2", "vUv1");
                n += t;
                A = n + A;
                h = "";
                a.webgl2 ? (h = Id(a), p.extensionVS && (h += p.extensionVS + "\n"), A = h + p.gles3VS + A) : (p.extensionVS && (h = p.extensionVS + "\n"), A = h + A);
                b.forceFragmentPrecision && "highp" != b.forceFragmentPrecision && "mediump" !== b.forceFragmentPrecision && "lowp" !== b.forceFragmentPrecision && (b.forceFragmentPrecision =
                    null);
                b.forceFragmentPrecision && ("highp" === b.forceFragmentPrecision && "highp" !== a.maxPrecision && (b.forceFragmentPrecision = "mediump"), "mediump" === b.forceFragmentPrecision && "lowp" === a.maxPrecision && (b.forceFragmentPrecision = "lowp"));
                h = "";
                a.webgl2 && (h += Id(a));
                a.extStandardDerivatives && !a.webgl2 && (h += "#extension GL_OES_standard_derivatives : enable\n\n");
                p.extensionPS && (h += p.extensionPS + "\n");
                a.webgl2 && (h += p.gles3PS);
                h += b.forceFragmentPrecision ? "precision " + b.forceFragmentPrecision + " float;\n\n" : Hd(a);
                if (18 === b.pass) return h = h + "uniform vec4 uColor;\n" + n, b.alphaTest && (h = h + "float dAlpha;\n" + this._addMap("opacity", "opacityPS", b, p), h += p.alphaTestPS), h += ue(), b.alphaTest && (h += "   getOpacity();\n   alphaTest(dAlpha);\n"), {
                    attributes: q,
                    vshader: A,
                    fshader: h + "\tgl_FragColor = uColor;\n}\n"
                };
                if (2 === b.pass) return h = h + "varying float vDepth;\n" + n + p.packDepthPS, b.alphaTest && (h += "float dAlpha;\n", h += this._addMap("opacity", "opacityPS", b, p), h += p.alphaTestPS), h += ue(), b.alphaTest && (h += "   getOpacity();\n", h += "   alphaTest(dAlpha);\n"),
                    h += "\tgl_FragColor = packFloat(vDepth);\n", h += "}\n", {
                        attributes: q,
                        vshader: A,
                        fshader: h
                    };
                if (k) return d = b.pass - 3, u = Math.floor(d / 5), d -= 5 * u, a.extStandardDerivatives && !a.webgl2 && (h += "uniform vec2 polygonOffset;\n"), 3 === d ? h = a.textureFloatHighPrecision ? h + "#define VSM_EXPONENT 15.0\n\n" : h + "#define VSM_EXPONENT 5.54\n\n" : 2 === d && (h += "#define VSM_EXPONENT 5.54\n\n"), 0 !== u && (h += "uniform vec3 view_position;\n", h += "uniform float light_radius;\n"), h += n, b.alphaTest && (h += "float dAlpha;\n", h += this._addMap("opacity",
                        "opacityPS", b, p), h += p.alphaTestPS), 0 !== d || a.webgl2 && 1 !== u ? 1 === d && (h += "vec2 encodeFloatRG( float v ) {\n", h += "\tvec2 enc = vec2(1.0, 255.0) * v;\n", h += "\tenc = fract(enc);\n", h += "\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n", h += "\treturn enc;\n", h += "}\n\n") : h += p.packDepthPS, h += ue(), b.alphaTest && (h += "   getOpacity();\n", h += "   alphaTest(dAlpha);\n"), h = 1 === u || (1 === d || 2 === d || 3 === d) && 0 !== u ? h + "   float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n" : h + "   float depth = gl_FragCoord.z;\n",
                    0 !== d || a.webgl2 && 1 !== u ? h = 0 === d || 4 === d ? h + "   gl_FragColor = vec4(1.0);\n" : 1 === d ? h + "   gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n" : h + p.storeEVSMPS : (a.extStandardDerivatives && !a.webgl2 && (h += "   float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n", h += "   depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n"), h += "   gl_FragColor = packFloat(depth);\n"), h += "}\n", {
                        attributes: q,
                        vshader: A,
                        fshader: h
                    };
                if (b.customFragmentShader) return a = h + b.customFragmentShader, {
                    attributes: q,
                    vshader: A,
                    fshader: a,
                    tag: 1
                };
                h = this._fsAddBaseCode(h + n, a, p, b);
                b.detailModes && (h += p.detailModesPS);
                n = h;
                h = "";
                0 < b.clearCoat && (h += "#define CLEARCOAT\n");
                !1 === b.opacityFadesSpecular && (h += "uniform float material_alphaFade;\n");
                x = 0;
                w = [];
                v = y = !1;
                for (t = 0; t < b.lights.length; t++)
                    if (l = b.lights[t], u = l._type, h += "uniform vec3 light" + t + "_color;\n", 0 === u ? h += "uniform vec3 light" + t + "_direction;\n" : (h += "uniform vec3 light" + t + "_position;\n", h += "uniform float light" +
                            t + "_radius;\n", 2 === u && (h += "uniform vec3 light" + t + "_direction;\n", h += "uniform float light" + t + "_innerConeAngle;\n", h += "uniform float light" + t + "_outerConeAngle;\n")), l.castShadows && !b.noShadow && (h += "uniform mat4 light" + t + "_shadowMatrix;\n", h = 0 !== u ? h + ("uniform vec4 light" + t + "_shadowParams;\n") : h + ("uniform vec3 light" + t + "_shadowParams;\n"), h = 1 === u ? h + ("uniform samplerCube light" + t + "_shadowMap;\n") : l._isPcf && a.webgl2 ? h + ("uniform sampler2DShadow light" + t + "_shadowMap;\n") : h + ("uniform sampler2D light" + t + "_shadowMap;\n"),
                            x++, w[l._shadowType] = !0, l._isVsm && (y = !0), l._isPcf && (a.webgl2 || a.extStandardDerivatives) && 2 === u && (v = !0)), l._cookie)
                        if (l._cookie._cubemap) 1 === u && (h += "uniform samplerCube light" + t + "_cookie;\n", h += "uniform float light" + t + "_cookieIntensity;\n", !l.castShadows || b.noShadow) && (h += "uniform mat4 light" + t + "_shadowMatrix;\n");
                        else if (2 === u) {
                    h += "uniform sampler2D light" + t + "_cookie;\n";
                    h += "uniform float light" + t + "_cookieIntensity;\n";
                    if (!l.castShadows || b.noShadow) h += "uniform mat4 light" + t + "_shadowMatrix;\n";
                    l._cookieTransform &&
                        (h += "uniform vec4 light" + t + "_cookieMatrix;\n", h += "uniform vec2 light" + t + "_cookieOffset;\n")
                }
                h += "\n";
                k = !b.hasTangents && a.extStandardDerivatives ? p.TBNderivativePS : b.fastTbn ? p.TBNfastPS : p.TBNPS;
                g && (b.normalMap || b.clearCoatNormalMap) && (h += b.packedNormal ? p.normalXYPS : p.normalXYZPS, b.hasTangents || (t = this._getUvSourceExpression("normalMapTransform", "normalMapUv", b), k = k.replace(/\$UV/g, t)), h += k);
                g && (b.normalMap ? (b.normalDetail && (h += this._addMap("normalDetail", "normalDetailMapPS", b, p)), t = this._getUvSourceExpression("normalMapTransform",
                    "normalMapUv", b), h = b.normalizeNormalMap ? h + p.normalMapPS.replace(/\$UV/g, t) : h + p.normalMapFastPS.replace(/\$UV/g, t)) : (h += p.normalVertexPS, b.enableGGXSpecular && (h += p.TBNObjectSpacePS)));
                h += vg(b.gamma, p);
                h += wg(b.toneMap, p);
                h += ii(b.fog, p);
                b.useRgbm && (h += p.rgbmPS);
                if (d || b.prefilteredCubemap) h += b.fixSeams ? p.fixCubemapSeamsStretchPS : p.fixCubemapSeamsNonePS;
                b.useCubeMapRotation && (h += "#define CUBEMAP_ROTATION\n");
                b.useRightHandedCubeMap && (h += "#define RIGHT_HANDED_CUBEMAP\n");
                g && (h += p.cubeMapRotatePS, h += 0 < b.cubeMapProjection ?
                    p.cubeMapProjectBoxPS : p.cubeMapProjectNonePS, h += b.skyboxIntensity ? p.envMultiplyPS : p.envConstPS);
                b.diffuseDetail && (h += this._addMap("diffuseDetail", "diffuseDetailMapPS", b, p));
                h += this._addMap("diffuse", "diffusePS", b, p);
                if (3 !== b.blendType || b.alphaTest || b.alphaToCoverage) h += this._addMap("opacity", "opacityPS", b, p);
                h += this._addMap("emissive", "emissivePS", b, p, b.emissiveFormat);
                b.useSpecular && (c || e) && (h = b.specularAntialias && b.normalMap ? b.normalizeNormalMap && g ? h + p.specularAaToksvigPS : h + p.specularAaToksvigFastPS :
                    h + p.specularAaNonePS, t = b.useMetalness ? "metalness" : "specular", h += this._addMap(t, t + "PS", b, p), h += this._addMap("gloss", "glossPS", b, p), 2 === b.fresnelModel && (h += p.fresnelSchlickPS));
                0 < b.clearCoat && (h += this._addMap("clearCoat", "clearCoatPS", b, p), h += this._addMap("clearCoatGloss", "clearCoatGlossPS", b, p), h += this._addMap("clearCoatNormal", "clearCoatNormalPS", b, p));
                b.heightMap && (b.normalMap || (t = this._getUvSourceExpression("heightMapTransform", "heightMapUv", b), b.hasTangents || (k = k.replace(/\$UV/g, t)), h += k), h += this._addMap("height",
                    "parallaxPS", b, p));
                if (k = b.aoMap || b.aoVertexColor) h += this._addMap("ao", "aoPS", b, p), b.occludeSpecular && (h = 1 === b.occludeSpecular ? h + (b.occludeSpecularFloat ? p.aoSpecOccSimplePS : p.aoSpecOccConstSimplePS) : h + (b.occludeSpecularFloat ? p.aoSpecOccPS : p.aoSpecOccConstPS));
                t = b.rgbmReflection ? "decodeRGBM" : b.hdrReflection ? "" : "gammaCorrectInput";
                b.sphereMap ? (t = 16 < a.fragmentUniformsCount ? p.reflectionSpherePS : p.reflectionSphereLowPS, t = t.replace(/\$texture2DSAMPLE/g, b.rgbmReflection ? "texture2DRGBM" : b.hdrReflection ? "texture2D" :
                    "texture2DSRGB"), h += t) : d ? h = b.prefilteredCubemap ? f ? h + p.reflectionPrefilteredCubeLodPS.replace(/\$DECODE/g, t) : h + p.reflectionPrefilteredCubePS.replace(/\$DECODE/g, t) : h + p.reflectionCubePS.replace(/\$textureCubeSAMPLE/g, b.rgbmReflection ? "textureCubeRGBM" : b.hdrReflection ? "textureCube" : "textureCubeSRGB") : b.dpAtlas && (h += p.reflectionDpAtlasPS.replace(/\$texture2DSAMPLE/g, b.rgbmReflection ? "texture2DRGBM" : b.hdrReflection ? "texture2D" : "texture2DSRGB"));
                if (d || b.sphereMap || b.dpAtlas) 0 < b.clearCoat && (h += p.reflectionCCPS),
                    b.refraction && (h += p.refractionPS);
                0 < x && (w[0] && (h += p.shadowStandardPS), w[4] && (h += p.shadowStandardGL2PS), y && (h += p.shadowVSM_commonPS, w[1] && (h += p.shadowVSM8PS), w[2] && (h += a.extTextureHalfFloatLinear ? p.shadowEVSMPS.replace(/\$/g, "16") : p.shadowEVSMnPS.replace(/\$/g, "16")), w[3] && (h += a.extTextureFloatLinear ? p.shadowEVSMPS.replace(/\$/g, "32") : p.shadowEVSMnPS.replace(/\$/g, "32"))), a.webgl2 || a.extStandardDerivatives || (h += p.biasConstPS), h += p.shadowCoordPS + p.shadowCommonPS, v && (h += p.shadowCoordPerspZbufferPS),
                    0 <= r && (w[0] && (h += p.shadowStandardVSPS), w[4] && (h += p.shadowStandardGL2VSPS), y && (w[1] && (h += p.shadowVSMVSPS.replace(/\$VSM/g, "VSM8").replace(/\$/g, "8")), w[2] && (h += p.shadowVSMVSPS.replace(/\$VSM/g, "VSM16").replace(/\$/g, "16")), w[3] && (h += p.shadowVSMVSPS.replace(/\$VSM/g, "VSM32").replace(/\$/g, "32")))));
                b.enableGGXSpecular && (h += "uniform float material_anisotropy;\n");
                c && (h += p.lightDiffuseLambertPS);
                t = !1;
                b.useSpecular ? (c && (h += 0 === b.shadingModel ? p.lightSpecularPhongPS : b.enableGGXSpecular ? p.lightSpecularAnisoGGXPS :
                    p.lightSpecularBlinnPS), b.sphereMap || d || b.dpAtlas || 0 < b.fresnelModel ? h = 0 < b.fresnelModel ? b.conserveEnergy ? h + p.combineDiffuseSpecularPS : h + p.combineDiffuseSpecularNoConservePS : h + p.combineDiffuseSpecularOldPS : b.diffuseMap ? h += p.combineDiffuseSpecularNoReflPS : (h += p.combineDiffuseSpecularNoReflSeparateAmbientPS, t = !0)) : h += p.combineDiffusePS;
                0 < b.clearCoat && (h += p.combineClearCoatPS);
                u = !0;
                if (b.lightMap || b.lightVertexColor) h += this._addMap("light", b.dirLightMap ? "lightmapDirPS" : "lightmapSinglePS", b, p, b.lightMapFormat),
                    u = b.lightMapWithoutAmbient;
                u && (l = b.rgbmAmbient ? "decodeRGBM" : b.hdrAmbient ? "" : "gammaCorrectInput", h = b.ambientSH ? h + p.ambientSHPS : b.prefilteredCubemap ? f ? h + p.ambientPrefilteredCubeLodPS.replace(/\$DECODE/g, l) : h + p.ambientPrefilteredCubePS.replace(/\$DECODE/g, l) : h + p.ambientConstantPS);
                b.ambientTint && !t && (h += "uniform vec3 material_ambient;\n");
                b.alphaTest && (h += p.alphaTestPS);
                b.msdf && (h += p.msdfPS);
                g && (h += p.viewDirPS, b.useSpecular && (h += b.enableGGXSpecular ? p.reflDirAnisoPS : p.reflDirPS));
                v = y = w = x = f = !1;
                b.twoSidedLighting &&
                    (h += "uniform float twoSidedLightingNegScaleFactor;\n");
                h = this._fsAddStartCode(h, a, p, b);
                g && (h = b.hasTangents || !a.extStandardDerivatives || b.fastTbn ? b.twoSidedLighting ? h + "   dVertexNormalW = gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor;\n" : h + "   dVertexNormalW = vNormalW;\n" : b.twoSidedLighting ? h + "   dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\n" : h + "   dVertexNormalW = normalize(vNormalW);\n",
                    (b.heightMap || b.normalMap) && b.hasTangents && (b.twoSidedLighting ? (h += "   dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\n", h += "   dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\n") : (h += "   dTangentW = vTangentW;\n", h += "   dBinormalW = vBinormalW;\n")));
                l = !1;
                3 !== b.blendType || b.alphaTest || b.alphaToCoverage ? b.heightMap && b.opacityMap ? l = !0 : (h += "   getOpacity();\n",
                    b.alphaTest && (h += "   alphaTest(dAlpha);\n")) : h += "   dAlpha = 1.0;\n";
                var B = !1;
                if (g) {
                    h += "   getViewDir();\n";
                    if (b.heightMap || b.normalMap || b.clearCoatNormalMap || b.enableGGXSpecular) h += "   getTBN();\n";
                    b.heightMap && (h += "   getParallax();\n");
                    l && (h += "   getOpacity();\n", b.alphaTest && (h += "   alphaTest(dAlpha);\n"));
                    h += "   getNormal();\n";
                    b.useSpecular && (b.enableGGXSpecular && (h += "   getGlossiness();\n", B = !0), h += "   getReflDir();\n")
                }
                h += "   getAlbedo();\n";
                0 < b.clearCoat && (h += "   getClearCoat();\n", h += "   getClearCoatGlossiness();\n",
                    h += "   getClearCoatNormal();\n");
                if (c && b.useSpecular || e) h += "   getSpecularity();\n", B || (h += "   getGlossiness();\n"), 0 < b.fresnelModel && (h += "   getFresnel();\n");
                u && (h += "   addAmbient();\n");
                b.ambientTint && !t && (h += "   dDiffuseLight *= material_ambient;\n");
                k && !b.occludeDirect && (h += "\tapplyAO();\n");
                if (b.lightMap || b.lightVertexColor) h += "   addLightMap();\n";
                if (c || e) {
                    if (d || b.sphereMap || b.dpAtlas) 0 < b.clearCoat && (h += "   addReflectionCC();\n"), h += "   addReflection();\n";
                    b.dirLightMap && (h += "   addDirLightMap();\n");
                    for (t = 0; t < b.lights.length; t++) {
                        l = b.lights[t];
                        u = l._type;
                        e = !1;
                        0 === u ? (h += "   dLightDirNormW = light" + t + "_direction;\n", h += "   dAtten = 1.0;\n") : (l._cookie && (2 !== u || l._cookie._cubemap ? 1 === u && l._cookie._cubemap && (e = v = !0) : e = v = !0), h += "   getLightDirPoint(light" + t + "_position);\n", f = !0, e && (h = 2 === u ? h + ("   dAtten3 = getCookie2D" + (l._cookieFalloff ? "" : "Clip") + (l._cookieTransform ? "Xform" : "") + "(light" + t + "_cookie, light" + t + "_shadowMatrix, light" + t + "_cookieIntensity" + (l._cookieTransform ? ", light" + t + "_cookieMatrix, light" +
                            t + "_cookieOffset" : "") + ")." + l._cookieChannel + ";\n") : h + ("   dAtten3 = getCookieCube(light" + t + "_cookie, light" + t + "_shadowMatrix, light" + t + "_cookieIntensity)." + l._cookieChannel + ";\n")), 0 === l._falloffMode ? (h += "   dAtten = getFalloffLinear(light" + t + "_radius);\n", x = !0) : (h += "   dAtten = getFalloffInvSquared(light" + t + "_radius);\n", w = !0), h += "   if (dAtten > 0.00001) {\n", 2 !== u || e && !l._cookieFalloff || (h += "\t   dAtten *= getSpotEffect(light" + t + "_direction, light" + t + "_innerConeAngle, light" + t + "_outerConeAngle);\n",
                            y = !0));
                        h += "\t   dAtten *= getLightDiffuse();\n";
                        if (l.castShadows && !b.noShadow) {
                            if (1 === l._shadowType) {
                                g = "VSM8";
                                var E = "0.0"
                            } else 2 === l._shadowType ? (g = "VSM16", E = "5.54") : 3 === l._shadowType ? (g = "VSM32", E = a.textureFloatHighPrecision ? "15.0" : "5.54") : g = 4 === l._shadowType ? "PCF5x5" : "PCF3x3";
                            null !== g && (1 === u ? (c = "(light" + t + "_shadowMap, light" + t + "_shadowParams);\n", l._normalOffsetBias && (h += "\t   normalOffsetPointShadow(light" + t + "_shadowParams);\n"), h += "\t   dAtten *= getShadowPoint" + g + c) : (r === t ? g += "VS" : (c = "(light" +
                                t + "_shadowMatrix, light" + t + "_shadowParams);\n", h += this._nonPointShadowMapProjection(a, b.lights[t], c)), 2 === u && (g = "Spot" + g), h += "\t   dAtten *= getShadow" + g + "(light" + t + "_shadowMap, light" + t + "_shadowParams" + (l._isVsm ? ", " + E : "") + ");\n"))
                        }
                        h += "\t   dDiffuseLight += dAtten * light" + t + "_color" + (e ? " * dAtten3" : "") + ";\n";
                        0 < b.clearCoat && (h += "\t   ccSpecularLight += getLightSpecularCC() * dAtten * light" + t + "_color" + (e ? " * dAtten3" : "") + ";\n");
                        b.useSpecular && (h += "\t   dAtten *= getLightSpecular();\n", h += "\t   dSpecularLight += dAtten * light" +
                            t + "_color" + (e ? " * dAtten3" : "") + ";\n");
                        0 !== u && (h += "   }\n");
                        h += "\n"
                    }(d || b.sphereMap || b.dpAtlas) && b.refraction && (h += "   addRefraction();\n")
                }
                h += "\n";
                k && (b.occludeDirect && (h += "\tapplyAO();\n"), b.occludeSpecular && (h += "\toccludeSpecular();\n"));
                if (!1 === b.opacityFadesSpecular) {
                    if (2 === b.blendType || 4 === b.blendType) h += "float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n", h += "#ifdef CLEARCOAT\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccReflection.a * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif\n",
                        h += "dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\n";
                    h += "dAlpha *= material_alphaFade;\n"
                }
                h += p.endPS;
                h = 2 === b.blendType || 6 === b.blendType || b.alphaToCoverage ? h + p.outputAlphaPS : 4 === b.blendType ? h + p.outputAlphaPremulPS : h + p.outputAlphaOpaquePS;
                b.msdf && (h += "   gl_FragColor = applyMsdf(gl_FragColor);\n");
                h += "\n";
                h += "}\n";
                f && (h = p.lightDirPointPS + h);
                x && (h = p.falloffLinearPS + h);
                w && (h = p.falloffInvSquaredPS + h);
                y && (h = p.spotPS + h);
                v && (h = p.cookiePS + h);
                a = "";
                h.includes("dReflection") && (a += "vec4 dReflection;\n");
                h.includes("dTBN") && (a += "mat3 dTBN;\n");
                h.includes("dAlbedo") && (a += "vec3 dAlbedo;\n");
                h.includes("dEmission") && (a += "vec3 dEmission;\n");
                h.includes("dNormalW") && (a += "vec3 dNormalW;\n");
                h.includes("dVertexNormalW") && (a += "vec3 dVertexNormalW;\n");
                h.includes("dTangentW") && (a += "vec3 dTangentW;\n");
                h.includes("dBinormalW") && (a += "vec3 dBinormalW;\n");
                h.includes("dViewDirW") && (a += "vec3 dViewDirW;\n");
                h.includes("dReflDirW") && (a += "vec3 dReflDirW;\n");
                h.includes("dDiffuseLight") && (a += "vec3 dDiffuseLight;\n");
                h.includes("dSpecularLight") && (a += "vec3 dSpecularLight;\n");
                h.includes("dLightDirNormW") && (a += "vec3 dLightDirNormW;\n");
                h.includes("dLightDirW") && (a += "vec3 dLightDirW;\n");
                h.includes("dLightPosW") && (a += "vec3 dLightPosW;\n");
                h.includes("dShadowCoord") && (a += "vec3 dShadowCoord;\n");
                h.includes("dNormalMap") && (a += "vec3 dNormalMap;\n");
                h.includes("dSpecularity") && (a += "vec3 dSpecularity;\n");
                h.includes("dUvOffset") && (a += "vec2 dUvOffset;\n");
                h.includes("dGlossiness") && (a += "float dGlossiness;\n");
                h.includes("dAlpha") &&
                    (a += "float dAlpha;\n");
                h.includes("dAtten") && (a += "float dAtten;\n");
                h.includes("dAtten3") && (a += "vec3 dAtten3;\n");
                h.includes("dAo") && (a += "float dAo;\n");
                h.includes("dMsdf") && (a += "vec4 dMsdf;\n");
                h.includes("ccReflection") && (a += "vec4 ccReflection;\n");
                h.includes("ccNormalW") && (a += "vec3 ccNormalW;\n");
                h.includes("ccReflDirW") && (a += "vec3 ccReflDirW;\n");
                h.includes("ccSpecularLight") && (a += "vec3 ccSpecularLight;\n");
                h.includes("ccSpecularity") && (a += "float ccSpecularity;\n");
                h.includes("ccGlossiness") &&
                    (a += "float ccGlossiness;\n");
                a = h = n + a + h;
                return {
                    attributes: q,
                    vshader: A,
                    fshader: a,
                    tag: 1
                }
            }
        },
        qh = {
            begin: ue,
            dummyFragmentCode: Dk,
            end: function() {
                return "}\n"
            },
            fogCode: ii,
            gammaCode: vg,
            precisionCode: Hd,
            skinCode: ji,
            tonemapCode: wg,
            versionCode: Id,
            basic: {
                generateKey: function(a) {
                    var b = "basic";
                    a.fog && (b += "_fog");
                    a.alphaTest && (b += "_atst");
                    a.vertexColors && (b += "_vcol");
                    a.diffuseMap && (b += "_diff");
                    return b += "_" + a.pass
                },
                createShaderDefinition: function(a, b) {
                    var c = {
                        vertex_position: "POSITION"
                    };
                    b.skin && (c.vertex_boneWeights =
                        "BLENDWEIGHT", c.vertex_boneIndices = "BLENDINDICES");
                    b.vertexColors && (c.vertex_color = "COLOR");
                    b.diffuseMap && (c.vertex_texCoord0 = "TEXCOORD0");
                    var d = "" + F.transformDeclVS;
                    b.skin ? (d += ji(a), d += F.transformSkinnedVS) : d += F.transformVS;
                    b.vertexColors && (d += "attribute vec4 vertex_color;\nvarying vec4 vColor;\n");
                    b.diffuseMap && (d += "attribute vec2 vertex_texCoord0;\nvarying vec2 vUv0;\n");
                    2 === b.pass && (d += "varying float vDepth;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n\n#endif\n");
                    d += ue();
                    d += "   gl_Position = getPosition();\n";
                    2 === b.pass && (d += "\tvDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n");
                    b.vertexColors && (d += "\tvColor = vertex_color;\n");
                    b.diffuseMap && (d += "\tvUv0 = vertex_texCoord0;\n");
                    var e = d + "}\n";
                    d = Hd(a);
                    d = b.vertexColors ? d + "varying vec4 vColor;\n" : d + "uniform vec4 uColor;\n";
                    b.diffuseMap && (d += "varying vec2 vUv0;\nuniform sampler2D texture_diffuseMap;\n");
                    b.fog && (d += ii(b.fog));
                    b.alphatest && (d += F.alphaTestPS);
                    2 === b.pass && (d = d + "varying float vDepth;\n" +
                        F.packDepthPS);
                    d += ue();
                    d = b.vertexColors ? d + "\tgl_FragColor = vColor;\n" : d + "\tgl_FragColor = uColor;\n";
                    b.diffuseMap && (d += "\tgl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n");
                    b.alphatest && (d += "   alphaTest(gl_FragColor.a);\n");
                    18 !== b.pass && (2 === b.pass ? d += "\tgl_FragColor = packFloat(vDepth);\n" : b.fog && (d += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n"));
                    return {
                        attributes: c,
                        vshader: e,
                        fshader: d + "}\n"
                    }
                }
            },
            particle: {
                generateKey: function(a) {
                    var b = "particle",
                        c;
                    for (c in a) a.hasOwnProperty(c) && (b +=
                        a[c]);
                    return b
                },
                _animTex: function(a) {
                    a = "" + (a.animTexLoop ? F.particleAnimFrameLoopVS : F.particleAnimFrameClampVS);
                    return a += F.particleAnimTexVS
                },
                createShaderDefinition: function(a, b) {
                    var c = "",
                        d = Hd(a) + "\n";
                    d += "#define PARTICLE\n";
                    a.webgl2 && (c += "#define GL2\n", d += "#define GL2\n");
                    c += "#define VERTEXSHADER\n";
                    b.mesh && (c += "#define USE_MESH\n");
                    b.localSpace && (c += "#define LOCAL_SPACE\n");
                    b.screenSpace && (c += "#define SCREEN_SPACE\n");
                    b.animTex && (c += "\nuniform vec2 animTexTilesParams;\n");
                    b.animTex && (c += "\nuniform vec4 animTexParams;\n");
                    b.animTex && (c += "\nuniform vec2 animTexIndexParams;\n");
                    2 == b.normal && (c += "\nvarying mat3 ParticleMat;\n");
                    1 == b.normal && (c += "\nvarying vec3 Normal;\n");
                    b.soft && (c += "\nvarying float vDepth;\n");
                    a = b.customFace ? F.particle_customFaceVS : F.particle_billboardVS;
                    b.useCpu ? (0 < b.soft && (c += F.screenDepthPS), c += F.particle_cpuVS, b.localSpace && (c += F.particle_localShiftVS), b.animTex && (c += this._animTex(b)), b.alignToMotion && (c += F.particle_pointAlongVS), c += b.mesh ? F.particle_meshVS : a, 1 == b.normal && (c += F.particle_normalVS),
                        2 == b.normal && (c += F.particle_TBNVS), 0 < b.stretch && (c += F.particle_stretchVS), c += F.particle_cpu_endVS) : (c += F.particle_initVS, c += b.pack8 ? F.particleInputRgba8PS : F.particleInputFloatPS, 0 < b.soft && (c += F.screenDepthPS), c += F.particleVS, b.localSpace && (c += F.particle_localShiftVS), b.animTex && (c += this._animTex(b)), b.wrap && (c += F.particle_wrapVS), b.alignToMotion && (c += F.particle_pointAlongVS), c += b.mesh ? F.particle_meshVS : a, 1 == b.normal && (c += F.particle_normalVS), 2 == b.normal && (c += F.particle_TBNVS), 0 < b.stretch && (c += F.particle_stretchVS),
                        c += F.particle_endVS);
                    0 < b.soft && (c += F.particle_softVS);
                    c += "}\n";
                    0 < b.normal && (1 == b.normal ? d += "\nvarying vec3 Normal;\n" : 2 == b.normal && (d += "\nvarying mat3 ParticleMat;\n"), d += "\nuniform vec3 lightCube[6];\n");
                    b.soft && (d += "\nvarying float vDepth;\n");
                    0 === b.normal && "none" === b.fog && (b.srgb = !1);
                    d += vg(b.gamma);
                    d += wg(b.toneMap);
                    d = "linear" === b.fog ? d + F.fogLinearPS : "exp" === b.fog ? d + F.fogExpPS : "exp2" === b.fog ? d + F.fogExp2PS : d + F.fogNonePS;
                    2 == b.normal && (d += "\nuniform sampler2D normalMap;\n");
                    0 < b.soft && (d += F.screenDepthPS);
                    d += F.particlePS;
                    0 < b.soft && (d += F.particle_softPS);
                    1 == b.normal && (d += "\nvec3 normal = Normal;\n");
                    2 == b.normal && (d += F.particle_normalMapPS);
                    0 < b.normal && (d += b.halflambert ? F.particle_halflambertPS : F.particle_lambertPS);
                    0 < b.normal && (d += F.particle_lightingPS);
                    2 == b.blend ? d += F.particle_blendNormalPS : 1 == b.blend ? d += F.particle_blendAddPS : 5 == b.blend && (d += F.particle_blendMultiplyPS);
                    d += F.particle_endPS;
                    return {
                        attributes: xg(c),
                        vshader: c,
                        fshader: d
                    }
                }
            },
            skybox: {
                generateKey: function(a) {
                    return "skybox" + a.rgbm + " " + a.hdr +
                        " " + a.fixSeams + a.toneMapping + a.gamma + a.useIntensity + a.useCubeMapRotation + a.useRightHandedCubeMap + a.mip
                },
                createShaderDefinition: function(a, b) {
                    a = Hd(a);
                    a += b.useCubeMapRotation ? "#define CUBEMAP_ROTATION\n" : "";
                    a += b.useRightHandedCubeMap ? "#define RIGHT_HANDED_CUBEMAP\n" : "";
                    a += b.mip ? F.fixCubemapSeamsStretchPS : F.fixCubemapSeamsNonePS;
                    a += b.useIntensity ? F.envMultiplyPS : F.envConstPS;
                    a += vg(b.gamma);
                    a += wg(b.toneMapping);
                    a += F.rgbmPS;
                    a += F.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g, b.rgbm ? "textureCubeRGBM" : b.hdr ?
                        "textureCube" : "textureCubeSRGB").replace(/\$FIXCONST/g, 1 - 1 / [128, 64, 32, 16, 8, 4, 2][b.mip] + "");
                    return {
                        attributes: {
                            aPosition: "POSITION"
                        },
                        vshader: F.skyboxVS,
                        fshader: a
                    }
                }
            },
            standard: Uj
        };
    Object.defineProperties(V.prototype, {
        minFilter: {
            get: function() {
                return this._minFilter
            },
            set: function(a) {
                this._minFilter !== a && (this._minFilter = a, this._parameterFlags |= 1)
            }
        },
        magFilter: {
            get: function() {
                return this._magFilter
            },
            set: function(a) {
                this._magFilter !== a && (this._magFilter = a, this._parameterFlags |= 2)
            }
        },
        addressU: {
            get: function() {
                return this._addressU
            },
            set: function(a) {
                this._addressU !== a && (this._addressU = a, this._parameterFlags |= 4)
            }
        },
        addressV: {
            get: function() {
                return this._addressV
            },
            set: function(a) {
                this._addressV !== a && (this._addressV = a, this._parameterFlags |= 8)
            }
        },
        addressW: {
            get: function() {
                return this._addressW
            },
            set: function(a) {
                this.device.webgl2 && this._volume && a !== this._addressW && (this._addressW = a, this._parameterFlags |= 16)
            }
        },
        compareOnRead: {
            get: function() {
                return this._compareOnRead
            },
            set: function(a) {
                this._compareOnRead !== a && (this._compareOnRead = a, this._parameterFlags |=
                    32)
            }
        },
        compareFunc: {
            get: function() {
                return this._compareFunc
            },
            set: function(a) {
                this._compareFunc !== a && (this._compareFunc = a, this._parameterFlags |= 64)
            }
        },
        anisotropy: {
            get: function() {
                return this._anisotropy
            },
            set: function(a) {
                this._anisotropy !== a && (this._anisotropy = a, this._parameterFlags |= 128)
            }
        },
        autoMipmap: {
            get: function() {
                return this._mipmaps
            },
            set: function(a) {
                this._mipmaps = a
            }
        },
        mipmaps: {
            get: function() {
                return this._mipmaps
            },
            set: function(a) {
                this._mipmaps !== a && (this._mipmaps = a, this._minFilterDirty = !0, a && (this._needsMipmapsUpload = !0))
            }
        },
        width: {
            get: function() {
                return this._width
            }
        },
        height: {
            get: function() {
                return this._height
            }
        },
        depth: {
            get: function() {
                return this._depth
            }
        },
        format: {
            get: function() {
                return this._format
            }
        },
        cubemap: {
            get: function() {
                return this._cubemap
            }
        },
        gpuSize: {
            get: function() {
                return V.calcGpuSize(this._width, this._height, this._depth, this._format, this.pot && this._mipmaps && !(this._compressed && 1 === this._levels.length), this._cubemap)
            }
        },
        volume: {
            get: function() {
                return this._volume
            }
        },
        flipY: {
            get: function() {
                return this._flipY
            },
            set: function(a) {
                this._flipY !==
                    a && (this._flipY = a, this._needsUpload = !0)
            }
        },
        premultiplyAlpha: {
            get: function() {
                return this._premultiplyAlpha
            },
            set: function(a) {
                this._premultiplyAlpha !== a && (this._premultiplyAlpha = a, this._needsUpload = !0)
            }
        },
        pot: {
            get: function() {
                return N.powerOfTwo(this._width) && N.powerOfTwo(this._height)
            }
        }
    });
    var rh = null,
        eb = null;
    Object.assign(V, {
        calcGpuSize: function(a, b, c, d, e, f) {
            rh || (rh = [1, 1, 2, 2, 2, 2, 4, 4, , , , 8, 8, 16, 16, 4, 4, 4, 4, 4, 4]);
            eb || (eb = [], eb[21] = 8, eb[22] = 8, eb[24] = 8, eb[25] = 8, eb[26] = 8, eb[27] = 8, eb[8] = 8, eb[29] = 8, eb[23] = 16, eb[9] =
                16, eb[10] = 16, eb[28] = 16, eb[30] = 16);
            for (var g = rh.hasOwnProperty(d) ? rh[d] : 0, k = eb.hasOwnProperty(d) ? eb[d] : 0, h = 0;;) {
                if (0 < g) h += a * b * c * g;
                else {
                    var l = Math.floor((a + 3) / 4),
                        n = Math.floor((b + 3) / 4),
                        p = Math.floor((c + 3) / 4);
                    if (24 === d || 25 === d) l = Math.floor(l / 2, 1);
                    h += l * n * p * k
                }
                if (!e || 1 === a && 1 === b && 1 === c) break;
                a = Math.max(Math.floor(a / 2), 1);
                b = Math.max(Math.floor(b / 2), 1);
                c = Math.max(Math.floor(c / 2), 1)
            }
            return h * (f ? 6 : 1)
        }
    });
    Object.assign(V.prototype, {
        destroy: function() {
            this.device && this.device.destroyTexture(this);
            this.device = null;
            this._levels = this._cubemap ? [
                [null, null, null, null, null, null]
            ] : [null]
        },
        dirtyAll: function() {
            this._levelsUpdated = this._cubemap ? [
                [!0, !0, !0, !0, !0, !0]
            ] : [!0];
            this._needsUpload = !0;
            this._needsMipmapsUpload = this._mipmaps;
            this._mipmapsUploaded = !1;
            this._parameterFlags = 255
        },
        lock: function(a) {
            a = a || {
                level: 0,
                face: 0,
                mode: 2
            };
            void 0 === a.level && (a.level = 0);
            void 0 === a.face && (a.face = 0);
            void 0 === a.mode && (a.mode = 2);
            this._lockedLevel = a.level;
            if (null === this._levels[a.level]) switch (this._format) {
                case 0:
                case 1:
                    this._levels[a.level] =
                        new Uint8Array(this._width * this._height * this._depth);
                    break;
                case 2:
                    this._levels[a.level] = new Uint8Array(this._width * this._height * this._depth * 2);
                    break;
                case 3:
                case 4:
                case 5:
                    this._levels[a.level] = new Uint16Array(this._width * this._height * this._depth);
                    break;
                case 6:
                    this._levels[a.level] = new Uint8Array(this._width * this._height * this._depth * 3);
                    break;
                case 7:
                    this._levels[a.level] = new Uint8Array(this._width * this._height * this._depth * 4);
                    break;
                case 8:
                    this._levels[a.level] = new Uint8Array(Math.floor((this._width + 3) /
                        4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
                    break;
                case 9:
                case 10:
                    this._levels[a.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
                    break;
                case 11:
                    this._levels[a.level] = new Uint16Array(this._width * this._height * this._depth * 3);
                    break;
                case 13:
                    this._levels[a.level] = new Float32Array(this._width * this._height * this._depth * 3);
                    break;
                case 12:
                    this._levels[a.level] = new Uint16Array(this._width * this._height * this._depth * 4);
                    break;
                case 14:
                    this._levels[a.level] = new Float32Array(this._width *
                        this._height * this._depth * 4)
            }
            return this._levels[a.level]
        },
        setSource: function(a, b) {
            var c, d = !1;
            b = b || 0;
            if (this._cubemap) {
                if (a[0]) {
                    var e = a[0].width || 0;
                    var f = a[0].height || 0;
                    for (c = 0; 6 > c; c++) {
                        var g = a[c];
                        if (!g || g.width !== e || g.height !== f || !this.device._isBrowserInterface(g)) {
                            d = !0;
                            break
                        }
                    }
                } else d = !0;
                if (!d)
                    for (c = 0; 6 > c; c++) this._levels[b][c] !== a[c] && (this._levelsUpdated[b][c] = !0)
            } else this.device._isBrowserInterface(a) || (d = !0), d || (a !== this._levels[b] && (this._levelsUpdated[b] = !0), e = a.width, f = a.height);
            if (d)
                if (this._height =
                    this._width = 4, this._cubemap)
                    for (c = 0; 6 > c; c++) this._levels[b][c] = null, this._levelsUpdated[b][c] = !0;
                else this._levels[b] = null, this._levelsUpdated[b] = !0;
            else 0 === b && (this._width = e, this._height = f), this._levels[b] = a;
            this._invalid === d && d || (this._invalid = d, this.upload())
        },
        getSource: function(a) {
            return this._levels[a || 0]
        },
        unlock: function() {
            this.upload();
            this._lockedLevel = -1
        },
        upload: function() {
            this._needsUpload = !0;
            this._needsMipmapsUpload = this._mipmaps
        },
        getDds: function() {
            7 !== this.format && console.error("This format is not implemented yet");
            for (var a = 128, b = 0, c, d; this._levels[b];) {
                if (this.cubemap)
                    for (d = 0; 6 > d; d++) {
                        if (!this._levels[b][d]) {
                            console.error("No level data for mip " + b + ", face " + d);
                            return
                        }
                        c = this._levels[b][d].length;
                        if (!c) {
                            console.error("No byte array for mip " + b + ", face " + d);
                            return
                        }
                        a += c
                    } else {
                        c = this._levels[b].length;
                        if (!c) {
                            console.error("No byte array for mip " + b);
                            return
                        }
                        a += c
                    }
                a += this._levels[b].length;
                b++
            }
            a = new ArrayBuffer(a);
            d = new Uint32Array(a, 0, 32);
            b = 528391;
            1 < this._levels.length && (b |= 131072);
            c = 4096;
            1 < this._levels.length &&
                (c |= 4194304);
            if (1 < this._levels.length || this.cubemap) c |= 8;
            var e = this.cubemap ? 65024 : 0;
            d[0] = 542327876;
            d[1] = 124;
            d[2] = b;
            d[3] = this.height;
            d[4] = this.width;
            d[5] = this.width * this.height * 4;
            d[6] = 0;
            d[7] = this._levels.length;
            for (b = 0; 11 > b; b++) d[8 + b] = 0;
            d[19] = 32;
            d[20] = 65;
            d[21] = 0;
            d[22] = 32;
            d[23] = 16711680;
            d[24] = 65280;
            d[25] = 255;
            d[26] = 4278190080;
            d[27] = c;
            d[28] = e;
            d[29] = 0;
            d[30] = 0;
            d[31] = 0;
            e = 128;
            if (this.cubemap)
                for (d = 0; 6 > d; d++)
                    for (b = 0; b < this._levels.length; b++) {
                        var f = this._levels[b][d];
                        var g = new Uint8Array(a, e, f.length);
                        for (c =
                            0; c < f.length; c++) g[c] = f[c];
                        e += f.length
                    } else
                        for (b = 0; b < this._levels.length; b++) {
                            f = this._levels[b];
                            g = new Uint8Array(a, e, f.length);
                            for (c = 0; c < f.length; c++) g[c] = f[c];
                            e += f.length
                        }
            return a
        }
    });
    Object.assign(dc.prototype, {
        destroy: function() {
            var a = this.device,
                b = a.buffers.indexOf(this); - 1 !== b && a.buffers.splice(b, 1);
            this.bufferId && (this.device.gl.deleteBuffer(this.bufferId), this.device._vram.ib -= this.storage.byteLength, this.bufferId = null, this.device.indexBuffer === this && (this.device.indexBuffer = null))
        },
        getFormat: function() {
            return this.format
        },
        getNumIndices: function() {
            return this.numIndices
        },
        lock: function() {
            return this.storage
        },
        unlock: function() {
            var a = this.device.gl;
            this.bufferId || (this.bufferId = a.createBuffer());
            switch (this.usage) {
                case 0:
                    var b = a.STATIC_DRAW;
                    break;
                case 1:
                    b = a.DYNAMIC_DRAW;
                    break;
                case 2:
                    b = a.STREAM_DRAW;
                    break;
                case 3:
                    b = this.device.webgl2 ? a.DYNAMIC_COPY : a.STATIC_DRAW
            }
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.bufferId);
            a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.storage, b)
        },
        setData: function(a) {
            if (a.byteLength !== this.numBytes) return !1;
            this.storage = a;
            this.unlock();
            return !0
        },
        _lockTypedArray: function() {
            var a = this.lock();
            return 2 === this.format ? new Uint32Array(a) : 1 === this.format ? new Uint16Array(a) : new Uint8Array(a)
        },
        writeData: function(a, b) {
            var c = this._lockTypedArray();
            if (a.length > b)
                if (ArrayBuffer.isView(a)) a = a.subarray(0, b), c.set(a);
                else {
                    var d;
                    for (d = 0; d < b; d++) c[d] = a[d]
                }
            else c.set(a);
            this.unlock()
        },
        readData: function(a) {
            var b = this._lockTypedArray(),
                c = this.numIndices;
            if (ArrayBuffer.isView(a)) a.set(b);
            else {
                a.length = 0;
                var d;
                for (d = 0; d < c; d++) a[d] =
                    b[d]
            }
            return c
        }
    });
    var Pn = 0;
    Object.assign(dd.prototype, {
        initDefaults: function() {
            this.recreate = !1;
            this.indexCount = this.vertexCount = this.maxIndices = this.maxVertices = this.indicesUsage = this.verticesUsage = 0;
            this.indexStreamUpdated = this.vertexStreamsUpdated = !1;
            this.vertexStreamDictionary = {};
            this.indices = null
        },
        _validateVertexCount: function(a, b) {},
        _changeVertexCount: function(a, b) {
            this.vertexCount ? this._validateVertexCount(a, b) : this.vertexCount = a
        }
    });
    Object.defineProperties(dd, {
        DEFAULT_COMPONENTS_POSITION: {
            value: 3
        },
        DEFAULT_COMPONENTS_NORMAL: {
            value: 3
        },
        DEFAULT_COMPONENTS_UV: {
            value: 2
        },
        DEFAULT_COMPONENTS_COLORS: {
            value: 4
        }
    });
    Object.defineProperties(sb.prototype, {
        aabb: {
            get: function() {
                return this._aabb
            },
            set: function(a) {
                this._aabb = a
            }
        },
        refCount: {
            get: function() {
                return this._refCount
            }
        }
    });
    Object.assign(sb.prototype, {
        incReference: function() {
            this._refCount++
        },
        decReference: function() {
            this._refCount--
        },
        destroy: function() {
            this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBuffer = null);
            var a, b;
            for (a = 0; a < this.indexBuffer.length; a++)(b =
                this.indexBuffer[a]) && b.destroy();
            this.indexBuffer.length = 0;
            this._geometryData = null
        },
        _initBoneAabbs: function(a) {
            this.boneAabb = [];
            this.boneUsed = [];
            var b = this.vertexBuffer.numVertices,
                c, d, e = [],
                f = [],
                g = this.boneUsed,
                k = this.skin.boneNames.length,
                h, l, n;
            for (c = 0; c < k; c++) e[c] = new z(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), f[c] = new z(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            var p = new Pb(this.vertexBuffer),
                q = p.element.POSITION,
                r = p.element.BLENDWEIGHT,
                t = p.element.BLENDINDICES;
            for (c = 0; c <
                b; c++) {
                for (d = 0; 4 > d; d++) {
                    var u = r.array[r.index + d];
                    if (0 < u) {
                        var x = t.array[t.index + d];
                        g[x] = !0;
                        var v = q.array[q.index];
                        var w = q.array[q.index + 1];
                        var y = q.array[q.index + 2];
                        u = f[x];
                        x = e[x];
                        x.x > v && (x.x = v);
                        x.y > w && (x.y = w);
                        x.z > y && (x.z = y);
                        u.x < v && (u.x = v);
                        u.y < w && (u.y = w);
                        u.z < y && (u.z = y);
                        if (a) {
                            v = h = v;
                            w = l = w;
                            var A = n = y;
                            for (y = 0; y < a.length; y++) {
                                var B = a[y];
                                var E = B.deltaPositions[3 * c];
                                var D = B.deltaPositions[3 * c + 1];
                                B = B.deltaPositions[3 * c + 2];
                                0 > E ? v += E : h += E;
                                0 > D ? w += D : l += D;
                                0 > B ? A += B : n += B
                            }
                            x.x > v && (x.x = v);
                            x.y > w && (x.y = w);
                            x.z > A && (x.z = A);
                            u.x < h && (u.x = h);
                            u.y < l && (u.y = l);
                            u.z < n && (u.z = n)
                        }
                    }
                }
                p.next()
            }
            for (c = 0; c < k; c++) a = new oa, a.setMinMax(e[c], f[c]), this.boneAabb.push(a)
        },
        _initGeometryData: function() {
            this._geometryData || (this._geometryData = new dd, this.vertexBuffer && (this._geometryData.vertexCount = this.vertexBuffer.numVertices, this._geometryData.maxVertices = this.vertexBuffer.numVertices), 0 < this.indexBuffer.length && this.indexBuffer[0] && (this._geometryData.indexCount = this.indexBuffer[0].numIndices, this._geometryData.maxIndices = this.indexBuffer[0].numIndices))
        },
        clear: function(a, b, c, d) {
            this._initGeometryData();
            this._geometryData.initDefaults();
            this._geometryData.recreate = !0;
            this._geometryData.maxVertices = c || 0;
            this._geometryData.maxIndices = d || 0;
            this._geometryData.verticesUsage = a ? 0 : 1;
            this._geometryData.indicesUsage = b ? 0 : 1
        },
        setVertexStream: function(a, b, c, d, e, f) {
            this._initGeometryData();
            this._geometryData._changeVertexCount(d || b.length / c, a);
            this._geometryData.vertexStreamsUpdated = !0;
            this._geometryData.vertexStreamDictionary[a] = new On(b, c, e || 6, f || !1)
        },
        getVertexStream: function(a,
            b) {
            var c = 0,
                d = !1;
            if (this._geometryData) {
                var e = this._geometryData.vertexStreamDictionary[a];
                e && (d = !0, c = this._geometryData.vertexCount, ArrayBuffer.isView(b) ? b.set(e.data) : (b.length = 0, b.push(e.data)))
            }
            d || this.vertexBuffer && (c = (new Pb(this.vertexBuffer)).readData(a, b));
            return c
        },
        setPositions: function(a, b, c) {
            this.setVertexStream("POSITION", a, b || dd.DEFAULT_COMPONENTS_POSITION, c, 6, !1)
        },
        setNormals: function(a, b, c) {
            this.setVertexStream("NORMAL", a, b || dd.DEFAULT_COMPONENTS_NORMAL, c, 6, !1)
        },
        setUvs: function(a, b,
            c, d) {
            this.setVertexStream("TEXCOORD" + a, b, c || dd.DEFAULT_COMPONENTS_UV, d, 6, !1)
        },
        setColors: function(a, b, c) {
            this.setVertexStream("COLOR", a, b || dd.DEFAULT_COMPONENTS_COLORS, c, 6, !1)
        },
        setColors32: function(a, b) {
            this.setVertexStream("COLOR", a, dd.DEFAULT_COMPONENTS_COLORS, b, 1, !0)
        },
        setIndices: function(a, b) {
            this._initGeometryData();
            this._geometryData.indexStreamUpdated = !0;
            this._geometryData.indices = a;
            this._geometryData.indexCount = b || a.length
        },
        getPositions: function(a) {
            return this.getVertexStream("POSITION", a)
        },
        getNormals: function(a) {
            return this.getVertexStream("NORMAL", a)
        },
        getUvs: function(a, b) {
            return this.getVertexStream("TEXCOORD" + a, b)
        },
        getColors: function(a) {
            return this.getVertexStream("COLOR", a)
        },
        getIndices: function(a) {
            var b = 0;
            if (this._geometryData && this._geometryData.indices) {
                var c = this._geometryData.indices;
                b = this._geometryData.indexCount;
                ArrayBuffer.isView(a) ? a.set(c) : (a.length = 0, a.push(c))
            } else 0 < this.indexBuffer.length && this.indexBuffer[0] && (b = this.indexBuffer[0].readData(a));
            return b
        },
        update: function(a,
            b) {
            this._geometryData && ((b || void 0 === b) && (b = this._geometryData.vertexStreamDictionary.POSITION) && 3 == b.componentCount && this._aabb.compute(b.data, this._geometryData.vertexCount), b = this._geometryData.recreate, this._geometryData.vertexCount > this._geometryData.maxVertices && (b = !0, this._geometryData.maxVertices = this._geometryData.vertexCount), b && this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBuffer = null), b = this._geometryData.recreate, this._geometryData.indexCount > this._geometryData.maxIndices &&
                (b = !0, this._geometryData.maxIndices = this._geometryData.indexCount), b && 0 < this.indexBuffer.length && this.indexBuffer[0] && (this.indexBuffer[0].destroy(), this.indexBuffer[0] = null), this._geometryData.vertexStreamsUpdated && this._updateVertexBuffer(), this._geometryData.indexStreamUpdated && this._updateIndexBuffer(), this.primitive[0].type = void 0 === a ? 4 : a, 0 < this.indexBuffer.length && this.indexBuffer[0] ? this._geometryData.indexStreamUpdated && (this.primitive[0].count = this._geometryData.indexCount, this.primitive[0].indexed = !0) : this._geometryData.vertexStreamsUpdated && (this.primitive[0].count = this._geometryData.vertexCount, this.primitive[0].indexed = !1), this._geometryData.vertexCount = 0, this._geometryData.indexCount = 0, this._geometryData.vertexStreamsUpdated = !1, this._geometryData.indexStreamUpdated = !1, this._geometryData.recreate = !1)
        },
        _buildVertexFormat: function(a) {
            var b = [],
                c;
            for (c in this._geometryData.vertexStreamDictionary) {
                var d = this._geometryData.vertexStreamDictionary[c];
                b.push({
                    semantic: c,
                    components: d.componentCount,
                    type: d.dataType,
                    normalize: d.dataTypeNormalize
                })
            }
            return new Na(this.device, b, a)
        },
        _updateVertexBuffer: function() {
            if (!this.vertexBuffer) {
                var a = this._geometryData.maxVertices,
                    b = this._buildVertexFormat(a);
                this.vertexBuffer = new ab(this.device, b, a, this._geometryData.verticesUsage)
            }
            a = new Pb(this.vertexBuffer);
            b = this._geometryData.vertexCount;
            for (var c in this._geometryData.vertexStreamDictionary) a.writeData(c, this._geometryData.vertexStreamDictionary[c].data, b), delete this._geometryData.vertexStreamDictionary[c];
            a.end()
        },
        _updateIndexBuffer: function() {
            if (0 >= this.indexBuffer.length || !this.indexBuffer[0]) this.indexBuffer[0] = new dc(this.device, 65535 < this._geometryData.maxVertices ? 2 : 1, this._geometryData.maxIndices, this._geometryData.indicesUsage);
            var a = this._geometryData.indices;
            a && (this.indexBuffer[0].writeData(a, this._geometryData.indexCount), this._geometryData.indices = null)
        },
        generateWireframe: function() {
            var a = function(r) {
                    switch (r.format) {
                        case 0:
                            return new Uint8Array(r.storage);
                        case 1:
                            return new Uint16Array(r.storage);
                        case 2:
                            return new Uint32Array(r.storage);
                        default:
                            return null
                    }
                },
                b = [];
            if (0 < this.indexBuffer.length && this.indexBuffer[0]) {
                var c = [
                    [0, 1],
                    [1, 2],
                    [2, 0]
                ];
                for (var d = this.primitive[0].base, e = this.primitive[0].count, f = this.indexBuffer[0], g = a(f), k = {}, h = d; h < d + e; h += 3)
                    for (var l = 0; 3 > l; l++) {
                        var n = g[h + c[l][0]],
                            p = g[h + c[l][1]],
                            q = n > p ? p << 16 | n : n << 16 | p;
                        void 0 === k[q] && (k[q] = 0, b.push(n, p))
                    }
                c = f.format
            } else {
                for (c = 0; c < this.vertexBuffer.numVertices; c += 3) b.push(c, c + 1, c + 1, c + 2, c + 2, c);
                c = 65535 < b.length ? 2 : 1
            }
            c = new dc(this.vertexBuffer.device,
                c, b.length);
            a(c).set(b);
            c.unlock();
            this.primitive[1] = {
                type: 1,
                base: 0,
                count: b.length,
                indexed: !0
            };
            this.indexBuffer[1] = c
        }
    });
    var Bc = new oa,
        sh = new oa,
        Vj = new Ed;
    Object.defineProperty(va.prototype, "mesh", {
        get: function() {
            return this._mesh
        },
        set: function(a) {
            this._mesh && this._mesh.decReference();
            (this._mesh = a) && a.incReference()
        }
    });
    Object.defineProperty(va.prototype, "aabb", {
        get: function() {
            var a;
            if (!this._updateAabb) return this._aabb;
            if (this._updateAabbFunc) return this._updateAabbFunc(this._aabb);
            if (this.skinInstance) {
                this.mesh.boneAabb ||
                    this.mesh._initBoneAabbs(this._morphInstance ? this._morphInstance.morph._targets : null);
                var b = this.mesh.boneUsed,
                    c = this.node.getWorldTransform(),
                    d = !0;
                for (a = 0; a < this.mesh.boneAabb.length; a++) b[a] && (sh.setFromTransformedAabb(this.mesh.boneAabb[a], this.skinInstance.matrices[a]), d ? (d = !1, Bc.center.copy(sh.center), Bc.halfExtents.copy(sh.halfExtents)) : Bc.add(sh));
                this._aabb.setFromTransformedAabb(Bc, c)
            } else this.node._aabbVer !== this._aabbVer && (this.mesh ? (Bc.center.copy(this.mesh.aabb.center), Bc.halfExtents.copy(this.mesh.aabb.halfExtents)) :
                (Bc.center.set(0, 0, 0), Bc.halfExtents.set(0, 0, 0)), this.mesh && this.mesh.morph && Bc._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax()), this._aabb.setFromTransformedAabb(Bc, this.node.getWorldTransform()), this._aabbVer = this.node._aabbVer);
            return this._aabb
        },
        set: function(a) {
            this._aabb = a
        }
    });
    Object.defineProperty(va.prototype, "material", {
        get: function() {
            return this._material
        },
        set: function(a) {
            var b;
            for (b = 0; b < this._shader.length; b++) this._shader[b] = null;
            if (this._material) {
                var c = this._material.meshInstances;
                b = c.indexOf(this); - 1 !== b && c.splice(b, 1)
            }
            b = this._material;
            if (this._material = a) this._material.meshInstances.push(this), this.updateKey(), (b && 3 !== b.blendType) !== (3 !== this._material.blendType) && (a = this._material._scene, !a && b && b._scene && (a = b._scene), a ? a.layers._dirtyBlend = !0 : this._material._dirtyBlend = !0)
        }
    });
    Object.defineProperty(va.prototype, "layer", {
        get: function() {
            return this._layer
        },
        set: function(a) {
            this._layer = a;
            this.updateKey()
        }
    });
    Object.defineProperty(va.prototype, "calculateSortDistance", {
        get: function() {
            return this._calculateSortDistance
        },
        set: function(a) {
            this._calculateSortDistance = a
        }
    });
    Object.defineProperty(va.prototype, "receiveShadow", {
        get: function() {
            return this._receiveShadow
        },
        set: function(a) {
            this._shaderDefs = (this._receiveShadow = a) ? this._shaderDefs & -2 : this._shaderDefs | 1;
            this._shader[0] = null;
            this._shader[1] = null
        }
    });
    Object.defineProperty(va.prototype, "skinInstance", {
        get: function() {
            return this._skinInstance
        },
        set: function(a) {
            this._shaderDefs = (this._skinInstance = a) ? this._shaderDefs | 2 : this._shaderDefs & -3;
            for (a = 0; a < this._shader.length; a++) this._shader[a] =
                null;
            this._setupSkinUpdate()
        }
    });
    Object.defineProperty(va.prototype, "morphInstance", {
        get: function() {
            return this._morphInstance
        },
        set: function(a) {
            if (this._morphInstance = a) this._morphInstance.meshInstance = this;
            this._shaderDefs = a && a.morph.useTextureMorph ? this._shaderDefs | 4096 : this._shaderDefs & -4097;
            this._shaderDefs = a && a.morph.morphPositions ? this._shaderDefs | 1024 : this._shaderDefs & -1025;
            this._shaderDefs = a && a.morph.morphNormals ? this._shaderDefs | 2048 : this._shaderDefs & -2049;
            for (a = 0; a < this._shader.length; a++) this._shader[a] =
                null
        }
    });
    Object.defineProperty(va.prototype, "screenSpace", {
        get: function() {
            return this._screenSpace
        },
        set: function(a) {
            this._shaderDefs = (this._screenSpace = a) ? this._shaderDefs | 256 : this._shaderDefs & -257;
            this._shader[0] = null
        }
    });
    Object.defineProperty(va.prototype, "key", {
        get: function() {
            return this._key[0]
        },
        set: function(a) {
            this._key[0] = a
        }
    });
    Object.defineProperty(va.prototype, "mask", {
        get: function() {
            return this._shaderDefs >> 16
        },
        set: function(a) {
            this._shaderDefs = this._shaderDefs & 65535 | a << 16;
            this._shader[0] = null;
            this._shader[1] = null
        }
    });
    Object.defineProperty(va.prototype, "instancingCount", {
        get: function() {
            return this.instancingData ? this.instancingData.count : 0
        },
        set: function(a) {
            this.instancingData && (this.instancingData.count = a)
        }
    });
    Object.assign(va.prototype, {
        syncAabb: function() {},
        _isVisible: function(a) {
            if (this.visible) {
                if (this.isVisibleFunc) return this.isVisibleFunc(a);
                var b = this.aabb.center;
                this._aabb._radiusVer !== this._aabbVer && (this._aabb._radius = this._aabb.halfExtents.length(), this._aabb._radiusVer = this._aabbVer);
                Vj.radius = this._aabb._radius;
                Vj.center = b;
                return a.frustum.containsSphere(Vj)
            }
            return !1
        },
        updateKey: function() {
            var a = this.material;
            this._key[0] = (this.layer & 15) << 27 | (3 === (a.alphaToCoverage || a.alphaTest ? 2 : a.blendType) ? 1 : 0) << 26 | 0 | (a.id & 33554431) << 0
        },
        setInstancing: function(a) {
            a ? (this.instancingData = new Qn(a.numVertices), this.instancingData.vertexBuffer = a, a.instancing = !0, this.cull = !1) : (this.instancingData = null, this.cull = !0)
        },
        clearParameters: function() {
            this.parameters = {}
        },
        getParameters: function() {
            return this.parameters
        },
        getParameter: function(a) {
            return this.parameters[a]
        },
        setParameter: function(a, b, c) {
            void 0 === c && (c = -524285);
            if (void 0 === b && "object" === typeof a) {
                b = a;
                if (b.length) {
                    for (a = 0; a < b.length; a++) this.setParameter(b[a]);
                    return
                }
                a = b.name;
                b = b.value
            }
            var d = this.parameters[a];
            d ? (d.data = b, d.passFlags = c) : this.parameters[a] = {
                scopeId: null,
                data: b,
                passFlags: c
            }
        },
        deleteParameter: function(a) {
            this.parameters[a] && delete this.parameters[a]
        },
        setParameters: function(a, b) {
            var c = this.parameters,
                d;
            for (d in c) {
                var e = c[d];
                e.passFlags & b &&
                    (e.scopeId || (e.scopeId = a.scope.resolve(d)), e.scopeId.setValue(e.data))
            }
        },
        setOverrideAabb: function(a) {
            this._updateAabb = !a;
            a && this.aabb.copy(a);
            this._setupSkinUpdate()
        },
        _setupSkinUpdate: function() {
            this._skinInstance && (this._skinInstance._updateBeforeCull = this._updateAabb)
        }
    });
    Object.defineProperty(yg.prototype, "key", {
        get: function() {
            return this._key[0]
        },
        set: function(a) {
            this._key[0] = a
        }
    });
    Object.defineProperties(Db, {
        FORMAT_FLOAT: {
            value: 0
        },
        FORMAT_HALF_FLOAT: {
            value: 1
        }
    });
    Object.defineProperties(Db.prototype, {
        morphPositions: {
            get: function() {
                return this._morphPositions
            }
        },
        morphNormals: {
            get: function() {
                return this._morphNormals
            }
        },
        maxActiveTargets: {
            get: function() {
                return this._useTextureMorph ? this._targets.length : this._morphPositions && this._morphNormals ? 4 : 8
            }
        },
        useTextureMorph: {
            get: function() {
                return this._useTextureMorph
            }
        }
    });
    Object.assign(Db.prototype, {
        _init: function() {
            this._useTextureMorph && (this._useTextureMorph = this._initTextureBased());
            var a;
            if (!this._useTextureMorph)
                for (a = 0; a < this._targets.length; a++) this._targets[a]._initVertexBuffers(this.device);
            for (a = 0; a < this._targets.length; a++) this._targets[a]._postInit()
        },
        _initTextureBased: function() {
            var a, b = [],
                c = [];
            for (a = 0; a < this._targets.length; a++) {
                var d = this._targets[a];
                d.options.deltaPositions && (b.push(d.options.deltaPositions), c.push({
                    target: d,
                    name: "texturePositions"
                }));
                d.options.deltaNormals && (b.push(d.options.deltaNormals), c.push({
                    target: d,
                    name: "textureNormals"
                }))
            }
            var e = [],
                f = [],
                g = 1,
                k = b[0].length;
            for (d = 0; d < k; d += 3) {
                var h = !1;
                for (a = 0; a < b.length; a++) {
                    var l = b[a];
                    if (0 !== l[d] || 0 !== l[d + 1] || 0 !== l[d + 2]) {
                        h = !0;
                        break
                    }
                }
                h ? (e.push(g), f.push(d / 3), g++) : e.push(0)
            }
            a = Math.min(this.device.maxTextureSize, 4096);
            d = Math.ceil(Math.sqrt(g));
            d = Math.min(d, a);
            l = Math.ceil(g / d);
            if (l > a) return !1;
            this.morphTextureWidth = d;
            this.morphTextureHeight = l;
            g = !1;
            h = 3;
            k = N.float2Half;
            this._textureFormat === Db.FORMAT_HALF_FLOAT && (g = !0, h = 4);
            a = this.morphTextureWidth * this.morphTextureHeight * h;
            var n = g ? new Uint16Array(a) : new Float32Array(a);
            for (a = 0; a < b.length; a++) {
                l = b[a];
                for (d = 0; d < f.length; d++) {
                    var p = f[d];
                    g ? (n[d * h + h] = k(l[3 * p]), n[d * h + h + 1] = k(l[3 *
                        p + 1]), n[d * h + h + 2] = k(l[3 * p + 2])) : (n[d * h + h] = l[3 * p], n[d * h + h + 1] = l[3 * p + 1], n[d * h + h + 2] = l[3 * p + 2])
                }
                d = c[a].target;
                d._setTexture(c[a].name, this._createTexture("MorphTarget", this._textureFormat === Db.FORMAT_FLOAT ? 13 : 12, n))
            }
            this.vertexBufferIds = new ab(this.device, new Na(this.device, [{
                semantic: "ATTR15",
                components: 1,
                type: 6
            }]), e.length, 0, new Float32Array(e));
            return !0
        },
        destroy: function() {
            this.vertexBufferIds && (this.vertexBufferIds.destroy(), this.vertexBufferIds = null);
            for (var a = 0; a < this._targets.length; a++) this._targets[a].destroy();
            this._targets.length = 0
        },
        getTarget: function(a) {
            return this._targets[a]
        },
        _updateMorphFlags: function() {
            this._morphNormals = this._morphPositions = !1;
            for (var a, b = 0; b < this._targets.length; b++) a = this._targets[b], a.morphPositions && (this._morphPositions = !0), a.morphNormals && (this._morphNormals = !0)
        },
        _calculateAabb: function() {
            this.aabb = new oa(new z(0, 0, 0), new z(0, 0, 0));
            for (var a, b = 0; b < this._targets.length; b++) a = this._targets[b], this.aabb._expand(a.aabb.getMin(), a.aabb.getMax())
        },
        _createTexture: function(a, b, c) {
            b =
                new V(this.device, {
                    width: this.morphTextureWidth,
                    height: this.morphTextureHeight,
                    format: b,
                    cubemap: !1,
                    mipmaps: !1,
                    minFilter: 0,
                    magFilter: 0,
                    addressU: 1,
                    addressV: 1
                });
            b.name = a;
            c && (b.lock().set(c), b.unlock());
            return b
        }
    });
    Object.assign(uf.prototype, {
        destroy: function() {
            this.shader = this.meshInstance = null;
            this.morph && (this.morph.destroy(), this.morph = null);
            this.rtPositions && (this.rtPositions.destroy(), this.rtPositions = null);
            this.texturePositions && (this.texturePositions.destroy(), this.texturePositions = null);
            this.rtNormals &&
                (this.rtNormals.destroy(), this.rtNormals = null);
            this.textureNormals && (this.textureNormals.destroy(), this.textureNormals = null)
        },
        getWeight: function(a) {
            return this._weights[a]
        },
        setWeight: function(a, b) {
            this._weights[a] = b;
            this._dirty = !0
        },
        _getFragmentShader: function(a) {
            var b, c = "";
            0 < a && (c += "varying vec2 uv0;\nuniform highp float morphFactor[" + a + "];\n");
            for (b = 0; b < a; b++) c += "uniform highp sampler2D morphBlendTex" + b + ";\n";
            c += "void main (void) {\n\thighp vec4 color = vec4(0, 0, 0, 1);\n";
            for (b = 0; b < a; b++) c += "\tcolor.xyz += morphFactor[" +
                b + "] * texture2D(morphBlendTex" + b + ", uv0).xyz;\n";
            return c + "\tgl_FragColor = color;\n}\n"
        },
        _getShader: function(a) {
            var b = this.shaderCache[a];
            b || (b = this._getFragmentShader(a), b = Wa(this.device, "attribute vec2 vertex_position;\nvarying vec2 uv0;\nvoid main(void) {\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tuv0 = vertex_position.xy * 0.5 + 0.5;\n}\n", b, "textureMorph" + a), this.shaderCache[a] = b);
            return b
        },
        _updateTextureRenderTarget: function(a, b) {
            for (var c = this.device, d = function(n, p) {
                    this.morphFactor.setValue(this._shaderMorphWeights);
                    c.setBlending(p);
                    p && (c.setBlendFunction(1, 1), c.setBlendEquation(0));
                    n = this._getShader(n);
                    La(c, a, n, void 0, void 0, p)
                }.bind(this), e = 0, f = !1, g = this._activeTargets.length, k = 0; k < g; k++) {
                var h = this._activeTargets[k],
                    l = h.target[b];
                l && (this["morphBlendTex" + e].setValue(l), this._shaderMorphWeights[e] = h.weight, e++, e >= this.maxSubmitCount && (d(e, f), e = 0, f = !0))
            }(0 < e || 0 === g && !this.zeroTextures) && d(e, f)
        },
        _updateTextureMorph: function() {
            if (0 < this._activeTargets.length || !this.zeroTextures) this._updateTextureRenderTarget(this.rtPositions,
                "texturePositions"), this._updateTextureRenderTarget(this.rtNormals, "textureNormals"), this.zeroTextures = 0 === this._activeTargets.length
        },
        _updateVertexMorph: function() {
            var a, b = this.maxSubmitCount;
            for (a = 0; a < b; a++) this._shaderMorphWeights[a] = 0, this._activeVertexBuffers[a] = null;
            b = 0;
            var c = this.morph.morphPositions ? 4 : 0;
            for (a = 0; a < this._activeTargets.length; a++) {
                var d = this._activeTargets[a].target;
                d._vertexBufferPositions && (this._activeVertexBuffers[b] = d._vertexBufferPositions, this._shaderMorphWeights[b] = this._activeTargets[a].weight,
                    b++);
                d._vertexBufferNormals && (this._activeVertexBuffers[c] = d._vertexBufferNormals, this._shaderMorphWeights[c] = this._activeTargets[a].weight, c++)
            }
        },
        update: function() {
            this._dirty = !1;
            var a = this.morph._targets,
                b = 0,
                c;
            for (c = 0; c < a.length; c++) {
                var d = Math.abs(this.getWeight(c));
                if (1E-5 < d) {
                    this._activeTargets.length <= b && (this._activeTargets[b] = {});
                    var e = this._activeTargets[b++];
                    e.absWeight = d;
                    e.weight = this.getWeight(c);
                    e.target = a[c]
                }
            }
            this._activeTargets.length = b;
            a = this.morph.maxActiveTargets;
            this._activeTargets.length >
                a && (this._activeTargets.sort(function(f, g) {
                    return f.absWeight < g.absWeight ? 1 : g.absWeight < f.absWeight ? -1 : 0
                }), this._activeTargets.length = a);
            this.morph.useTextureMorph ? this._updateTextureMorph() : this._updateVertexMorph()
        }
    });
    var bm = new J;
    Object.assign(Ic.prototype, {
        init: function(a, b) {
            if (a.supportsBoneTextures) {
                b *= 3;
                var c = Math.ceil(Math.sqrt(b));
                c = N.roundUp(c, 3);
                this.boneTexture = new V(a, {
                    width: c,
                    height: Math.ceil(b / c),
                    format: 14,
                    mipmaps: !1,
                    minFilter: 0,
                    magFilter: 0
                });
                this.boneTexture.name = "skin";
                this.matrixPalette =
                    this.boneTexture.lock()
            } else this.matrixPalette = new Float32Array(12 * b)
        },
        initSkin: function(a) {
            this.skin = a;
            this.bones = [];
            var b = a.inverseBindPose.length;
            this.init(a.device, b);
            this.matrices = [];
            for (a = 0; a < b; a++) this.matrices[a] = new J
        },
        uploadBones: function(a) {
            a.supportsBoneTextures && (this.boneTexture.lock(), this.boneTexture.unlock())
        },
        _updateMatrices: function(a, b) {
            if (this._skinUpdateIndex !== b)
                for (this._skinUpdateIndex = b, bm.copy(a.getWorldTransform()).invert(), a = this.bones.length - 1; 0 <= a; a--) this.matrices[a].mulAffine2(bm,
                    this.bones[a].getWorldTransform()), this.matrices[a].mulAffine2(this.matrices[a], this.skin.inverseBindPose[a])
        },
        updateMatrices: function(a, b) {
            this._updateBeforeCull && this._updateMatrices(a, b)
        },
        updateMatrixPalette: function(a, b) {
            this._updateMatrices(a, b);
            b = this.matrixPalette;
            for (var c, d = this.bones.length, e = 0; e < d; e++) a = this.matrices[e].data, c = 12 * e, b[c] = a[0], b[c + 1] = a[4], b[c + 2] = a[8], b[c + 3] = a[12], b[c + 4] = a[1], b[c + 5] = a[5], b[c + 6] = a[9], b[c + 7] = a[13], b[c + 8] = a[2], b[c + 9] = a[6], b[c + 10] = a[10], b[c + 11] = a[14];
            this.uploadBones(this.skin.device)
        }
    });
    Object.assign(tb.prototype, {
        getGraph: function() {
            return this.graph
        },
        setGraph: function(a) {
            this.graph = a
        },
        getCameras: function() {
            return this.cameras
        },
        setCameras: function(a) {
            this.cameras = a
        },
        getLights: function() {
            return this.lights
        },
        setLights: function(a) {
            this.lights = a
        },
        getMaterials: function() {
            var a, b = [];
            for (a = 0; a < this.meshInstances.length; a++) {
                var c = this.meshInstances[a]; - 1 === b.indexOf(c.material) && b.push(c.material)
            }
            return b
        },
        clone: function() {
            var a, b, c = [],
                d = [],
                e = function(r) {
                    var t = r.clone();
                    c.push(r);
                    d.push(t);
                    for (var u = 0; u < r._children.length; u++) t.addChild(e(r._children[u]));
                    return t
                },
                f = e(this.graph),
                g = [],
                k = [],
                h = [];
            for (a = 0; a < this.skinInstances.length; a++) {
                var l = this.skinInstances[a].skin,
                    n = new Ic(l),
                    p = [];
                for (b = 0; b < l.boneNames.length; b++) {
                    var q = f.findByName(l.boneNames[b]);
                    p.push(q)
                }
                n.bones = p;
                k.push(n)
            }
            for (a = 0; a < this.morphInstances.length; a++) b = new uf(this.morphInstances[a].morph), h.push(b);
            for (a = 0; a < this.meshInstances.length; a++) b = this.meshInstances[a], l = c.indexOf(b.node), l = new va(d[l], b.mesh, b.material),
                b.skinInstance && (n = this.skinInstances.indexOf(b.skinInstance), l.skinInstance = k[n]), b.morphInstance && (b = this.morphInstances.indexOf(b.morphInstance), l.morphInstance = h[b]), g.push(l);
            a = new tb;
            a.graph = f;
            a.meshInstances = g;
            a.skinInstances = k;
            a.morphInstances = h;
            a.getGraph().syncHierarchy();
            return a
        },
        destroy: function() {
            for (var a = this.meshInstances, b, c, d = 0; d < a.length; d++) {
                b = a[d];
                if (c = b.mesh) b.mesh = null, 1 > c.refCount && c.destroy();
                (c = b.skinInstance) && (c = c.boneTexture) && c.destroy();
                b.skinInstance = null;
                (c = b.morphInstance) &&
                c.destroy();
                b.morphInstance = null;
                b.material = null
            }
        },
        generateWireframe: function() {
            var a, b = [];
            for (a = 0; a < this.meshInstances.length; a++) {
                var c = this.meshInstances[a].mesh; - 1 === b.indexOf(c) && b.push(c)
            }
            for (a = 0; a < b.length; ++a) c = b[a], c.primitive[1] || c.generateWireframe()
        }
    });
    bb.MODEL = "model";
    bb.ELEMENT = "element";
    bb.SPRITE = "sprite";
    Jd.prototype = Object.create(Jd.prototype);
    Jd.prototype.constructor = Jd;
    Object.assign(Jd.prototype, {
        updateMatrices: function(a, b) {},
        updateMatrixPalette: function(a, b) {
            b = this.matrixPalette;
            for (var c, d = this.bones.length, e = 0; e < d; e++) a = this.bones[e].getWorldTransform().data, c = 12 * e, b[c] = a[0], b[c + 1] = a[4], b[c + 2] = a[8], b[c + 3] = a[12], b[c + 4] = a[1], b[c + 5] = a[5], b[c + 6] = a[9], b[c + 7] = a[13], b[c + 8] = a[2], b[c + 9] = a[6], b[c + 10] = a[10], b[c + 11] = a[14];
            Ic.prototype.uploadBones.call(this, this.device)
        }
    });
    Ia.prototype.destroyManager = function() {
        this.scene = this.rootNode = this.device = null;
        this._batchGroups = {};
        this._batchList = [];
        this._dirtyGroups = []
    };
    Ia.prototype.addGroup = function(a, b, c, d, e) {
        void 0 === d && (d = this._batchGroupCounter,
            this._batchGroupCounter++);
        if (!this._batchGroups[d]) return this._batchGroups[d] = a = new bb(d, a, b, c, e)
    };
    Ia.prototype.removeGroup = function(a) {
        if (this._batchGroups[a]) {
            for (var b = [], c = 0; c < this._batchList.length; c++) this._batchList[c].batchGroupId !== a ? b.push(this._batchList[c]) : this.destroy(this._batchList[c]);
            this._batchList = b;
            this._removeModelsFromBatchGroup(this.rootNode, a);
            delete this._batchGroups[a]
        }
    };
    Ia.prototype.markGroupDirty = function(a) {
        0 > this._dirtyGroups.indexOf(a) && this._dirtyGroups.push(a)
    };
    Ia.prototype.getGroupByName = function(a) {
        var b = this._batchGroups,
            c;
        for (c in b)
            if (b.hasOwnProperty(c) && b[c].name === a) return b[c];
        return null
    };
    Ia.prototype.getBatches = function(a) {
        for (var b = [], c = this._batchList.length, d = 0; d < c; d++) {
            var e = this._batchList[d];
            e.batchGroupId === a && b.push(e)
        }
        return b
    };
    Ia.prototype._removeModelsFromBatchGroup = function(a, b) {
        if (a.enabled) {
            a.model && a.model.batchGroupId === b && (a.model.batchGroupId = -1);
            a.element && a.element.batchGroupId === b && (a.element.batchGroupId = -1);
            a.sprite && a.sprite.batchGroupId ===
                b && (a.sprite.batchGroupId = -1);
            for (var c = 0; c < a._children.length; c++) this._removeModelsFromBatchGroup(a._children[c], b)
        }
    };
    Ia.prototype.insert = function(a, b, c) {
        var d = this._batchGroups[b];
        d && 0 > d._obj[a].indexOf(c) && (d._obj[a].push(c), this.markGroupDirty(b))
    };
    Ia.prototype.remove = function(a, b, c) {
        var d = this._batchGroups[b];
        d && (c = d._obj[a].indexOf(c), 0 <= c && (d._obj[a].splice(c, 1), this.markGroupDirty(b)))
    };
    Ia.prototype._extractModel = function(a, b, c, d) {
        if (!a.model || !a.model.model) return b;
        if (a.model.isStatic) {
            d =
                this.scene.drawCalls;
            var e = a.model.meshInstances;
            for (c = 0; c < d.length; c++) d[c]._staticSource && (0 > e.indexOf(d[c]._staticSource) || b.push(d[c]));
            for (c = 0; c < e.length; c++) 0 <= d.indexOf(e[c]) && b.push(e[c])
        } else b = d[a.model.batchGroupId] = b.concat(a.model.meshInstances);
        a.model.removeModelFromLayers();
        return b
    };
    Ia.prototype._extractElement = function(a, b, c) {
        if (a.element) {
            var d = !1;
            a.element._text && 0 < a.element._text._model.meshInstances.length ? (b.push(a.element._text._model.meshInstances[0]), a.element.removeModelFromLayers(a.element._text._model),
                d = !0) : a.element._image && (b.push(a.element._image._renderable.meshInstance), a.element.removeModelFromLayers(a.element._image._renderable.model), a.element._image._renderable.unmaskMeshInstance && (b.push(a.element._image._renderable.unmaskMeshInstance), a.element._image._renderable.unmaskMeshInstance.stencilFront && a.element._image._renderable.unmaskMeshInstance.stencilBack || (a.element._dirtifyMask(), a.element._onPrerender())), d = !0);
            d && (c._ui = !0)
        }
    };
    Ia.prototype._collectAndRemoveModels = function(a, b) {
        for (var c,
                d, e, f = 0; f < b.length; f++)
            if (c = b[f], d = this._batchGroups[c]) {
                (e = a[c]) || (e = a[c] = []);
                for (c = 0; c < d._obj.model.length; c++) e = this._extractModel(d._obj.model[c], e, d, a);
                for (c = 0; c < d._obj.element.length; c++) this._extractElement(d._obj.element[c], e, d);
                for (var g = 0; g < d._obj.sprite.length; g++) c = d._obj.sprite[g], c.sprite && c.sprite._meshInstance && (d.dynamic || 0 === c.sprite.sprite._renderMode) && (e.push(c.sprite._meshInstance), c.sprite.removeModelFromLayers(), d._sprite = !0, c.sprite._batchGroup = d)
            }
    };
    Ia.prototype.generate =
        function(a) {
            var b, c = {};
            a || (a = Object.keys(this._batchGroups));
            var d = [];
            for (b = 0; b < this._batchList.length; b++) 0 > a.indexOf(this._batchList[b].batchGroupId) ? d.push(this._batchList[b]) : this.destroy(this._batchList[b]);
            this._batchList = d;
            this._collectAndRemoveModels(c, a);
            if (a === this._dirtyGroups) this._dirtyGroups.length = 0;
            else {
                d = [];
                for (b = 0; b < this._dirtyGroups.length; b++) 0 > a.indexOf(this._dirtyGroups[b]) && d.push(this._dirtyGroups[b]);
                this._dirtyGroups = d
            }
            var e, f;
            for (f in c)
                if (c.hasOwnProperty(f) && (b = c[f], a =
                        this._batchGroups[f])) {
                    var g = this.prepare(b, a.dynamic, a.maxAabbSize, a._ui || a._sprite);
                    for (b = 0; b < g.length; b++)
                        if (e = this.create(g[b], a.dynamic, parseInt(f, 10)))
                            for (d = 0; d < a.layers.length; d++) {
                                var k = this.scene.layers.getLayerById(a.layers[d]);
                                k && k.addMeshInstances(e.model.meshInstances)
                            }
                }
        };
    var zg = new z,
        Fk = new z,
        Gk = new z;
    Ia.prototype.prepare = function(a, b, c, d) {
        if (0 === a.length) return [];
        void 0 === c && (c = Number.POSITIVE_INFINITY);
        c *= .5;
        var e = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit,
            f = this.device.extUintElement ?
            4294967295 : 65535,
            g = new oa,
            k = new oa,
            h = null,
            l, n = [],
            p, q = 0;
        d && a.sort(function(I, T) {
            return I.drawOrder - T.drawOrder
        });
        for (var r = a, t, u = d ? function(I) {
                h ? h.add(I.aabb) : h = I.aabb.clone();
                t.push(I)
            } : function(I) {
                t.push(I)
            }; 0 < r.length;) {
            n[q] = [r[0]];
            t = [];
            a = r[0].material;
            var x = r[0].layer;
            var v = r[0]._shaderDefs;
            var w = r[0].parameters;
            var y = r[0].stencilFront;
            var A = r[0]._staticLightList;
            var B = r[0].mesh.vertexBuffer.getNumVertices();
            var E = r[0].drawOrder;
            g.copy(r[0].aabb);
            var D = li(r[0]);
            var C = r[0].mesh.vertexBuffer.format.batchingHash;
            var G = r[0].mesh.primitive[0].indexed;
            h = null;
            for (p = 1; p < r.length; p++) {
                var K = r[p];
                if (b && n[q].length >= e) {
                    t = t.concat(r.slice(p));
                    break
                }
                if (a !== K.material || x !== K.layer || C !== K.mesh.vertexBuffer.format.batchingHash || G !== K.mesh.primitive[0].indexed || v !== K._shaderDefs || B + K.mesh.vertexBuffer.getNumVertices() > f) u(K);
                else if (k.copy(g), k.add(K.aabb), k.halfExtents.x > c || k.halfExtents.y > c || k.halfExtents.z > c) u(K);
                else if (!y || (l = K.stencilFront) && y.func == l.func && y.zpass == l.zpass)
                    if (D != li(K)) u(K);
                    else if (Rn(w, K.parameters)) {
                    var R =
                        K._staticLightList;
                    if (A && R) {
                        if (!Sn(A, R)) {
                            u(K);
                            continue
                        }
                    } else if (A || R) {
                        u(K);
                        continue
                    }
                    d && h && h.intersects(K.aabb) && K.drawOrder !== E ? u(K) : (g.add(K.aabb), B += K.mesh.vertexBuffer.getNumVertices(), n[q].push(K))
                } else u(K);
                else u(K)
            }
            q++;
            r = t
        }
        return n
    };
    Ia.prototype.create = function(a, b, c) {
        this._init || (this.transformVS = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n#define DYNAMICBATCH\n" + F.transformVS, this.skinTexVS = F.skinBatchTexVS, this.skinConstVS = F.skinBatchConstVS, this.vertexFormats = {}, this._init = !0);
        var d, e, f = null,
            g = null,
            k = 0,
            h = 0,
            l = null;
        for (d = 0; d < a.length; d++)
            if (a[d].visible) {
                var n = a[d].mesh;
                var p = n.vertexBuffer.numVertices;
                k += p;
                h += n.primitive[0].indexed ? n.primitive[0].count : 6 == n.primitive[0].type && 4 === n.primitive[0].count ? 6 : 0;
                if (!f) {
                    g = a[d].material;
                    f = {};
                    p = n.vertexBuffer.format.elements;
                    for (e = 0; e < p.length; e++) {
                        var q = p[e].name;
                        f[q] = {
                            numComponents: p[e].numComponents,
                            dataType: p[e].dataType,
                            normalize: p[e].normalize,
                            count: 0
                        }
                    }
                    b && (f.BLENDINDICES = {
                        numComponents: 1,
                        dataType: 6,
                        normalize: !1,
                        count: 0
                    })
                }
            }
        if (f) {
            l =
                new ki(a, b, c);
            this._batchList.push(l);
            var r = 0,
                t = 0,
                u, x = new z;
            h = new(65535 >= k ? Uint16Array : Uint32Array)(h);
            for (q in f) {
                var v = f[q];
                v.typeArrayType = Fd[v.dataType];
                v.elementByteSize = sf[v.dataType];
                v.buffer = new v.typeArrayType(k * v.numComponents)
            }
            for (d = 0; d < a.length; d++)
                if (a[d].visible) {
                    n = a[d].mesh;
                    p = n.vertexBuffer.numVertices;
                    b || (u = a[d].node.getWorldTransform());
                    for (q in f)
                        if ("BLENDINDICES" !== q) {
                            v = f[q];
                            k = new v.typeArrayType(v.buffer.buffer, v.elementByteSize * v.count);
                            var w = n.getVertexStream(q, k) * v.numComponents;
                            v.count += w;
                            if (!b && 3 <= v.numComponents && ("POSITION" == q || "NORMAL" == q || "TANGENT" == q))
                                for (u.transformFunction = "POSITION" == q ? J.prototype.transformPoint : J.prototype.transformVector, e = 0; e < w; e += v.numComponents) x.set(k[e], k[e + 1], k[e + 2]), u.transformFunction(x, x), k[e] = x.x, k[e + 1] = x.y, k[e + 2] = x.z
                        }
                    if (b)
                        for (v = f.BLENDINDICES, e = 0; e < p; e++) v.buffer[v.count++] = d;
                    if (n.primitive[0].indexed) v = n.primitive[0].base, k = n.primitive[0].count, e = n.indexBuffer[0].getFormat(), n = new am[e](n.indexBuffer[0].storage);
                    else if (6 == n.primitive[0].type &&
                        4 === n.primitive[0].count) v = 0, k = 6, n = [0, 1, 3, 2, 3, 1];
                    else continue;
                    for (e = 0; e < k; e++) h[e + t] = n[v + e] + r;
                    t += k;
                    r += p
                }
            n = new sb(this.device);
            for (q in f) v = f[q], n.setVertexStream(q, v.buffer, v.numComponents, void 0, v.dataType, v.normalize);
            0 < h.length && n.setIndices(h);
            n.update(4, !1);
            b && (g = g.clone(), g.chunks.transformVS = this.transformVS, g.chunks.skinTexVS = this.skinTexVS, g.chunks.skinConstVS = this.skinConstVS, g.update());
            a = new va(this.rootNode, n, g);
            a.castShadow = l.origMeshInstances[0].castShadow;
            a.parameters = l.origMeshInstances[0].parameters;
            a.isStatic = l.origMeshInstances[0].isStatic;
            a.layer = l.origMeshInstances[0].layer;
            a._staticLightList = l.origMeshInstances[0]._staticLightList;
            a._shaderDefs = l.origMeshInstances[0]._shaderDefs;
            a.cull = l.origMeshInstances[0].cull;
            (d = this._batchGroups[c]) && d._ui && (a.cull = !1);
            if (b) {
                b = [];
                for (d = 0; d < l.origMeshInstances.length; d++) b.push(l.origMeshInstances[d].node);
                a.skinInstance = new Jd(this.device, b, this.rootNode)
            }
            a._updateAabb = !1;
            a.drawOrder = l.origMeshInstances[0].drawOrder;
            a.stencilFront = l.origMeshInstances[0].stencilFront;
            a.stencilBack = l.origMeshInstances[0].stencilBack;
            a.flipFaces = 0 > li(l.origMeshInstances[0]);
            l.meshInstance = a;
            this.update(l);
            b = new tb;
            b.meshInstances = [l.meshInstance];
            b.castShadows = l.origMeshInstances[0].castShadows;
            l.model = b
        }
        return l
    };
    Ia.prototype.update = function(a) {
        a._aabb.copy(a.origMeshInstances[0].aabb);
        for (var b = 1; b < a.origMeshInstances.length; b++) a._aabb.add(a.origMeshInstances[b].aabb);
        a.meshInstance.aabb = a._aabb;
        a._aabb._radiusVer = -1;
        a.meshInstance._aabbVer = 0
    };
    Ia.prototype.updateAll = function() {
        0 <
            this._dirtyGroups.length && this.generate(this._dirtyGroups);
        for (var a = 0; a < this._batchList.length; a++) this._batchList[a].dynamic && this.update(this._batchList[a])
    };
    Ia.prototype.clone = function(a, b) {
        var c = new ki(b, a.dynamic, a.batchGroupId);
        this._batchList.push(c);
        for (var d = [], e = 0; e < b.length; e++) d.push(b[e].node);
        c.meshInstance = new va(a.meshInstance.node, a.meshInstance.mesh, a.meshInstance.material);
        c.meshInstance._updateAabb = !1;
        c.meshInstance.parameters = b[0].parameters;
        c.meshInstance.isStatic = b[0].isStatic;
        c.meshInstance.cull = b[0].cull;
        c.meshInstance.layer = b[0].layer;
        c.meshInstance._staticLightList = b[0]._staticLightList;
        a.dynamic && (c.meshInstance.skinInstance = new Jd(this.device, d, this.rootNode));
        c.meshInstance.castShadow = a.meshInstance.castShadow;
        c.meshInstance._shader = a.meshInstance._shader;
        b = new tb;
        b.meshInstances = [c.meshInstance];
        b.castShadows = a.origMeshInstances[0].castShadows;
        c.model = b;
        return c
    };
    Ia.prototype.destroy = function(a) {
        a.refCounter = 0;
        if (a.model) {
            for (var b = this._batchGroups[a.batchGroupId].layers,
                    c = 0; c < b.length; c++) {
                var d = this.scene.layers.getLayerById(b[c]);
                d && d.removeMeshInstances(a.model.meshInstances)
            }
            a.model.destroy()
        }
    };
    Ia.prototype.decrement = function(a) {
        a.refCounter--;
        0 === a.refCounter && this.destroy(a)
    };
    var We = new z,
        ge = new z,
        cm = new z,
        dm = new J;
    Object.defineProperty(pa.prototype, "aspectRatio", {
        get: function() {
            return this._aspectRatio
        },
        set: function(a) {
            this._aspectRatio !== a && (this._aspectRatio = a, this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "aspectRatioMode", {
        get: function() {
            return this._aspectRatioMode
        },
        set: function(a) {
            this._aspectRatioMode !== a && (this._aspectRatioMode = a, this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "calculateProjection", {
        get: function() {
            return this._calculateProjection
        },
        set: function(a) {
            this._calculateProjection = a;
            this._projMatDirty = !0
        }
    });
    Object.defineProperty(pa.prototype, "calculateTransform", {
        get: function() {
            return this._calculateTransform
        },
        set: function(a) {
            this._calculateTransform = a
        }
    });
    Object.defineProperty(pa.prototype, "clearColor", {
        get: function() {
            return this._clearColor
        },
        set: function(a) {
            this._clearColor.copy(a)
        }
    });
    Object.defineProperty(pa.prototype, "clearColorBuffer", {
        get: function() {
            return this._clearColorBuffer
        },
        set: function(a) {
            this._clearColorBuffer = a
        }
    });
    Object.defineProperty(pa.prototype, "clearDepth", {
        get: function() {
            return this._clearDepth
        },
        set: function(a) {
            this._clearDepth = a
        }
    });
    Object.defineProperty(pa.prototype, "clearDepthBuffer", {
        get: function() {
            return this._clearDepthBuffer
        },
        set: function(a) {
            this._clearDepthBuffer = a
        }
    });
    Object.defineProperty(pa.prototype, "clearStencil", {
        get: function() {
            return this._clearStencil
        },
        set: function(a) {
            this._clearStencil = a
        }
    });
    Object.defineProperty(pa.prototype, "clearStencilBuffer", {
        get: function() {
            return this._clearStencilBuffer
        },
        set: function(a) {
            this._clearStencilBuffer = a
        }
    });
    Object.defineProperty(pa.prototype, "cullingMask", {
        get: function() {
            return this._cullingMask
        },
        set: function(a) {
            this._cullingMask = a
        }
    });
    Object.defineProperty(pa.prototype, "cullFaces", {
        get: function() {
            return this._cullFaces
        },
        set: function(a) {
            this._cullFaces = a
        }
    });
    Object.defineProperty(pa.prototype,
        "farClip", {
            get: function() {
                return this._farClip
            },
            set: function(a) {
                this._farClip !== a && (this._farClip = a, this._projMatDirty = !0)
            }
        });
    Object.defineProperty(pa.prototype, "flipFaces", {
        get: function() {
            return this._flipFaces
        },
        set: function(a) {
            this._flipFaces = a
        }
    });
    Object.defineProperty(pa.prototype, "fov", {
        get: function() {
            return this._fov
        },
        set: function(a) {
            this._fov !== a && (this._fov = a, this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "frustumCulling", {
        get: function() {
            return this._frustumCulling
        },
        set: function(a) {
            this._frustumCulling =
                a
        }
    });
    Object.defineProperty(pa.prototype, "horizontalFov", {
        get: function() {
            return this._horizontalFov
        },
        set: function(a) {
            this._horizontalFov !== a && (this._horizontalFov = a, this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            this._layers = a.slice(0)
        }
    });
    Object.defineProperty(pa.prototype, "nearClip", {
        get: function() {
            return this._nearClip
        },
        set: function(a) {
            this._nearClip !== a && (this._nearClip = a, this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype,
        "node", {
            get: function() {
                return this._node
            },
            set: function(a) {
                this._node = a
            }
        });
    Object.defineProperty(pa.prototype, "orthoHeight", {
        get: function() {
            return this._orthoHeight
        },
        set: function(a) {
            this._orthoHeight !== a && (this._orthoHeight = a, this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "projection", {
        get: function() {
            return this._projection
        },
        set: function(a) {
            this._projection !== a && (this._projection = a, this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "projectionMatrix", {
        get: function() {
            this._evaluateProjectionMatrix();
            return this._projMat
        }
    });
    Object.defineProperty(pa.prototype, "rect", {
        get: function() {
            return this._rect
        },
        set: function(a) {
            this._rect.copy(a)
        }
    });
    Object.defineProperty(pa.prototype, "renderTarget", {
        get: function() {
            return this._renderTarget
        },
        set: function(a) {
            this._renderTarget = a
        }
    });
    Object.defineProperty(pa.prototype, "scissorRect", {
        get: function() {
            return this._scissorRect
        },
        set: function(a) {
            this._scissorRect.copy(a)
        }
    });
    Object.defineProperty(pa.prototype, "viewMatrix", {
        get: function() {
            if (this._viewMatDirty) {
                var a =
                    this._node.getWorldTransform();
                this._viewMat.copy(a).invert();
                this._viewMatDirty = !1
            }
            return this._viewMat
        }
    });
    Object.defineProperty(pa.prototype, "vrDisplay", {
        get: function() {
            return this._vrDisplay
        },
        set: function(a) {
            if (this._vrDisplay = a) a._camera = this
        }
    });
    Object.assign(pa.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.aspectRatio = a.aspectRatio;
            this.aspectRatioMode = a.aspectRatioMode;
            this.calculateProjection = a.calculateProjection;
            this.calculateTransform = a.calculateTransform;
            this.clearColor = a.clearColor;
            this.clearColorBuffer = a.clearColorBuffer;
            this.clearDepth = a.clearDepth;
            this.clearDepthBuffer = a.clearDepthBuffer;
            this.clearStencil = a.clearStencil;
            this.clearStencilBuffer = a.clearStencilBuffer;
            this.cullFaces = a.cullFaces;
            this.cullingMask = a.cullingMask;
            this.farClip = a.farClip;
            this.flipFaces = a.flipFaces;
            this.fov = a.fov;
            this.frustumCulling = a.frustumCulling;
            this.horizontalFov = a.horizontalFov;
            this.layers = a.layers;
            this.nearClip = a.nearClip;
            this.orthoHeight = a.orthoHeight;
            this.projection =
                a.projection;
            this.rect = a.rect;
            this.renderTarget = a.renderTarget;
            this.scissorRect = a.scissorRect;
            this.vrDisplay = a.vrDisplay
        },
        _updateViewProjMat: function() {
            if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix), this._viewProjMatDirty = !1
        },
        worldToScreen: function(a, b, c, d) {
            void 0 === d && (d = new z);
            this._updateViewProjMat();
            this._viewProjMat.transformPoint(a, d);
            var e = this._viewProjMat.data;
            a = a.x * e[3] + a.y * e[7] + a.z * e[11] + 1 * e[15];
            d.x = .5 * (d.x /
                a + 1) * b;
            d.y = .5 * (1 - d.y / a) * c;
            return d
        },
        screenToWorld: function(a, b, c, d, e, f) {
            void 0 === f && (f = new z);
            We.set(a / d, (e - b) / e, c / (this._farClip - this._nearClip));
            We.scale(2);
            We.sub(z.ONE);
            0 === this._projection ? (J._getPerspectiveHalfSize(ge, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov), ge.x *= We.x, ge.y *= We.y, a = this._node.getWorldTransform(), ge.z = -this._nearClip, a.transformPoint(ge, cm), a = this._node.getPosition(), f.sub2(cm, a), f.normalize(), f.scale(c), f.add(a)) : (this._updateViewProjMat(), dm.copy(this._viewProjMat).invert(),
                dm.transformPoint(We, f));
            return f
        },
        _evaluateProjectionMatrix: function() {
            if (this._projMatDirty) {
                if (0 === this._projection) this._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov), this._projMatSkybox.copy(this._projMat);
                else {
                    var a = this._orthoHeight,
                        b = a * this._aspectRatio;
                    this._projMat.setOrtho(-b, b, -a, a, this._nearClip, this._farClip);
                    this._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip)
                }
                this._projMatDirty = !1
            }
        },
        getProjectionMatrixSkybox: function() {
            this._evaluateProjectionMatrix();
            return this._projMatSkybox
        }
    });
    var em = new J,
        Wj = new z,
        fm = new Y,
        Xj = new Y,
        gm = new z,
        hm = new z,
        gp = new J,
        hp = new Y;
    Z.prototype = Object.create(M.prototype);
    Z.prototype.constructor = Z;
    Object.defineProperty(Z.prototype, "right", {
        get: function() {
            this._right || (this._right = new z);
            return this.getWorldTransform().getX(this._right).normalize()
        }
    });
    Object.defineProperty(Z.prototype, "up", {
        get: function() {
            this._up || (this._up = new z);
            return this.getWorldTransform().getY(this._up).normalize()
        }
    });
    Object.defineProperty(Z.prototype,
        "forward", {
            get: function() {
                this._forward || (this._forward = new z);
                return this.getWorldTransform().getZ(this._forward).normalize().scale(-1)
            }
        });
    Object.defineProperty(Z.prototype, "enabled", {
        get: function() {
            return this._enabled && this._enabledInHierarchy
        },
        set: function(a) {
            this._enabled !== a && (this._enabled = a, this._parent && !this._parent.enabled || this._notifyHierarchyStateChanged(this, a))
        }
    });
    Object.defineProperty(Z.prototype, "parent", {
        get: function() {
            return this._parent
        }
    });
    Object.defineProperty(Z.prototype, "path", {
        get: function() {
            var a = this._parent;
            if (a) {
                for (var b = this.name; a && a._parent;) b = a.name + "/" + b, a = a._parent;
                return b
            }
            return ""
        }
    });
    Object.defineProperty(Z.prototype, "root", {
        get: function() {
            var a = this._parent;
            if (!a) return this;
            for (; a._parent;) a = a._parent;
            return a
        }
    });
    Object.defineProperty(Z.prototype, "children", {
        get: function() {
            return this._children
        }
    });
    Object.defineProperty(Z.prototype, "graphDepth", {
        get: function() {
            return this._graphDepth
        }
    });
    Object.assign(Z.prototype, {
        _notifyHierarchyStateChanged: function(a, b) {
            a._onHierarchyStateChanged(b);
            a = a._children;
            for (var c = 0, d = a.length; c < d; c++) a[c]._enabled && this._notifyHierarchyStateChanged(a[c], b)
        },
        _onHierarchyStateChanged: function(a) {
            (this._enabledInHierarchy = a) && !this._frozen && this._unfreezeParentToRoot()
        },
        _cloneInternal: function(a) {
            a.name = this.name;
            for (var b = this.tags._list, c = 0; c < b.length; c++) a.tags.add(b[c]);
            a._labels = Object.assign({}, this._labels);
            a.localPosition.copy(this.localPosition);
            a.localRotation.copy(this.localRotation);
            a.localScale.copy(this.localScale);
            a.localEulerAngles.copy(this.localEulerAngles);
            a.position.copy(this.position);
            a.rotation.copy(this.rotation);
            a.eulerAngles.copy(this.eulerAngles);
            a.localTransform.copy(this.localTransform);
            a._dirtyLocal = this._dirtyLocal;
            a.worldTransform.copy(this.worldTransform);
            a._dirtyWorld = this._dirtyWorld;
            a._dirtyNormal = this._dirtyNormal;
            a._aabbVer = this._aabbVer + 1;
            a._enabled = this._enabled;
            a.scaleCompensation = this.scaleCompensation;
            a._enabledInHierarchy = !1
        },
        clone: function() {
            var a = new Z;
            this._cloneInternal(a);
            return a
        },
        find: function(a, b) {
            var c = [],
                d = this._children.length,
                e;
            if (a instanceof Function)
                for ((b = a(this)) && c.push(this), e = 0; e < d; e++) {
                    var f = this._children[e].find(a);
                    f.length && (c = c.concat(f))
                } else
                    for (this[a] && (e = this[a] instanceof Function ? this[a]() : this[a], e === b && c.push(this)), e = 0; e < d; ++e) f = this._children[e].find(a, b), f.length && (c = c.concat(f));
            return c
        },
        findOne: function(a, b) {
            var c, d = this._children.length,
                e;
            if (a instanceof Function) {
                if (e = a(this)) return this;
                for (c = 0; c < d; c++)
                    if (e = this._children[c].findOne(a)) return e
            } else {
                if (this[a] && (c = this[a] instanceof Function ?
                        this[a]() : this[a], c === b)) return this;
                for (c = 0; c < d; c++)
                    if (e = this._children[c].findOne(a, b), null !== e) return e
            }
            return null
        },
        findByTag: function() {
            var a = this.tags._processArguments(arguments);
            return this._findByTag(a)
        },
        _findByTag: function(a) {
            var b = [],
                c, d = this._children.length;
            for (c = 0; c < d; c++) {
                this._children[c].tags._has(a) && b.push(this._children[c]);
                var e = this._children[c]._findByTag(a);
                e.length && (b = b.concat(e))
            }
            return b
        },
        findByName: function(a) {
            if (this.name === a) return this;
            for (var b = 0; b < this._children.length; b++) {
                var c =
                    this._children[b].findByName(a);
                if (null !== c) return c
            }
            return null
        },
        findByPath: function(a) {
            a = a.split("/");
            for (var b = this, c = null, d = 0, e = a.length; d < e && b; d++) {
                var f = a[d];
                c = null;
                b = b._children;
                for (var g = 0, k = b.length; g < k; g++)
                    if (b[g].name == f) {
                        c = b[g];
                        break
                    }
                b = c
            }
            return c
        },
        forEach: function(a, b) {
            a.call(b, this);
            for (var c = this._children, d = 0; d < c.length; d++) c[d].forEach(a, b)
        },
        isDescendantOf: function(a) {
            for (var b = this._parent; b;) {
                if (b === a) return !0;
                b = b._parent
            }
            return !1
        },
        isAncestorOf: function(a) {
            return a.isDescendantOf(this)
        },
        getEulerAngles: function() {
            this.getWorldTransform().getEulerAngles(this.eulerAngles);
            return this.eulerAngles
        },
        getLocalEulerAngles: function() {
            this.localRotation.getEulerAngles(this.localEulerAngles);
            return this.localEulerAngles
        },
        getLocalPosition: function() {
            return this.localPosition
        },
        getLocalRotation: function() {
            return this.localRotation
        },
        getLocalScale: function() {
            return this.localScale
        },
        getLocalTransform: function() {
            this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale),
                this._dirtyLocal = !1);
            return this.localTransform
        },
        getPosition: function() {
            this.getWorldTransform().getTranslation(this.position);
            return this.position
        },
        getRotation: function() {
            this.rotation.setFromMat4(this.getWorldTransform());
            return this.rotation
        },
        getScale: function() {
            this._scale || (this._scale = new z);
            return this.getWorldTransform().getScale(this._scale)
        },
        getWorldTransform: function() {
            if (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;
            this._parent && this._parent.getWorldTransform();
            this._sync();
            return this.worldTransform
        },
        reparent: function(a, b) {
            var c = this._parent;
            c && c.removeChild(this);
            a && (0 <= b ? a.insertChild(this, b) : a.addChild(this))
        },
        setLocalEulerAngles: function(a, b, c) {
            a instanceof z ? this.localRotation.setFromEulerAngles(a.x, a.y, a.z) : this.localRotation.setFromEulerAngles(a, b, c);
            this._dirtyLocal || this._dirtifyLocal()
        },
        setLocalPosition: function(a, b, c) {
            a instanceof z ? this.localPosition.copy(a) : this.localPosition.set(a, b, c);
            this._dirtyLocal || this._dirtifyLocal()
        },
        setLocalRotation: function(a,
            b, c, d) {
            a instanceof Y ? this.localRotation.copy(a) : this.localRotation.set(a, b, c, d);
            this._dirtyLocal || this._dirtifyLocal()
        },
        setLocalScale: function(a, b, c) {
            a instanceof z ? this.localScale.copy(a) : this.localScale.set(a, b, c);
            this._dirtyLocal || this._dirtifyLocal()
        },
        _dirtifyLocal: function() {
            this._dirtyLocal || (this._dirtyLocal = !0, this._dirtyWorld || this._dirtifyWorld())
        },
        _unfreezeParentToRoot: function() {
            for (var a = this._parent; a;) a._frozen = !1, a = a._parent
        },
        _dirtifyWorld: function() {
            this._dirtyWorld || this._unfreezeParentToRoot();
            this._dirtifyWorldInternal()
        },
        _dirtifyWorldInternal: function() {
            if (!this._dirtyWorld) {
                this._frozen = !1;
                this._dirtyWorld = !0;
                for (var a = 0; a < this._children.length; a++) this._children[a]._dirtyWorld || this._children[a]._dirtifyWorldInternal()
            }
            this._dirtyNormal = !0;
            this._aabbVer++
        },
        setPosition: function() {
            var a = new z,
                b = new J;
            return function(c, d, e) {
                c instanceof z ? a.copy(c) : a.set(c, d, e);
                null === this._parent ? this.localPosition.copy(a) : (b.copy(this._parent.getWorldTransform()).invert(), b.transformPoint(a, this.localPosition));
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        setRotation: function() {
            var a = new Y,
                b = new Y;
            return function(c, d, e, f) {
                c instanceof Y ? a.copy(c) : a.set(c, d, e, f);
                null === this._parent ? this.localRotation.copy(a) : (c = this._parent.getRotation(), b.copy(c).invert(), this.localRotation.copy(b).mul(a));
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        setEulerAngles: function() {
            var a = new Y;
            return function(b, c, d) {
                b instanceof z ? this.localRotation.setFromEulerAngles(b.x, b.y, b.z) : this.localRotation.setFromEulerAngles(b, c, d);
                null !==
                    this._parent && (b = this._parent.getRotation(), a.copy(b).invert(), this.localRotation.mul2(a, this.localRotation));
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        addChild: function(a) {
            if (null !== a._parent) throw Error("GraphNode is already parented");
            this._children.push(a);
            this._onInsertChild(a)
        },
        addChildAndSaveTransform: function(a) {
            var b = a.getPosition(),
                c = a.getRotation(),
                d = a._parent;
            d && d.removeChild(a);
            a.setPosition(gp.copy(this.worldTransform).invert().transformPoint(b));
            a.setRotation(hp.copy(this.getRotation()).invert().mul(c));
            this._children.push(a);
            this._onInsertChild(a)
        },
        insertChild: function(a, b) {
            if (null !== a._parent) throw Error("GraphNode is already parented");
            this._children.splice(b, 0, a);
            this._onInsertChild(a)
        },
        _onInsertChild: function(a) {
            a._parent = this;
            var b = a._enabled && this.enabled;
            a._enabledInHierarchy !== b && (a._enabledInHierarchy = b, a._notifyHierarchyStateChanged(a, b));
            a._updateGraphDepth();
            a._dirtifyWorld();
            this._frozen && a._unfreezeParentToRoot();
            a.fire && a.fire("insert", this);
            this.fire && this.fire("childinsert", a)
        },
        _updateGraphDepth: function() {
            this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
            for (var a = 0, b = this._children.length; a < b; a++) this._children[a]._updateGraphDepth()
        },
        removeChild: function(a) {
            var b, c = this._children.length;
            for (b = 0; b < c; ++b)
                if (this._children[b] === a) {
                    this._children.splice(b, 1);
                    a._parent = null;
                    a.fire && a.fire("remove", this);
                    this.fire && this.fire("childremove", a);
                    break
                }
        },
        _sync: function() {
            this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale),
                this._dirtyLocal = !1);
            if (this._dirtyWorld) {
                if (null === this._parent) this.worldTransform.copy(this.localTransform);
                else if (this.scaleCompensation) {
                    var a = this._parent,
                        b = this.localScale,
                        c = a;
                    if (c) {
                        for (; c && c.scaleCompensation;) c = c._parent;
                        if (c && (c = c._parent)) {
                            var d = c.worldTransform.getScale();
                            gm.mul2(d, this.localScale);
                            b = gm
                        }
                    }
                    Xj.setFromMat4(a.worldTransform);
                    fm.mul2(Xj, this.localRotation);
                    c = a.worldTransform;
                    a.scaleCompensation && (hm.mul2(d, a.getLocalScale()), em.setTRS(a.worldTransform.getTranslation(Wj), Xj,
                        hm), c = em);
                    c.transformPoint(this.localPosition, Wj);
                    this.worldTransform.setTRS(Wj, fm, b)
                } else this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
                this._dirtyWorld = !1
            }
        },
        syncHierarchy: function() {
            if (this._enabled && !this._frozen) {
                this._frozen = !0;
                (this._dirtyLocal || this._dirtyWorld) && this._sync();
                for (var a = this._children, b = 0, c = a.length; b < c; b++) a[b].syncHierarchy()
            }
        },
        lookAt: function() {
            var a = new J,
                b = new z,
                c = new z,
                d = new Y;
            return function(e, f, g, k, h, l) {
                if (e instanceof z) b.copy(e), f instanceof
                z ? c.copy(f) : c.copy(z.UP);
                else {
                    if (void 0 === g) return;
                    b.set(e, f, g);
                    void 0 !== k ? c.set(k, h, l) : c.copy(z.UP)
                }
                a.setLookAt(this.getPosition(), b, c);
                d.setFromMat4(a);
                this.setRotation(d)
            }
        }(),
        translate: function() {
            var a = new z;
            return function(b, c, d) {
                b instanceof z ? a.copy(b) : a.set(b, c, d);
                a.add(this.getPosition());
                this.setPosition(a)
            }
        }(),
        translateLocal: function() {
            var a = new z;
            return function(b, c, d) {
                b instanceof z ? a.copy(b) : a.set(b, c, d);
                this.localRotation.transformVector(a, a);
                this.localPosition.add(a);
                this._dirtyLocal ||
                    this._dirtifyLocal()
            }
        }(),
        rotate: function() {
            var a = new Y,
                b = new Y;
            return function(c, d, e) {
                c instanceof z ? a.setFromEulerAngles(c.x, c.y, c.z) : a.setFromEulerAngles(c, d, e);
                null === this._parent ? this.localRotation.mul2(a, this.localRotation) : (c = this.getRotation(), d = this._parent.getRotation(), b.copy(d).invert(), a.mul2(b, a), this.localRotation.mul2(a, c));
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        rotateLocal: function() {
            var a = new Y;
            return function(b, c, d) {
                b instanceof z ? a.setFromEulerAngles(b.x, b.y, b.z) : a.setFromEulerAngles(b,
                    c, d);
                this.localRotation.mul(a);
                this._dirtyLocal || this._dirtifyLocal()
            }
        }()
    });
    var Yj, Zj, th, uh, ip = [null, function(a, b) {
            return a.drawOrder - b.drawOrder
        }, function(a, b) {
            Yj = a._key[0];
            Zj = b._key[0];
            return Yj === Zj && a.mesh && b.mesh ? b.mesh.id - a.mesh.id : Zj - Yj
        }, function(a, b) {
            return b.zdist - a.zdist
        }, function(a, b) {
            return a.zdist - b.zdist
        }],
        mi = 0;
    Ik.prototype.clearVisibleLists = function(a) {
        this.visibleOpaque[a] && (this.visibleOpaque[a].length = 0, this.visibleOpaque[a].list.length = 0);
        this.visibleTransparent[a] && (this.visibleTransparent[a].length =
            0, this.visibleTransparent[a].list.length = 0)
    };
    Object.defineProperty(ka.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            if (a !== this._enabled)
                if (this._enabled = a) {
                    if (this.incrementCounter(), this.onEnable) this.onEnable()
                } else if (this.decrementCounter(), this.onDisable) this.onDisable()
        }
    });
    Object.defineProperty(ka.prototype, "clearColor", {
        get: function() {
            return this._clearColor
        },
        set: function(a) {
            this._clearColor.copy(a)
        }
    });
    ka.prototype._updateClearFlags = function() {
        var a = 0;
        this._clearColorBuffer &&
            (a |= 1);
        this._clearDepthBuffer && (a |= 2);
        this._clearStencilBuffer && (a |= 4);
        this._clearOptions.flags = a
    };
    Object.defineProperty(ka.prototype, "clearColorBuffer", {
        get: function() {
            return this._clearColorBuffer
        },
        set: function(a) {
            this._clearColorBuffer = a;
            this._updateClearFlags()
        }
    });
    Object.defineProperty(ka.prototype, "clearDepthBuffer", {
        get: function() {
            return this._clearDepthBuffer
        },
        set: function(a) {
            this._clearDepthBuffer = a;
            this._updateClearFlags()
        }
    });
    Object.defineProperty(ka.prototype, "clearStencilBuffer", {
        get: function() {
            return this._clearStencilBuffer
        },
        set: function(a) {
            this._clearStencilBuffer = a;
            this._updateClearFlags()
        }
    });
    ka.prototype.incrementCounter = function() {
        if (0 === this._refCounter && (this._enabled = !0, this.onEnable)) this.onEnable();
        this._refCounter++
    };
    ka.prototype.decrementCounter = function() {
        if (1 === this._refCounter) {
            if (this._enabled = !1, this.onDisable) this.onDisable()
        } else if (0 === this._refCounter) return;
        this._refCounter--
    };
    ka.prototype.addMeshInstances = function(a, b) {
        for (var c = this._shaderVersion, d, e, f, g = this.shadowCasters, k = 0; k < a.length; k++) d =
            a[k], f = d.material, e = 3 === f.blendType ? this.opaqueMeshInstances : this.transparentMeshInstances, 0 > this.opaqueMeshInstances.indexOf(d) && 0 > this.transparentMeshInstances.indexOf(d) && e.push(d), !b && d.castShadow && 0 > g.indexOf(d) && g.push(d), !this.passThrough && 0 <= c && f._shaderVersion !== c && (f.updateShader !== la.prototype.updateShader && (f.clearVariants(), f.shader = null), f._shaderVersion = c);
        this.passThrough || (this._dirty = !0)
    };
    ka.prototype.removeMeshInstanceFromArray = function(a, b) {
        for (var c, d = -1, e = 0, f = b.length, g = 0; g <
            f; g++) {
            c = b[g];
            if (c === a) {
                d = g;
                e = 1;
                break
            }
            if (c._staticSource === a) 0 > d && (d = g), e++;
            else if (0 <= d) break
        }
        0 <= d && b.splice(d, e)
    };
    ka.prototype.removeMeshInstances = function(a, b) {
        for (var c, d = this.opaqueMeshInstances, e = this.transparentMeshInstances, f = this.shadowCasters, g = 0; g < a.length; g++) c = a[g], this.removeMeshInstanceFromArray(c, d), this.removeMeshInstanceFromArray(c, e), b || (c = f.indexOf(c), 0 <= c && f.splice(c, 1));
        this._dirty = !0
    };
    ka.prototype.clearMeshInstances = function(a) {
        if (0 !== this.opaqueMeshInstances.length || 0 !== this.transparentMeshInstances.length ||
            !a && 0 !== this.shadowCasters.length) this.opaqueMeshInstances.length = 0, this.transparentMeshInstances.length = 0, a || (this.shadowCasters.length = 0), this.passThrough || (this._dirty = !0)
    };
    ka.prototype.addLight = function(a) {
        0 <= this._lightComponents.indexOf(a) || (this._lightComponents.push(a), this._lights.push(a.light), this._dirtyLights = !0, this._generateLightHash())
    };
    ka.prototype.removeLight = function(a) {
        var b = this._lightComponents.indexOf(a);
        0 > b || (this._lightComponents.splice(b, 1), b = this._lights.indexOf(a.light),
            this._lights.splice(b, 1), this._dirtyLights = !0, this._generateLightHash())
    };
    ka.prototype.clearLights = function() {
        this._lightComponents.length = 0;
        this._lights.length = 0;
        this._dirtyLights = !0
    };
    ka.prototype.addShadowCasters = function(a) {
        for (var b, c = this.shadowCasters, d = 0; d < a.length; d++) b = a[d], b.castShadow && 0 > c.indexOf(b) && c.push(b);
        this._dirtyLights = !0
    };
    ka.prototype.removeShadowCasters = function(a) {
        for (var b, c = this.shadowCasters, d = 0; d < a.length; d++) b = c.indexOf(a[d]), 0 <= b && c.splice(b, 1);
        this._dirtyLights = !0
    };
    ka.prototype._generateLightHash = function() {
        if (0 < this._lights.length) {
            this._lights.sort(Un);
            for (var a = "", b = "", c = 0; c < this._lights.length; c++) this._lights[c].isStatic ? b += this._lights[c].key : a += this._lights[c].key;
            this._lightHash = 0 === a.length ? 0 : se(a);
            this._staticLightHash = 0 === b.length ? 0 : se(b)
        } else this._staticLightHash = this._lightHash = 0
    };
    ka.prototype._generateCameraHash = function() {
        if (1 < this.cameras.length) {
            this.cameras.sort(Tn);
            for (var a = "", b = 0; b < this.cameras.length; b++) a += this.cameras[b].entity.getGuid();
            this._cameraHash = se(a)
        } else this._cameraHash = 0;
        this._dirtyCameras = !0
    };
    ka.prototype.addCamera = function(a) {
        0 <= this.cameras.indexOf(a) || (this.cameras.push(a), this._generateCameraHash())
    };
    ka.prototype.removeCamera = function(a) {
        a = this.cameras.indexOf(a);
        0 > a || (this.cameras.splice(a, 1), this._generateCameraHash(), this.instances.clearVisibleLists(a))
    };
    ka.prototype.clearCameras = function() {
        this._cameraHash = this.cameras.length = 0;
        this._dirtyCameras = !0
    };
    ka.prototype._sortCameras = function() {
        this._generateCameraHash()
    };
    ka.prototype._calculateSortDistances = function(a, b, c, d) {
        var e;
        for (e = 0; e < b; e++) {
            var f = a[e];
            if (!(f.command || 2 >= f.layer))
                if (f.calculateSortDistance) f.zdist = f.calculateSortDistance(f, c, d);
                else {
                    var g = f.aabb.center;
                    var k = g.x - c.x;
                    var h = g.y - c.y;
                    g = g.z - c.z;
                    f.zdist = k * d.x + h * d.y + g * d.z
                }
        }
    };
    ka.prototype._sortVisible = function(a, b, c) {
        var d = this.instances,
            e = a ? this.transparentSortMode : this.opaqueSortMode;
        if (0 !== e)
            if (a = a ? d.visibleTransparent[c] : d.visibleOpaque[c], 5 === e) th = b.getPosition(), uh = b.forward, this.customCalculateSortValues &&
                this.customCalculateSortValues(a.list, a.length, th, uh), a.list.length !== a.length && (a.list.length = a.length), this.customSortCallback && a.list.sort(this.customSortCallback);
            else {
                if (3 === e || 4 === e) th = b.getPosition(), uh = b.forward, this._calculateSortDistances(a.list, a.length, th, uh);
                a.list.length !== a.length && (a.list.length = a.length);
                a.list.sort(ip[e])
            }
    };
    for (var im = (new J).mul2((new J).setTranslate(.5, .5, .5), (new J).setScale(.5, .5, .5)), jp = {
                r: 1,
                g: 2,
                b: 3,
                a: 4
            }, jm = [(new Y).setFromEulerAngles(0, 90, 180), (new Y).setFromEulerAngles(0, -90, 180), (new Y).setFromEulerAngles(90, 0, 0), (new Y).setFromEulerAngles(-90, 0, 0), (new Y).setFromEulerAngles(0, 180, 180), (new Y).setFromEulerAngles(0, 0, 180)], Mk = [{}, {}, {}, {}, {}], he = new Float32Array(2), Wf = {
                x: 1,
                y: 1,
                z: 0,
                w: 0
            }, ie = new J, vh = new J, km = new J, Xb = new J, Bb = new J, lm = new rb, nc = new J, Yb, Qc = new J, Rc = new J, Xe = new J, Ye = new J, Ze = new z, $e = new z, Xf, Yf, mm = new J, nm = new J, om = new J, pm = new J, vd = new z, wh = new z, xh = new z, qm = new z, je = {
                center: null,
                radius: 0
            }, yh = new oa, Zf = [0, 0, 0, 0], af, Mb, ak, zh, Ok = {}, bf, cf, Ah = null, bk =
            0, ua = [], rm = 0; 8 > rm; rm++) ua.push(new z);
    var za = [new z, new z, new z, new z, new z, new z, new z, new z];
    Object.assign(Ag.prototype, {
        sortCompare: function(a, b) {
            if (a.layer === b.layer) {
                if (a.drawOrder && b.drawOrder) return a.drawOrder - b.drawOrder;
                if (a.zdist && b.zdist) return b.zdist - a.zdist;
                if (a.zdist2 && b.zdist2) return a.zdist2 - b.zdist2
            }
            return b._key[0] - a._key[0]
        },
        sortCompareMesh: function(a, b) {
            if (a.layer === b.layer) {
                if (a.drawOrder && b.drawOrder) return a.drawOrder - b.drawOrder;
                if (a.zdist && b.zdist) return b.zdist - a.zdist
            }
            bf =
                a._key[0];
            cf = b._key[0];
            return bf === cf && a.mesh && b.mesh ? b.mesh.id - a.mesh.id : cf - bf
        },
        depthSortCompare: function(a, b) {
            bf = a._key[1];
            cf = b._key[1];
            return bf === cf && a.mesh && b.mesh ? b.mesh.id - a.mesh.id : cf - bf
        },
        lightCompare: function(a, b) {
            return a.key - b.key
        },
        getShadowCamera: function(a, b) {
            var c = b._shadowCamera;
            if (null === c) {
                c = b._shadowType;
                var d = 4 === c || 0 === c && a.webgl2;
                1 === b._type && (d = !1);
                var e = new pa;
                e.clearColor = 1 <= c && 3 >= c ? new L(0, 0, 0, 0) : new L(1, 1, 1, 1);
                e.clearColorBuffer = !d;
                e.clearDepthBuffer = !0;
                e.clearStencilBuffer = !1;
                e.node = new Z;
                c = b._shadowCamera = e;
                Nk(a, b)
            } else d = c.renderTarget, d.width === b._shadowResolution && d.height === b._shadowResolution || Nk(a, b);
            return c
        },
        updateCameraFrustum: function(a) {
            if (a.vrDisplay && a.vrDisplay.presenting) {
                Yb = a.vrDisplay.combinedProj;
                var b = a._node.parent;
                b ? Bb.copy(b.getWorldTransform()).mul(a.vrDisplay.combinedViewInv).invert() : Bb.copy(a.vrDisplay.combinedView);
                Xb.copy(Bb).invert();
                this.viewInvId.setValue(Xb.data);
                nc.mul2(Yb, Bb);
                a.frustum.setFromMat4(nc)
            } else if (a.xr && a.xr.views.length) {
                b =
                    a.xr.views[0];
                nc.mul2(b.projMat, b.viewOffMat);
                a.frustum.setFromMat4(nc);
                return
            }
            Yb = a.projectionMatrix;
            a.calculateProjection && a.calculateProjection(Yb, 0);
            if (a.calculateTransform) a.calculateTransform(Xb, 0);
            else {
                b = a._node.getPosition();
                var c = a._node.getRotation();
                Xb.setTRS(b, c, z.ONE);
                this.viewInvId.setValue(Xb.data)
            }
            Bb.copy(Xb).invert();
            nc.mul2(Yb, Bb);
            a.frustum.setFromMat4(nc)
        },
        setCamera: function(a, b, c, d) {
            var e = a.vrDisplay,
                f;
            if (e && e.presenting) {
                Xf = e.leftProj;
                Yf = e.rightProj;
                Yb = e.combinedProj;
                a.calculateProjection &&
                    (a.calculateProjection(Xf, 1), a.calculateProjection(Yf, 2), a.calculateProjection(Yb, 0));
                if (a.calculateTransform) a.calculateTransform(Qc, 1), a.calculateTransform(Rc, 2), a.calculateTransform(Xb, 0), Xe.copy(Qc).invert(), Ye.copy(Rc).invert(), Bb.copy(Xb).invert();
                else if (f = a._node.parent) {
                    var g = f.getWorldTransform();
                    Qc.mul2(g, e.leftViewInv);
                    Rc.mul2(g, e.rightViewInv);
                    Xe.copy(Qc).invert();
                    Ye.copy(Rc).invert();
                    Bb.copy(f.getWorldTransform()).mul(e.combinedViewInv).invert()
                } else Qc.copy(e.leftViewInv), Rc.copy(e.rightViewInv),
                    Xe.copy(e.leftView), Ye.copy(e.rightView), Bb.copy(e.combinedView);
                Bg(mm, Xe);
                Bg(nm, Ye);
                om.mul2(Xf, Xe);
                pm.mul2(Yf, Ye);
                Ze.x = Qc.data[12];
                Ze.y = Qc.data[13];
                Ze.z = Qc.data[14];
                $e.x = Rc.data[12];
                $e.y = Rc.data[13];
                $e.z = Rc.data[14];
                nc.mul2(Yb, Bb);
                a.frustum.setFromMat4(nc)
            } else if (a.xr && a.xr.session) {
                (f = a._node.parent) && (g = f.getWorldTransform());
                e = a.xr.views;
                for (var k = 0; k < e.length; k++) {
                    var h = e[k];
                    f ? (h.viewInvOffMat.mul2(g, h.viewInvMat), h.viewOffMat.copy(h.viewInvOffMat).invert()) : (h.viewInvOffMat.copy(h.viewInvMat),
                        h.viewOffMat.copy(h.viewMat));
                    Bg(h.viewMat3, h.viewOffMat);
                    h.projViewOffMat.mul2(h.projMat, h.viewOffMat);
                    h.position[0] = h.viewInvOffMat.data[12];
                    h.position[1] = h.viewInvOffMat.data[13];
                    h.position[2] = h.viewInvOffMat.data[14];
                    a.frustum.setFromMat4(h.projViewOffMat)
                }
            } else Yb = a.projectionMatrix, a.calculateProjection && a.calculateProjection(Yb, 0), this.projId.setValue(Yb.data), this.projSkyboxId.setValue(a.getProjectionMatrixSkybox().data), a.calculateTransform ? a.calculateTransform(Xb, 0) : (f = a._node.getPosition(),
                g = a._node.getRotation(), Xb.setTRS(f, g, z.ONE)), this.viewInvId.setValue(Xb.data), Bb.copy(Xb).invert(), this.viewId.setValue(Bb.data), Bg(lm, Bb), this.viewId3.setValue(lm.data), nc.mul2(Yb, Bb), this.viewProjId.setValue(nc.data), f = a._node.getPosition(), this.viewPos[0] = f.x, this.viewPos[1] = f.y, this.viewPos[2] = f.z, this.viewPosId.setValue(this.viewPos), a.frustum.setFromMat4(nc);
            this.nearClipId.setValue(a._nearClip);
            this.farClipId.setValue(a._farClip);
            f = a._nearClip;
            g = a._farClip;
            this.cameraParams[0] = 1 / g;
            this.cameraParams[1] =
                g;
            this.cameraParams[2] = .5 * (1 - g / f);
            this.cameraParams[3] = .5 * (1 + g / f);
            this.cameraParamsId.setValue(this.cameraParams);
            this.clearView(a, b, c, !1);
            c = this.device;
            f = b ? b.width : c.width;
            b = b ? b.height : c.height;
            a = a.scissorRect;
            c.setScissor(Math.floor(a.x * f), Math.floor(a.y * b), Math.floor(a.z * f), Math.floor(a.w * b));
            d && c.setScissor(1, 1, f - 2, b - 2)
        },
        clearView: function(a, b, c, d, e) {
            var f = this.device;
            f.setRenderTarget(b);
            f.updateBegin();
            d && (f.setColorWrite(!0, !0, !0, !0), f.setDepthWrite(!0));
            d = a.rect;
            var g = b ? b.width : f.width,
                k =
                b ? b.height : f.height;
            b = Math.floor(d.x * g);
            var h = Math.floor(d.y * k);
            g = Math.floor(d.z * g);
            d = Math.floor(d.w * k);
            f.setViewport(b, h, g, d);
            f.setScissor(b, h, g, d);
            c && (e || (e = a._clearOptions), f.clear(e ? e : {
                color: [a._clearColor.r, a._clearColor.g, a._clearColor.b, a._clearColor.a],
                depth: a._clearDepth,
                flags: (a._clearColorBuffer ? 1 : 0) | (a._clearDepthBuffer ? 2 : 0) | (a._clearStencilBuffer ? 4 : 0),
                stencil: a._clearStencil
            }))
        },
        dispatchGlobalLights: function(a) {
            var b;
            this.mainLight = -1;
            this.ambientColor[0] = a.ambientLight.r;
            this.ambientColor[1] =
                a.ambientLight.g;
            this.ambientColor[2] = a.ambientLight.b;
            if (a.gammaCorrection)
                for (b = 0; 3 > b; b++) this.ambientColor[b] = Math.pow(this.ambientColor[b], 2.2);
            this.ambientId.setValue(this.ambientColor);
            this.exposureId.setValue(a.exposure);
            a.skyboxModel && this.skyboxIntensityId.setValue(a.skyboxIntensity)
        },
        _resolveLight: function(a, b) {
            var c = "light" + b;
            this.lightColorId[b] = a.resolve(c + "_color");
            this.lightDir[b] = new Float32Array(3);
            this.lightDirId[b] = a.resolve(c + "_direction");
            this.lightShadowMapId[b] = a.resolve(c +
                "_shadowMap");
            this.lightShadowMatrixId[b] = a.resolve(c + "_shadowMatrix");
            this.lightShadowParamsId[b] = a.resolve(c + "_shadowParams");
            this.lightShadowMatrixVsId[b] = a.resolve(c + "_shadowMatrixVS");
            this.lightShadowParamsVsId[b] = a.resolve(c + "_shadowParamsVS");
            this.lightDirVs[b] = new Float32Array(3);
            this.lightDirVsId[b] = a.resolve(c + "_directionVS");
            this.lightRadiusId[b] = a.resolve(c + "_radius");
            this.lightPos[b] = new Float32Array(3);
            this.lightPosId[b] = a.resolve(c + "_position");
            this.lightInAngleId[b] = a.resolve(c + "_innerConeAngle");
            this.lightOutAngleId[b] = a.resolve(c + "_outerConeAngle");
            this.lightPosVsId[b] = a.resolve(c + "_positionVS");
            this.lightCookieId[b] = a.resolve(c + "_cookie");
            this.lightCookieIntId[b] = a.resolve(c + "_cookieIntensity");
            this.lightCookieMatrixId[b] = a.resolve(c + "_cookieMatrix");
            this.lightCookieOffsetId[b] = a.resolve(c + "_cookieOffset")
        },
        dispatchDirectLights: function(a, b, c) {
            var d = a.length,
                e, f = 0;
            this.mainLight = -1;
            var g = this.device.scope;
            for (e = 0; e < d; e++)
                if (a[e].mask & c) {
                    var k = a[e];
                    var h = k._node.getWorldTransform();
                    this.lightColorId[f] ||
                        this._resolveLight(g, f);
                    this.lightColorId[f].setValue(b.gammaCorrection ? k._linearFinalColor : k._finalColor);
                    h.getY(k._direction).scale(-1);
                    k._direction.normalize();
                    this.lightDir[f][0] = k._direction.x;
                    this.lightDir[f][1] = k._direction.y;
                    this.lightDir[f][2] = k._direction.z;
                    this.lightDirId[f].setValue(this.lightDir[f]);
                    if (k.castShadows) {
                        var l = k._isPcf && this.device.webgl2 ? k._shadowCamera.renderTarget.depthBuffer : k._shadowCamera.renderTarget.colorBuffer;
                        k._isVsm ? h = -2E-4 : (h = k.shadowBias / k._shadowCamera._farClip *
                            100, !this.device.webgl2 && this.device.extStandardDerivatives && (h *= -100));
                        var n = k._isVsm ? k.vsmBias / (k._shadowCamera._farClip / 7) : k._normalOffsetBias;
                        this.lightShadowMapId[f].setValue(l);
                        this.lightShadowMatrixId[f].setValue(k._shadowMatrix.data);
                        l = k._rendererParams;
                        3 !== l.length && (l.length = 3);
                        l[0] = k._shadowResolution;
                        l[1] = n;
                        l[2] = h;
                        this.lightShadowParamsId[f].setValue(l);
                        0 > this.mainLight && (this.lightShadowMatrixVsId[f].setValue(k._shadowMatrix.data), this.lightShadowParamsVsId[f].setValue(l), k._direction.normalize(),
                            this.lightDirVs[f][0] = k._direction.x, this.lightDirVs[f][1] = k._direction.y, this.lightDirVs[f][2] = k._direction.z, this.lightDirVsId[f].setValue(this.lightDirVs[f]), this.mainLight = e)
                    }
                    f++
                }
            return f
        },
        dispatchPointLight: function(a, b, c, d) {
            var e = c._node.getWorldTransform();
            this.lightColorId[d] || this._resolveLight(b, d);
            this.lightRadiusId[d].setValue(c.attenuationEnd);
            this.lightColorId[d].setValue(a.gammaCorrection ? c._linearFinalColor : c._finalColor);
            e.getTranslation(c._position);
            this.lightPos[d][0] = c._position.x;
            this.lightPos[d][1] = c._position.y;
            this.lightPos[d][2] = c._position.z;
            this.lightPosId[d].setValue(this.lightPos[d]);
            c.castShadows && (this.lightShadowMapId[d].setValue(c._shadowCamera.renderTarget.colorBuffer), a = c._rendererParams, 4 !== a.length && (a.length = 4), a[0] = c._shadowResolution, a[1] = c._normalOffsetBias, a[2] = c.shadowBias, a[3] = 1 / c.attenuationEnd, this.lightShadowParamsId[d].setValue(a));
            c._cookie && (this.lightCookieId[d].setValue(c._cookie), this.lightShadowMatrixId[d].setValue(e.data), this.lightCookieIntId[d].setValue(c.cookieIntensity))
        },
        dispatchSpotLight: function(a, b, c, d) {
            var e = c._node.getWorldTransform();
            this.lightColorId[d] || this._resolveLight(b, d);
            this.lightInAngleId[d].setValue(c._innerConeAngleCos);
            this.lightOutAngleId[d].setValue(c._outerConeAngleCos);
            this.lightRadiusId[d].setValue(c.attenuationEnd);
            this.lightColorId[d].setValue(a.gammaCorrection ? c._linearFinalColor : c._finalColor);
            e.getTranslation(c._position);
            this.lightPos[d][0] = c._position.x;
            this.lightPos[d][1] = c._position.y;
            this.lightPos[d][2] = c._position.z;
            this.lightPosId[d].setValue(this.lightPos[d]);
            e.getY(c._direction).scale(-1);
            c._direction.normalize();
            this.lightDir[d][0] = c._direction.x;
            this.lightDir[d][1] = c._direction.y;
            this.lightDir[d][2] = c._direction.z;
            this.lightDirId[d].setValue(this.lightDir[d]);
            c.castShadows && (c._isVsm ? a = -2E-4 : (a = 20 * c.shadowBias, !this.device.webgl2 && this.device.extStandardDerivatives && (a *= -100)), b = c._isVsm ? c.vsmBias / (c.attenuationEnd / 7) : c._normalOffsetBias, this.lightShadowMapId[d].setValue(c._isPcf && this.device.webgl2 ? c._shadowCamera.renderTarget.depthBuffer : c._shadowCamera.renderTarget.colorBuffer),
                this.lightShadowMatrixId[d].setValue(c._shadowMatrix.data), e = c._rendererParams, 4 !== e.length && (e.length = 4), e[0] = c._shadowResolution, e[1] = b, e[2] = a, e[3] = 1 / c.attenuationEnd, this.lightShadowParamsId[d].setValue(e));
            c._cookie && (this.lightCookieId[d].setValue(c._cookie), c.castShadows || (a = this.getShadowCamera(this.device, c), b = a._node, b.setPosition(c._node.getPosition()), b.setRotation(c._node.getRotation()), b.rotateLocal(-90, 0, 0), a.projection = 0, a.aspectRatio = 1, a.fov = 2 * c._outerConeAngle, ie.setTRS(b.getPosition(),
                b.getRotation(), z.ONE).invert(), vh.mul2(a.projectionMatrix, ie), c._shadowMatrix.mul2(im, vh)), this.lightShadowMatrixId[d].setValue(c._shadowMatrix.data), this.lightCookieIntId[d].setValue(c.cookieIntensity), c._cookieTransform && (c._cookieTransformUniform[0] = c._cookieTransform.x, c._cookieTransformUniform[1] = c._cookieTransform.y, c._cookieTransformUniform[2] = c._cookieTransform.z, c._cookieTransformUniform[3] = c._cookieTransform.w, this.lightCookieMatrixId[d].setValue(c._cookieTransformUniform), c._cookieOffsetUniform[0] =
                c._cookieOffset.x, c._cookieOffsetUniform[1] = c._cookieOffset.y, this.lightCookieOffsetId[d].setValue(c._cookieOffsetUniform)))
        },
        dispatchLocalLights: function(a, b, c, d, e) {
            var f = a[1];
            a = a[2];
            var g = f.length,
                k = a.length,
                h = d,
                l = this.device.scope;
            for (d = 0; d < g; d++) {
                var n = f[d];
                n.mask & c && !n.isStatic && (this.dispatchPointLight(b, l, n, h), h++)
            }
            f = 0;
            if (e)
                for (n = e[f]; n && 1 === n._type;) this.dispatchPointLight(b, l, n, h), h++, f++, n = e[f];
            for (d = 0; d < k; d++) n = a[d], n.mask & c && !n.isStatic && (this.dispatchSpotLight(b, l, n, h), h++);
            if (e)
                for (n =
                    e[f]; n && 2 === n._type;) this.dispatchSpotLight(b, l, n, h), h++, f++, n = e[f]
        },
        cull: function(a, b, c) {
            var d = 0,
                e, f = b.length,
                g = a.cullingMask || 4294967295;
            if (!a.frustumCulling) {
                for (e = 0; e < f; e++) {
                    var k = b[e];
                    if (k.visible || k.command) k.mask && 0 === (k.mask & g) || (c[d] = k, d++, k.visibleThisFrame = !0)
                }
                return d
            }
            for (e = 0; e < f; e++)
                if (k = b[e], k.command) c[d] = k, d++, k.visibleThisFrame = !0;
                else if (k.visible) {
                var h = !0;
                k.mask && 0 === (k.mask & g) || (k.cull && (h = k._isVisible(a)), h && (c[d] = k, d++, k.visibleThisFrame = !0))
            }
            return d
        },
        cullLights: function(a,
            b) {
            var c;
            for (c = 0; c < b.length; c++) {
                var d = b[c];
                var e = d._type;
                d.castShadows && d.enabled && 0 !== d.shadowUpdateMode && 0 !== e && (d.getBoundingSphere(je), a.frustum.containsSphere(je) && (d.visibleThisFrame = !0))
            }
        },
        updateCpuSkinMatrices: function(a) {
            bk++;
            var b = a.length;
            if (0 !== b) {
                var c, d;
                for (c = 0; c < b; c++)
                    if (d = a[c].skinInstance) d.updateMatrices(a[c].node, bk), d._dirty = !0
            }
        },
        updateGpuSkinMatrices: function(a) {
            var b, c, d = a.length;
            for (b = 0; b < d; b++) a[b].visibleThisFrame && (c = a[b].skinInstance) && c._dirty && (c.updateMatrixPalette(a[b].node,
                bk), c._dirty = !1)
        },
        updateMorphing: function(a) {
            var b, c, d = a.length;
            for (b = 0; b < d; b++)(c = a[b].morphInstance) && c._dirty && a[b].visibleThisFrame && c.update()
        },
        setBaseConstants: function(a, b) {
            a.setCullMode(b.cull);
            b.opacityMap && (this.opacityMapId.setValue(b.opacityMap), this.alphaTestId.setValue(b.alphaTest))
        },
        setSkinning: function(a, b, c) {
            b.skinInstance && (this._skinDrawCalls++, a.supportsBoneTextures ? (af = b.skinInstance.boneTexture, this.boneTextureId.setValue(af), Zf[0] = af.width, Zf[1] = af.height, Zf[2] = 1 / af.width, Zf[3] =
                1 / af.height, this.boneTextureSizeId.setValue(Zf)) : this.poseMatrixId.setValue(b.skinInstance.matrixPalette))
        },
        drawInstance: function(a, b, c, d, e) {
            if (Mb = b.instancingData) {
                if (0 < Mb.count && (this._instancedDrawCalls++, a.setVertexBuffer(Mb.vertexBuffer), a.draw(c.primitive[d], Mb.count), Mb.vertexBuffer === Ah)) return this._removedByInstancing += Mb.count, b.instancingData = null, Mb.count - 1
            } else ak = b.node.worldTransform, this.modelMatrixId.setValue(ak.data), e && (zh = b.node.normalMatrix, b.node._dirtyNormal && (ak.invertTo3x3(zh),
                zh.transpose(), b.node._dirtyNormal = !1), this.normalMatrixId.setValue(zh.data)), a.draw(c.primitive[d]);
            return 0
        },
        drawInstance2: function(a, b, c, d) {
            if (Mb = b.instancingData) {
                if (0 < Mb.count && (this._instancedDrawCalls++, a.draw(c.primitive[d], Mb.count, !0), Mb.vertexBuffer === Ah)) return this._removedByInstancing += Mb.count, b.instancingData = null, Mb.count - 1
            } else a.draw(c.primitive[d], void 0, !0);
            return 0
        },
        renderShadows: function(a, b) {
            var c = this.device,
                d;
            for (d = 0; d < a.length; d++) {
                var e = a[d];
                var f = e._type;
                if (e.castShadows &&
                    e.enabled && (e._shadowCamera || this.getShadowCamera(c, e), 0 !== e.shadowUpdateMode && e.visibleThisFrame)) {
                    var g = this.getShadowCamera(c, e);
                    var k = g._node;
                    var h = 0;
                    var l = 1;
                    if (0 === f) {
                        if (0 > e._visibleLength[b]) continue;
                        h = e._visibleCameraSettings[b];
                        k.setPosition(h.x, h.y, h.z);
                        g.orthoHeight = h.orthoHeight;
                        g.farClip = h.farClip;
                        h = b
                    } else if (2 === f) {
                        var n = k.getPosition();
                        this.viewPos[0] = n.x;
                        this.viewPos[1] = n.y;
                        this.viewPos[2] = n.z;
                        this.viewPosId.setValue(this.viewPos);
                        this.shadowMapLightRadiusId.setValue(e.attenuationEnd)
                    } else 1 ===
                        f && (n = k.getPosition(), this.viewPos[0] = n.x, this.viewPos[1] = n.y, this.viewPos[2] = n.z, this.viewPosId.setValue(this.viewPos), this.shadowMapLightRadiusId.setValue(e.attenuationEnd), l = 6);
                    1 !== f && (ie.setTRS(k.getPosition(), k.getRotation(), z.ONE).invert(), vh.mul2(g.projectionMatrix, ie), e._shadowMatrix.mul2(im, vh));
                    c.webgl2 ? 1 === f ? c.setDepthBias(!1) : (c.setDepthBias(!0), c.setDepthBiasValues(-1E3 * e.shadowBias, -1E3 * e.shadowBias)) : c.extStandardDerivatives && (1 === f ? (this.polygonOffset[0] = 0, this.polygonOffset[1] = 0) :
                        (this.polygonOffset[0] = -1E3 * e.shadowBias, this.polygonOffset[1] = -1E3 * e.shadowBias), this.polygonOffsetId.setValue(this.polygonOffset));
                    1 === e.shadowUpdateMode && (e.shadowUpdateMode = 0);
                    this._shadowMapUpdates += l;
                    c.setBlending(!1);
                    c.setDepthWrite(!0);
                    c.setDepthTest(!0);
                    e._isPcf && c.webgl2 && 1 !== f ? c.setColorWrite(!1, !1, !1, !1) : c.setColorWrite(!0, !0, !0, !0);
                    for (h ? l = h + 1 : h = 0; h < l;) {
                        1 === f && (k.setRotation(jm[h]), g.renderTarget = e._shadowCubeMap[h]);
                        this.setCamera(g, g.renderTarget, !0, 1 !== f);
                        n = e._visibleList[h];
                        var p =
                            e._visibleLength[h];
                        var q = e._shadowType;
                        var r = q + 5 * f;
                        for (q = 0; q < p; q++) {
                            var t = n[q];
                            var u = t.mesh;
                            var x = t.material;
                            this.setBaseConstants(c, x);
                            this.setSkinning(c, t, x);
                            x.dirty && (x.updateUniforms(), x.dirty = !1);
                            x.chunks && (this.setCullMode(!0, !1, t), x.setParameters(c), t.setParameters(c, 8));
                            x = t._shader[3 + r];
                            if (!x) {
                                this.updateShader(t, t._shaderDefs, null, 3 + r);
                                x = t._shader[3 + r];
                                var v = t._key,
                                    w = t.material,
                                    y = t.skinInstance ? 10 : 0,
                                    A = 0;
                                w.opacityMap && (w = w.opacityMapChannel) && (A = jp[w]);
                                v[1] = y + A
                            }
                            c.setShader(x);
                            x = t.renderStyle;
                            this.setVertexBuffers(c, u);
                            this.setMorphing(c, t.morphInstance);
                            c.setIndexBuffer(u.indexBuffer[x]);
                            q += this.drawInstance(c, t, u, x);
                            this._shadowDrawCalls++
                        }
                        h++;
                        0 === f && (e._visibleLength[b] = -1)
                    }
                    if (e._isVsm && (f = e._vsmBlurSize, 1 < f)) {
                        g = g.renderTarget;
                        k = Lk(c, e._shadowResolution, e._shadowType, 1);
                        l = 1 === e._shadowType;
                        h = e.vsmBlurMode;
                        n = (l ? this.blurPackedVsmShader : this.blurVsmShader)[h][f];
                        if (!n) {
                            n = this.blurVsmWeights;
                            x = q = f;
                            25 < x && (x = 25);
                            v = (x - 1) / 6;
                            r = .5 * (x - 1);
                            t = Array(x);
                            for (u = p = 0; u < x; ++u) y = u - r, t[u] = Math.exp(-(y * y) /
                                (2 * v * v)), p += t[u];
                            for (u = 0; u < x; ++u) t[u] /= p;
                            n[q] = t;
                            n = F.fullscreenQuadVS;
                            q = "#define SAMPLES " + f + "\n";
                            q = l ? q + this.blurPackedVsmShaderCode[h] : q + this.blurVsmShaderCode[h];
                            n = Wa(this.device, n, q, "blurVsm" + h + f + l);
                            l ? this.blurPackedVsmShader[h][f] = n : this.blurVsmShader[h][f] = n
                        }
                        Wf.z = e._shadowResolution - 2;
                        Wf.w = Wf.z;
                        this.sourceId.setValue(g.colorBuffer);
                        he[0] = 1 / e._shadowResolution;
                        he[1] = 0;
                        this.pixelOffsetId.setValue(he);
                        1 === h && this.weightId.setValue(this.blurVsmWeights[f]);
                        La(c, k, n, null, Wf);
                        this.sourceId.setValue(k.colorBuffer);
                        he[1] = he[0];
                        he[0] = 0;
                        this.pixelOffsetId.setValue(he);
                        La(c, g, n, null, Wf)
                    }
                }
            }
            c.webgl2 ? c.setDepthBias(!1) : c.extStandardDerivatives && (this.polygonOffset[0] = 0, this.polygonOffset[1] = 0, this.polygonOffsetId.setValue(this.polygonOffset))
        },
        updateShader: function(a, b, c, d, e) {
            a.material._scene = this.scene;
            a.material._dirtyBlend && (this.scene.layers._dirtyBlend = !0);
            a.material.updateShader(this.device, this.scene, b, c, d, e);
            a._shader[d] = a.material.shader
        },
        setCullMode: function(a, b, c) {
            var d = c.material,
                e = 0;
            a && (a = 1, 0 < d.cull &&
                3 > d.cull && (c.flipFaces && (a *= -1), b && (a *= -1), b = c.node.worldTransform, b.getX(vd), b.getY(wh), b.getZ(xh), vd.cross(vd, wh), 0 > vd.dot(xh) && (a *= -1)), e = 0 > a ? 2 === d.cull ? 1 : 2 : d.cull);
            this.device.setCullMode(e);
            0 === e && 0 === d.cull && (c = c.node.worldTransform, c.getX(vd), c.getY(wh), c.getZ(xh), vd.cross(vd, wh), 0 > vd.dot(xh) ? this.twoSidedLightingNegScaleFactorId.setValue(-1) : this.twoSidedLightingNegScaleFactorId.setValue(1))
        },
        setVertexBuffers: function(a, b) {
            a.setVertexBuffer(b.vertexBuffer)
        },
        setMorphing: function(a, b) {
            if (b)
                if (b.morph.useTextureMorph) a.setVertexBuffer(b.morph.vertexBufferIds),
                    this.morphPositionTex.setValue(b.texturePositions), this.morphNormalTex.setValue(b.textureNormals), this.morphTexParams.setValue(b._textureParams);
                else {
                    for (var c, d, e = 0; e < b._activeVertexBuffers.length; e++)
                        if (c = b._activeVertexBuffers[e]) d = "ATTR" + (e + 8), c.format.elements[0].name = d, c.format.elements[0].scopeId = a.scope.resolve(d), c.format.update(), a.setVertexBuffer(c);
                    this.morphWeightsA.setValue(b._shaderMorphWeightsA);
                    this.morphWeightsB.setValue(b._shaderMorphWeightsB)
                }
        },
        renderForward: function(a, b, c, d, e,
            f, g, k) {
            var h = this.device,
                l = this.scene,
                n = a.vrDisplay;
            k = k ? k._lightHash : 0;
            var p = 1 << e,
                q, r = null,
                t = .5 * h.width;
            for (q = 0; q < c; q++) {
                var u = b[q];
                if (!f || !u.mask || f & u.mask)
                    if (u.command) u.command();
                    else {
                        var x = u.mesh;
                        var v = u.material;
                        var w = u._shaderDefs;
                        var y = u.mask;
                        this.setSkinning(h, u, v);
                        v && v === r && w !== A && (r = null);
                        if (u.isStatic || E) r = null;
                        if (v !== r) {
                            this._materialSwitches++;
                            v.dirty && (v.updateUniforms(), v.dirty = !1);
                            if (!u._shader[e] || u._shaderDefs !== w || u._lightHash !== k) {
                                if (u.isStatic) this.updateShader(u, w, u._staticLightList,
                                    e, d);
                                else {
                                    var A = e + "_" + w + "_" + k;
                                    u._shader[e] = v.variants[A];
                                    u._shader[e] || (this.updateShader(u, w, null, e, d), v.variants[A] = u._shader[e])
                                }
                                u._shaderDefs = w;
                                u._lightHash = k
                            }
                            u._shader[e].failed || h.setShader(u._shader[e]) || (u._shader[e].failed = !0);
                            v.setParameters(h);
                            if (!r || y !== B) {
                                var B = this.dispatchDirectLights(d[0], l, y);
                                this.dispatchLocalLights(d, l, y, B, u._staticLightList)
                            }
                            this.alphaTestId.setValue(v.alphaTest);
                            h.setBlending(v.blend);
                            v.blend && (v.separateAlphaBlend ? (h.setBlendFunctionSeparate(v.blendSrc, v.blendDst,
                                v.blendSrcAlpha, v.blendDstAlpha), h.setBlendEquationSeparate(v.blendEquation, v.blendAlphaEquation)) : (h.setBlendFunction(v.blendSrc, v.blendDst), h.setBlendEquation(v.blendEquation)));
                            h.setColorWrite(v.redWrite, v.greenWrite, v.blueWrite, v.alphaWrite);
                            h.setDepthWrite(v.depthWrite);
                            h.setDepthTest(v.depthTest);
                            h.setAlphaToCoverage(v.alphaToCoverage);
                            v.depthBias || v.slopeDepthBias ? (h.setDepthBias(!0), h.setDepthBiasValues(v.depthBias, v.slopeDepthBias)) : h.setDepthBias(!1)
                        }
                        this.setCullMode(a._cullFaces, a._flipFaces,
                            u);
                        B = u.stencilFront || v.stencilFront;
                        r = u.stencilBack || v.stencilBack;
                        B || r ? (h.setStencilTest(!0), B === r ? (h.setStencilFunc(B.func, B.ref, B.readMask), h.setStencilOperation(B.fail, B.zfail, B.zpass, B.writeMask)) : (B ? (h.setStencilFuncFront(B.func, B.ref, B.readMask), h.setStencilOperationFront(B.fail, B.zfail, B.zpass, B.writeMask)) : (h.setStencilFuncFront(7, 0, 255), h.setStencilOperationFront(0, 0, 0, 255)), r ? (h.setStencilFuncBack(r.func, r.ref, r.readMask), h.setStencilOperationBack(r.fail, r.zfail, r.zpass, r.writeMask)) : (h.setStencilFuncBack(7,
                            0, 255), h.setStencilOperationBack(0, 0, 0, 255)))) : h.setStencilTest(!1);
                        u.setParameters(h, p);
                        this.setVertexBuffers(h, x);
                        this.setMorphing(h, u.morphInstance);
                        B = u.renderStyle;
                        h.setIndexBuffer(x.indexBuffer[B]);
                        g && g(u, q);
                        if (n && n.presenting) h.setViewport(0, 0, t, h.height), this.projId.setValue(Xf.data), this.projSkyboxId.setValue(Xf.data), this.viewInvId.setValue(Qc.data), this.viewId.setValue(Xe.data), this.viewId3.setValue(mm.data), this.viewProjId.setValue(om.data), this.viewPos[0] = Ze.x, this.viewPos[1] = Ze.y, this.viewPos[2] =
                            Ze.z, this.viewPosId.setValue(this.viewPos), q += this.drawInstance(h, u, x, B, !0), this._forwardDrawCalls++, h.setViewport(t, 0, t, h.height), this.projId.setValue(Yf.data), this.projSkyboxId.setValue(Yf.data), this.viewInvId.setValue(Rc.data), this.viewId.setValue(Ye.data), this.viewId3.setValue(nm.data), this.viewProjId.setValue(pm.data), this.viewPos[0] = $e.x, this.viewPos[1] = $e.y, this.viewPos[2] = $e.z, this.viewPosId.setValue(this.viewPos), q += this.drawInstance2(h, u, x, B), this._forwardDrawCalls++;
                        else if (a.xr && a.xr.session &&
                            a.xr.views.length)
                            for (r = a.xr.views, A = 0; A < r.length; A++) {
                                var E = r[A];
                                h.setViewport(E.viewport.x, E.viewport.y, E.viewport.z, E.viewport.w);
                                this.projId.setValue(E.projMat.data);
                                this.projSkyboxId.setValue(E.projMat.data);
                                this.viewId.setValue(E.viewOffMat.data);
                                this.viewInvId.setValue(E.viewInvOffMat.data);
                                this.viewId3.setValue(E.viewMat3.data);
                                this.viewProjId.setValue(E.projViewOffMat.data);
                                this.viewPosId.setValue(E.position);
                                q = 0 === A ? q + this.drawInstance(h, u, x, B, !0) : q + this.drawInstance2(h, u, x, B);
                                this._forwardDrawCalls++
                            } else q +=
                                this.drawInstance(h, u, x, B, !0), this._forwardDrawCalls++;
                        q < c - 1 && b[q + 1].material === v && v.setParameters(h, u.parameters);
                        r = v;
                        A = w;
                        B = y;
                        E = u.isStatic
                    }
            }
            h.updateEnd()
        },
        setupInstancing: function(a) {
            a.enableAutoInstancing && (Ah || (Ah = new ab(a, Na.defaultInstancingFormat, a.autoInstancingMaxObjects, 1)))
        },
        revertStaticMeshes: function(a) {
            var b, c = a.length,
                d = [];
            for (b = 0; b < c; b++) {
                var e = a[b];
                if (e._staticSource) {
                    if (e._staticSource !== f) {
                        d.push(e._staticSource);
                        var f = e._staticSource
                    }
                } else d.push(e)
            }
            a.length = d.length;
            for (b = 0; b <
                d.length; b++) a[b] = d[b]
        },
        prepareStaticMeshes: function(a, b) {
            var c, d, e, f, g = this.device,
                k = a.length,
                h = [],
                l, n, p, q = new z,
                r = new z,
                t = new oa,
                u = new J,
                x = [],
                v, w = [],
                y = [],
                A = [];
            for (c = 0; c < k; c++) {
                var B = a[c];
                if (B.isStatic) {
                    var E = B.aabb;
                    A.length = 0;
                    for (v = 1; 2 >= v; v++)
                        for (d = 0; d < b.length; d++) {
                            var D = b[d];
                            D._type === v && D.enabled && D.mask & B.mask && D.isStatic && (w[d] || (w[d] = new oa, D._node.getWorldTransform(), D.getBoundingSphere(je), w[d].center.copy(je.center), w[d].halfExtents.x = je.radius, w[d].halfExtents.y = je.radius, w[d].halfExtents.z =
                                je.radius), w[d].intersects(E) && A.push(d))
                        }
                    if (0 === A.length) h.push(B);
                    else {
                        E = B.mesh;
                        v = E.vertexBuffer;
                        D = E.indexBuffer[B.renderStyle];
                        var C = 2 === D.bytesPerIndex ? new Uint16Array(D.lock()) : new Uint32Array(D.lock());
                        var G = E.primitive[B.renderStyle].count / 3;
                        var K = E.primitive[B.renderStyle].base;
                        var R = v.format.elements;
                        var I = v.format.size / 4;
                        E = new Float32Array(v.storage);
                        for (e = 0; e < R.length; e++) "POSITION" === R[e].name && (l = R[e].offset / 4);
                        x.length = G;
                        for (e = 0; e < G; e++) x[e] = 0;
                        R = !1;
                        y.length = 6 * G;
                        for (e = 0; e < G; e++) {
                            var T =
                                p = n = Number.MAX_VALUE;
                            var S = -Number.MAX_VALUE;
                            var ba = -Number.MAX_VALUE;
                            var ha = -Number.MAX_VALUE;
                            for (f = 0; 3 > f; f++) {
                                d = C[3 * e + f + K];
                                d = d * I + l;
                                var W = E[d];
                                var Q = E[d + 1];
                                d = E[d + 2];
                                W < n && (n = W);
                                Q < p && (p = Q);
                                d < T && (T = d);
                                W > S && (S = W);
                                Q > ba && (ba = Q);
                                d > ha && (ha = d)
                            }
                            d = 6 * e;
                            y[d] = n;
                            y[d + 1] = p;
                            y[d + 2] = T;
                            y[d + 3] = S;
                            y[d + 4] = ba;
                            y[d + 5] = ha
                        }
                        for (W = 0; W < A.length; W++)
                            for (d = A[W], u.copy(B.node.worldTransform).invert(), t.setFromTransformedAabb(w[d], u), Q = t.getMin(), n = t.getMax(), f = 1 << W, e = 0; e < G; e++) d = 6 * e, y[d] <= n.x && y[d + 3] >= Q.x && y[d + 1] <= n.y && y[d + 4] >= Q.y &&
                                y[d + 2] <= n.z && y[d + 5] >= Q.z && (x[e] |= f, R = !0);
                        if (R) {
                            R = {};
                            for (e = 0; e < G; e++) {
                                d = 3 * e + K;
                                var Nb = x[e];
                                R[Nb] || (R[Nb] = []);
                                f = R[Nb];
                                f.push(C[d]);
                                f.push(C[d + 1]);
                                f.push(C[d + 2])
                            }
                            for (Nb in R) {
                                f = R[Nb];
                                C = new dc(g, D.format, f.length, D.usage);
                                (2 === C.bytesPerIndex ? new Uint16Array(C.lock()) : new Uint32Array(C.lock())).set(f);
                                C.unlock();
                                T = p = n = Number.MAX_VALUE;
                                S = -Number.MAX_VALUE;
                                ba = -Number.MAX_VALUE;
                                ha = -Number.MAX_VALUE;
                                for (e = 0; e < f.length; e++) d = f[e], W = E[d * I + l], Q = E[d * I + l + 1], d = E[d * I + l + 2], W < n && (n = W), Q < p && (p = Q), d < T && (T = d), W > S && (S =
                                    W), Q > ba && (ba = Q), d > ha && (ha = d);
                                q.set(n, p, T);
                                r.set(S, ba, ha);
                                e = new oa;
                                e.setMinMax(q, r);
                                G = new sb(g);
                                G.vertexBuffer = v;
                                G.indexBuffer[0] = C;
                                G.primitive[0].type = 4;
                                G.primitive[0].base = 0;
                                G.primitive[0].count = f.length;
                                G.primitive[0].indexed = !0;
                                G.aabb = e;
                                C = new va(B.node, G, B.material);
                                C.isStatic = B.isStatic;
                                C.visible = B.visible;
                                C.layer = B.layer;
                                C.castShadow = B.castShadow;
                                C._receiveShadow = B._receiveShadow;
                                C.cull = B.cull;
                                C.pick = B.pick;
                                C.mask = B.mask;
                                C.parameters = B.parameters;
                                C._shaderDefs = B._shaderDefs;
                                C._staticSource = B;
                                C._staticLightList = B._staticLightList ? B._staticLightList : [];
                                for (e = 0; e < A.length; e++) f = 1 << e, Nb & f && (G = b[A[e]], 0 > C._staticLightList.indexOf(G) && C._staticLightList.push(G));
                                C._staticLightList.sort(this.lightCompare);
                                h.push(C)
                            }
                        } else h.push(B)
                    }
                } else h.push(B)
            }
            a.length = h.length;
            for (c = 0; c < h.length; c++) a[c] = h[c]
        },
        updateShaders: function(a) {
            var b, c = [];
            for (b = 0; b < a.length; b++) {
                var d = a[b];
                void 0 !== d.material && -1 === c.indexOf(d.material) && c.push(d.material)
            }
            for (b = 0; b < c.length; b++) a = c[b], a.updateShader !== la.prototype.updateShader &&
                (a.clearVariants(), a.shader = null)
        },
        updateLitShaders: function(a) {
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                void 0 !== c.material && (c = c.material, c.updateShader === la.prototype.updateShader || !1 === c.useLighting || c.emitter && !c.emitter.lighting || (c.clearVariants(), c.shader = null))
            }
        },
        beginFrame: function(a) {
            var b = this.scene,
                c = a._meshInstances;
            a = a._lights;
            b.updateShaders ? (this.updateShaders(c), b.updateShaders = !1, b.updateLitShaders = !1, b._shaderVersion++) : b.updateLitShaders && (this.updateLitShaders(c), b.updateLitShaders = !1, b._shaderVersion++);
            this.updateCpuSkinMatrices(c);
            var d = c.length;
            for (b = 0; b < d; b++) c[b].visibleThisFrame = !1;
            d = a.length;
            for (b = 0; b < d; b++) a[b].visibleThisFrame = 0 === a[b]._type
        },
        beginLayers: function(a) {
            var b = this.scene,
                c = a.layerList.length,
                d, e = this.scene._shaderVersion;
            for (d = 0; d < c; d++) a.layerList[d]._postRenderCounter = 0;
            for (d = 0; d < c; d++) {
                var f = a.layerList[d];
                f._shaderVersion = e;
                f._preRenderCalledForCameras = 0;
                f._postRenderCalledForCameras = 0;
                var g = a.subLayerList[d];
                f._postRenderCounter = g ? f._postRenderCounter |
                    2 : f._postRenderCounter | 1;
                f._postRenderCounterMax = f._postRenderCounter;
                for (g = 0; g < f.cameras.length; g++) f.instances.visibleOpaque[g] || (f.instances.visibleOpaque[g] = new Hk), f.instances.visibleTransparent[g] || (f.instances.visibleTransparent[g] = new Hk), f.instances.visibleOpaque[g].done = !1, f.instances.visibleTransparent[g].done = !1;
                f.cameras.length < f.instances.visibleOpaque.length && f.instances.visibleOpaque.splice(f.cameras.length, 1);
                f.cameras.length < f.instances.visibleTransparent.length && f.instances.visibleTransparent.splice(f.cameras.length,
                    1);
                f._needsStaticPrepare && f._staticLightHash && (f._staticPrepareDone && (this.revertStaticMeshes(f.opaqueMeshInstances), this.revertStaticMeshes(f.transparentMeshInstances)), this.prepareStaticMeshes(f.opaqueMeshInstances, f._lights), this.prepareStaticMeshes(f.transparentMeshInstances, f._lights), a._dirty = !0, b.updateShaders = !0, f._needsStaticPrepare = !1, f._staticPrepareDone = !0)
            }
        },
        cullLocalShadowmap: function(a, b) {
            var c, d, e, f;
            var g = a._type;
            if (0 !== g) {
                a.visibleThisFrame = !0;
                var k = this.getShadowCamera(this.device,
                    a);
                k.projection = 0;
                k.nearClip = a.attenuationEnd / 1E3;
                k.farClip = a.attenuationEnd;
                k.aspectRatio = 1;
                if (2 === g) {
                    k.fov = 2 * a._outerConeAngle;
                    var h = 1
                } else k.fov = 90, h = 6;
                var l = k._node;
                var n = a._node;
                l.setPosition(n.getPosition());
                2 === g && (l.setRotation(n.getRotation()), l.rotateLocal(-90, 0, 0));
                for (c = 0; c < h; c++) {
                    1 === g && (l.setRotation(jm[c]), k.renderTarget = a._shadowCubeMap[c]);
                    this.updateCameraFrustum(k);
                    (e = a._visibleList[c]) || (e = a._visibleList[c] = []);
                    n = f = a._visibleLength[c] = 0;
                    for (d = b.length; n < d; n++) {
                        var p = b[n];
                        var q = !0;
                        p.cull && (q = p._isVisible(k));
                        q && (e[f] = p, f++, p.visibleThisFrame = !0)
                    }
                    a._visibleLength[c] = f;
                    e.length !== f && (e.length = f);
                    e.sort(this.depthSortCompare)
                }
            }
        },
        cullDirectionalShadowmap: function(a, b, c, d) {
            var e = this.device;
            a.visibleThisFrame = !0;
            e = this.getShadowCamera(e, a);
            var f = e._node;
            var g = a._node;
            f.setPosition(g.getPosition());
            f.setRotation(g.getRotation());
            f.rotateLocal(-90, 0, 0);
            var k = a.shadowDistance || c._farClip;
            var h = c._nearClip;
            var l = c._fov * Math.PI / 180;
            var n = c._aspectRatio;
            var p = c._projection;
            var q = 0 ===
                p ? Math.tan(l / 2) * h : c._orthoHeight;
            var r = q * n;
            ua[0].x = r;
            ua[0].y = -q;
            ua[0].z = -h;
            ua[1].x = r;
            ua[1].y = q;
            ua[1].z = -h;
            ua[2].x = -r;
            ua[2].y = q;
            ua[2].z = -h;
            ua[3].x = -r;
            ua[3].y = -q;
            ua[3].z = -h;
            0 === p && (q = Math.tan(l / 2) * k, r = q * n);
            ua[4].x = r;
            ua[4].y = -q;
            ua[4].z = -k;
            ua[5].x = r;
            ua[5].y = q;
            ua[5].z = -k;
            ua[6].x = -r;
            ua[6].y = q;
            ua[6].z = -k;
            ua[7].x = -r;
            ua[7].y = -q;
            ua[7].z = -k;
            n = qm.sub2(ua[0], ua[6]).length();
            n = Math.max(n, qm.sub2(ua[4], ua[6]).length());
            ie.copy(f.getWorldTransform()).invert();
            km.copy(ie).mul(c._node.getWorldTransform());
            for (l = 0; 8 >
                l; l++) km.transformPoint(ua[l], ua[l]);
            k = h = c = 1E6;
            r = q = p = -1E6;
            for (l = 0; 8 > l; l++) {
                var t = ua[l];
                t.x < k && (k = t.x);
                t.x > r && (r = t.x);
                t.y < h && (h = t.y);
                t.y > q && (q = t.y);
                t.z < c && (c = t.z);
                t.z > p && (p = t.z)
            }
            l = n / a._shadowResolution;
            k = Math.floor((k - .5 * (n - (r - k))) / l) * l;
            h = Math.floor((h - .5 * (n - (q - h))) / l) * l;
            k = .5 * (k + n + k);
            h = .5 * (h + n + h);
            f.translateLocal(k, h, 1E5);
            e.projection = 1;
            e.nearClip = 0;
            e.farClip = 2E5;
            e.aspectRatio = 1;
            e.orthoHeight = .5 * n;
            this.updateCameraFrustum(e);
            q = !0;
            (p = a._visibleList[d]) || (p = a._visibleList[d] = []);
            l = n = a._visibleLength[d] =
                0;
            for (r = b.length; l < r; l++) {
                var u = b[l];
                t = !0;
                u.cull && (t = u._isVisible(e));
                t && (p[n] = u, n++, u.visibleThisFrame = !0, t = u.aabb, q ? (yh.copy(t), q = !1) : yh.add(t))
            }
            a._visibleLength[d] = n;
            p.length !== n && (p.length = n);
            p.sort(this.depthSortCompare);
            b = yh.getMin();
            l = yh.getMax();
            za[0].x = za[1].x = za[2].x = za[3].x = b.x;
            za[1].y = za[3].y = za[7].y = za[5].y = b.y;
            za[2].z = za[3].z = za[6].z = za[7].z = b.z;
            za[4].x = za[5].x = za[6].x = za[7].x = l.x;
            za[0].y = za[2].y = za[4].y = za[6].y = l.y;
            za[0].z = za[1].z = za[4].z = za[5].z = l.z;
            l = 9999999999;
            b = -9999999999;
            for (p =
                0; 8 > p; ++p) ie.transformPoint(za[p], za[p]), n = za[p].z, n < l && (l = n), n > b && (b = n);
            p = b;
            l > c && (c = l);
            f.setPosition(g.getPosition());
            f.translateLocal(k, h, p + .01);
            e.farClip = p - c;
            (g = a._visibleCameraSettings[d]) || (g = a._visibleCameraSettings[d] = {});
            a = f.getPosition();
            g.x = a.x;
            g.y = a.y;
            g.z = a.z;
            g.orthoHeight = e.orthoHeight;
            g.farClip = e.farClip
        },
        gpuUpdate: function(a) {
            this.updateGpuSkinMatrices(a);
            this.updateMorphing(a)
        },
        setSceneConstants: function() {
            var a, b = this.device,
                c = this.scene;
            this.dispatchGlobalLights(c);
            if ("none" !== c.fog) {
                this.fogColor[0] =
                    c.fogColor.r;
                this.fogColor[1] = c.fogColor.g;
                this.fogColor[2] = c.fogColor.b;
                if (c.gammaCorrection)
                    for (a = 0; 3 > a; a++) this.fogColor[a] = Math.pow(this.fogColor[a], 2.2);
                this.fogColorId.setValue(this.fogColor);
                "linear" === c.fog ? (this.fogStartId.setValue(c.fogStart), this.fogEndId.setValue(c.fogEnd)) : this.fogDensityId.setValue(c.fogDensity)
            }
            this._screenSize[0] = b.width;
            this._screenSize[1] = b.height;
            this._screenSize[2] = 1 / b.width;
            this._screenSize[3] = 1 / b.height;
            this.screenSizeId.setValue(this._screenSize)
        },
        renderComposition: function(a) {
            var b =
                this.device,
                c, d = a._renderedRt,
                e = a._renderedByCam,
                f = a._renderedLayer,
                g, k, h, l;
            this.scene.updateSkybox && (this.scene._updateSkybox(b), this.scene.updateSkybox = !1);
            this.beginLayers(a);
            a._update() & 2 && (this.scene.updateLitShaders = !0);
            this.beginFrame(a);
            this.setSceneConstants();
            var n = 0;
            for (g = 0; g < a.layerList.length; g++) {
                var p = a.layerList[g];
                if (p.enabled && a.subLayerEnabled[g]) {
                    var q = a.subLayerList[g];
                    var r = p.instances;
                    var t = p.cameras;
                    for (k = 0; k < t.length; k++)
                        if (c = t[k]) {
                            c.frameBegin(p.renderTarget);
                            var u = q ? p.transparentMeshInstances :
                                p.opaqueMeshInstances;
                            var x = l = !1;
                            for (h = 0; h < n; h++)
                                if (e[h] === c && (l = !0, f[h] === p)) {
                                    x = !0;
                                    break
                                }
                            l || (this.updateCameraFrustum(c.camera), this._camerasRendered++);
                            x || this.cullLights(c.camera, p._lights);
                            l && x || (e[n] = c, f[n] = p, n++);
                            h = q ? r.visibleTransparent[k] : r.visibleOpaque[k];
                            if (!h.done) {
                                if (p.onPreCull) p.onPreCull(k);
                                h.length = this.cull(c.camera, u, h.list);
                                h.done = !0;
                                if (p.onPostCull) p.onPostCull(k)
                            }
                            c.frameEnd()
                        }
                }
            }
            for (g = 0; g < a._lights.length; g++) c = a._lights[g], c.visibleThisFrame && 0 !== c._type && c.castShadows && c.enabled &&
                0 !== c.shadowUpdateMode && (p = a._lightShadowCasters[g], this.cullLocalShadowmap(c, p));
            q = -1;
            for (g = 0; g < a._lights.length; g++)
                if (c = a._lights[g], 0 === c._type && (q++, c.castShadows && c.enabled && 0 !== c.shadowUpdateMode))
                    for (p = a._lightShadowCasters[g], t = a._globalLightCameras[q], k = 0; k < t.length; k++) this.cullDirectionalShadowmap(c, p, t[k].camera, a._globalLightCameraIds[q][k]);
            this.gpuUpdate(a._meshInstances);
            this.renderShadows(a._splitLights[2]);
            this.renderShadows(a._splitLights[1]);
            for (g = n = 0; g < a._renderList.length; g++)
                if (p =
                    a.layerList[a._renderList[g]], p.enabled && a.subLayerEnabled[a._renderList[g]]) {
                    r = p.instances;
                    q = a.subLayerList[a._renderList[g]];
                    t = a._renderListCamera[g];
                    (c = p.cameras[t]) && c.frameBegin(p.renderTarget);
                    if (!q && p.onPreRenderOpaque) p.onPreRenderOpaque(t);
                    else if (q && p.onPreRenderTransparent) p.onPreRenderTransparent(t);
                    if (!(p._preRenderCalledForCameras & 1 << t)) {
                        if (p.onPreRender) p.onPreRender(t);
                        p._preRenderCalledForCameras |= 1 << t;
                        p.overrideClear && this.clearView(c.camera, p.renderTarget, !0, !0, p._clearOptions)
                    }
                    if (c) {
                        k =
                            p.renderTarget;
                        f = !1;
                        for (h = 0; h < n; h++)
                            if (d[h] === k && e[h] === c) {
                                f = !0;
                                break
                            }
                        f || (p.overrideClear || this.clearView(c.camera, p.renderTarget, !0, !0), d[n] = k, e[n] = c, n++);
                        this.renderShadows(p._splitLights[0], t);
                        p._sortVisible(q, c.camera.node, t);
                        h = q ? r.visibleTransparent[t] : r.visibleOpaque[t];
                        this.scene._activeCamera = c.camera;
                        this.setCamera(c.camera, p.renderTarget);
                        this.renderForward(c.camera, h.list, h.length, p._splitLights, p.shaderPass, p.cullingMask, p.onDrawCall, p);
                        b.setColorWrite(!0, !0, !0, !0);
                        b.setStencilTest(!1);
                        b.setAlphaToCoverage(!1);
                        b.setDepthBias(!1);
                        c.frameEnd()
                    }
                    if (!q && p.onPostRenderOpaque) p.onPostRenderOpaque(t);
                    else if (q && p.onPostRenderTransparent) p.onPostRenderTransparent(t);
                    !p.onPostRender || p._postRenderCalledForCameras & 1 << t || (p._postRenderCounter &= ~(q ? 2 : 1), 0 === p._postRenderCounter && (p.onPostRender(t), p._postRenderCalledForCameras |= 1 << t, p._postRenderCounter = p._postRenderCounterMax))
                }
        }
    });
    ed.prototype = Object.create(la.prototype);
    ed.prototype.constructor = ed;
    Object.assign(ed.prototype, {
        clone: function() {
            var a =
                new ed;
            la.prototype._cloneInternal.call(this, a);
            a.color.copy(this.color);
            a.colorMap = this.colorMap;
            a.vertexColors = this.vertexColors;
            return a
        },
        updateUniforms: function() {
            this.clearParameters();
            this.colorUniform[0] = this.color.r;
            this.colorUniform[1] = this.color.g;
            this.colorUniform[2] = this.color.b;
            this.colorUniform[3] = this.color.a;
            this.setParameter("uColor", this.colorUniform);
            this.colorMap && this.setParameter("texture_diffuseMap", this.colorMap)
        },
        updateShader: function(a, b, c, d, e, f) {
            b = {
                skin: !!this.meshInstances[0].skinInstance,
                vertexColors: this.vertexColors,
                diffuseMap: !!this.colorMap,
                pass: e
            };
            this.shader = a.getProgramLibrary().getProgram("basic", b)
        }
    });
    var Bh = new Z;
    Cg.prototype.addLayer = function(a) {
        0 > this.layers.indexOf(a) && this.layers.push(a)
    };
    Cg.prototype.getLayerIdx = function(a) {
        return this.layerToBatch[a.id]
    };
    Cg.prototype.addLayerIdx = function(a, b) {
        this.layerToBatch[b.id] = a
    };
    Object.assign(Pk.prototype, {
        init: function(a, b, c, d) {
            this.mesh || (this.mesh = new sb(a), this.mesh.primitive[0].type = 1, this.mesh.primitive[0].base = 0, this.mesh.primitive[0].indexed = !1, this.material = new ed, this.material.vertexColors = !0, this.material.blend = !0, this.material.blendType = 2, this.material.update());
            for (this.layer = c; this.linesUsed + d > this.numLinesAllocated;) this.vb && (this.vb.destroy(), this.vb = null), this.numLinesAllocated *= 2;
            this.vertexFormat = b;
            this.vb || (this.vb = new ab(a, b, 2 * this.numLinesAllocated, 1), this.mesh.vertexBuffer = this.vb, this.vbRam = new DataView(this.vb.lock()), this.meshInstance || (Bh.worldTransform = J.IDENTITY, Bh._dirtyWorld = Bh._dirtyNormal = !1, this.meshInstance =
                new va(Bh, this.mesh, this.material), this.meshInstance.cull = !1))
        },
        addLines: function(a, b) {
            for (var c = !!b.length, d = 2 * this.linesUsed * this.vertexFormat.size, e, f = 0; f < a.length; f++) this.vbRam.setFloat32(d, a[f].x, !0), d += 4, this.vbRam.setFloat32(d, a[f].y, !0), d += 4, this.vbRam.setFloat32(d, a[f].z, !0), d += 4, e = c ? b[f] : b, this.vbRam.setUint8(d, 255 * e.r), d += 1, this.vbRam.setUint8(d, 255 * e.g), d += 1, this.vbRam.setUint8(d, 255 * e.b), d += 1, this.vbRam.setUint8(d, 255 * e.a), d += 1;
            this.linesUsed += a.length / 2
        },
        finalize: function(a) {
            0 < this.linesUsed &&
                (this.vb.setData(this.vbRam.buffer), this.mesh.primitive[0].count = 2 * this.linesUsed, a[0] = this.meshInstance, this.layer.addMeshInstances(a, !0), this.linesUsed = 0)
        }
    });
    xa.prototype = Object.create(M.prototype);
    xa.prototype.constructor = xa;
    xa.prototype._splitLightsArray = function(a) {
        var b = a._lights;
        a._splitLights[0].length = 0;
        a._splitLights[1].length = 0;
        for (var c = a._splitLights[2].length = 0; c < b.length; c++) {
            var d = b[c];
            d.enabled && a._splitLights[d._type].push(d)
        }
    };
    xa.prototype._update = function() {
        function a(r, t, u) {
            for (var x,
                    v = !1, w = u.length, y = 0; y < w; y++) x = u[y], t.has(x) || (t.add(x), r.push(x), (x = x.material) && x._dirtyBlend && (v = !0, x._dirtyBlend = !1));
            return v
        }

        function b(r, t, u) {
            for (var x, v = 0; v < t.length;) x = (x = t[v].material) && 3 !== x.blendType, x === u ? (r.push(t[v]), t[v] = t[t.length - 1], t.length--) : v++
        }
        var c, d, e = this.layerList.length,
            f = 0;
        if (!this._dirty || !this._dirtyLights || !this._dirtyCameras)
            for (c = 0; c < e; c++) {
                var g = this.layerList[c];
                g._dirty && (this._dirty = !0);
                g._dirtyLights && (this._dirtyLights = !0);
                g._dirtyCameras && (this._dirtyCameras = !0)
            }
        if (this._dirty) {
            f |= 1;
            this._meshInstances.length = 0;
            this._meshInstancesSet.clear();
            for (c = 0; c < e; c++) g = this.layerList[c], g.passThrough || (this._dirtyBlend = a(this._meshInstances, this._meshInstancesSet, g.opaqueMeshInstances) || this._dirtyBlend, this._dirtyBlend = a(this._meshInstances, this._meshInstancesSet, g.transparentMeshInstances) || this._dirtyBlend), g._dirty = !1, g._version++;
            this._dirty = !1
        }
        if (this._dirtyBlend) {
            f |= 8;
            for (c = 0; c < e; c++) g = this.layerList[c], g.passThrough || (b(g.opaqueMeshInstances, g.transparentMeshInstances, !1), b(g.transparentMeshInstances, g.opaqueMeshInstances, !0));
            this._dirtyBlend = !1
        }
        if (this._dirtyLights) {
            f |= 2;
            this._lights.length = 0;
            this._lightsMap.clear();
            for (c = 0; c < e; c++) {
                g = this.layerList[c];
                var k = g._lights;
                for (d = 0; d < k.length; d++) {
                    var h = k[d];
                    this._lightsMap.has(h) || (this._lightsMap.set(h, this._lights.length), this._lights.push(h))
                }
            }
            g = this._lights.length;
            this._lightShadowCasters.length = g;
            this._lightShadowCastersSets.length = g;
            for (c = 0; c < g; c++) this._lightShadowCasters[c] ? this._lightShadowCasters[c].length =
                0 : this._lightShadowCasters[c] = [], this._lightShadowCastersSets[c] ? this._lightShadowCastersSets[c].clear() : this._lightShadowCastersSets[c] = new Set;
            this._splitLightsArray(this);
            this._dirtyLights = !1;
            for (c = 0; c < e; c++) g = this.layerList[c], this._splitLightsArray(g), g._dirtyLights = !1
        }
        if (f) {
            for (c = 0; c < this._lightShadowCasters.length; c++) this._lightShadowCasters[c].length = 0, this._lightShadowCastersSets[c].clear();
            for (c = 0; c < e; c++)
                for (g = this.layerList[c], k = g._lights, d = 0; d < k.length; d++) {
                    var l = this._lightsMap.get(k[d]);
                    h = this._lightShadowCasters[l];
                    var n = this._lightShadowCastersSets[l];
                    var p = g.shadowCasters;
                    for (l = 0; l < p.length; l++) {
                        var q = p[l];
                        n.has(q) || (n.add(q), h.push(q))
                    }
                }
        }
        if (f & 2 || this._dirtyCameras)
            for (this._globalLightCameras.length = 0, k = this._splitLights[0], d = 0; d < k.length; d++)
                for (h = k[d], this._globalLightCameras[d] = [], c = 0; c < e; c++)
                    if (g = this.layerList[c], 0 <= g._splitLights[0].indexOf(h))
                        for (l = 0; l < g.cameras.length; l++) 0 > this._globalLightCameras[d].indexOf(g.cameras[l]) && this._globalLightCameras[d].push(g.cameras[l]);
        if (this._dirtyCameras) {
            f |= 4;
            for (c = this.cameras.length = 0; c < e; c++)
                for (g = this.layerList[c], d = 0; d < g.cameras.length; d++) k = g.cameras[d], l = this.cameras.indexOf(k), 0 > l && (l = this.cameras.length, this.cameras.push(k));
            this._renderList.length = 0;
            for (c = k = this._renderListCamera.length = 0; c < e; c++)
                if (k) k--;
                else if (g = this.layerList[c], 0 !== g.cameras.length || g.isPostEffect)
                if (h = g._cameraHash, 0 === h) this._renderList.push(c), this._renderListCamera.push(0);
                else {
                    l = 1;
                    for (d = c + 1; d < e; d++)
                        if (n = this.layerList[d]._cameraHash, h !==
                            n) {
                            l = d - c - 1;
                            break
                        } else d === e - 1 && (l = d - c);
                    if (1 === l)
                        for (h = 0; h < g.cameras.length; h++) this._renderList.push(c), this._renderListCamera.push(h);
                    else {
                        for (h = h = 0; h < g.cameras.length; h++)
                            for (d = 0; d <= l; d++) this._renderList.push(c + d), this._renderListCamera.push(h);
                        k = l
                    }
                }
            this._dirtyCameras = !1;
            for (c = 0; c < e; c++) this.layerList[c]._dirtyCameras = !1
        }
        if (f & 2 || f & 4)
            for (d = this._globalLightCameraIds.length = 0; d < this._globalLightCameras.length; d++) {
                e = [];
                for (c = 0; c < this._globalLightCameras[d].length; c++) l = this.cameras.indexOf(this._globalLightCameras[d][c]),
                    0 > l || e.push(l);
                this._globalLightCameraIds.push(e)
            }
        return f
    };
    xa.prototype._isLayerAdded = function(a) {
        return 0 <= this.layerList.indexOf(a) ? !0 : !1
    };
    xa.prototype._isSublayerAdded = function(a, b) {
        for (var c = 0; c < this.layerList.length; c++)
            if (this.layerList[c] === a && this.subLayerList[c] === b) return !0;
        return !1
    };
    xa.prototype.push = function(a) {
        this._isLayerAdded(a) || (this.layerList.push(a), this.layerList.push(a), this._opaqueOrder[a.id] = this.subLayerList.push(!1) - 1, this._transparentOrder[a.id] = this.subLayerList.push(!0) -
            1, this.subLayerEnabled.push(!0), this.subLayerEnabled.push(!0), this._dirtyCameras = this._dirtyLights = this._dirty = !0, this.fire("add", a))
    };
    xa.prototype.insert = function(a, b) {
        if (!this._isLayerAdded(a)) {
            this.layerList.splice(b, 0, a, a);
            this.subLayerList.splice(b, 0, !1, !0);
            var c = this.layerList.length;
            this._updateOpaqueOrder(b, c - 1);
            this._updateTransparentOrder(b, c - 1);
            this.subLayerEnabled.splice(b, 0, !0, !0);
            this._dirtyCameras = this._dirtyLights = this._dirty = !0;
            this.fire("add", a)
        }
    };
    xa.prototype.remove = function(a) {
        var b =
            this.layerList.indexOf(a);
        delete this._opaqueOrder[b];
        for (delete this._transparentOrder[b]; 0 <= b;) this.layerList.splice(b, 1), this.subLayerList.splice(b, 1), this.subLayerEnabled.splice(b, 1), b = this.layerList.indexOf(a), this._dirtyCameras = this._dirtyLights = this._dirty = !0, this.fire("remove", a);
        a = this.layerList.length;
        this._updateOpaqueOrder(0, a - 1);
        this._updateTransparentOrder(0, a - 1)
    };
    xa.prototype.pushOpaque = function(a) {
        this._isSublayerAdded(a, !1) || (this.layerList.push(a), this._opaqueOrder[a.id] = this.subLayerList.push(!1) -
            1, this.subLayerEnabled.push(!0), this._dirtyCameras = this._dirtyLights = this._dirty = !0, this.fire("add", a))
    };
    xa.prototype.insertOpaque = function(a, b) {
        this._isSublayerAdded(a, !1) || (this.layerList.splice(b, 0, a), this.subLayerList.splice(b, 0, !1), this._updateOpaqueOrder(b, this.subLayerList.length - 1), this.subLayerEnabled.splice(b, 0, !0), this._dirtyCameras = this._dirtyLights = this._dirty = !0, this.fire("add", a))
    };
    xa.prototype.removeOpaque = function(a) {
        for (var b = 0, c = this.layerList.length; b < c; b++)
            if (this.layerList[b] ===
                a && !this.subLayerList[b]) {
                this.layerList.splice(b, 1);
                this.subLayerList.splice(b, 1);
                c--;
                this._updateOpaqueOrder(b, c - 1);
                this.subLayerEnabled.splice(b, 1);
                this._dirtyCameras = this._dirtyLights = this._dirty = !0;
                0 > this.layerList.indexOf(a) && this.fire("remove", a);
                break
            }
    };
    xa.prototype.pushTransparent = function(a) {
        this._isSublayerAdded(a, !0) || (this.layerList.push(a), this._transparentOrder[a.id] = this.subLayerList.push(!0) - 1, this.subLayerEnabled.push(!0), this._dirtyCameras = this._dirtyLights = this._dirty = !0, this.fire("add",
            a))
    };
    xa.prototype.insertTransparent = function(a, b) {
        this._isSublayerAdded(a, !0) || (this.layerList.splice(b, 0, a), this.subLayerList.splice(b, 0, !0), this._updateTransparentOrder(b, this.subLayerList.length - 1), this.subLayerEnabled.splice(b, 0, !0), this._dirtyCameras = this._dirtyLights = this._dirty = !0, this.fire("add", a))
    };
    xa.prototype.removeTransparent = function(a) {
        for (var b = 0, c = this.layerList.length; b < c; b++)
            if (this.layerList[b] === a && this.subLayerList[b]) {
                this.layerList.splice(b, 1);
                this.subLayerList.splice(b, 1);
                c--;
                this._updateTransparentOrder(b, c - 1);
                this.subLayerEnabled.splice(b, 1);
                this._dirtyCameras = this._dirtyLights = this._dirty = !0;
                0 > this.layerList.indexOf(a) && this.fire("remove", a);
                break
            }
    };
    xa.prototype._getSublayerIndex = function(a, b) {
        var c = this.layerList.indexOf(a);
        return 0 > c || this.subLayerList[c] !== b && (c = this.layerList.indexOf(a, c + 1), 0 > c || this.subLayerList[c] !== b) ? -1 : c
    };
    xa.prototype.getOpaqueIndex = function(a) {
        return this._getSublayerIndex(a, !1)
    };
    xa.prototype.getTransparentIndex = function(a) {
        return this._getSublayerIndex(a, !0)
    };
    xa.prototype.getLayerById = function(a) {
        for (var b = 0; b < this.layerList.length; b++)
            if (this.layerList[b].id === a) return this.layerList[b];
        return null
    };
    xa.prototype.getLayerByName = function(a) {
        for (var b = 0; b < this.layerList.length; b++)
            if (this.layerList[b].name === a) return this.layerList[b];
        return null
    };
    xa.prototype._updateOpaqueOrder = function(a, b) {
        for (; a <= b; a++) !1 === this.subLayerList[a] && (this._opaqueOrder[this.layerList[a].id] = a)
    };
    xa.prototype._updateTransparentOrder = function(a, b) {
        for (; a <= b; a++) !0 === this.subLayerList[a] &&
            (this._transparentOrder[this.layerList[a].id] = a)
    };
    xa.prototype._sortLayersDescending = function(a, b, c) {
        var d, e = -1,
            f = -1;
        var g = 0;
        for (d = a.length; g < d; g++) {
            var k = a[g];
            c.hasOwnProperty(k) && (e = Math.max(e, c[k]))
        }
        g = 0;
        for (d = b.length; g < d; g++) k = b[g], c.hasOwnProperty(k) && (f = Math.max(f, c[k]));
        return -1 === e && -1 !== f ? 1 : -1 === f && -1 !== e ? -1 : f - e
    };
    xa.prototype.sortTransparentLayers = function(a, b) {
        return this._sortLayersDescending(a, b, this._transparentOrder)
    };
    xa.prototype.sortOpaqueLayers = function(a, b) {
        return this._sortLayersDescending(a,
            b, this._opaqueOrder)
    };
    var oc = [],
        Sc = [],
        Ya, Za = new z,
        Cc = new oa,
        $f = new oa,
        ag = {},
        sm = ["texture_lightMap", "texture_dirLightMap"],
        ck = [];
    Object.assign(ni.prototype, {
        destroy: function() {
            this.assets = this.renderer = this.scene = this.root = this.device = null
        },
        calculateLightmapSize: function(a) {
            var b = this.scene.lightmapSizeMultiplier || 16,
                c = 1,
                d = 1,
                e = 1,
                f = 1;
            if (a.model.asset) {
                var g = this.assets.get(a.model.asset).data;
                g.area && (c = g.area.x, d = g.area.y, e = g.area.z, f = g.area.uv)
            } else a.model._area && (g = a.model, g._area && (c = g._area.x,
                d = g._area.y, e = g._area.z, f = g._area.uv));
            g = a.model.lightmapSizeMultiplier || 1;
            c *= g;
            d *= g;
            e *= g;
            Za.copy(a.localScale);
            for (a = a._parent; a;) Za.mul(a.localScale), a = a._parent;
            Za.x = Math.abs(Za.x);
            Za.y = Math.abs(Za.y);
            Za.z = Math.abs(Za.z);
            c = c * Za.y * Za.z + d * Za.x * Za.z + e * Za.x * Za.y;
            c = Math.sqrt(c / f);
            return Math.min(N.nextPowerOfTwo(c * b), this.scene.lightmapMaxResolution || 2048)
        },
        bake: function(a, b) {
            var c, d, e = this.device,
                f = this.scene,
                g = 1;
            void 0 === b && (b = 1);
            1 === b && (g = 2);
            var k;
            b = [];
            var h = [];
            if (a) {
                var l;
                for (c = Sc.length - 1; 0 <= c; c--)
                    for (d =
                        0; d < a.length; d++)
                        if (Sc[c] === a[d]) {
                            for (l = 0; l < oc[c].length; l++) oc[c][l].destroy();
                            oc.splice(c, 1);
                            Sc.splice(c, 1)
                        }
                l = [];
                for (c = 0; c < a.length; c++) Dg(a[c], l, h);
                a = l;
                Dg(this.root, null, null, b)
            } else {
                for (c = 0; c < oc.length; c++)
                    for (d = 0; d < oc[c].length; d++) oc[c][d].destroy();
                oc = [];
                Sc = [];
                a = [];
                Dg(this.root, a, h, b)
            }
            if (0 === a.length) e.fire("lightmapper:end", {
                timestamp: Lb(),
                target: this
            });
            else {
                l = !1;
                f._needsStaticPrepare && (f._needsStaticPrepare = !1, l = !0);
                var n = [
                        [],
                        []
                    ],
                    p = {};
                d = new V(this.device, {
                    width: 4,
                    height: 4,
                    format: 7,
                    type: "rgbm"
                });
                d.name = "lightmap";
                for (c = 0; c < a.length; c++) {
                    var q = this.calculateLightmapSize(a[c]);
                    for (k = 0; k < g; k++) {
                        var r = new V(e, {
                            width: q,
                            height: q,
                            format: 7,
                            mipmaps: !1,
                            type: 0 === k ? "rgbm" : "default",
                            minFilter: 0,
                            magFilter: 0
                        });
                        r.name = "lightmap";
                        n[k].push(r)
                    }
                    if (!p[q]) {
                        var t = new V(e, {
                            width: q,
                            height: q,
                            format: 7,
                            mipmaps: !1,
                            type: "rgbm",
                            minFilter: 0,
                            magFilter: 0
                        });
                        t.name = "lightmap";
                        t = new sa(e, t, {
                            depth: !1
                        });
                        p[q] = t
                    }
                }
                var u = f.layers;
                u._update();
                q = [];
                t = [];
                var x = [],
                    v = [],
                    w = u._lights;
                for (c = 0; c < w.length; c++) w[c].enabled && (r = w[c].mask, 0 !==
                    (r & 4) && (t.push(r), x.push(w[c].shadowUpdateMode), w[c].mask = 4294967295, w[c].shadowUpdateMode = 0 === w[c]._type ? 2 : 1, q.push(w[c]), w[c].isStatic = !1)), v.push(w[c].enabled), w[c].enabled = !1;
                var y = "#define UV1LAYOUT\n" + F.transformVS,
                    A = F.bakeLmEndPS;
                r = Wa(e, F.fullscreenQuadVS, F.dilatePS, "lmDilate");
                var B = e.scope.resolve("source"),
                    E = e.scope.resolve("pixelOffset"),
                    D = e.scope.resolve("bakeDir"),
                    C = new Float32Array(2);
                u = u._meshInstances;
                for (c = 0; c < u.length; c++) u[c].node && u[c].node.getWorldTransform();
                u = f.fog;
                var G = f.ambientLight.r,
                    K = f.ambientLight.g,
                    R = f.ambientLight.b;
                f.fog = "none";
                f.ambientLight.set(0, 0, 0);
                Ya || (Ya = new pa, Ya.clearColor = new L(0, 0, 0, 0), Ya.clearColorBuffer = !0, Ya.clearDepthBuffer = !1, Ya.clearStencilBuffer = !1, Ya.frustumCulling = !1, Ya.node = new Z);
                var I, T = [];
                T.length = Sc.length;
                for (I = 0; I < b.length; I++) {
                    var S = b[I].model.model.meshInstances;
                    var ba = [];
                    for (c = 0; c < S.length; c++) ba.push(S[c]._shaderDefs), S[c]._shaderDefs &= -193;
                    for (c = 0; c < Sc.length; c++)
                        if (Sc[c] === b[I]) {
                            T[c] = ba;
                            break
                        }
                }
                ba = [];
                var ha = [];
                for (I = 0; I < b.length; I++)
                    if (ba[I] =
                        b[I].model.castShadows, b[I].model.castShadows = b[I].model.castShadowsLightmap, b[I].model.castShadowsLightmap) {
                        var W = b[I].model.meshInstances;
                        for (c = 0; c < W.length; c++) W[c].visibleThisFrame = !0, ha.push(W[c])
                    }
                this.renderer.updateCpuSkinMatrices(ha);
                this.renderer.gpuUpdate(ha);
                var Q = [],
                    Nb = [];
                W = [
                    [],
                    []
                ];
                var df = [];
                df.length = a.length;
                for (k = 0; k < g; k++) ck[k] || (c = new ma, c.chunks.transformVS = y, 0 === k ? (c.chunks.endPS = A, c.ambient = new L(0, 0, 0), c.ambientTint = !0, c.lightMap = d) : (c.chunks.basePS = F.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n",
                    c.chunks.endPS = F.bakeDirLmEndPS), c.chunks.outputAlphaPS = "\n", c.chunks.outputAlphaOpaquePS = "\n", c.chunks.outputAlphaPremulPS = "\n", c.cull = 0, c.forceUv1 = !0, c.update(), c.updateShader(e, f), c.name = "lmMaterial" + k, ck[k] = c);
                for (I = 0; I < a.length; I++) {
                    S = h[I];
                    df[I] = 0;
                    if (0 < S.length)
                        for (Cc.copy(S[0].aabb), c = 0; c < S.length; c++) S[c].node.getWorldTransform(), Cc.add(S[c].aabb);
                    c = new oa;
                    c.copy(Cc);
                    Nb.push(c);
                    for (c = 0; c < S.length; c++) {
                        var Ea = S[c];
                        Ea._shaderDefs &= -193;
                        Ea.mask = 4;
                        Ea.deleteParameter("texture_lightMap");
                        Ea.deleteParameter("texture_dirLightMap");
                        Ea.setParameter("texture_lightMap", Ea.material.lightMap ? Ea.material.lightMap : d);
                        Ea.setParameter("texture_dirLightMap", d)
                    }
                    for (k = 0; k < g; k++) {
                        var mb = n[k][I];
                        var Dc = new sa(e, mb, {
                            depth: !1
                        });
                        W[k].push(Dc)
                    }
                }
                for (d = 0; d < q.length; d++) q[d].enabled = !1;
                y = [
                    [],
                    [],
                    []
                ];
                A = !1;
                for (c = 0; c < q.length; c++) {
                    q[c].enabled = !0;
                    var Tc = !1;
                    q[c]._cacheShadowMap = !0;
                    0 !== q[c]._type && (q[c]._node.getWorldTransform(), q[c].getBoundingSphere(ag), $f.center = ag.center, $f.halfExtents.x = ag.radius, $f.halfExtents.y = ag.radius, $f.halfExtents.z = ag.radius);
                    if (2 === q[c]._type) {
                        I = q[c];
                        var nb = this.renderer.getShadowCamera(e, I);
                        nb._node.setPosition(I._node.getPosition());
                        nb._node.setRotation(I._node.getRotation());
                        nb._node.rotateLocal(-90, 0, 0);
                        nb.projection = 0;
                        nb.nearClip = I.attenuationEnd / 1E3;
                        nb.farClip = I.attenuationEnd;
                        nb.aspectRatio = 1;
                        nb.fov = 2 * I._outerConeAngle;
                        this.renderer.updateCameraFrustum(nb)
                    }
                    0 < h.length && this.renderer.updateShaders(h[0]);
                    for (I = 0; I < a.length; I++) {
                        S = h[I];
                        Cc = Nb[I];
                        if (0 === q[c]._type) Za.copy(Cc.center), Za.y += Cc.halfExtents.y, Ya.node.setPosition(Za),
                            Ya.node.setEulerAngles(-90, 0, 0), d = Math.max(Cc.halfExtents.x, Cc.halfExtents.z), Ya.projection = 1, Ya.nearClip = 0, Ya.farClip = 2 * Cc.halfExtents.y, Ya.aspectRatio = 1, Ya.orthoHeight = d;
                        else if (!$f.intersects(Cc)) continue;
                        if (2 === q[c]._type) {
                            k = !1;
                            for (d = 0; d < S.length; d++)
                                if (S[d]._isVisible(nb)) {
                                    k = !0;
                                    break
                                }
                            if (!k) continue
                        }
                        0 === q[c]._type ? (y[0][0] = q[c], y[1].length = 0, y[2].length = 0, !Tc && q[c].castShadows && (this.renderer.cullDirectionalShadowmap(q[c], ha, Ya, 0), this.renderer.renderShadows(y[0], 0), Tc = !0)) : (y[0].length = 0, 1 ===
                            q[c]._type ? (y[1][0] = q[c], y[2].length = 0, !Tc && q[c].castShadows && (this.renderer.cullLocalShadowmap(q[c], ha), this.renderer.renderShadows(y[1]), Tc = !0)) : (y[1].length = 0, y[2][0] = q[c], !Tc && q[c].castShadows && (this.renderer.cullLocalShadowmap(q[c], ha), this.renderer.renderShadows(y[2]), Tc = !0)));
                        for (d = 0; d < S.length; d++) Q[d] = S[d].material;
                        for (k = 0; k < g; k++) {
                            mb = n[k][I];
                            Dc = W[k][I];
                            Ea = p[mb.width];
                            var qc = Ea.colorBuffer;
                            0 === k ? A = f.updateShaders : A && (f.updateShaders = !0);
                            for (d = 0; d < S.length; d++) S[d].material = ck[k];
                            1 < g && this.renderer.updateShaders(S);
                            this.renderer.setCamera(Ya, Ea, !0);
                            1 === k && D.setValue(q[c].bakeDir ? 1 : 0);
                            this.renderer._forwardTime = 0;
                            this.renderer._shadowMapTime = 0;
                            this.renderer.renderForward(Ya, S, S.length, y, 1);
                            n[k][I] = qc;
                            W[k][I] = Ea;
                            p[mb.width] = Dc;
                            for (d = 0; d < S.length; d++) Ea = S[d], Ea.setParameter(sm[k], qc), Ea._shaderDefs |= 64
                        }
                        df[I]++;
                        for (d = 0; d < S.length; d++) S[d].material = Q[d]
                    }
                    q[c].enabled = !1;
                    q[c]._cacheShadowMap = !1;
                    q[c]._isCachedShadowMap && q[c]._destroyShadowMap()
                }
                for (I = 0; I < a.length; I++) {
                    S = h[I];
                    nb = [];
                    for (k = 0; k < g; k++) {
                        mb = n[k][I];
                        Dc = W[k][I];
                        Ea = p[mb.width];
                        qc = Ea.colorBuffer;
                        C[0] = 1 / mb.width;
                        C[1] = 1 / mb.height;
                        E.setValue(C);
                        for (c = 0; 4 > c; c++) B.setValue(mb), La(e, Ea, r), B.setValue(qc), La(e, Dc, r);
                        for (c = 0; c < S.length; c++) Ea = S[c], Ea.mask = 2, S[c].setParameter(sm[k], mb), 1 === k && (S[c]._shaderDefs |= 128);
                        nb[k] = mb;
                        k === g - 1 && Dc.destroy()
                    }
                    oc.push(nb);
                    Sc.push(a[I])
                }
                for (var Uc in p) p.hasOwnProperty(Uc) && (p[Uc].colorBuffer.destroy(), p[Uc].destroy());
                for (c = 0; c < oc.length; c++)
                    for (d = 0; d < oc[c].length; d++) r = oc[c][d], r.minFilter = 1, r.magFilter = 1;
                for (I = 0; I < b.length; I++) b[I].model.castShadows =
                    ba[I];
                for (c = 0; c < T.length; c++)
                    if (T[c])
                        for (S = Sc[c].model.model.meshInstances, d = 0; d < S.length; d++) S[d]._shaderDefs |= T[c][d] & 192;
                for (c = 0; c < q.length; c++) q[c].mask = t[c], q[c].shadowUpdateMode = x[c];
                for (c = 0; c < w.length; c++) w[c].enabled = v[c];
                f.fog = u;
                f.ambientLight.set(G, K, R);
                l && (f._needsStaticPrepare = !0)
            }
        }
    });
    var Vc, tm = 1,
        dk = new J,
        ek = new J,
        Ec = new z,
        Fa = new z,
        rc = new z,
        ef = new z,
        ob = new z,
        Aa = new z,
        ff = new z,
        gf = new z,
        bg = new z,
        um = new z,
        pb = new z,
        Ch = new z,
        ke = new z;
    pi.prototype.calcSpawnPosition = function(a, b, c, d, e) {
        var f =
            this._emitter,
            g = Math.random(),
            k = Math.random(),
            h = Math.random(),
            l = Math.random();
        f.useCpu && (a[4 * e + 8 * f.numParticlesPot] = g, a[4 * e + 1 + 8 * f.numParticlesPot] = k, a[4 * e + 2 + 8 * f.numParticlesPot] = h);
        Fa.x = g - .5;
        Fa.y = k - .5;
        Fa.z = h - .5;
        0 === f.emitterShape ? (l = Math.max(Math.abs(Fa.x), Math.max(Math.abs(Fa.y), Math.abs(Fa.z))), k = l + (.5 - l) * c[1], h = l + (.5 - l) * c[2], Fa.x = (l + (.5 - l) * c[0]) * (l == Math.abs(Fa.x) ? Math.sign(Fa.x) : 2 * Fa.x), Fa.y = k * (l == Math.abs(Fa.y) ? Math.sign(Fa.y) : 2 * Fa.y), Fa.z = h * (l == Math.abs(Fa.z) ? Math.sign(Fa.z) : 2 * Fa.z), f.localSpace ?
            Ec.copy(b.transformPoint(Fa)) : Ec.copy(d).add(b.transformPoint(Fa))) : (Fa.normalize(), b = 0 === f.emitterRadius ? 0 : f.emitterRadiusInner / f.emitterRadius, b = l * (1 - b) + b, f.localSpace ? Ec.copy(Fa.scale(b * f.emitterRadius)) : Ec.copy(d).add(Fa.scale(b * f.emitterRadius)));
        d = -N.lerp(f.rate, f.rate2, g) * e;
        f.pack8 ? (l = (Ec.x - f.worldBounds.center.x) / f.worldBoundsSize.x + .5, c = (Ec.y - f.worldBounds.center.y) / f.worldBoundsSize.y + .5, b = (Ec.z - f.worldBounds.center.z) / f.worldBoundsSize.z + .5, g = N.lerp(f.startAngle * N.DEG_TO_RAD, f.startAngle2 *
                N.DEG_TO_RAD, g), g = g % (2 * Math.PI) / (2 * Math.PI), l = Eg(l), a[4 * e] = l[0], a[4 * e + 1] = l[1], c = Eg(c), a[4 * e + 2] = c[0], a[4 * e + 3] = c[1], b = Eg(b), a[4 * e + 4 * f.numParticlesPot] = b[0], a[4 * e + 1 + 4 * f.numParticlesPot] = b[1], g = Eg(g), a[4 * e + 2 + 4 * f.numParticlesPot] = g[0], a[4 * e + 3 + 4 * f.numParticlesPot] = g[1], a[4 * e + 3 + 8 * f.numParticlesPot] = 1, g = Math.max(f.lifetime, (f.numParticles - 1) * Math.max(f.rate, f.rate2)), c = (d + g) / (g + (f.lifetime + 1)), g = ve(c), d = ve(255 * c), b = ve(65025 * c), c = ve(160581375 * c), g -= d / 255, d -= b / 255, g = [g, d, b - c / 255, c - c / 255], a[4 * e + 12 * f.numParticlesPot] =
            g[0], a[4 * e + 1 + 12 * f.numParticlesPot] = g[1], a[4 * e + 2 + 12 * f.numParticlesPot] = g[2], a[4 * e + 3 + 12 * f.numParticlesPot] = g[3]) : (a[4 * e] = Ec.x, a[4 * e + 1] = Ec.y, a[4 * e + 2] = Ec.z, a[4 * e + 3] = N.lerp(f.startAngle * N.DEG_TO_RAD, f.startAngle2 * N.DEG_TO_RAD, g), a[4 * e + 3 + 4 * f.numParticlesPot] = d)
    };
    pi.prototype.update = function(a, b, c, d, e, f, g, k) {
        var h = this._emitter;
        if (h.meshInstance.node) {
            var l = h.meshInstance.node.worldTransform;
            for (f = 0; 12 > f; f++) dk.data[f] = l.data[f];
            ek.copy(dk);
            ek.invert();
            Vc = h.meshInstance.node.localScale;
            tm = Math.max(Math.max(Vc.x,
                Vc.y), Vc.z)
        }
        f = null === h.meshInstance.node || h.localSpace ? z.ZERO : h.meshInstance.node.getPosition();
        var n = h.camera ? h.camera._node.getPosition() : z.ZERO,
            p = h.useMesh ? 17 : 15,
            q = h.precision - 1;
        for (l = 0; l < h.numParticles; l++) {
            var r = Math.floor(h.vbCPU[l * h.numParticleVerts * (h.useMesh ? 6 : 4) + 3]),
                t = c[4 * r + 8 * h.numParticlesPot];
            rc.x = t;
            rc.y = c[4 * r + 1 + 8 * h.numParticlesPot];
            rc.z = c[4 * r + 2 + 8 * h.numParticlesPot];
            var u = h.rate + (h.rate2 - h.rate) * t,
                x = h.lifetime,
                v = c[4 * r + 3 + 4 * h.numParticlesPot] + g,
                w = Math.max(Math.min(v / x, 1), 0),
                y = 0;
            var A = 0;
            (0 >= v - g || v >= x) && this.calcSpawnPosition(c, d, e, f, r);
            var B = 0 < v && v < x;
            if (B) {
                A = w * q;
                var E = Math.floor(A);
                var D = Math.ceil(A);
                A %= 1;
                var C = h.qRotSpeed[E];
                var G = h.qRotSpeed[D];
                var K = C + (G - C) * A;
                C = h.qRotSpeed2[E];
                G = h.qRotSpeed2[D];
                var R = C + (G - C) * A;
                C = h.qScale[E];
                G = h.qScale[D];
                y = C + (G - C) * A;
                C = h.qScale2[E];
                G = h.qScale2[D];
                var I = C + (G - C) * A;
                C = h.qAlpha[E];
                G = h.qAlpha[D];
                var T = C + (G - C) * A;
                C = h.qAlpha2[E];
                G = h.qAlpha2[D];
                var S = C + (G - C) * A;
                C = h.qRadialSpeed[E];
                G = h.qRadialSpeed[D];
                var ba = C + (G - C) * A;
                C = h.qRadialSpeed2[E];
                G = h.qRadialSpeed2[D];
                C += (G - C) * A;
                ba += 100 * t % 1 * (C - ba);
                ef.x = c[4 * r];
                ef.y = c[4 * r + 1];
                ef.z = c[4 * r + 2];
                h.localSpace ? bg.copy(ef) : bg.copy(ef).sub(f);
                bg.normalize().scale(ba);
                E *= 3;
                D *= 3;
                C = h.qLocalVelocity[E];
                G = h.qLocalVelocity[D];
                Aa.x = C + (G - C) * A;
                C = h.qLocalVelocity[E + 1];
                G = h.qLocalVelocity[D + 1];
                Aa.y = C + (G - C) * A;
                C = h.qLocalVelocity[E + 2];
                G = h.qLocalVelocity[D + 2];
                Aa.z = C + (G - C) * A;
                C = h.qLocalVelocity2[E];
                G = h.qLocalVelocity2[D];
                gf.x = C + (G - C) * A;
                C = h.qLocalVelocity2[E + 1];
                G = h.qLocalVelocity2[D + 1];
                gf.y = C + (G - C) * A;
                C = h.qLocalVelocity2[E + 2];
                G = h.qLocalVelocity2[D +
                    2];
                gf.z = C + (G - C) * A;
                C = h.qVelocity[E];
                G = h.qVelocity[D];
                ob.x = C + (G - C) * A;
                C = h.qVelocity[E + 1];
                G = h.qVelocity[D + 1];
                ob.y = C + (G - C) * A;
                C = h.qVelocity[E + 2];
                G = h.qVelocity[D + 2];
                ob.z = C + (G - C) * A;
                C = h.qVelocity2[E];
                G = h.qVelocity2[D];
                ff.x = C + (G - C) * A;
                C = h.qVelocity2[E + 1];
                G = h.qVelocity2[D + 1];
                ff.y = C + (G - C) * A;
                C = h.qVelocity2[E + 2];
                G = h.qVelocity2[D + 2];
                ff.z = C + (G - C) * A;
                Aa.x += (gf.x - Aa.x) * rc.x;
                Aa.y += (gf.y - Aa.y) * rc.y;
                Aa.z += (gf.z - Aa.z) * rc.z;
                0 < h.initialVelocity && (1 === h.emitterShape ? (Fa.copy(rc).scale(2).sub(z.ONE).normalize(), Aa.add(Fa.scale(h.initialVelocity))) :
                    Aa.add(z.FORWARD.scale(h.initialVelocity)));
                ob.x += (ff.x - ob.x) * rc.x;
                ob.y += (ff.y - ob.y) * rc.y;
                ob.z += (ff.z - ob.z) * rc.z;
                K += (R - K) * rc.y;
                y = (y + 1E4 * t % 1 * (I - y)) * tm;
                A = 1E3 * t % 1 * (S - T);
                h.meshInstance.node && (h.localSpace ? (Aa.x /= Vc.x, Aa.y /= Vc.y, Aa.z /= Vc.z) : dk.transformPoint(Aa, Aa));
                h.localSpace ? (ek.transformPoint(ob, ob), Aa.add(ob).add(bg)) : (Aa.add(ob.mul(Vc)), Aa.add(bg.mul(Vc)));
                Ch.copy(Aa);
                um.copy(ef).add(Aa.scale(g));
                pb.copy(um);
                c[4 * r] = pb.x;
                c[4 * r + 1] = pb.y;
                c[4 * r + 2] = pb.z;
                c[4 * r + 3] += K * g;
                h.wrap && h.wrapBounds && (h.localSpace ||
                    pb.sub(f), pb.x = oi(pb.x, h.wrapBounds.x) - .5 * h.wrapBounds.x, pb.y = oi(pb.y, h.wrapBounds.y) - .5 * h.wrapBounds.y, pb.z = oi(pb.z, h.wrapBounds.z) - .5 * h.wrapBounds.z, h.localSpace || pb.add(f));
                0 < h.sort && (1 === h.sort ? (ke.copy(pb).sub(n), h.particleDistance[r] = -(ke.x * ke.x + ke.y * ke.y + ke.z * ke.z)) : 2 === h.sort ? h.particleDistance[r] = v : 3 === h.sort && (h.particleDistance[r] = -v))
            }
            k ? 0 > v && (c[4 * r + 3 + 8 * h.numParticlesPot] = -1) : (v >= x && (v -= Math.max(x, (h.numParticles - 1) * u), c[4 * r + 3 + 8 * h.numParticlesPot] = h.loop ? 1 : -1), 0 > v && h.loop && (c[4 * r + 3 + 8 * h.numParticlesPot] =
                1));
            0 > c[4 * r + 3 + 8 * h.numParticlesPot] && (B = !1);
            c[4 * r + 3 + 4 * h.numParticlesPot] = v;
            for (K = 0; K < h.numParticleVerts; K++) t = (l * h.numParticleVerts + K) * (h.useMesh ? 6 : 4), u = h.vbCPU[t], x = h.vbCPU[t + 1], v = h.vbCPU[t + 2], B || (u = x = v = 0), E = l * h.numParticleVerts * p + K * p, a[E] = pb.x, a[E + 1] = pb.y, a[E + 2] = pb.z, a[E + 3] = w, a[E + 4] = h.alignToMotion ? 0 : c[4 * r + 3], a[E + 5] = y, a[E + 6] = A, a[E + 7] = Ch.x, a[E + 8] = u, a[E + 9] = x, a[E + 10] = v, a[E + 11] = Ch.y, a[E + 12] = r, a[E + 13] = Ch.z, a[E + 14] = h.vbCPU[t + 3], h.useMesh && (a[E + 15] = h.vbCPU[t + 4], a[E + 16] = h.vbCPU[t + 5])
        }
        if (0 < h.sort && h.camera) {
            a =
                h.useMesh ? 6 : 4;
            c = h.particleDistance;
            for (l = 0; l < h.numParticles; l++) b[l][0] = l, b[l][1] = c[Math.floor(h.vbCPU[l * h.numParticleVerts * a + 3])];
            h.vbOld.set(h.vbCPU);
            b.sort(function(ha, W) {
                return ha[1] - W[1]
            });
            for (l = 0; l < h.numParticles; l++)
                for (c = b[l][0] * h.numParticleVerts * a, d = l * h.numParticleVerts * a, f = 0; f < h.numParticleVerts * a; f++) h.vbCPU[d + f] = h.vbOld[c + f]
        }
    };
    var vm = new rb,
        wm = new rb,
        xm = new rb;
    Fg.prototype._setInputBounds = function() {
        this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
        this.inBoundsSizeUniform[1] =
            this._emitter.prevWorldBoundsSize.y;
        this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
        this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
        this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
        this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
        this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
        this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform)
    };
    Fg.prototype.randomize = function() {
        this.frameRandomUniform[0] = Math.random();
        this.frameRandomUniform[1] = Math.random();
        this.frameRandomUniform[2] = Math.random()
    };
    Fg.prototype.update = function(a, b, c, d, e) {
        var f = this._emitter;
        a.setBlending(!1);
        a.setColorWrite(!0, !0, !0, !0);
        a.setCullMode(0);
        a.setDepthTest(!1);
        a.setDepthWrite(!1);
        this.randomize();
        this.constantGraphSampleSize.setValue(1 / f.precision);
        this.constantGraphNumSamples.setValue(f.precision);
        this.constantNumParticles.setValue(f.numParticles);
        this.constantNumParticlesPot.setValue(f.numParticlesPot);
        this.constantInternalTex0.setValue(f.internalTex0);
        this.constantInternalTex1.setValue(f.internalTex1);
        this.constantInternalTex2.setValue(f.internalTex2);
        this.constantInternalTex3.setValue(f.internalTex3);
        var g = f.meshInstance.node,
            k = null === g ? z.ONE : g.localScale;
        if (f.pack8) {
            this.worldBoundsMulUniform[0] = f.worldBoundsMul.x;
            this.worldBoundsMulUniform[1] = f.worldBoundsMul.y;
            this.worldBoundsMulUniform[2] = f.worldBoundsMul.z;
            this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
            this.worldBoundsAddUniform[0] = f.worldBoundsAdd.x;
            this.worldBoundsAddUniform[1] =
                f.worldBoundsAdd.y;
            this.worldBoundsAddUniform[2] = f.worldBoundsAdd.z;
            this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
            this._setInputBounds();
            var h = f.maxVel * Math.max(Math.max(k.x, k.y), k.z);
            h = Math.max(h, 1);
            this.constantMaxVel.setValue(h)
        }
        h = null === g || f.localSpace ? z.ZERO : g.getPosition();
        g = null === g ? J.IDENTITY : g.getWorldTransform();
        0 === f.emitterShape ? (Qk(b, vm), this.constantSpawnBounds.setValue(vm.data), this.constantSpawnPosInnerRatio.setValue(c)) : (this.constantSpawnBoundsSphere.setValue(f.emitterRadius),
            this.constantSpawnBoundsSphereInnerRatio.setValue(0 === f.emitterRadius ? 0 : f.emitterRadiusInner / f.emitterRadius));
        this.constantInitialVelocity.setValue(f.initialVelocity);
        Qk(g, wm);
        g.invertTo3x3(xm);
        this.emitterPosUniform[0] = h.x;
        this.emitterPosUniform[1] = h.y;
        this.emitterPosUniform[2] = h.z;
        this.constantEmitterPos.setValue(this.emitterPosUniform);
        this.constantFrameRandom.setValue(this.frameRandomUniform);
        this.constantDelta.setValue(d);
        this.constantRate.setValue(f.rate);
        this.constantRateDiv.setValue(f.rate2 -
            f.rate);
        this.constantStartAngle.setValue(f.startAngle * N.DEG_TO_RAD);
        this.constantStartAngle2.setValue(f.startAngle2 * N.DEG_TO_RAD);
        this.constantSeed.setValue(f.seed);
        this.constantLifetime.setValue(f.lifetime);
        this.emitterScaleUniform[0] = k.x;
        this.emitterScaleUniform[1] = k.y;
        this.emitterScaleUniform[2] = k.z;
        this.constantEmitterScale.setValue(this.emitterScaleUniform);
        this.constantEmitterMatrix.setValue(wm.data);
        this.constantEmitterMatrixInv.setValue(xm.data);
        this.constantLocalVelocityDivMult.setValue(f.localVelocityUMax);
        this.constantVelocityDivMult.setValue(f.velocityUMax);
        this.constantRotSpeedDivMult.setValue(f.rotSpeedUMax[0]);
        b = f.swapTex ? f.particleTexOUT : f.particleTexIN;
        b = f.beenReset ? f.particleTexStart : b;
        c = f.swapTex ? f.particleTexIN : f.particleTexOUT;
        this.constantParticleTexIN.setValue(b);
        La(a, f.swapTex ? f.rtParticleTexIN : f.rtParticleTexOUT, e ? f.shaderParticleUpdateOnStop : f.loop ? f.shaderParticleUpdateRespawn : f.shaderParticleUpdateNoRespawn);
        f.material.setParameter("particleTexOUT", b);
        f.material.setParameter("particleTexIN",
            c);
        f.beenReset = !1;
        f.swapTex = !f.swapTex;
        a.setDepthTest(!0);
        a.setDepthWrite(!0);
        f.prevWorldBoundsSize.copy(f.worldBoundsSize);
        f.prevWorldBoundsCenter.copy(f.worldBounds.center);
        f.pack8 && this._setInputBounds()
    };
    var ym = [
            [-1, -1],
            [1, -1],
            [1, 1],
            [-1, 1]
        ],
        Zb = function(a, b, c, d, e, f, g) {
            e || (e = 14);
            var k = 0;
            g && 7 === e && (k = 1);
            a = new V(a, {
                width: b,
                height: c,
                format: e,
                cubemap: !1,
                mipmaps: !1,
                minFilter: k,
                magFilter: k,
                addressU: 1,
                addressV: 1
            });
            a.name = "PSTexture";
            b = a.lock();
            if (7 === e) {
                e = new Uint8Array(d.length);
                for (c = 0; c < d.length; c++) e[c] =
                    d[c] * f * 255;
                d = e
            }
            b.set(d);
            a.unlock();
            return a
        },
        zm = new hb([0, 0, 1, 0]),
        Am = new hb([0, 1, 1, 1]),
        Bm = new Cb([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]),
        kp = new Cb([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]),
        Wc = 2,
        Xc = new Float32Array(3),
        le = new J,
        Cm = new z,
        Dh = new z,
        Eh = new z,
        Rk, Gg, $b = function(a, b) {
            this.graphicsDevice = a;
            this.precision = 32;
            this._addTimeTime = 0;
            if (!$b.DEFAULT_PARAM_TEXTURE) {
                var c = new Float32Array(1024),
                    d, e;
                for (e = 0; 16 > e; e++)
                    for (d = 0; 16 > d; d++) {
                        var f = d + 1 - 8.5;
                        var g = e + 1 - 8.5;
                        g = Math.max(Math.min(1 - Math.max(Math.min(Math.sqrt(f * f + g * g) /
                            16, 1), 0) - .5, 1), 0);
                        f = 16 * e + d;
                        c[4 * f] = 1;
                        c[4 * f + 1] = 1;
                        c[4 * f + 2] = 1;
                        c[4 * f + 3] = g
                    }
                $b.DEFAULT_PARAM_TEXTURE = Zb(a, 16, 16, c, 7, 1, !0);
                $b.DEFAULT_PARAM_TEXTURE.minFilter = 1;
                $b.DEFAULT_PARAM_TEXTURE.magFilter = 1
            }
            Rk = this;
            Gg = b;
            U("numParticles", 1);
            this.numParticles > a.maxTextureSize && (console.warn("WARNING: can't create more than " + a.maxTextureSize + " particles on this device."), this.numParticles = a.maxTextureSize);
            U("rate", 1);
            U("rate2", this.rate);
            U("lifetime", 50);
            U("emitterExtents", new z(0, 0, 0));
            U("emitterExtentsInner", new z(0,
                0, 0));
            U("emitterRadius", 0);
            U("emitterRadiusInner", 0);
            U("emitterShape", 0);
            U("initialVelocity", 1);
            U("wrap", !1);
            U("localSpace", !1);
            U("screenSpace", !1);
            U("wrapBounds", null);
            U("colorMap", $b.DEFAULT_PARAM_TEXTURE);
            U("normalMap", null);
            U("loop", !0);
            U("preWarm", !1);
            U("sort", 0);
            U("mode", 0);
            U("scene", null);
            U("lighting", !1);
            U("halfLambert", !1);
            U("intensity", 1);
            U("stretch", 0);
            U("alignToMotion", !1);
            U("depthSoftening", 0);
            U("mesh", null);
            U("particleNormal", new z(0, 1, 0));
            U("orientation", 0);
            U("depthWrite", !1);
            U("noFog", !1);
            U("blendType", 2);
            U("node", null);
            U("startAngle", 0);
            U("startAngle2", this.startAngle);
            U("animTilesX", 1);
            U("animTilesY", 1);
            U("animStartFrame", 0);
            U("animNumFrames", 1);
            U("animNumAnimations", 1);
            U("animIndex", 0);
            U("randomizeAnimIndex", !1);
            U("animSpeed", 1);
            U("animLoop", !0);
            this._gpuUpdater = new Fg(this, a);
            this._cpuUpdater = new pi(this);
            this.constantLightCube = a.scope.resolve("lightCube[0]");
            this.emitterPosUniform = new Float32Array(3);
            this.wrapBoundsUniform = new Float32Array(3);
            this.emitterScaleUniform = new Float32Array([1,
                1, 1
            ]);
            U("colorGraph", kp);
            U("colorGraph2", this.colorGraph);
            U("scaleGraph", Am);
            U("scaleGraph2", this.scaleGraph);
            U("alphaGraph", Am);
            U("alphaGraph2", this.alphaGraph);
            U("localVelocityGraph", Bm);
            U("localVelocityGraph2", this.localVelocityGraph);
            U("velocityGraph", Bm);
            U("velocityGraph2", this.velocityGraph);
            U("rotationSpeedGraph", zm);
            U("rotationSpeedGraph2", this.rotationSpeedGraph);
            U("radialSpeedGraph", zm);
            U("radialSpeedGraph2", this.radialSpeedGraph);
            this.lightCube = new Float32Array(18);
            this.lightCubeDir = Array(6);
            this.lightCubeDir[0] = new z(-1, 0, 0);
            this.lightCubeDir[1] = new z(1, 0, 0);
            this.lightCubeDir[2] = new z(0, -1, 0);
            this.lightCubeDir[3] = new z(0, 1, 0);
            this.lightCubeDir[4] = new z(0, 0, -1);
            this.lightCubeDir[5] = new z(0, 0, 1);
            this.animTilesParams = new Float32Array(2);
            this.animParams = new Float32Array(4);
            this.animIndexParams = new Float32Array(2);
            this.camera = this.particleDistance = this.vbOld = this.vbToSort = this.colorParam = this.internalTex2 = this.internalTex1 = this.internalTex0 = null;
            this.swapTex = !1;
            this.useMesh = !0;
            this.useCpu = !1;
            this.pack8 = !0;
            this.localBounds = new oa;
            this.worldBoundsNoTrail = new oa;
            this.worldBoundsTrail = [new oa, new oa];
            this.worldBounds = new oa;
            this.worldBoundsSize = new z;
            this.prevWorldBoundsSize = new z;
            this.prevWorldBoundsCenter = new z;
            this.prevEmitterExtents = this.emitterExtents;
            this.prevEmitterRadius = this.emitterRadius;
            this.worldBoundsMul = new z;
            this.worldBoundsAdd = new z;
            this.timeToSwitchBounds = 0;
            this.shaderParticleUpdateOnStop = this.shaderParticleUpdateNoRespawn = this.shaderParticleUpdateRespawn = null;
            this.numParticleIndices =
                this.numParticleVerts = 0;
            this.meshInstance = this.material = null;
            this.drawOrder = 0;
            this.seed = Math.random();
            this.fixedTimeStep = 1 / 60;
            this.maxSubSteps = 10;
            this.simTimeTotal = this.simTime = 0;
            this.beenReset = !1;
            this._layer = null;
            this.rebuild()
        };
    Object.assign($b.prototype, {
        onChangeCamera: function() {
            this.regenShader();
            this.resetMaterial()
        },
        calculateBoundsMad: function() {
            this.worldBoundsMul.x = 1 / this.worldBoundsSize.x;
            this.worldBoundsMul.y = 1 / this.worldBoundsSize.y;
            this.worldBoundsMul.z = 1 / this.worldBoundsSize.z;
            this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).scale(-1);
            this.worldBoundsAdd.x += .5;
            this.worldBoundsAdd.y += .5;
            this.worldBoundsAdd.z += .5
        },
        calculateWorldBounds: function() {
            if (this.node) {
                this.prevWorldBoundsSize.copy(this.worldBoundsSize);
                this.prevWorldBoundsCenter.copy(this.worldBounds.center);
                this.useCpu || (0 === this.emitterShape ? !this.emitterExtents.equals(this.prevEmitterExtents) : this.emitterRadius !== this.prevEmitterRadius) && this.calculateLocalBounds();
                var a = this.node.getWorldTransform();
                this.localSpace ? this.worldBoundsNoTrail.copy(this.localBounds) : this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds,
                    a);
                this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
                this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
                var b = this.simTimeTotal;
                b >= this.timeToSwitchBounds && (this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]), this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail), this.timeToSwitchBounds = b + this.lifetime);
                this.worldBounds.copy(this.worldBoundsTrail[0]);
                this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
                this.localSpace ? (this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds,
                    a), this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, a)) : (this.meshInstance.aabb.copy(this.worldBounds), this.meshInstance.mesh.aabb.copy(this.worldBounds));
                this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
                this.pack8 && this.calculateBoundsMad()
            }
        },
        resetWorldBounds: function() {
            this.node && (this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? J.IDENTITY : this.node.getWorldTransform()), this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail), this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
                this.worldBounds.copy(this.worldBoundsTrail[0]), this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2), this.prevWorldBoundsSize.copy(this.worldBoundsSize), this.prevWorldBoundsCenter.copy(this.worldBounds.center), this.timeToSwitchBounds = this.simTimeTotal = 0)
        },
        calculateLocalBounds: function() {
            var a = Number.MAX_VALUE,
                b = Number.MAX_VALUE,
                c = Number.MAX_VALUE,
                d = -Number.MAX_VALUE,
                e = -Number.MAX_VALUE,
                f = -Number.MAX_VALUE,
                g = 0,
                k = 0,
                h = this.lifetime / this.precision,
                l = [this.qVelocity, this.qVelocity2],
                n = [this.qLocalVelocity,
                    this.qLocalVelocity2
                ],
                p = [0, 0],
                q = [0, 0],
                r = [0, 0],
                t = [0, 0],
                u = [0, 0],
                x, v;
            for (x = 0; x < this.precision + 1; x++) {
                var w = Math.min(x, this.precision - 1);
                for (v = 0; 2 > v; v++) {
                    var y = n[v][3 * w] * h + p[v];
                    var A = n[v][3 * w + 1] * h + q[v];
                    var B = n[v][3 * w + 2] * h + r[v];
                    a = Math.min(y, a);
                    b = Math.min(A, b);
                    c = Math.min(B, c);
                    d = Math.max(y, d);
                    e = Math.max(A, e);
                    f = Math.max(B, f);
                    p[v] = y;
                    q[v] = A;
                    r[v] = B
                }
                for (v = 0; 2 > v; v++) u[v] += h * Math.sqrt(l[v][3 * w] * l[v][3 * w] + l[v][3 * w + 1] * l[v][3 * w + 1] + l[v][3 * w + 2] * l[v][3 * w + 2]);
                t[0] += this.qRadialSpeed[w] * h;
                t[1] += this.qRadialSpeed2[w] * h;
                g = Math.max(g, Math.max(Math.abs(t[0]), Math.abs(t[1])));
                k = Math.max(k, this.qScale[w])
            }
            0 === this.emitterShape ? (y = .5 * this.emitterExtents.x, A = .5 * this.emitterExtents.y, B = .5 * this.emitterExtents.z) : B = A = y = this.emitterRadius;
            h = Math.max(u[0], u[1]);
            Dh.x = a - k - y - g - h;
            Dh.y = b - k - A - g - h;
            Dh.z = c - k - B - g - h;
            Eh.x = d + k + y + g + h;
            Eh.y = e + k + A + g + h;
            Eh.z = f + k + B + g + h;
            this.localBounds.setMinMax(Dh, Eh)
        },
        rebuild: function() {
            var a, b = this.graphicsDevice;
            null === this.colorMap && (this.colorMap = $b.DEFAULT_PARAM_TEXTURE);
            this.spawnBounds = 0 === this.emitterShape ?
                this.emitterExtents : this.emitterRadius;
            this.useCpu = this.useCpu || 0 < this.sort || 1 >= b.maxVertexTextures || 64 > b.fragmentUniformsCount || b.forceCpuParticles || !b.extTextureFloat;
            this._destroyResources();
            this.pack8 = (this.pack8 || !b.textureFloatRenderable) && !this.useCpu;
            Wc = this.useCpu || this.pack8 ? 4 : 2;
            this.useMesh = !1;
            this.mesh && (65535 < this.numParticles * this.mesh.vertexBuffer.numVertices ? console.warn("WARNING: particle system can't render mesh particles because numParticles * numVertices is more than 65k. Reverting to quad particles.") :
                this.useMesh = !0);
            this.numParticlesPot = N.nextPowerOfTwo(this.numParticles);
            this.rebuildGraphs();
            this.calculateLocalBounds();
            this.resetWorldBounds();
            this.node && (this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? J.IDENTITY : this.node.getWorldTransform()), this.worldBoundsTrail[0].copy(this.worldBounds), this.worldBoundsTrail[1].copy(this.worldBounds), this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2), this.prevWorldBoundsSize.copy(this.worldBoundsSize), this.prevWorldBoundsCenter.copy(this.worldBounds.center),
                this.pack8 && this.calculateBoundsMad());
            this.vbToSort = Array(this.numParticles);
            for (a = 0; a < this.numParticles; a++) this.vbToSort[a] = [0, 0];
            this.particleDistance = new Float32Array(this.numParticles);
            this._gpuUpdater.randomize();
            this.particleTex = new Float32Array(this.numParticlesPot * Wc * 4);
            var c = null === this.node || this.localSpace ? z.ZERO : this.node.getPosition();
            0 === this.emitterShape && (null === this.node || this.localSpace ? le.setTRS(z.ZERO, Y.IDENTITY, this.spawnBounds) : le.setTRS(z.ZERO, this.node.getRotation(), Cm.copy(this.spawnBounds).mul(this.node.localScale)),
                Xc[0] = 0 != this.emitterExtents.x ? this.emitterExtentsInner.x / this.emitterExtents.x : 0, Xc[1] = 0 != this.emitterExtents.y ? this.emitterExtentsInner.y / this.emitterExtents.y : 0, Xc[2] = 0 != this.emitterExtents.z ? this.emitterExtentsInner.z / this.emitterExtents.z : 0);
            for (a = 0; a < this.numParticles; a++) this._cpuUpdater.calcSpawnPosition(this.particleTex, le, Xc, c, a), this.useCpu && (this.particleTex[4 * a + 3 + 8 * this.numParticlesPot] = 1);
            this.particleTexStart = new Float32Array(this.numParticlesPot * Wc * 4);
            for (a = 0; a < this.particleTexStart.length; a++) this.particleTexStart[a] =
                this.particleTex[a];
            this.useCpu || (this.pack8 ? (this.particleTexIN = Zb(b, this.numParticlesPot, Wc, this.particleTex, 7, 1, !1), this.particleTexOUT = Zb(b, this.numParticlesPot, Wc, this.particleTex, 7, 1, !1), this.particleTexStart = Zb(b, this.numParticlesPot, Wc, this.particleTexStart, 7, 1, !1)) : (this.particleTexIN = Zb(b, this.numParticlesPot, Wc, this.particleTex), this.particleTexOUT = Zb(b, this.numParticlesPot, Wc, this.particleTex), this.particleTexStart = Zb(b, this.numParticlesPot, Wc, this.particleTexStart)), this.rtParticleTexIN =
                new sa(b, this.particleTexIN, {
                    depth: !1
                }), this.rtParticleTexOUT = new sa(b, this.particleTexOUT, {
                    depth: !1
                }), this.swapTex = !1);
            a = (this.localSpace ? "#define LOCAL_SPACE\n" : "") + F.particleUpdaterInitPS + (this.pack8 ? F.particleInputRgba8PS + F.particleOutputRgba8PS : F.particleInputFloatPS + F.particleOutputFloatPS) + (0 === this.emitterShape ? F.particleUpdaterAABBPS : F.particleUpdaterSpherePS) + F.particleUpdaterStartPS;
            c = a + F.particleUpdaterNoRespawnPS + F.particleUpdaterEndPS;
            var d = a + F.particleUpdaterOnStopPS + F.particleUpdaterEndPS,
                e = this.emitterShape + "" + this.pack8 + this.localSpace;
            this.shaderParticleUpdateRespawn = Wa(b, F.fullscreenQuadVS, a + F.particleUpdaterRespawnPS + F.particleUpdaterEndPS, "fsQuad0" + e);
            this.shaderParticleUpdateNoRespawn = Wa(b, F.fullscreenQuadVS, c, "fsQuad1" + e);
            this.shaderParticleUpdateOnStop = Wa(b, F.fullscreenQuadVS, d, "fsQuad2" + e);
            this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
            this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
            this._allocate(this.numParticles);
            b = new sb(b);
            b.vertexBuffer = this.vertexBuffer;
            b.indexBuffer[0] = this.indexBuffer;
            b.primitive[0].type = 4;
            b.primitive[0].base = 0;
            b.primitive[0].count = this.numParticles * this.numParticleIndices;
            b.primitive[0].indexed = !0;
            this.material = new la;
            this.material.name = this.node.name;
            this.material.cull = 0;
            this.material.alphaWrite = !1;
            this.material.blend = !0;
            this.material.blendType = this.blendType;
            this.material.depthWrite = this.depthWrite;
            this.material.emitter = this;
            this.regenShader();
            this.resetMaterial();
            a = this.meshInstance ? this.meshInstance.visible :
                !0;
            this.meshInstance = new va(this.node, b, this.material);
            this.meshInstance.pick = !1;
            this.meshInstance.updateKey();
            this.meshInstance.cull = !0;
            this.meshInstance._noDepthDrawGl1 = !0;
            this.localSpace ? this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform()) : this.meshInstance.aabb.copy(this.worldBounds);
            this.meshInstance._updateAabb = !1;
            this.meshInstance.visible = a;
            this._initializeTextures();
            this.resetTime();
            this.addTime(0, !1);
            this.preWarm && this.prewarm(this.lifetime)
        },
        _isAnimated: function() {
            return 1 <=
                this.animNumFrames && (1 < this.animTilesX || 1 < this.animTilesY) && (this.colorMap && this.colorMap !== $b.DEFAULT_PARAM_TEXTURE || this.normalMap)
        },
        rebuildGraphs: function() {
            var a = this.precision,
                b = this.graphicsDevice,
                c;
            this.qLocalVelocity = this.localVelocityGraph.quantize(a);
            this.qVelocity = this.velocityGraph.quantize(a);
            this.qColor = this.colorGraph.quantizeClamped(a, 0, 1);
            this.qRotSpeed = this.rotationSpeedGraph.quantize(a);
            this.qScale = this.scaleGraph.quantize(a);
            this.qAlpha = this.alphaGraph.quantize(a);
            this.qRadialSpeed =
                this.radialSpeedGraph.quantize(a);
            this.qLocalVelocity2 = this.localVelocityGraph2.quantize(a);
            this.qVelocity2 = this.velocityGraph2.quantize(a);
            this.qColor2 = this.colorGraph2.quantizeClamped(a, 0, 1);
            this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(a);
            this.qScale2 = this.scaleGraph2.quantize(a);
            this.qAlpha2 = this.alphaGraph2.quantize(a);
            this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(a);
            for (c = 0; c < a; c++) this.qRotSpeed[c] *= N.DEG_TO_RAD, this.qRotSpeed2[c] *= N.DEG_TO_RAD;
            this.localVelocityUMax = new Float32Array(3);
            this.velocityUMax = new Float32Array(3);
            this.colorUMax = new Float32Array(3);
            this.rotSpeedUMax = [0];
            this.scaleUMax = [0];
            this.alphaUMax = [0];
            this.radialSpeedUMax = [0];
            this.qLocalVelocityDiv = Ld(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
            this.qVelocityDiv = Ld(this.qVelocity, this.qVelocity2, this.velocityUMax);
            this.qColorDiv = Ld(this.qColor, this.qColor2, this.colorUMax);
            this.qRotSpeedDiv = Ld(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
            this.qScaleDiv = Ld(this.qScale, this.qScale2, this.scaleUMax);
            this.qAlphaDiv = Ld(this.qAlpha, this.qAlpha2, this.alphaUMax);
            this.qRadialSpeedDiv = Ld(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);
            if (this.pack8) {
                var d = [0, 0, 0];
                Kd(this.qVelocity, d);
                var e = [0, 0, 0];
                Kd(this.qVelocity2, e);
                c = [0, 0, 0];
                Kd(this.qLocalVelocity, c);
                var f = [0, 0, 0];
                Kd(this.qLocalVelocity2, f);
                var g = [0];
                Kd(this.qRadialSpeed, g);
                var k = [0];
                Kd(this.qRadialSpeed2, k);
                var h = Math.max(d[0], e[0]);
                h = Math.max(h, d[1]);
                h = Math.max(h, e[1]);
                h = Math.max(h, d[2]);
                h = Math.max(h, e[2]);
                d = Math.max(c[0], f[0]);
                d = Math.max(d,
                    c[1]);
                d = Math.max(d, f[1]);
                d = Math.max(d, c[2]);
                d = Math.max(d, f[2]);
                this.maxVel = h + d + Math.max(g[0], k[0])
            }
            if (!this.useCpu) {
                this.internalTex0 = Zb(b, a, 1, Sk(this.qLocalVelocity, this.qLocalVelocityDiv));
                this.internalTex1 = Zb(b, a, 1, Sk(this.qVelocity, this.qVelocityDiv));
                c = this.qRotSpeed;
                f = this.qScale;
                g = this.qScaleDiv;
                k = this.qRotSpeedDiv;
                h = this.qAlphaDiv;
                d = Array(4 * c.length);
                for (e = 0; e < c.length; e++) d[4 * e] = c[e], d[4 * e + 1] = f[e], d[4 * e + 2] = 0, d[4 * e + 3] = (255 * g[e] << 16 | 255 * k[e] << 8 | 255 * h[e]) / 16777216;
                this.internalTex2 = Zb(b, a, 1,
                    d);
                c = this.qRadialSpeed;
                f = this.qRadialSpeedDiv;
                g = Array(4 * c.length);
                for (k = 0; k < c.length; k++) g[4 * k] = c[k], g[4 * k + 1] = f[k], g[4 * k + 2] = 0, g[4 * k + 3] = 0;
                this.internalTex3 = Zb(b, a, 1, g)
            }
            c = this.qColor;
            f = this.qAlpha;
            g = Array(4 * f.length);
            for (k = 0; k < f.length; k++) g[4 * k] = c[3 * k], g[4 * k + 1] = c[3 * k + 1], g[4 * k + 2] = c[3 * k + 2], g[4 * k + 3] = f[k];
            this.colorParam = Zb(b, a, 1, g, 7, 1, !0)
        },
        _initializeTextures: function() {
            this.colorMap && (this.material.setParameter("colorMap", this.colorMap), this.lighting && this.normalMap && this.material.setParameter("normalMap",
                this.normalMap))
        },
        regenShader: function() {
            var a = this.graphicsDevice.getProgramLibrary(),
                b = null !== this.normalMap;
            this.normalOption = 0;
            this.lighting && (this.normalOption = b ? 2 : 1);
            this.material.updateShader = function() {
                this.emitter.scene && this.emitter.camera != this.emitter.scene._activeCamera && (this.emitter.camera = this.emitter.scene._activeCamera, this.emitter.onChangeCamera());
                this.shader = a.getProgram("particle", {
                    useCpu: this.emitter.useCpu,
                    normal: this.emitter.normalOption,
                    halflambert: this.emitter.halfLambert,
                    stretch: this.emitter.stretch,
                    alignToMotion: this.emitter.alignToMotion,
                    soft: this.emitter.depthSoftening,
                    mesh: this.emitter.useMesh,
                    gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
                    toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
                    fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none",
                    wrap: this.emitter.wrap && this.emitter.wrapBounds,
                    localSpace: this.emitter.localSpace,
                    screenSpace: this.emitter.inTools ? !1 : this.emitter.screenSpace,
                    blend: this.blendType,
                    animTex: this.emitter._isAnimated(),
                    animTexLoop: this.emitter.animLoop,
                    pack8: this.emitter.pack8,
                    customFace: 0 != this.emitter.orientation
                })
            };
            this.material.updateShader()
        },
        resetMaterial: function() {
            var a = this.material;
            a.setParameter("stretch", this.stretch);
            this._isAnimated() && (a.setParameter("animTexTilesParams", this.animTilesParams), a.setParameter("animTexParams", this.animParams), a.setParameter("animTexIndexParams", this.animIndexParams));
            a.setParameter("colorMult", this.intensity);
            this.useCpu || (a.setParameter("internalTex0", this.internalTex0),
                a.setParameter("internalTex1", this.internalTex1), a.setParameter("internalTex2", this.internalTex2), a.setParameter("internalTex3", this.internalTex3));
            a.setParameter("colorParam", this.colorParam);
            a.setParameter("numParticles", this.numParticles);
            a.setParameter("numParticlesPot", this.numParticlesPot);
            a.setParameter("lifetime", this.lifetime);
            a.setParameter("rate", this.rate);
            a.setParameter("rateDiv", this.rate2 - this.rate);
            a.setParameter("seed", this.seed);
            a.setParameter("scaleDivMult", this.scaleUMax[0]);
            a.setParameter("alphaDivMult",
                this.alphaUMax[0]);
            a.setParameter("radialSpeedDivMult", this.radialSpeedUMax[0]);
            a.setParameter("graphNumSamples", this.precision);
            a.setParameter("graphSampleSize", 1 / this.precision);
            a.setParameter("emitterScale", new Float32Array([1, 1, 1]));
            this.pack8 && (this._gpuUpdater._setInputBounds(), a.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform), a.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform), a.setParameter("maxVel", this.maxVel));
            this.wrap && this.wrapBounds && (this.wrapBoundsUniform[0] =
                this.wrapBounds.x, this.wrapBoundsUniform[1] = this.wrapBounds.y, this.wrapBoundsUniform[2] = this.wrapBounds.z, a.setParameter("wrapBounds", this.wrapBoundsUniform));
            this.colorMap && a.setParameter("colorMap", this.colorMap);
            this.lighting && this.normalMap && a.setParameter("normalMap", this.normalMap);
            0 < this.depthSoftening && a.setParameter("softening", 1 / (this.depthSoftening * this.depthSoftening * 100));
            0 < this.stretch && (a.cull = 0);
            this._compParticleFaceParams()
        },
        _compParticleFaceParams: function() {
            if (0 == this.orientation) {
                var a =
                    new Float32Array([1, 0, 0]);
                var b = new Float32Array([0, 0, 1])
            } else {
                a = 1 == this.orientation ? this.particleNormal.normalize() : (null === this.node ? J.IDENTITY : this.node.getWorldTransform()).transformVector(this.particleNormal).normalize();
                var c = new z(1, 0, 0);
                1 == Math.abs(c.dot(a)) && c.set(0, 0, 1);
                b = (new z).cross(a, c).normalize();
                c.cross(b, a).normalize();
                a = new Float32Array([c.x, c.y, c.z]);
                b = new Float32Array([b.x, b.y, b.z])
            }
            this.material.setParameter("faceTangent", a);
            this.material.setParameter("faceBinorm", b)
        },
        _allocate: function(a) {
            var b =
                a * this.numParticleVerts,
                c = a * this.numParticleIndices;
            if (void 0 === this.vertexBuffer || this.vertexBuffer.getNumVertices() !== b) {
                if (this.useCpu) var d = [{
                    semantic: "ATTR0",
                    components: 4,
                    type: 6
                }, {
                    semantic: "ATTR1",
                    components: 4,
                    type: 6
                }, {
                    semantic: "ATTR2",
                    components: 4,
                    type: 6
                }, {
                    semantic: "ATTR3",
                    components: 1,
                    type: 6
                }, {
                    semantic: "ATTR4",
                    components: this.useMesh ? 4 : 2,
                    type: 6
                }];
                else d = [{
                    semantic: "ATTR0",
                    components: 4,
                    type: 6
                }], this.useMesh && d.push({
                    semantic: "ATTR1",
                    components: 2,
                    type: 6
                });
                d = new Na(this.graphicsDevice, d);
                this.vertexBuffer =
                    new ab(this.graphicsDevice, d, b, 1);
                this.indexBuffer = new dc(this.graphicsDevice, 1, c);
                d = new Float32Array(this.vertexBuffer.lock());
                if (this.useMesh) {
                    var e = new Float32Array(this.mesh.vertexBuffer.lock());
                    var f = e.length / this.mesh.vertexBuffer.numVertices;
                    for (c = 0; c < this.mesh.vertexBuffer.format.elements.length; c++)
                        if ("TEXCOORD0" === this.mesh.vertexBuffer.format.elements[c].name) {
                            var g = this.mesh.vertexBuffer.format.elements[c].offset / 4;
                            break
                        }
                }
                for (c = 0; c < b; c++) {
                    var k = Math.floor(c / this.numParticleVerts);
                    if (this.useMesh) {
                        var h =
                            c % this.numParticleVerts;
                        d[6 * c] = e[h * f];
                        d[6 * c + 1] = e[h * f + 1];
                        d[6 * c + 2] = e[h * f + 2];
                        d[6 * c + 3] = k;
                        d[6 * c + 4] = e[h * f + g + 0];
                        d[6 * c + 5] = e[h * f + g + 1]
                    } else h = c % 4, d[4 * c] = ym[h][0], d[4 * c + 1] = ym[h][1], d[4 * c + 2] = 0, d[4 * c + 3] = k
                }
                this.useCpu && (this.vbCPU = new Float32Array(d), this.vbOld = new Float32Array(this.vbCPU.length));
                this.vertexBuffer.unlock();
                this.useMesh && this.mesh.vertexBuffer.unlock();
                b = 0;
                f = new Uint16Array(this.indexBuffer.lock());
                this.useMesh && (e = new Uint16Array(this.mesh.indexBuffer[0].lock()));
                for (c = 0; c < a; c++)
                    if (this.useMesh)
                        for (g =
                            0; g < this.numParticleIndices; g++) f[c * this.numParticleIndices + g] = e[g] + c * this.numParticleVerts;
                    else g = 4 * c, f[b++] = g, f[b++] = g + 1, f[b++] = g + 2, f[b++] = g, f[b++] = g + 2, f[b++] = g + 3;
                this.indexBuffer.unlock();
                this.useMesh && this.mesh.indexBuffer[0].unlock()
            }
        },
        reset: function() {
            this.beenReset = !0;
            this.seed = Math.random();
            this.material.setParameter("seed", this.seed);
            if (this.useCpu)
                for (var a = 0; a < this.particleTexStart.length; a++) this.particleTex[a] = this.particleTexStart[a];
            else this._initializeTextures();
            this.resetWorldBounds();
            this.resetTime();
            a = this.loop;
            this.loop = !0;
            this.addTime(0, !1);
            this.loop = a;
            this.preWarm && this.prewarm(this.lifetime)
        },
        prewarm: function(a) {
            var b = Math.min(Math.floor(a / this.lifetime * this.precision), this.precision);
            a /= b;
            for (var c = 0; c < b; c++) this.addTime(a, !1)
        },
        resetTime: function() {
            var a = Math.max(this.rate, this.rate2) * this.numParticles + this.lifetime;
            this.endTime = Date.now() + 1E3 * a
        },
        finishFrame: function() {
            this.useCpu && this.vertexBuffer.unlock()
        },
        addTime: function(a, b) {
            var c = this.graphicsDevice;
            this.simTimeTotal +=
                a;
            this.calculateWorldBounds();
            if (this._isAnimated()) {
                var d = this.animTilesParams;
                d[0] = 1 / this.animTilesX;
                d[1] = 1 / this.animTilesY;
                d = this.animParams;
                d[0] = this.animStartFrame;
                d[1] = this.animNumFrames * this.animSpeed;
                d[2] = this.animNumFrames - 1;
                d[3] = this.animNumAnimations - 1;
                d = this.animIndexParams;
                d[0] = this.animIndex;
                d[1] = this.randomizeAnimIndex
            }
            this.scene && this.camera != this.scene._activeCamera && (this.camera = this.scene._activeCamera, this.onChangeCamera());
            0 === this.emitterShape && (Xc[0] = 0 != this.emitterExtents.x ?
                this.emitterExtentsInner.x / this.emitterExtents.x : 0, Xc[1] = 0 != this.emitterExtents.y ? this.emitterExtentsInner.y / this.emitterExtents.y : 0, Xc[2] = 0 != this.emitterExtents.z ? this.emitterExtentsInner.z / this.emitterExtents.z : 0, null === this.meshInstance.node ? le.setTRS(z.ZERO, Y.IDENTITY, this.emitterExtents) : le.setTRS(z.ZERO, this.meshInstance.node.getRotation(), Cm.copy(this.emitterExtents).mul(this.meshInstance.node.localScale)));
            d = null === this.meshInstance.node ? z.ONE : this.meshInstance.node.localScale;
            this.emitterScaleUniform[0] =
                d.x;
            this.emitterScaleUniform[1] = d.y;
            this.emitterScaleUniform[2] = d.z;
            this.material.setParameter("emitterScale", this.emitterScaleUniform);
            if (this.localSpace && this.meshInstance.node) {
                var e = this.meshInstance.node.getPosition();
                this.emitterPosUniform[0] = e.x;
                this.emitterPosUniform[1] = e.y;
                this.emitterPosUniform[2] = e.z;
                this.material.setParameter("emitterPos", this.emitterPosUniform)
            }
            this._compParticleFaceParams();
            this.useCpu ? (c = new Float32Array(this.vertexBuffer.lock()), this._cpuUpdater.update(c, this.vbToSort,
                this.particleTex, le, Xc, e, a, b)) : this._gpuUpdater.update(c, le, Xc, a, b);
            if (!this.loop && Date.now() > this.endTime) {
                if (this.onFinished) this.onFinished();
                this.meshInstance.visible = !1
            }
            this.meshInstance && (this.meshInstance.drawOrder = this.drawOrder)
        },
        _destroyResources: function() {
            this.particleTexIN && (this.particleTexIN.destroy(), this.particleTexIN = null);
            this.particleTexOUT && (this.particleTexOUT.destroy(), this.particleTexOUT = null);
            this.particleTexStart && this.particleTexStart.destroy && (this.particleTexStart.destroy(),
                this.particleTexStart = null);
            this.rtParticleTexIN && (this.rtParticleTexIN.destroy(), this.rtParticleTexIN = null);
            this.rtParticleTexOUT && (this.rtParticleTexOUT.destroy(), this.rtParticleTexOUT = null);
            this.internalTex0 && (this.internalTex0.destroy(), this.internalTex0 = null);
            this.internalTex1 && (this.internalTex1.destroy(), this.internalTex1 = null);
            this.internalTex2 && (this.internalTex2.destroy(), this.internalTex2 = null);
            this.internalTex3 && (this.internalTex3.destroy(), this.internalTex3 = null);
            this.colorParam && (this.colorParam.destroy(),
                this.colorParam = null);
            this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBuffer = void 0);
            this.indexBuffer && (this.indexBuffer.destroy(), this.indexBuffer = void 0);
            this.material && (this.material.destroy(), this.material = null)
        },
        destroy: function() {
            this.camera = null;
            this._destroyResources()
        }
    });
    ra.prototype = Object.create(M.prototype);
    ra.prototype.constructor = ra;
    ra.prototype.destroy = function() {
        this.root = null;
        this.defaultMaterial.destroy();
        this.defaultMaterial = null;
        this.off()
    };
    Object.defineProperty(ra.prototype,
        "fog", {
            get: function() {
                return this._fog
            },
            set: function(a) {
                a !== this._fog && (this._fog = a, this.updateShaders = !0)
            }
        });
    Object.defineProperty(ra.prototype, "gammaCorrection", {
        get: function() {
            return this._gammaCorrection
        },
        set: function(a) {
            a !== this._gammaCorrection && (this._gammaCorrection = a, this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype, "toneMapping", {
        get: function() {
            return this._toneMapping
        },
        set: function(a) {
            a !== this._toneMapping && (this._toneMapping = a, this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype,
        "skybox", {
            get: function() {
                return this._skyboxCubeMap
            },
            set: function(a) {
                this._skyboxCubeMap = a;
                this._resetSkyboxModel();
                this.updateShaders = !0
            }
        });
    Object.defineProperty(ra.prototype, "skyboxIntensity", {
        get: function() {
            return this._skyboxIntensity
        },
        set: function(a) {
            this._skyboxIntensity = a;
            this._resetSkyboxModel();
            this.updateShaders = !0
        }
    });
    Object.defineProperty(ra.prototype, "skyboxRotation", {
        get: function() {
            return this._skyboxRotation
        },
        set: function(a) {
            this._skyboxRotation.equals(a) || (this._skyboxRotation.copy(a),
                this._resetSkyboxModel(), this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype, "skyboxMip", {
        get: function() {
            return this._skyboxMip
        },
        set: function(a) {
            this._skyboxMip = a;
            this._resetSkyboxModel();
            this.updateShaders = !0
        }
    });
    Object.defineProperty(ra.prototype, "skyboxPrefiltered128", {
        get: function() {
            return this._skyboxPrefiltered[0]
        },
        set: function(a) {
            this._skyboxPrefiltered[0] !== a && (this._skyboxPrefiltered[0] = a, this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype, "skyboxPrefiltered64", {
        get: function() {
            return this._skyboxPrefiltered[1]
        },
        set: function(a) {
            this._skyboxPrefiltered[1] !== a && (this._skyboxPrefiltered[1] = a, this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype, "skyboxPrefiltered32", {
        get: function() {
            return this._skyboxPrefiltered[2]
        },
        set: function(a) {
            this._skyboxPrefiltered[2] !== a && (this._skyboxPrefiltered[2] = a, this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype, "skyboxPrefiltered16", {
        get: function() {
            return this._skyboxPrefiltered[3]
        },
        set: function(a) {
            this._skyboxPrefiltered[3] !== a && (this._skyboxPrefiltered[3] = a,
                this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype, "skyboxPrefiltered8", {
        get: function() {
            return this._skyboxPrefiltered[4]
        },
        set: function(a) {
            this._skyboxPrefiltered[4] !== a && (this._skyboxPrefiltered[4] = a, this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype, "skyboxPrefiltered4", {
        get: function() {
            return this._skyboxPrefiltered[5]
        },
        set: function(a) {
            this._skyboxPrefiltered[5] !== a && (this._skyboxPrefiltered[5] = a, this.updateShaders = !0)
        }
    });
    Object.defineProperty(ra.prototype, "drawCalls", {
        get: function() {
            var a =
                this.layers._meshInstances;
            a.length || (this.layers._update(), a = this.layers._meshInstances);
            return a
        },
        set: function(a) {}
    });
    Object.defineProperty(ra.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            var b = this._layers;
            this._layers = a;
            this.fire("set:layers", b, a)
        }
    });
    ra.prototype.applySettings = function(a) {
        this._gravity.set(a.physics.gravity[0], a.physics.gravity[1], a.physics.gravity[2]);
        this.ambientLight.set(a.render.global_ambient[0], a.render.global_ambient[1], a.render.global_ambient[2]);
        this._fog = a.render.fog;
        this.fogColor.set(a.render.fog_color[0], a.render.fog_color[1], a.render.fog_color[2]);
        this.fogStart = a.render.fog_start;
        this.fogEnd = a.render.fog_end;
        this.fogDensity = a.render.fog_density;
        this._gammaCorrection = a.render.gamma_correction;
        this._toneMapping = a.render.tonemapping;
        this.lightmapSizeMultiplier = a.render.lightmapSizeMultiplier;
        this.lightmapMaxResolution = a.render.lightmapMaxResolution;
        this.lightmapMode = a.render.lightmapMode;
        this.exposure = a.render.exposure;
        this._skyboxIntensity =
            void 0 === a.render.skyboxIntensity ? 1 : a.render.skyboxIntensity;
        this._skyboxMip = void 0 === a.render.skyboxMip ? 0 : a.render.skyboxMip;
        void 0 !== a.render.skyboxRotation && this._skyboxRotation.set(a.render.skyboxRotation);
        this._resetSkyboxModel();
        this.updateShaders = !0
    };
    ra.prototype._updateSkybox = function(a) {
        if (!this.skyboxModel) {
            var b = [0, 1, 3, 4, 5, 6],
                c = this._skyboxMip ? this._skyboxPrefiltered[b[this._skyboxMip]] || this._skyboxPrefiltered[0] || this._skyboxCubeMap : this._skyboxCubeMap || this._skyboxPrefiltered[0];
            if (c) {
                this._skyboxIsRenderTarget =
                    c._isRenderTarget ? !0 : !1;
                var d = new la,
                    e = this;
                d.updateShader = function(k, h, l, n, p) {
                    this.shader = a.getProgramLibrary().getProgram("skybox", {
                        rgbm: "rgbm" === c.type,
                        hdr: "rgbm" === c.type || 14 === c.format,
                        useIntensity: 1 !== e.skyboxIntensity,
                        useCubeMapRotation: !e.skyboxRotation.equals(Y.IDENTITY),
                        useRightHandedCubeMap: e._skyboxIsRenderTarget,
                        mip: c.fixCubemapSeams ? e.skyboxMip : 0,
                        fixSeams: c.fixCubemapSeams,
                        gamma: 1 === p ? e.gammaCorrection ? 3 : 0 : e.gammaCorrection,
                        toneMapping: 1 === p ? 0 : e.toneMapping
                    })
                };
                d.updateShader();
                d.setParameter("texture_cubeMap",
                    c);
                this.skyboxRotation.equals(Y.IDENTITY) || (this._skyboxRotationMat4 || (this._skyboxRotationMat4 = new J), this._skyboxRotationMat3 || (this._skyboxRotationMat3 = new rb), this._skyboxRotationMat4.setTRS(pc.Vec3.ZERO, this._skyboxRotation, pc.Vec3.ONE), this._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3), d.setParameter("cubeMapRotationMatrix", this._skyboxRotationMat3.data));
                d.cull = 2;
                d.depthWrite = !1;
                if (b = this.layers.getLayerById(2)) {
                    var f = new Z,
                        g = Hg(a);
                    d = new va(f, g, d);
                    d.cull = !1;
                    d._noDepthDrawGl1 = !0;
                    g = new tb;
                    g.graph = f;
                    g.meshInstances = [d];
                    this.skyboxModel = g;
                    b.addMeshInstances(g.meshInstances);
                    this.skyLayer = b;
                    this._firstUpdateSkybox && (b.enabled = !0, this._firstUpdateSkybox = !1);
                    this.fire("set:skybox", c)
                }
            }
        }
    };
    ra.prototype._resetSkyboxModel = function() {
        this.skyboxModel && (this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances), this.skyboxModel.destroy());
        this.skyboxModel = null;
        this.updateSkybox = !0
    };
    ra.prototype.setSkybox = function(a) {
        var b;
        a || (a = [null, null, null, null, null, null, null]);
        var c = !1;
        this._skyboxCubeMap !==
            a[0] && (c = !0);
        if (!c)
            for (b = 0; 6 > b && !c; b++) this._skyboxPrefiltered[b] !== a[b + 1] && (c = !0);
        if (c) {
            for (b = 0; 6 > b; b++) this._skyboxPrefiltered[b] = a[b + 1];
            this.skybox = a[0]
        }
    };
    ra.prototype.destroy = function() {
        this.skybox = null
    };
    ra.prototype.addModel = function(a) {
        if (!this.containsModel(a)) {
            var b = this.layers.getLayerById(0);
            b && (b.addMeshInstances(a.meshInstances), this._models.push(a))
        }
    };
    ra.prototype.addShadowCaster = function(a) {
        var b = this.layers.getLayerById(0);
        b && b.addShadowCasters(a.meshInstances)
    };
    ra.prototype.removeModel =
        function(a) {
            var b = this._models.indexOf(a);
            if (-1 !== b) {
                var c = this.layers.getLayerById(0);
                c && (c.removeMeshInstances(a.meshInstances), this._models.splice(b, 1))
            }
        };
    ra.prototype.removeShadowCasters = function(a) {
        var b = this.layers.getLayerById(0);
        b && b.removeShadowCasters(a.meshInstances)
    };
    ra.prototype.containsModel = function(a) {
        return 0 <= this._models.indexOf(a)
    };
    ra.prototype.getModels = function(a) {
        return this._models
    };
    if (fd()) {
        var ac = function(a, b, c) {
            c = c || {};
            this.volume = void 0 === c.volume ? 1 : c.volume;
            this.loop =
                void 0 === c.loop ? !1 : c.loop;
            this.pitch = void 0 === c.pitch ? 1 : c.pitch;
            this.sound = b;
            this.suspended = this.paused = !1;
            this.startOffset = this.startTime = 0;
            this.manager = a;
            this.source = null;
            this.gain = a.context.createGain()
        };
        Object.assign(ac.prototype, {
            play: function() {
                if (this.source) throw Error("Call stop() before calling play()");
                this._createSource();
                if (this.source && (this.startTime = this.manager.context.currentTime, this.source.start(0, this.startOffset % this.source.buffer.duration), this.setVolume(this.volume), this.setLoop(this.loop),
                        this.setPitch(this.pitch), this.manager.on("volumechange", this.onManagerVolumeChange, this), this.manager.on("suspend", this.onManagerSuspend, this), this.manager.on("resume", this.onManagerResume, this), this.manager.suspended)) this.onManagerSuspend()
            },
            pause: function() {
                this.source && (this.paused = !0, this.startOffset += this.manager.context.currentTime - this.startTime, this.source.stop(0), this.source = null)
            },
            unpause: function() {
                this.source || !this.paused ? console.warn("Call pause() before unpausing.") : (this._createSource(),
                    this.source && (this.startTime = this.manager.context.currentTime, this.source.start(0, this.startOffset % this.source.buffer.duration), this.setVolume(this.volume), this.setLoop(this.loop), this.setPitch(this.pitch), this.paused = !1))
            },
            stop: function() {
                this.source && (this.source.stop(0), this.source = null);
                this.manager.off("volumechange", this.onManagerVolumeChange, this);
                this.manager.off("suspend", this.onManagerSuspend, this);
                this.manager.off("resume", this.onManagerResume, this)
            },
            setLoop: function(a) {
                this.loop = a;
                this.source &&
                    (this.source.loop = a)
            },
            setVolume: function(a) {
                this.volume = a = N.clamp(a, 0, 1);
                this.gain && (this.gain.gain.value = a * this.manager.volume)
            },
            setPitch: function(a) {
                this.pitch = a;
                this.source && (this.source.playbackRate.value = a)
            },
            isPlaying: function() {
                return !this.paused && this.source.playbackState === this.source.PLAYING_STATE
            },
            getDuration: function() {
                return this.source ? this.source.buffer.duration : 0
            },
            _createSource: function() {
                var a = this.manager.context;
                this.sound.buffer && (this.source = a.createBufferSource(), this.source.buffer =
                    this.sound.buffer, this.source.connect(this.gain), this.gain.connect(a.destination), this.loop || (this.source.onended = this.pause.bind(this)))
            }
        })
    } else we() ? (ac = function(a, b, c) {
            this.volume = c.volume || 1;
            this.loop = c.loop || !1;
            this.sound = b;
            this.pitch = void 0 !== c.pitch ? c.pitch : 1;
            this.suspended = this.paused = !1;
            this.manager = a;
            b.audio && (this.source = b.audio.cloneNode(!1), this.source.pause())
        }, Object.assign(ac.prototype, {
            play: function() {
                this.source && (this.paused = !1, this.setVolume(this.volume), this.setLoop(this.loop),
                    this.setPitch(this.pitch), this.source.play());
                this.manager.on("volumechange", this.onManagerVolumeChange, this);
                this.manager.on("suspend", this.onManagerSuspend, this);
                this.manager.on("resume", this.onManagerResume, this);
                if (this.manager.suspended) this.onManagerSuspend()
            },
            pause: function() {
                this.source && (this.paused = !0, this.source.pause())
            },
            unpause: function() {
                this.source && (this.paused = !1, this.source.play())
            },
            stop: function() {
                this.source && this.source.pause();
                this.manager.off("volumechange", this.onManagerVolumeChange,
                    this);
                this.manager.off("suspend", this.onManagerSuspend, this);
                this.manager.off("resume", this.onManagerResume, this)
            },
            setVolume: function(a) {
                this.volume = a = N.clamp(a, 0, 1);
                this.source && (this.source.volume = a * this.manager.volume)
            },
            setLoop: function(a) {
                this.loop = a;
                this.source && (this.source.loop = a)
            },
            setPitch: function(a) {
                this.pitch = a;
                this.source && (this.source.playbackRate = a)
            },
            getDuration: function() {
                return this.source && !isNaN(this.source.duration) ? this.source.duration : 0
            },
            isPlaying: function() {
                return !this.source.paused
            }
        })) :
        ac = function() {};
    Object.assign(ac.prototype, {
        getVolume: function() {
            return this.volume
        },
        getLoop: function() {
            return this.loop
        },
        getPitch: function() {
            return this.pitch
        },
        onManagerVolumeChange: function() {
            this.setVolume(this.getVolume())
        },
        onManagerSuspend: function() {
            this.isPlaying() && !this.suspended && (this.suspended = !0, this.pause())
        },
        onManagerResume: function() {
            this.suspended && (this.suspended = !1, this.unpause())
        }
    });
    var Kf = "inverse";
    if (fd()) {
        var $a = function(a, b, c) {
            ac.call(this, a, b, c);
            this.position = new z;
            this.velocity =
                new z;
            this.panner = a.context.createPanner()
        };
        $a.prototype = Object.create(ac.prototype);
        $a.prototype.constructor = $a;
        Object.assign($a.prototype, {
            getPosition: function() {
                return this.position
            },
            setPosition: function(a) {
                this.position.copy(a);
                this.panner.setPosition(a.x, a.y, a.z)
            },
            getVelocity: function() {
                return this.velocity
            },
            setVelocity: function(a) {
                this.velocity.copy(a);
                this.panner.setVelocity(a.x, a.y, a.z)
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(a) {
                this.panner.maxDistance =
                    a
            },
            getMinDistance: function() {
                return this.panner.refDistance
            },
            setMinDistance: function(a) {
                this.panner.refDistance = a
            },
            getRollOffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRollOffFactor: function(a) {
                this.panner.rolloffFactor = a
            },
            getDistanceModel: function() {
                return this.pannel.distanceModel
            },
            setDistanceModel: function(a) {
                this.panner.distanceModel = a
            },
            _createSource: function() {
                var a = this.manager.context;
                this.source = a.createBufferSource();
                this.source.buffer = this.sound.buffer;
                this.source.connect(this.panner);
                this.panner.connect(this.gain);
                this.gain.connect(a.destination);
                this.loop || (this.source.onended = this.pause.bind(this))
            }
        })
    } else if (we()) {
        var fk = new z;
        $a = function(a, b) {
            ac.call(this, a, b);
            this.position = new z;
            this.velocity = new z;
            this.maxDistance = 1E4;
            this.rollOffFactor = this.minDistance = 1;
            this.distanceModel = Kf
        };
        $a.prototype = Object.create(ac.prototype);
        $a.prototype.constructor = $a;
        Object.assign($a.prototype, {
            getPosition: function() {
                return this.position
            },
            setPosition: function(a) {
                this.position.copy(a);
                if (this.source) {
                    var b =
                        this.manager.listener.getPosition();
                    a = this.minDistance;
                    var c = this.maxDistance,
                        d = this.rollOffFactor,
                        e = this.distanceModel;
                    fk = fk.sub2(b, this.position);
                    b = fk.length();
                    if (b < a) a = 1;
                    else if (b > c) a = 0;
                    else {
                        var f = 0;
                        "linear" === e ? f = 1 - d * (b - a) / (c - a) : e === Kf ? f = a / (a + d * (b - a)) : "exponential" === e && (f = Math.pow(b / a, -d));
                        a = N.clamp(f, 0, 1)
                    }
                    c = this.getVolume();
                    this.source.volume = c * a
                }
            },
            getVelocity: function() {
                return this.velocity
            },
            setVelocity: function(a) {
                this.velocity.copy(a)
            },
            getMaxDistance: function() {
                return this.maxDistance
            },
            setMaxDistance: function(a) {
                this.maxDistance =
                    a
            },
            getMinDistance: function() {
                return this.minDistance
            },
            setMinDistance: function(a) {
                this.minDistance = a
            },
            getRollOffFactor: function() {
                return this.rollOffFactor
            },
            setRollOffFactor: function(a) {
                this.rollOffFactor = a
            },
            getDistanceModel: function() {
                return this.distanceModel
            },
            setDistanceModel: function(a) {
                this.distanceModel = a
            }
        })
    } else $a = function() {};
    Object.assign(wi.prototype, {
        getPosition: function() {
            return this.position
        },
        setPosition: function(a) {
            this.position.copy(a);
            this.listener && this.listener.setPosition(a.x, a.y,
                a.z)
        },
        getVelocity: function() {
            return this.velocity
        },
        setVelocity: function(a) {
            this.velocity.copy(a);
            this.listener && this.listener.setPosition(a.x, a.y, a.z)
        },
        setOrientation: function(a) {
            this.orientation.copy(a);
            this.listener && this.listener.setOrientation(-a.data[8], -a.data[9], -a.data[10], a.data[4], a.data[5], a.data[6])
        },
        getOrientation: function() {
            return this.orientation
        }
    });
    ec.prototype = Object.create(M.prototype);
    ec.prototype.constructor = ec;
    Object.assign(ec.prototype, {
        suspend: function() {
            this.suspended = !0;
            this.fire("suspend")
        },
        resume: function() {
            this.suspended = !1;
            this.fire("resume")
        },
        destroy: function() {
            window.removeEventListener("mousedown", this.resumeContext);
            window.removeEventListener("touchend", this.resumeContext);
            this.fire("destroy");
            this.context && this.context.close && (this.context.close(), this.context = null)
        },
        playSound: function(a, b) {
            b = b || {};
            var c = null;
            ac && (c = new ac(this, a, b), c.play());
            return c
        },
        playSound3d: function(a, b, c) {
            c = c || {};
            var d = null;
            $a && (d = new $a(this, a, c), d.setPosition(b), c.volume && d.setVolume(c.volume), c.loop &&
                d.setLoop(c.loop), c.maxDistance && d.setMaxDistance(c.maxDistance), c.minDistance && d.setMinDistance(c.minDistance), c.rollOffFactor && d.setRollOffFactor(c.rollOffFactor), c.distanceModel && d.setDistanceModel(c.distanceModel), d.play());
            return d
        }
    });
    Object.defineProperty(ec.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            this._volume = a = N.clamp(a, 0, 1);
            this.fire("volumechange", a)
        }
    });
    Rb.prototype.getDuration = function() {
        return this.duration
    };
    Rb.prototype.getName = function() {
        return this.name
    };
    Rb.prototype.getNode = function(a) {
        return this._nodeDict[a]
    };
    Object.defineProperty(Rb.prototype, "nodes", {
        get: function() {
            return this._nodes
        }
    });
    Rb.prototype.getNodes = function() {
        return this._nodes
    };
    Rb.prototype.setDuration = function(a) {
        this.duration = a
    };
    Rb.prototype.setName = function(a) {
        this.name = a
    };
    Rb.prototype.addNode = function(a) {
        this._nodes.push(a);
        this._nodeDict[a._name] = a
    };
    Object.defineProperties(vf.prototype, {
        morphPositions: {
            get: function() {
                return !!this._vertexBufferPositions || !!this.texturePositions
            }
        },
        morphNormals: {
            get: function() {
                return !!this._vertexBufferNormals || !!this.textureNormals
            }
        }
    });
    Object.assign(vf.prototype, {
        _postInit: function() {
            this.options = null
        },
        _initVertexBuffers: function(a) {
            var b = this.options;
            this._vertexBufferPositions = this._createVertexBuffer(a, b.deltaPositions, b.deltaPositionsType);
            this._vertexBufferNormals = this._createVertexBuffer(a, b.deltaNormals, b.deltaNormalsType);
            this._vertexBufferPositions && (this.deltaPositions = this._vertexBufferPositions.lock())
        },
        _createVertexBuffer: function(a,
            b, c) {
            return b ? new ab(a, new Na(a, [{
                semantic: "ATTR0",
                components: 3,
                type: c || 6
            }]), b.length / 3, 0, b) : null
        },
        _setTexture: function(a, b) {
            this[a] = b
        },
        destroy: function() {
            this._vertexBufferPositions && (this._vertexBufferPositions.destroy(), this._vertexBufferPositions = null);
            this._vertexBufferNormals && (this._vertexBufferNormals.destroy(), this._vertexBufferNormals = null);
            this.texturePositions && (this.texturePositions.destroy(), this.texturePositions = null);
            this.textureNormals && (this.textureNormals.destroy(), this.textureNormals =
                null)
        }
    });
    Object.assign(wf.prototype, {
        encode: function(a) {
            return uc.joinPath([uc.joinPath(a[0]), a[1], uc.joinPath(a[2])], "/")
        },
        decode: function(a) {
            a = uc.splitPath(a, "/");
            return [uc.splitPath(a[0]), a[1], uc.splitPath(a[2])]
        }
    });
    fa.prototype = Object.create(Z.prototype);
    fa.prototype.constructor = fa;
    fa.prototype.addComponent = function(a, b) {
        var c = this._app.systems[a];
        return !c || this.c[a] ? null : c.addComponent(this, b)
    };
    fa.prototype.removeComponent = function(a) {
        var b = this._app.systems[a];
        b && this.c[a] && b.removeComponent(this)
    };
    fa.prototype.findComponent = function(a) {
        var b = this.findOne(function(c) {
            return c.c && c.c[a]
        });
        return b && b.c[a]
    };
    fa.prototype.findComponents = function(a) {
        return this.find(function(b) {
            return b.c && b.c[a]
        }).map(function(b) {
            return b.c[a]
        })
    };
    fa.prototype.getGuid = function() {
        this._guid || this.setGuid(Xl.create());
        return this._guid
    };
    fa.prototype.setGuid = function(a) {
        var b = this._app._entityIndex;
        this._guid && delete b[this._guid];
        this._guid = a;
        b[this._guid] = this
    };
    fa.prototype._notifyHierarchyStateChanged = function(a,
        b) {
        var c = !1;
        a === this && 0 === this._app._enableList.length && (c = !0);
        a._beingEnabled = !0;
        a._onHierarchyStateChanged(b);
        a._onHierarchyStatePostChanged && this._app._enableList.push(a);
        var d, e = a._children;
        var f = 0;
        for (d = e.length; f < d; f++) e[f]._enabled && this._notifyHierarchyStateChanged(e[f], b);
        a._beingEnabled = !1;
        if (c) {
            for (f = 0; f < this._app._enableList.length; f++) this._app._enableList[f]._onHierarchyStatePostChanged();
            this._app._enableList.length = 0
        }
    };
    fa.prototype._onHierarchyStateChanged = function(a) {
        Z.prototype._onHierarchyStateChanged.call(this,
            a);
        var b = this.c,
            c;
        for (c in b)
            if (b.hasOwnProperty(c)) {
                var d = b[c];
                if (d.enabled)
                    if (a) d.onEnable();
                    else d.onDisable()
            }
    };
    fa.prototype._onHierarchyStatePostChanged = function() {
        var a = this.c,
            b;
        for (b in a)
            if (a.hasOwnProperty(b)) a[b].onPostStateChange()
    };
    fa.prototype.findByGuid = function(a) {
        return this._guid === a ? this : (a = this._app._entityIndex[a]) && (a === this || a.isDescendantOf(this)) ? a : null
    };
    fa.prototype.destroy = function() {
        this._destroying = !0;
        for (a in this.c) this.c[a].enabled = !1;
        for (a in this.c) this.c[a].system.removeComponent(this);
        this._parent && this._parent.removeChild(this);
        var a = this._children;
        for (var b = a.shift(); b;) b instanceof fa && b.destroy(), b._parent = null, b = a.shift();
        this.fire("destroy", this);
        this.off();
        this._guid && delete this._app._entityIndex[this._guid];
        this._destroying = !1
    };
    fa.prototype.clone = function() {
        var a = {},
            b = this._cloneRecursively(a);
        a[this.getGuid()] = b;
        Wk(this, this, b, a);
        return b
    };
    fa.prototype._cloneRecursively = function(a) {
        var b = new fa(this._app);
        Z.prototype._cloneInternal.call(this, b);
        for (var c in this.c) this.c[c].system.cloneComponent(this,
            b);
        for (c = 0; c < this._children.length; c++) {
            var d = this._children[c];
            if (d instanceof fa) {
                var e = d._cloneRecursively(a);
                b.addChild(e);
                a[d.getGuid()] = e
            }
        }
        return b
    };
    Object.defineProperties(xf.prototype, {
        components: {
            get: function() {
                return this._components
            }
        },
        data: {
            get: function() {
                return this._data
            }
        }
    });
    Object.assign(Xk.prototype, {
        update: function(a, b) {
            if (a < this._left || a >= this._right) {
                var c = b.length;
                c ? a < b[0] ? (this._left = -Infinity, this._right = b[0], this._p0 = this._p1 = this._recip = this._len = 0) : a >= b[c - 1] ? (this._left = b[c -
                    1], this._right = Infinity, this._recip = this._len = 0, this._p0 = this._p1 = c - 1) : (c = this._findKey(a, b), this._left = b[c], this._right = b[c + 1], this._len = this._right - this._left, b = 1 / this._len, this._recip = isFinite(b) ? b : 0, this._p0 = c, this._p1 = c + 1) : (this._left = -Infinity, this._right = Infinity, this._p0 = this._p1 = this._recip = this._len = 0)
            }
            this._t = 0 === this._recip ? 0 : (a - this._left) * this._recip;
            this._hermite.valid = !1
        },
        _findKey: function(a, b) {
            for (var c = 0; a >= b[c + 1];) c++;
            return c
        },
        eval: function(a, b, c) {
            var d = c._data;
            c = c._components;
            var e = this._p0 * c,
                f;
            if (0 === b)
                for (f = 0; f < c; ++f) a[f] = d[e + f];
            else {
                var g = this._t,
                    k = this._p1 * c;
                switch (b) {
                    case 1:
                        for (f = 0; f < c; ++f) a[f] = N.lerp(d[e + f], d[k + f], g);
                        break;
                    case 2:
                        b = this._hermite;
                        b.valid || (f = g * g, e = g + g, k = 1 - g, k *= k, b.valid = !0, b.p0 = (1 + e) * k, b.m0 = g * k, b.p1 = f * (3 - e), b.m1 = f * (g - 1));
                        g = (3 * this._p0 + 1) * c;
                        e = (3 * this._p0 + 2) * c;
                        k = (3 * this._p1 + 1) * c;
                        var h = 3 * this._p1 * c;
                        for (f = 0; f < c; ++f) a[f] = b.p0 * d[g + f] + b.m0 * d[e + f] * this._len + b.p1 * d[k + f] + b.m1 * d[h + f] * this._len
                }
            }
        }
    });
    Object.defineProperties(Lg.prototype, {
        paths: {
            get: function() {
                return this._paths
            }
        },
        input: {
            get: function() {
                return this._input
            }
        },
        output: {
            get: function() {
                return this._output
            }
        },
        interpolation: {
            get: function() {
                return this._interpolation
            }
        }
    });
    Object.defineProperties(Md.prototype, {
        name: {
            get: function() {
                return this._name
            }
        },
        duration: {
            get: function() {
                return this._duration
            }
        },
        inputs: {
            get: function() {
                return this._inputs
            }
        },
        outputs: {
            get: function() {
                return this._outputs
            }
        },
        curves: {
            get: function() {
                return this._curves
            }
        }
    });
    Object.assign(Md.prototype, {
        eval: function(a, b) {
            b._time = a;
            var c = this._inputs,
                d = this._outputs,
                e = this._curves,
                f = b._cache;
            b = b._results;
            var g;
            for (g = 0; g < c.length; ++g) f[g].update(a, c[g]._data);
            for (g = 0; g < e.length; ++g) a = e[g], f[a._input].eval(b[g], a._interpolation, d[a._output])
        }
    });
    Object.defineProperties(yf.prototype, {
        name: {
            get: function() {
                return this._name
            },
            set: function(a) {
                this._name = a
            }
        },
        track: {
            get: function() {
                return this._track
            }
        },
        snapshot: {
            get: function() {
                return this._snapshot
            }
        },
        time: {
            get: function() {
                return this._time
            },
            set: function(a) {
                this._time = a
            }
        },
        speed: {
            get: function() {
                return this._speed
            },
            set: function(a) {
                this._speed =
                    a
            }
        },
        loop: {
            get: function() {
                return this._loop
            },
            set: function(a) {
                this._loop = a
            }
        },
        blendWeight: {
            get: function() {
                return this._blendWeight
            },
            set: function(a) {
                this._blendWeight = a
            }
        },
        blendOrder: {
            get: function() {
                return this._blendOrder
            },
            set: function(a) {
                this._blendOrder = a
            }
        }
    });
    Object.assign(yf.prototype, {
        _update: function(a) {
            if (this._playing) {
                var b = this._time,
                    c = this._track.duration,
                    d = this._speed,
                    e = this._loop;
                b += d * a;
                0 <= d ? b > c && (e ? b = b % c || 0 : (b = this._track.duration, this.pause())) : 0 > b && (e ? b = c + (b % c || 0) : (b = 0, this.pause()));
                this._time =
                    b
            }
            this._time != this._snapshot._time && this._track.eval(this._time, this._snapshot)
        },
        play: function() {
            this._playing = !0;
            this._time = 0
        },
        stop: function() {
            this._playing = !1;
            this._time = 0
        },
        pause: function() {
            this._playing = !1
        },
        resume: function() {
            this._playing = !0
        },
        reset: function() {
            this._time = 0
        }
    });
    Object.defineProperties(Jc.prototype, {
        func: {
            get: function() {
                return this._func
            }
        },
        type: {
            get: function() {
                return this._type
            }
        },
        components: {
            get: function() {
                return this._components
            }
        }
    });
    uc.joinPath = function(a, b) {
        b = b || ".";
        return a.map(function(c) {
            return c.replace(/\\/g,
                "\\\\").replace(new RegExp("\\" + b, "g"), "\\" + b)
        }).join(b)
    };
    uc.splitPath = function(a, b) {
        b = b || ".";
        for (var c = [], d = "", e = 0; e < a.length;) {
            var f = a[e++];
            "\\" === f && e < a.length ? (f = a[e++], d = "\\" === f || f === b ? d + f : d + ("\\" + f)) : f === b ? (c.push(d), d = "") : d += f
        }
        0 < d.length && c.push(d);
        return c
    };
    Object.assign(uc.prototype, {
        resolve: function(a) {
            return null
        },
        unresolve: function(a) {},
        update: function(a) {}
    });
    Object.assign(zf.prototype, {
        resolve: function(a) {
            var b = this.propertyLocator.decode(a);
            a = this.nodes[b[0][0] || ""];
            if (!a) return null;
            b = this.handlers[b[2][0]];
            if (!b) return null;
            b = b(a.node);
            if (!b) return null;
            0 === a.count && this.activeNodes.push(a.node);
            a.count++;
            return b
        },
        unresolve: function(a) {
            a = this.propertyLocator.decode(a);
            if ("graph" === a[1]) {
                var b = this.nodes[a[0][0]];
                b.count--;
                if (0 === b.count) {
                    a = this.activeNodes;
                    b = a.indexOf(b.node);
                    var c = a.length;
                    b < c - 1 && (a[b] = a[c - 1]);
                    a.pop()
                }
            }
        },
        update: function(a) {
            a = this.activeNodes;
            for (var b = 0; b < a.length; ++b) a[b]._dirtifyLocal()
        }
    });
    Object.defineProperties(Ja.prototype, {
        clips: {
            get: function() {
                return this._clips
            }
        }
    });
    Ja._dot = function(a, b) {
        for (var c = a.length, d = 0, e = 0; e < c; ++e) d += a[e] * b[e];
        return d
    };
    Ja._normalize = function(a) {
        var b = Ja._dot(a, a);
        if (0 < b) {
            b = 1 / Math.sqrt(b);
            for (var c = a.length, d = 0; d < c; ++d) a[d] *= b
        }
    };
    Ja._set = function(a, b, c) {
        var d = a.length;
        if ("quaternion" === c) {
            var e = Ja._dot(b, b);
            0 < e && (e = 1 / Math.sqrt(e));
            for (c = 0; c < d; ++c) a[c] = b[c] * e
        } else
            for (c = 0; c < d; ++c) a[c] = b[c]
    };
    Ja._blendVec = function(a, b, c) {
        for (var d = 1 - c, e = a.length, f = 0; f < e; ++f) a[f] = a[f] * d + b[f] * c
    };
    Ja._blendQuat = function(a, b, c) {
        var d = a.length,
            e = 1 - c;
        0 > Ja._dot(a,
            b) && (c = -c);
        for (var f = 0; f < d; ++f) a[f] = a[f] * e + b[f] * c;
        Ja._normalize(a)
    };
    Ja._blend = function(a, b, c, d) {
        "quaternion" === d ? Ja._blendQuat(a, b, c) : Ja._blendVec(a, b, c)
    };
    Ja._stableSort = function(a, b) {
        for (var c = a.length, d = 0; d < c - 1; ++d)
            for (var e = d + 1; e < c; ++e)
                if (b(a[e], a[d])) {
                    var f = a[d];
                    a[d] = a[e];
                    a[e] = f
                }
    };
    Object.assign(Ja.prototype, {
        addClip: function(a) {
            for (var b = this._targets, c = a.track.curves, d = a.snapshot, e = [], f = [], g = 0; g < c.length; ++g)
                for (var k = c[g].paths, h = 0; h < k.length; ++h) {
                    var l = k[h],
                        n = b[l];
                    if (!n) {
                        var p = this._binder.resolve(l);
                        if (p) {
                            n = {
                                target: p,
                                value: [],
                                curves: 0,
                                blendCounter: 0
                            };
                            for (p = 0; p < n.target.components; ++p) n.value.push(0);
                            b[l] = n
                        }
                    }
                    n && (n.curves++, e.push(d._results[g]), f.push(n))
                }
            this._clips.push(a);
            this._inputs.push(e);
            this._outputs.push(f)
        },
        removeClip: function(a) {
            for (var b = this._targets, c = this._clips, d = c[a].track.curves, e = 0; e < d.length; ++e)
                for (var f = d[e].paths, g = 0; g < f.length; ++g) {
                    var k = f[g],
                        h = b[k];
                    h && (h.curves--, 0 === h.curves && (this._binder.unresolve(k), delete b[k]))
                }
            c.splice(a, 1);
            this._inputs.splice(a, 1);
            this._outputs.splice(a,
                1)
        },
        removeClips: function() {
            for (; 0 < this._clips.length;) this.removeClip(0)
        },
        findClip: function(a) {
            for (var b = this._clips, c = 0; c < b.length; ++c) {
                var d = b[c];
                if (d.name === a) return d
            }
            return null
        },
        update: function(a) {
            var b = this._clips,
                c = b.map(function(q, r) {
                    return r
                });
            Ja._stableSort(c, function(q, r) {
                return b[q].blendOrder < b[r].blendOrder
            });
            var d;
            for (d = 0; d < b.length; ++d) {
                var e = c[d];
                var f = b[e];
                var g = this._inputs[e];
                e = this._outputs[e];
                var k = f.blendWeight;
                0 < k && f._update(a);
                if (1 <= k)
                    for (f = 0; f < g.length; ++f) {
                        var h = g[f];
                        var l =
                            e[f];
                        var n = l.value;
                        Ja._set(n, h, l.target.type);
                        l.blendCounter++
                    } else if (0 < k)
                        for (f = 0; f < g.length; ++f) h = g[f], l = e[f], n = l.value, 0 === l.blendCounter ? Ja._set(n, h, l.target.type) : Ja._blend(n, h, k, l.target.type), l.blendCounter++
            }
            c = this._targets;
            for (var p in c) c.hasOwnProperty(p) && (d = c[p], d.target.func(d.value), d.blendCounter = 0);
            this._binder.update(a)
        }
    });
    xi.prototype._validate = function(a) {
        if (!a.header) throw Error('pc.I18n#addData: Missing "header" field');
        if (!a.header.version) throw Error('pc.I18n#addData: Missing "header.version" field');
        if (1 !== a.header.version) throw Error('pc.I18n#addData: Invalid "header.version" field');
        if (!a.data) throw Error('pc.I18n#addData: Missing "data" field');
        if (!Array.isArray(a.data)) throw Error('pc.I18n#addData: "data" field must be an array');
        for (var b = 0, c = a.data.length; b < c; b++) {
            var d = a.data[b];
            if (!d.info) throw Error('pc.I18n#addData: missing "data[' + b + '].info" field');
            if (!d.info.locale) throw Error('pc.I18n#addData: missing "data[' + b + '].info.locale" field');
            if ("string" !== typeof d.info.locale) throw Error('pc.I18n#addData: "data[' +
                b + '].info.locale" must be a string');
            if (!d.messages) throw Error('pc.I18n#addData: missing "data[' + b + '].messages" field');
        }
    };
    xi.prototype.parse = function(a) {
        return a.data
    };
    var cg = {},
        wd = function(a, b) {
            for (var c = 0, d = a.length; c < d; c++) cg[a[c]] = b
        },
        xd = function(a) {
            var b = a.indexOf("-");
            return -1 !== b ? a.substring(0, b) : a
        },
        Mg = "en-US",
        Fh = {
            en: "en-US",
            es: "en-ES",
            zh: "zh-CN",
            "zh-HK": "zh-TW",
            "zh-TW": "zh-HK",
            "zh-MO": "zh-HK",
            fr: "fr-FR",
            de: "de-DE",
            it: "it-IT",
            ru: "ru-RU",
            ja: "ja-JP"
        };
    wd("ja ko th vi zh id".split(" "), function(a) {
        return 0
    });
    wd(["fa", "hi"], function(a) {
        return 0 <= a && 1 >= a ? 0 : 1
    });
    wd(["fr", "pt"], function(a) {
        return 0 <= a && 2 > a ? 0 : 1
    });
    wd(["da"], function(a) {
        return 1 === a || !Number.isInteger(a) && 0 <= a && 1 >= a ? 0 : 1
    });
    wd("de en it el es tr fi sv nb no ur".split(" "), function(a) {
        return 1 === a ? 0 : 1
    });
    wd(["ru", "uk"], function(a) {
        if (Number.isInteger(a)) {
            var b = a % 10;
            a %= 100;
            if (1 === b && 11 !== a) return 0;
            if (2 <= b && 4 >= b && (12 > a || 14 < a)) return 1;
            if (0 === b || 5 <= b && 9 >= b || 11 <= a && 14 >= a) return 2
        }
        return 3
    });
    wd(["pl"], function(a) {
        if (Number.isInteger(a)) {
            if (1 === a) return 0;
            var b = a % 10;
            a %= 100;
            if (2 <= b && 4 >= b && (12 > a || 14 < a)) return 1;
            if (0 <= b && 1 >= b || 5 <= b && 9 >= b || 12 <= a && 14 >= a) return 2
        }
        return 3
    });
    wd(["ar"], function(a) {
        if (0 === a) return 0;
        if (1 === a) return 1;
        if (2 === a) return 2;
        if (Number.isInteger(a)) {
            a %= 100;
            if (3 <= a && 10 >= a) return 3;
            if (11 <= a && 99 >= a) return 4
        }
        return 5
    });
    var gk = cg[xd(Mg)];
    Oa.prototype = Object.create(M.prototype);
    Oa.prototype.constructor = Oa;
    Oa.findAvailableLocale = function(a, b) {
        if (b[a]) return a;
        var c = Fh[a];
        if (c && b[c]) return c;
        a = xd(a);
        c = Fh[a];
        return b[c] ? c : b[a] ? a : Mg
    };
    Oa.prototype.getText =
        function(a, b) {
            var c = a;
            if (!b) {
                b = this._locale;
                var d = this._lang
            }
            var e = this._translations[b];
            e || (d || (d = xd(b)), b = this._findFallbackLocale(b, d), e = this._translations[b]);
            e && e.hasOwnProperty(a) && (c = e[a], Array.isArray(c) && (c = c[0]), null === c || void 0 === c) && (c = a);
            return c
        };
    Oa.prototype.getPluralText = function(a, b, c) {
        var d = a;
        if (c) {
            var e = xd(c);
            var f = cg[e] || gk
        } else c = this._locale, e = this._lang, f = this._pluralFn;
        var g = this._translations[c];
        g || (c = this._findFallbackLocale(c, e), e = xd(c), f = cg[e] || gk, g = this._translations[c]);
        g && g[a] && f && (b = f(b), d = g[a][b], null === d || void 0 === d) && (d = a);
        return d
    };
    Oa.prototype.addData = function(a) {
        try {
            var b = this._parser.parse(a)
        } catch (g) {
            console.error(g);
            return
        }
        a = 0;
        for (var c = b.length; a < c; a++) {
            var d = b[a],
                e = d.info.locale;
            d = d.messages;
            if (!this._translations[e]) {
                this._translations[e] = {};
                var f = xd(e);
                this._availableLangs[f] || (this._availableLangs[f] = e)
            }
            Object.assign(this._translations[e], d);
            this.fire("data:add", e, d)
        }
    };
    Oa.prototype.removeData = function(a) {
        var b;
        try {
            var c = this._parser.parse(a)
        } catch (h) {
            console.error(h);
            return
        }
        a = 0;
        for (var d = c.length; a < d; a++) {
            var e = c[a],
                f = e.info.locale,
                g = this._translations[f];
            if (g) {
                e = e.messages;
                for (b in e) delete g[b];
                var k = !1;
                for (b in g) {
                    k = !0;
                    break
                }
                k || (delete this._translations[f], delete this._availableLangs[xd(f)]);
                this.fire("data:remove", f, e)
            }
        }
    };
    Oa.prototype.destroy = function() {
        this._parser = this._assets = this._availableLangs = this._translations = null;
        this.off()
    };
    Object.defineProperty(Oa.prototype, "locale", {
        get: function() {
            return this._locale
        },
        set: function(a) {
            if (this._locale !== a) {
                var b =
                    xd(a);
                if ("in" === b) {
                    b = "id";
                    var c = b,
                        d = a.indexOf("-");
                    a = -1 !== d ? c + a.substring(d) : c;
                    if (this._locale === a) return
                }
                c = this._locale;
                this._locale = a;
                this._lang = b;
                this._pluralFn = cg[this._lang] || gk;
                this.fire("set:locale", a, c)
            }
        }
    });
    Object.defineProperty(Oa.prototype, "assets", {
        get: function() {
            return this._assets
        },
        set: function(a) {
            var b, c = {};
            var d = 0;
            for (b = a.length; d < b; d++) {
                var e = a[d] instanceof aa ? a[d].id : a[d];
                c[e] = !0
            }
            for (d = this._assets.length; d--;) e = this._assets[d], c[e] || (this._app.assets.off("add:" + e, this._onAssetAdd,
                this), (a = this._app.assets.get(e)) && this._onAssetRemove(a), this._assets.splice(d, 1));
            for (e in c)
                if (e = parseInt(e, 10), -1 === this._assets.indexOf(e))
                    if (this._assets.push(e), a = this._app.assets.get(e)) this._onAssetAdd(a);
                    else this._app.assets.once("add:" + e, this._onAssetAdd, this)
        }
    });
    Oa.prototype._findFallbackLocale = function(a, b) {
        return (a = Fh[a]) && this._translations[a] || (a = Fh[b]) && this._translations[a] ? a : (a = this._availableLangs[b]) && this._translations[a] ? a : Mg
    };
    Oa.prototype._onAssetAdd = function(a) {
        a.on("load",
            this._onAssetLoad, this);
        a.on("change", this._onAssetChange, this);
        a.on("remove", this._onAssetRemove, this);
        a.on("unload", this._onAssetUnload, this);
        a.resource && this._onAssetLoad(a)
    };
    Oa.prototype._onAssetLoad = function(a) {
        this.addData(a.resource)
    };
    Oa.prototype._onAssetChange = function(a) {
        a.resource && this.addData(a.resource)
    };
    Oa.prototype._onAssetRemove = function(a) {
        a.off("load", this._onAssetLoad, this);
        a.off("change", this._onAssetChange, this);
        a.off("remove", this._onAssetRemove, this);
        a.off("unload", this._onAssetUnload,
            this);
        a.resource && this.removeData(a.resource);
        this._app.assets.once("add:" + a.id, this._onAssetAdd, this)
    };
    Oa.prototype._onAssetUnload = function(a) {
        a.resource && this.removeData(a.resource)
    };
    var hf = /^\s*(?:(?:[a-z]+[a-z0-9\-\+\.]*:)?\/\/|data:|blob:)/i,
        hk = [],
        dg = function(a) {
            var b = "_" + a;
            hk.push(b);
            Object.defineProperty(yi.prototype, a, {
                get: function() {
                    return this[b] || null
                },
                set: function(c) {
                    if (!!this[b] !== !!c || this[b] && c && this[b].hash !== c.hash) this[b] = c ? {
                        url: c.url,
                        filename: c.filename,
                        size: c.size,
                        hash: c.hash,
                        opt: c.opt || 0
                    } : null, this.asset.file && (this.asset.fire("change", this.asset, "file", this.asset._file, this.asset._file), this.asset.reload())
                }
            })
        };
    dg("dxt");
    dg("pvr");
    dg("etc1");
    dg("etc2");
    dg("basis");
    yi.prototype.clear = function() {
        for (var a = 0; a < hk.length; a++) this[hk[a]] = null
    };
    var Wn = -1,
        lp = {
            pvr: "extCompressedTexturePVRTC",
            dxt: "extCompressedTextureS3TC",
            etc2: "extCompressedTextureETC",
            etc1: "extCompressedTextureETC1",
            basis: "canvas"
        },
        Dm = ["pvr", "dxt", "etc2", "etc1", "basis"];
    aa.prototype = Object.create(M.prototype);
    aa.prototype.constructor = aa;
    Object.assign(aa.prototype, {
        getFileUrl: function() {
            var a = this.getPreferredFile();
            if (!a || !a.url) return null;
            var b = a.url;
            this.registry && this.registry.prefix && !hf.test(b) && (b = this.registry.prefix + b);
            if ("script" !== this.type && a.hash) {
                var c = -1 !== b.indexOf("?") ? "&" : "?";
                b += c + "t=" + a.hash
            }
            return b
        },
        getPreferredFile: function() {
            if (!this.file) return null;
            if ("texture" === this.type || "textureatlas" === this.type || "bundle" === this.type)
                for (var a = this.registry._loader._app, b = a.graphicsDevice,
                        c = 0, d = Dm.length; c < d; c++) {
                    var e = Dm[c];
                    if (b[lp[e]]) {
                        if (this.file.variants[e]) return this.file.variants[e];
                        if (a.enableBundles) {
                            var f = a.bundles.listBundlesForAsset(this);
                            if (f)
                                for (var g = 0, k = f.length; g < k; g++)
                                    if (f[g].file && f[g].file.variants && f[g].file.variants[e]) return this.file
                        }
                    }
                }
            return this.file
        },
        getAbsoluteUrl: function(a) {
            var b = ca.getDirectory(this.file.url);
            return ca.join(b, a)
        },
        getLocalizedAssetId: function(a) {
            a = Oa.findAvailableLocale(a, this._i18n);
            return this._i18n[a] || null
        },
        addLocalizedAssetId: function(a,
            b) {
            this._i18n[a] = b;
            this.fire("add:localized", a, b)
        },
        removeLocalizedAssetId: function(a) {
            var b = this._i18n[a];
            b && (delete this._i18n[a], this.fire("remove:localized", a, b))
        },
        ready: function(a, b) {
            b = b || this;
            if (this.resource) a.call(b, this);
            else this.once("load", function(c) {
                a.call(b, c)
            })
        },
        reload: function() {
            this.loaded && (this.loaded = !1, this.registry.load(this))
        },
        unload: function() {
            if (this.loaded || 0 !== this._resources.length) {
                this.fire("unload", this);
                this.registry.fire("unload:" + this.id, this);
                var a = this._resources;
                this.resources = [];
                this.loaded = !1;
                this.file && this.registry._loader.clearCache(this.getFileUrl(), this.type);
                for (var b = 0; b < a.length; ++b) {
                    var c = a[b];
                    c && c.destroy && c.destroy()
                }
            }
        }
    });
    Object.defineProperty(aa.prototype, "id", {
        get: function() {
            return this._id
        },
        set: function(a) {
            this._id = a
        }
    });
    Object.defineProperty(aa.prototype, "file", {
        get: function() {
            return this._file
        },
        set: function(a) {
            var b;
            if (!!a !== !!this._file || a && this._file && a.hash !== this._file)
                if (a) {
                    this._file || (this._file = {});
                    this._file.url = a.url;
                    this._file.filename =
                        a.filename;
                    this._file.hash = a.hash;
                    this._file.size = a.size;
                    this._file.variants = this.variants;
                    this._file.contents = a.contents;
                    if (a.hasOwnProperty("variants") && (this.variants.clear(), a.variants))
                        for (b in a.variants) a.variants[b] && (this.variants[b] = a.variants[b]);
                    this.fire("change", this, "file", this._file, this._file);
                    this.reload()
                } else this._file = null, this.variants.clear();
            else if (a && this._file && a.hasOwnProperty("variants") && (this.variants.clear(), a.variants))
                for (b in a.variants) a.variants[b] && (this.variants[b] =
                    a.variants[b])
        }
    });
    Object.defineProperty(aa.prototype, "data", {
        get: function() {
            return this._data
        },
        set: function(a) {
            var b = this._data;
            this._data = a;
            a !== b && (this.fire("change", this, "data", a, b), this.loaded && this.registry._loader.patch(this, this.registry))
        }
    });
    Object.defineProperty(aa.prototype, "resource", {
        get: function() {
            return this._resources[0]
        },
        set: function(a) {
            var b = this._resources[0];
            this._resources[0] = a;
            this.fire("change", this, "resource", a, b)
        }
    });
    Object.defineProperty(aa.prototype, "resources", {
        get: function() {
            return this._resources
        },
        set: function(a) {
            var b = this._resources;
            this._resources = a;
            this.fire("change", this, "resources", a, b)
        }
    });
    Object.defineProperty(aa.prototype, "preload", {
        get: function() {
            return this._preload
        },
        set: function(a) {
            a = !!a;
            this._preload !== a && (this._preload = a) && !this.loaded && !this.loading && this.registry && this.registry.load(this)
        }
    });
    Object.defineProperty(aa.prototype, "loadFaces", {
        get: function() {
            return this._loadFaces
        },
        set: function(a) {
            a = !!a;
            this.hasOwnProperty("_loadFaces") && a === this._loadFaces || (this._loadFaces = a, this.loaded &&
                this.registry._loader.patch(this, this.registry))
        }
    });
    var Gh = function(a) {
            switch (a) {
                case "SCALAR":
                    return 1;
                case "VEC2":
                    return 2;
                case "VEC3":
                    return 3;
                case "VEC4":
                    return 4;
                case "MAT2":
                    return 4;
                case "MAT3":
                    return 9;
                case "MAT4":
                    return 16;
                default:
                    return 3
            }
        },
        ik = function(a) {
            switch (a) {
                case 5120:
                    return 0;
                case 5121:
                    return 1;
                case 5122:
                    return 2;
                case 5123:
                    return 3;
                case 5124:
                    return 4;
                case 5125:
                    return 5;
                case 5126:
                    return 6;
                default:
                    return 0
            }
        },
        mp = function(a) {
            switch (a) {
                case 5120:
                    return 1;
                case 5121:
                    return 1;
                case 5122:
                    return 2;
                case 5123:
                    return 2;
                case 5124:
                    return 4;
                case 5125:
                    return 4;
                case 5126:
                    return 4;
                default:
                    return 0
            }
        },
        np = function(a) {
            switch (a) {
                case 5120:
                    return Int8Array;
                case 5121:
                    return Uint8Array;
                case 5122:
                    return Int16Array;
                case 5123:
                    return Uint16Array;
                case 5124:
                    return Int32Array;
                case 5125:
                    return Uint32Array;
                case 5126:
                    return Float32Array;
                default:
                    return null
            }
        },
        Hh = {
            POSITION: "POSITION",
            NORMAL: "NORMAL",
            TANGENT: "TANGENT",
            COLOR_0: "COLOR",
            JOINTS_0: "BLENDINDICES",
            WEIGHTS_0: "BLENDWEIGHT",
            TEXCOORD_0: "TEXCOORD0",
            TEXCOORD_1: "TEXCOORD1"
        },
        Yc = function(a, b) {
            var c = Gh(a.type),
                d = np(a.componentType);
            if (!d) return null;
            if (a.sparse) {
                var e = a.sparse,
                    f = Yc(Object.assign({
                        count: e.count,
                        type: "SCALAR"
                    }, e.indices), b),
                    g = Yc(Object.assign({
                        count: e.count,
                        type: a.scalar,
                        componentType: a.componentType
                    }, e.values), b);
                a = a.hasOwnProperty("bufferView") ? Yc({
                    bufferView: a.bufferView,
                    byteOffset: a.byteOffset,
                    componentType: a.componentType,
                    count: a.count,
                    type: a.type
                }, b).slice() : new d(a.count * c);
                for (d = 0; d < e.count; ++d) {
                    b = f[d];
                    for (var k = 0; k < c; ++k) a[b * c + k] = g[d * c + k]
                }
            } else e =
                b[a.bufferView], a = new d(e.buffer, e.byteOffset + (a.hasOwnProperty("byteOffset") ? a.byteOffset : 0), a.count * c);
            return a
        },
        op = function(a) {
            if (!a.hasOwnProperty("mode")) return 4;
            switch (a.mode) {
                case 0:
                    return 0;
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 3:
                    return 3;
                case 4:
                    return 4;
                case 5:
                    return 5;
                case 6:
                    return 6;
                default:
                    return 4
            }
        },
        Em = function(a, b) {
            var c = a.POSITION;
            if (c && 3 === c.components) {
                if (c.size !== c.stride) {
                    var d = c.stride / sf[c.type],
                        e = new Fd[c.type](c.buffer, c.offset, c.count * d);
                    var f = new Fd[c.type](3 * c.count);
                    for (var g =
                            0; g < c.count; ++g) f[3 * g] = e[g * d], f[3 * g + 1] = e[g * d + 1], f[3 * g + 2] = e[g * d + 2]
                } else f = new Fd[c.type](c.buffer, c.offset, 3 * c.count);
                c = c.count;
                if (!b)
                    for (b = new Uint16Array(c), d = 0; d < c; d++) b[d] = d;
                f = Tk(f, b);
                b = new Float32Array(f.length);
                b.set(f);
                a.NORMAL = {
                    buffer: b.buffer,
                    size: 12,
                    offset: 0,
                    stride: 12,
                    count: c,
                    components: 3,
                    type: 6
                }
            }
        },
        pp = function(a) {
            var b, c, d = [],
                e = [],
                f = [];
            for (b = 0; b < a.format.elements.length; ++b) {
                var g = a.format.elements[b];
                if ("TEXCOORD0" === g.name || "TEXCOORD1" === g.name) switch (g.dataType) {
                    case 6:
                        d.push({
                            offset: g.offset /
                                4 + 1,
                            stride: g.stride / 4
                        });
                        break;
                    case 3:
                        e.push({
                            offset: g.offset / 2 + 1,
                            stride: g.stride / 2
                        });
                        break;
                    case 1:
                        f.push({
                            offset: g.offset + 1,
                            stride: g.stride
                        })
                }
            }
            g = function(k, h, l) {
                h = new h(a.storage);
                for (b = 0; b < k.length; ++b) {
                    var n = k[b].offset,
                        p = k[b].stride;
                    for (c = 0; c < a.numVertices; ++c) h[n] = l - h[n], n += p
                }
            };
            0 < d.length && g(d, Float32Array, 1);
            0 < e.length && g(e, Uint16Array, 65535);
            0 < f.length && g(f, Uint8Array, 255)
        },
        Fm = function(a, b, c) {
            var d = b.POSITION,
                e = d.count,
                f = [];
            for (p in b) b.hasOwnProperty(p) && f.push({
                semantic: p,
                components: b[p].components,
                type: b[p].type,
                normalize: !!b[p].normalize
            });
            var g = "POSITION NORMAL TANGENT COLOR BLENDINDICES BLENDWEIGHT TEXCOORD0 TEXCOORD1".split(" ");
            f.sort(function(u, x) {
                u = g.indexOf(u.semantic);
                x = g.indexOf(x.semantic);
                return u < x ? -1 : x < u ? 1 : 0
            });
            var k, h = new Na(a, f),
                l = !0;
            for (f = 0; f < h.elements.length; ++f) {
                var n = h.elements[f];
                var p = b[n.name];
                var q = p.offset - d.offset;
                if (p.buffer !== d.buffer || p.stride !== n.stride || p.size !== n.size || q !== n.offset) {
                    l = !1;
                    break
                }
            }
            a = new ab(a, h, e, 0);
            f = a.lock();
            q = new Uint32Array(f);
            if (l) d = new Uint32Array(d.buffer,
                d.offset, e * a.format.size / 4), q.set(d);
            else
                for (f = 0; f < a.format.elements.length; ++f) {
                    n = a.format.elements[f];
                    l = n.stride / 4;
                    p = b[n.name];
                    d = new Uint32Array(p.buffer, p.offset, p.count * p.stride / 4);
                    h = p.stride / 4;
                    var r = 0;
                    n = n.offset / 4;
                    var t = Math.floor((p.size + 3) / 4);
                    for (p = 0; p < e; ++p) {
                        for (k = 0; k < t; ++k) q[n + k] = d[r + k];
                        r += h;
                        n += l
                    }
                }
            c || pp(a);
            a.unlock();
            return a
        },
        qp = function(a, b, c, d, e, f, g) {
            var k, h = {},
                l = [];
            for (k in b) b.hasOwnProperty(k) && Hh.hasOwnProperty(k) && (h[k] = b[k], l.push(k + ":" + b[k]));
            l.sort();
            l = l.join();
            var n = g[l];
            if (!n) {
                n = {};
                for (k in h) {
                    h = d[b[k]];
                    var p = Yc(h, e),
                        q = e[h.bufferView],
                        r = Hh[k],
                        t = Gh(h.type) * mp(h.componentType);
                    q = q.hasOwnProperty("byteStride") ? q.byteStride : t;
                    n[r] = {
                        buffer: p.buffer,
                        size: t,
                        offset: p.byteOffset,
                        stride: q,
                        count: h.count,
                        components: Gh(h.type),
                        type: ik(h.componentType),
                        normalize: h.normalized
                    }
                }
                n.hasOwnProperty("NORMAL") || Em(n, c);
                n = Fm(a, n, f);
                g[l] = n
            }
            return n
        },
        rp = function(a, b, c, d, e, f, g) {
            var k, h = b.num_points(),
                l = {};
            c = c.attributes;
            for (var n in c)
                if (c.hasOwnProperty(n) && Hh.hasOwnProperty(n)) {
                    var p = Hh[n];
                    var q =
                        d.GetAttributeByUniqueId(b, c[n]);
                    var r = h * q.num_components();
                    switch (q.data_type()) {
                        case e.DT_UINT8:
                            var t = k = 1;
                            var u = e._malloc(r * t);
                            d.GetAttributeDataArrayForAllPoints(b, q, e.DT_UINT8, r * t, u);
                            r = (new Uint8Array(e.HEAPU8.buffer, u, r)).slice();
                            break;
                        case e.DT_UINT16:
                            k = 3;
                            t = 2;
                            u = e._malloc(r * t);
                            d.GetAttributeDataArrayForAllPoints(b, q, e.DT_UINT16, r * t, u);
                            r = (new Uint16Array(e.HEAPU16.buffer, u, r)).slice();
                            break;
                        default:
                            k = 6, t = 4, u = e._malloc(r * t), d.GetAttributeDataArrayForAllPoints(b, q, e.DT_FLOAT32, r * t, u), r = (new Float32Array(e.HEAPF32.buffer,
                                u, r)).slice()
                    }
                    e._free(u);
                    u = r;
                    r = q.num_components();
                    q = q.normalized();
                    t *= r;
                    l[p] = {
                        values: u,
                        buffer: u.buffer,
                        size: t,
                        offset: 0,
                        stride: t,
                        count: h,
                        components: r,
                        type: k,
                        normalize: q
                    }
                }
            l.hasOwnProperty("NORMAL") || Em(l, f);
            return Fm(a, l, g)
        },
        Ih = new J,
        jf = new z,
        sp = function(a, b, c, d, e, f, g) {
            var k = [];
            b.primitives.forEach(function(h) {
                var l = null,
                    n = new sb(a),
                    p = !0;
                if (h.hasOwnProperty("extensions")) {
                    var q = h.extensions;
                    if (q.hasOwnProperty("KHR_draco_mesh_compression")) {
                        var r = window.DracoDecoderModule;
                        if (r && (q = q.KHR_draco_mesh_compression,
                                q.hasOwnProperty("attributes"))) {
                            var t = d[q.bufferView];
                            p = new r.DecoderBuffer;
                            p.Init(t, t.length);
                            t = new r.Decoder;
                            var u = t.GetEncodedGeometryType(p);
                            switch (u) {
                                case r.POINT_CLOUD:
                                    var x = 0;
                                    var v = new r.PointCloud;
                                    var w = t.DecodeBufferToPointCloud(p, v);
                                    break;
                                case r.TRIANGULAR_MESH:
                                    x = 4, v = new r.Mesh, w = t.DecodeBufferToMesh(p, v)
                            }
                            if (!w || !w.ok() || 0 == v.ptr) {
                                e("Failed to decode draco compressed asset: " + (w ? w.error_msg() : "Mesh asset - invalid draco compressed geometry type: " + u));
                                return
                            }
                            w = v.num_faces();
                            if (u == r.TRIANGULAR_MESH) {
                                l =
                                    65535 < v.num_points();
                                u = 3 * w;
                                var y = u * (l ? 4 : 2);
                                w = r._malloc(y);
                                l ? (t.GetTrianglesUInt32Array(v, y, w), l = (new Uint32Array(r.HEAPU32.buffer, w, u)).slice()) : (t.GetTrianglesUInt16Array(v, y, w), l = (new Uint16Array(r.HEAPU16.buffer, w, u)).slice());
                                r._free(w)
                            }
                            u = rp(a, v, q, t, r, l, f);
                            r.destroy(v);
                            r.destroy(t);
                            r.destroy(p);
                            p = !1
                        }
                    }
                }
                u || (l = h.hasOwnProperty("indices") ? Yc(c[h.indices], d) : null, u = qp(a, h.attributes, l, c, d, f, g), x = op(h));
                n.vertexBuffer = u;
                n.primitive[0].type = x;
                n.primitive[0].base = 0;
                n.primitive[0].indexed = null !== l;
                null !==
                    l ? (x = l instanceof Uint8Array ? 0 : l instanceof Uint16Array ? 1 : 2, 2 !== x || a.extUintElement || (x = 1, l = new Uint16Array(l)), x = new dc(a, x, l.length, 0, l), n.indexBuffer[0] = x, n.primitive[0].count = l.length) : n.primitive[0].count = u.numVertices;
                n.materialIndex = h.material;
                var A = c[h.attributes.POSITION];
                x = A.min;
                r = A.max;
                x = new oa(new z((r[0] + x[0]) / 2, (r[1] + x[1]) / 2, (r[2] + x[2]) / 2), new z((r[0] - x[0]) / 2, (r[1] - x[1]) / 2, (r[2] - x[2]) / 2));
                n.aabb = x;
                if (p && h.hasOwnProperty("targets")) {
                    var B = [];
                    h.targets.forEach(function(E, D) {
                        var C = {};
                        E.hasOwnProperty("POSITION") &&
                            (A = c[E.POSITION], C.deltaPositions = Yc(A, d), C.deltaPositionsType = ik(A.componentType), A.hasOwnProperty("min") && A.hasOwnProperty("max") && (C.aabb = new oa, C.aabb.setMinMax(new z(A.min), new z(A.max))));
                        E.hasOwnProperty("NORMAL") && (A = c[E.NORMAL], C.deltaNormals = Yc(A, d), C.deltaNormalsType = ik(A.componentType));
                        b.hasOwnProperty("extras") && b.extras.hasOwnProperty("targetNames") ? C.name = b.extras.targetNames[D] : C.name = B.length.toString(10);
                        B.push(new vf(a, C))
                    });
                    n.morph = new Db(B);
                    if (b.hasOwnProperty("weights"))
                        for (h =
                            0; h < b.weights.length; ++h) B[h].defaultWeight = b.weights[h]
                }
                k.push(n)
            });
            return k
        },
        tp = function(a, b, c) {
            var d = [1, 1],
                e = [0, 0],
                f = function(n, p, q) {
                    var r, t = n.texCoord;
                    if (t)
                        for (r = 0; r < q.length; ++r) p[q[r] + "MapUv"] = t;
                    t = d;
                    var u = e;
                    if (n = n.extensions)
                        if (n = n.KHR_texture_transform) n.scale && (t = n.scale), n.offset && (u = n.offset);
                    for (r = 0; r < q.length; ++r) p[q[r] + "MapTiling"] = new P(t[0], t[1]), p[q[r] + "MapOffset"] = new P(u[0], c ? u[1] : 1 - t[1] - u[1])
                },
                g = new ma;
            g.occludeSpecular = !0;
            g.diffuseTint = !0;
            g.diffuseVertexColor = !0;
            g.specularTint = !0;
            g.specularVertexColor = !0;
            a.hasOwnProperty("name") && (g.name = a.name);
            if (a.hasOwnProperty("extensions") && a.extensions.hasOwnProperty("KHR_materials_pbrSpecularGlossiness")) {
                var k = a.extensions.KHR_materials_pbrSpecularGlossiness;
                if (k.hasOwnProperty("diffuseFactor")) {
                    var h = k.diffuseFactor;
                    g.diffuse.set(Math.pow(h[0], 1 / 2.2), Math.pow(h[1], 1 / 2.2), Math.pow(h[2], 1 / 2.2));
                    g.opacity = null != h[3] ? h[3] : 1
                } else g.diffuse.set(1, 1, 1), g.opacity = 1;
                if (k.hasOwnProperty("diffuseTexture")) {
                    var l = k.diffuseTexture;
                    h = b[l.index];
                    g.diffuseMap = h;
                    g.diffuseMapChannel = "rgb";
                    g.opacityMap = h;
                    g.opacityMapChannel = "a";
                    f(l, g, ["diffuse", "opacity"])
                }
                g.useMetalness = !1;
                k.hasOwnProperty("specularFactor") ? (h = k.specularFactor, g.specular.set(Math.pow(h[0], 1 / 2.2), Math.pow(h[1], 1 / 2.2), Math.pow(h[2], 1 / 2.2))) : g.specular.set(1, 1, 1);
                k.hasOwnProperty("glossinessFactor") ? g.shininess = 100 * k.glossinessFactor : g.shininess = 100;
                k.hasOwnProperty("specularGlossinessTexture") && (h = k.specularGlossinessTexture, g.specularMap = g.glossMap = b[h.index], g.specularMapChannel =
                    "rgb", g.glossMapChannel = "a", f(h, g, ["gloss", "metalness"]));
                g.chunks.specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\n\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\n\t#ifdef MAPCOLOR\n\t\tdSpecularity *= material_specular;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\t\tvec3 srgb = texture2D(texture_specularMap, $UV).$CH;\n\t\tdSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));\n\t#endif\n\n\t#ifdef MAPVERTEX\n\t\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}"
            } else a.hasOwnProperty("pbrMetallicRoughness") &&
                (k = a.pbrMetallicRoughness, k.hasOwnProperty("baseColorFactor") ? (h = k.baseColorFactor, g.diffuse.set(Math.pow(h[0], 1 / 2.2), Math.pow(h[1], 1 / 2.2), Math.pow(h[2], 1 / 2.2)), g.opacity = h[3]) : (g.diffuse.set(1, 1, 1), g.opacity = 1), k.hasOwnProperty("baseColorTexture") && (l = k.baseColorTexture, h = b[l.index], g.diffuseMap = h, g.diffuseMapChannel = "rgb", g.opacityMap = h, g.opacityMapChannel = "a", f(l, g, ["diffuse", "opacity"])), g.useMetalness = !0, k.hasOwnProperty("metallicFactor") ? g.metalness = k.metallicFactor : g.metalness = 1, k.hasOwnProperty("roughnessFactor") ?
                    g.shininess = 100 * k.roughnessFactor : g.shininess = 100, k.hasOwnProperty("metallicRoughnessTexture") && (h = k.metallicRoughnessTexture, g.metalnessMap = g.glossMap = b[h.index], g.metalnessMapChannel = "b", g.glossMapChannel = "g", f(h, g, ["gloss", "metalness"])), g.chunks.glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\n\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\n#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n#endif\n\n#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n#endif\n\n#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n#endif\n\n\tdGlossiness = 1.0 - dGlossiness;\n\n\tdGlossiness += 0.0000001;\n}");
            a.hasOwnProperty("normalTexture") && (h = a.normalTexture, g.normalMap = b[h.index], f(h, g, ["normal"]), h.hasOwnProperty("scale") && (g.bumpiness = h.scale));
            a.hasOwnProperty("occlusionTexture") && (h = a.occlusionTexture, g.aoMap = b[h.index], g.aoMapChannel = "r", f(h, g, ["ao"]));
            a.hasOwnProperty("emissiveFactor") ? (h = a.emissiveFactor, g.emissive.set(Math.pow(h[0], 1 / 2.2), Math.pow(h[1], 1 / 2.2), Math.pow(h[2], 1 / 2.2)), g.emissiveTint = !0) : (g.emissive.set(0, 0, 0), g.emissiveTint = !1);
            a.hasOwnProperty("emissiveTexture") && (h = a.emissiveTexture,
                g.emissiveMap = b[h.index], f(h, g, ["emissive"]));
            if (a.hasOwnProperty("alphaMode")) switch (a.alphaMode) {
                case "MASK":
                    g.blendType = 3;
                    a.hasOwnProperty("alphaCutoff") ? g.alphaTest = a.alphaCutoff : g.alphaTest = .5;
                    break;
                case "BLEND":
                    g.blendType = 2;
                    break;
                default:
                case "OPAQUE":
                    g.blendType = 3
            } else g.blendType = 3;
            a.hasOwnProperty("doubleSided") ? (g.twoSidedLighting = a.doubleSided, g.cull = a.doubleSided ? 0 : 1) : (g.twoSidedLighting = !1, g.cull = 1);
            a.hasOwnProperty("extensions") && a.extensions.hasOwnProperty("KHR_materials_clearcoat") &&
                (h = a.extensions.KHR_materials_clearcoat, h.hasOwnProperty("clearcoatFactor") ? g.clearCoat = .25 * h.clearcoatFactor : g.clearCoat = 0, h.hasOwnProperty("clearcoatTexture") && (k = h.clearcoatTexture, g.clearCoatMap = b[k.index], g.clearCoatMapChannel = "r", f(k, g, ["clearCoat"])), h.hasOwnProperty("clearcoatRoughnessFactor") ? g.clearCoatGlossiness = h.clearcoatRoughnessFactor : g.clearCoatGlossiness = 0, h.hasOwnProperty("clearcoatRoughnessTexture") && (k = h.clearcoatRoughnessTexture, g.clearCoatGlossMap = b[k.index], g.clearCoatGlossMapChannel =
                    "g", f(k, g, ["clearCoatGloss"])), h.hasOwnProperty("clearcoatNormalTexture") && (h = h.clearcoatNormalTexture, g.clearCoatNormalMap = b[h.index], f(h, g, ["clearCoatNormal"]), h.hasOwnProperty("scale") && (g.clearCoatBumpiness = h.scale)), g.chunks.clearCoatGlossPS = "#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\n\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\n#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGlossiness;\n#endif\n\n#ifdef MAPTEXTURE\n\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\n#endif\n\n#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n#endif\n\n\tccGlossiness = 1.0 - ccGlossiness;\n\n\tccGlossiness += 0.0000001;\n}");
            a.hasOwnProperty("extensions") && a.extensions.hasOwnProperty("KHR_materials_unlit") && (g.useLighting = !1, g.emissive.copy(g.diffuse), g.emissiveTint = g.diffuseTint, g.emissiveMap = g.diffuseMap, g.emissiveMapUv = g.diffuseMapUv, g.emissiveMapTiling.copy(g.diffuseMapTiling), g.emissiveMapOffset.copy(g.diffuseMapOffset), g.emissiveMapChannel = g.diffuseMapChannel, g.emissiveVertexColor = g.diffuseVertexColor, g.emissiveVertexColorChannel = g.diffuseVertexColorChannel, g.diffuse.set(0, 0, 0), g.diffuseTint = !1, g.diffuseMap = null,
                g.diffuseVertexColor = !1);
            g.update();
            return g
        },
        up = function(a, b, c, d, e) {
            var f = function(u) {
                    var x = Yc(u, d);
                    return new xf(Gh(u.type), new x.constructor(x))
                },
                g = {
                    STEP: 0,
                    LINEAR: 1,
                    CUBICSPLINE: 2
                },
                k = {},
                h = [],
                l = {},
                n = [],
                p = [],
                q;
            for (q = 0; q < a.samplers.length; ++q) {
                var r = a.samplers[q];
                k.hasOwnProperty(r.input) || (k[r.input] = h.length, h.push(f(c[r.input])));
                l.hasOwnProperty(r.output) || (l[r.output] = n.length, n.push(f(c[r.output])));
                var t = r.hasOwnProperty("interpolation") && g.hasOwnProperty(r.interpolation) ? g[r.interpolation] :
                    1;
                p.push(new Lg([], k[r.input], l[r.output], t))
            }
            c = [];
            f = new wf;
            g = {
                translation: "localPosition",
                rotation: "localRotation",
                scale: "localScale",
                weights: "weights"
            };
            for (q = 0; q < a.channels.length; ++q) l = a.channels[q], k = l.target, l = p[l.sampler], l._paths.push(f.encode([
                [e[k.node].name], "graph", [g[k.path]]
            ])), k.path.startsWith("rotation") && 2 !== l.interpolation ? c.push(l.output) : k.path.startsWith("weights") && (n[l.output]._components = n[l.output].data.length / h[l.input].data.length);
            c.sort();
            f = null;
            for (q = 0; q < c.length; ++q)
                if (e =
                    c[q], 0 === q || e !== f) {
                    f = n[e];
                    if (4 === f.components)
                        for (f = f.data, g = f.length - 4, k = 0; k < g; k += 4) 0 > f[k + 0] * f[k + 4] + f[k + 1] * f[k + 5] + f[k + 2] * f[k + 6] + f[k + 3] * f[k + 7] && (f[k + 4] *= -1, f[k + 5] *= -1, f[k + 6] *= -1, f[k + 7] *= -1);
                    f = e
                }
            for (q = e = 0; q < h.length; q++) f = h[q]._data, e = Math.max(e, 0 === f.length ? 0 : f[f.length - 1]);
            return new Md(a.hasOwnProperty("name") ? a.name : "animation_" + b, e, h, n, p)
        },
        vp = function(a, b) {
            var c = new Z;
            a.hasOwnProperty("name") && 0 < a.name.length ? c.name = a.name : c.name = "node_" + b;
            a.hasOwnProperty("matrix") && (Ih.data.set(a.matrix), Ih.getTranslation(jf),
                c.setLocalPosition(jf), Ih.getEulerAngles(jf), c.setLocalEulerAngles(jf), Ih.getScale(jf), c.setLocalScale(jf));
            a.hasOwnProperty("rotation") && (b = a.rotation, c.setLocalRotation(b[0], b[1], b[2], b[3]));
            a.hasOwnProperty("translation") && (b = a.translation, c.setLocalPosition(b[0], b[1], b[2]));
            a.hasOwnProperty("scale") && (a = a.scale, c.setLocalScale(a[0], a[1], a[2]));
            return c
        },
        wp = function(a, b, c, d) {
            return b.hasOwnProperty("skins") && 0 !== b.skins.length ? b.skins.map(function(e) {
                var f = b.accessors,
                    g, k = e.joints,
                    h = k.length,
                    l = [];
                if (e.hasOwnProperty("inverseBindMatrices")) {
                    var n = Yc(f[e.inverseBindMatrices], d),
                        p = [];
                    for (f = 0; f < h; f++) {
                        for (g = 0; 16 > g; g++) p[g] = n[16 * f + g];
                        g = new J;
                        g.set(p);
                        l.push(g)
                    }
                } else
                    for (f = 0; f < h; f++) g = new J, l.push(g);
                n = [];
                for (f = 0; f < h; f++) n[f] = c[k[f]].name;
                e = e.skeleton;
                l = new Kg(a, l, n);
                l.skeleton = c[e];
                l.bones = [];
                for (f = 0; f < k.length; f++) l.bones[f] = c[k[f]];
                return l
            }) : []
        },
        xp = function(a, b, c, d, e) {
            if (!b.hasOwnProperty("meshes") || 0 === b.meshes.length || !b.hasOwnProperty("accessors") || 0 === b.accessors.length || !b.hasOwnProperty("bufferViews") ||
                0 === b.bufferViews.length) return [];
            var f = {};
            return b.meshes.map(function(g) {
                return sp(a, g, b.accessors, c, d, e, f)
            })
        },
        yp = function(a, b, c, d) {
            if (!a.hasOwnProperty("materials") || 0 === a.materials.length) return [];
            var e = c && c.material && c.material.preprocess,
                f = c && c.material && c.material.process || tp,
                g = c && c.material && c.material.postprocess;
            return a.materials.map(function(k) {
                e && e(k);
                var h = f(k, b, d);
                g && g(k, h);
                return h
            })
        },
        zp = function(a, b, c, d) {
            if (!a.hasOwnProperty("animations") || 0 === a.animations.length) return [];
            var e = d &&
                d.animation && d.animation.preprocess,
                f = d && d.animation && d.animation.postprocess;
            return a.animations.map(function(g, k) {
                e && e(g);
                k = up(g, k, a.accessors, c, b);
                f && f(g, k);
                return k
            })
        },
        Ap = function(a, b) {
            if (!a.hasOwnProperty("nodes") || 0 === a.nodes.length) return [];
            var c = b && b.node && b.node.preprocess,
                d = b && b.node && b.node.process || vp,
                e = b && b.node && b.node.postprocess;
            b = a.nodes.map(function(n, p) {
                c && c(n);
                p = d(n, p);
                e && e(n, p);
                return p
            });
            for (var f = 0; f < a.nodes.length; ++f) {
                var g = a.nodes[f];
                if (g.hasOwnProperty("children"))
                    for (var k =
                            0; k < g.children.length; ++k) {
                        var h = b[f],
                            l = b[g.children[k]];
                        l.parent || h.addChild(l)
                    }
            }
            return b
        },
        Bp = function(a, b) {
            var c = [],
                d = a.scenes.length;
            if (1 === d && 1 === a.scenes[0].nodes.length) c.push(b[a.scenes[0].nodes[0]]);
            else
                for (var e = 0; e < d; e++) {
                    for (var f = a.scenes[e], g = new Z(f.name), k = 0; k < f.nodes.length; k++) g.addChild(b[f.nodes[k]]);
                    c.push(g)
                }
            return c
        },
        Gm = function(a, b, c, d, e, f) {
            var g = e && e.global && e.global.preprocess,
                k = e && e.global && e.global.postprocess;
            g && g(b);
            var h = b.asset && "PlayCanvas" === b.asset.generator;
            g = Ap(b,
                e);
            var l = Bp(b, g),
                n = zp(b, g, c, e);
            e = yp(b, d.map(function(p) {
                return p.resource
            }), e, h);
            h = xp(a, b, c, f, h);
            a = wp(a, b, g, c);
            d = {
                gltf: b,
                nodes: g,
                scenes: l,
                animations: n,
                textures: d,
                materials: e,
                meshes: h,
                skins: a
            };
            k && k(b, d);
            f(null, d)
        },
        Cp = function(a, b) {
            var c = {
                    magFilter: 9729,
                    minFilter: 9987,
                    wrapS: 10497,
                    wrapT: 10497
                },
                d = function(f) {
                    switch (f) {
                        case 9728:
                            return 0;
                        case 9729:
                            return 1;
                        case 9984:
                            return 2;
                        case 9985:
                            return 4;
                        case 9986:
                            return 3;
                        case 9987:
                            return 5;
                        default:
                            return 1
                    }
                },
                e = function(f) {
                    switch (f) {
                        case 33071:
                            return 1;
                        case 33648:
                            return 2;
                        case 10497:
                            return 0;
                        default:
                            return 0
                    }
                };
            a && (b = b || c, a.minFilter = d(b.minFilter), a.magFilter = d(b.magFilter), a.addressU = e(b.wrapS), a.addressV = e(b.wrapT))
        },
        Dp = function(a, b, c, d, e, f, g) {
            var k = f && f.image && f.image.preprocess,
                h = f && f.image && f.image.processAsync || function(p, q) {
                    q(null, null)
                },
                l = f && f.image && f.image.postprocess,
                n = function(p, q, r, t) {
                    var u = {
                            "image/png": "png",
                            "image/jpeg": "jpg",
                            "image/basis": "basis",
                            "image/ktx": "ktx",
                            "image/vnd-ms.dds": "dds"
                        },
                        x = {
                            url: p
                        };
                    q && (q = u[q]) && (x.filename = "glb-texture-" + b + "." + q);
                    var v = new aa("texture_" + b, "texture", x, null, {
                        crossOrigin: r
                    });
                    v.on("load", function() {
                        t && URL.revokeObjectURL(p);
                        l && l(a, v);
                        g(null, v)
                    });
                    v.on("error", function(w, y) {
                        g(w)
                    });
                    e.add(v);
                    e.load(v)
                };
            k && k(a);
            h(a, function(p, q) {
                p ? g(p) : q ? (l && l(a, q), g(null, q)) : a.hasOwnProperty("uri") ? /^data:.*,.*$/i.test(a.uri) ? (q = p = a.uri, q = q.substring(q.indexOf(":") + 1, q.indexOf(";")), n(p, q)) : n(ca.join(d, a.uri), null, "anonymous") : a.hasOwnProperty("bufferView") && a.hasOwnProperty("mimeType") ? (p = new Blob([c[a.bufferView]], {
                        type: a.mimeType
                    }),
                    n(URL.createObjectURL(p), a.mimeType, null, !0)) : g("Invalid image found in gltf (neither uri or bufferView found). index=" + b)
            })
        },
        Ep = function(a, b, c, d, e, f) {
            if (a.hasOwnProperty("images") && 0 !== a.images.length && a.hasOwnProperty("textures") && 0 !== a.textures.length)
                for (var g = e && e.texture && e.texture.preprocess, k = e && e.texture && e.texture.processAsync || function(u, x, v) {
                        v(null, null)
                    }, h = e && e.texture && e.texture.postprocess, l = [], n = [], p = a.textures.length, q = function(u, x) {
                        n[x] || (n[x] = []);
                        n[x].push(u);
                        if (0 === --p) {
                            var v = [];
                            n.forEach(function(w, y) {
                                w.forEach(function(A, B) {
                                    if (0 === B) var E = l[y];
                                    else {
                                        E = l[y];
                                        var D = new pc.Asset(E.name + "_clone", E.type, E.file, E.data, E.options);
                                        D.loaded = !0;
                                        for (var C = E.resource, G = new pc.Texture(C.device, C), K = [], R = 0; R < C._levels.length; ++R) {
                                            var I = [];
                                            if (C.cubemap)
                                                for (var T = 0; 6 > T; ++T) I.push(C._levels[R][T]);
                                            else I = C._levels[R];
                                            K.push(I)
                                        }
                                        G._levels = K;
                                        D.resource = G;
                                        E.registry.add(D);
                                        E = D
                                    }
                                    Cp(E.resource, (a.samplers || [])[a.textures[A].sampler]);
                                    v[A] = E;
                                    h && h(a.textures[B], E)
                                })
                            });
                            f(null, v)
                        }
                    }, r = 0; r < a.textures.length; ++r) {
                    var t =
                        a.textures[r];
                    g && g(t);
                    k(t, a.images, function(u, x, v, w) {
                        if (v) f(v);
                        else {
                            if (void 0 === w || null === w) w = x.source;
                            l[w] ? q(u, w) : Dp(a.images[w], u, b, c, d, e, function(y, A) {
                                y ? f(y) : (l[w] = A, q(u, w))
                            })
                        }
                    }.bind(null, r, t))
                } else f(null, [])
        },
        Fp = function(a, b, c, d, e) {
            var f = [];
            if (null === a.buffers || 0 === a.buffers.length) e(null, f);
            else {
                var g = d && d.buffer && d.buffer.preprocess,
                    k = d && d.buffer && d.buffer.processAsync || function(q, r) {
                        r(null, null)
                    },
                    h = d && d.buffer && d.buffer.postprocess,
                    l = a.buffers.length,
                    n = function(q, r) {
                        f[q] = r;
                        h && h(a.buffers[q],
                            r);
                        0 === --l && e(null, f)
                    };
                for (d = 0; d < a.buffers.length; ++d) {
                    var p = a.buffers[d];
                    g && g(p);
                    k(p, function(q, r, t, u) {
                        if (t) e(t);
                        else if (u) n(q, new Uint8Array(u));
                        else if (r.hasOwnProperty("uri"))
                            if (/^data:.*,.*$/i.test(r.uri)) {
                                r = atob(r.uri.split(",")[1]);
                                t = new Uint8Array(r.length);
                                for (u = 0; u < r.length; u++) t[u] = r.charCodeAt(u);
                                n(q, t)
                            } else wa.get(ca.join(c, r.uri), {
                                cache: !0,
                                responseType: "arraybuffer",
                                retry: !1
                            }, function(x, v, w) {
                                v ? e(v) : n(x, new Uint8Array(w))
                            }.bind(null, q));
                        else n(q, b)
                    }.bind(null, d, p))
                }
            }
        },
        Hm = function(a, b) {
            a =
                JSON.parse(function(c) {
                    if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(c);
                    for (var d = "", e = 0; e < c.length; e++) d += String.fromCharCode(c[e]);
                    return decodeURIComponent(escape(d))
                }(a));
            a.asset && a.asset.version && 2 > parseFloat(a.asset.version) ? b("Invalid gltf version. Expected version 2.0 or above but found version '" + a.asset.version + "'.") : b(null, a)
        },
        Im = function(a, b, c) {
            if (a && a.toLowerCase().endsWith(".glb")) {
                a = new DataView(b);
                var d = a.getUint32(0, !0),
                    e = a.getUint32(4, !0),
                    f = a.getUint32(8, !0);
                if (1179937895 !== d) c("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + d.toString(16));
                else if (2 !== e) c("Invalid version number found in glb header. Expected 2, found " + e);
                else if (0 >= f || f > b.byteLength) c("Invalid length found in glb header. Found " + f);
                else {
                    d = [];
                    for (e = 12; e < f;) {
                        var g = a.getUint32(e, !0);
                        if (e + g + 8 > b.byteLength) throw Error("Invalid chunk length found in glb. Found " + g);
                        var k = a.getUint32(e + 4, !0),
                            h = new Uint8Array(b, e + 8, g);
                        d.push({
                            length: g,
                            type: k,
                            data: h
                        });
                        e += g + 8
                    }
                    1 !== d.length &&
                        2 !== d.length ? c("Invalid number of chunks found in glb file.") : 1313821514 !== d[0].type ? c("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + d[0].type.toString(16)) : 1 < d.length && 5130562 !== d[1].type ? c("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + d[1].type.toString(16)) : c(null, {
                            gltfChunk: d[0].data,
                            binaryChunk: 2 === d.length ? d[1].data : null
                        })
                }
            } else c(null, {
                gltfChunk: b,
                binaryChunk: null
            })
        },
        Jm = function(a, b, c, d) {
            var e = [],
                f = c && c.bufferView && c.bufferView.preprocess,
                g = c &&
                c.bufferView && c.bufferView.processAsync || function(p, q, r) {
                    r(null, null)
                },
                k = c && c.bufferView && c.bufferView.postprocess,
                h = a.bufferViews.length,
                l = function(p, q) {
                    var r = a.bufferViews[p];
                    r.hasOwnProperty("byteStride") && (q.byteStride = r.byteStride);
                    e[p] = q;
                    k && k(r, q);
                    0 === --h && d(null, e)
                };
            for (c = 0; c < a.bufferViews.length; ++c) {
                var n = a.bufferViews[c];
                f && f(n);
                g(n, b, function(p, q, r, t) {
                    r ? d(r) : t ? l(p, t) : (r = b[q.buffer], q = new Uint8Array(r.buffer, r.byteOffset + (q.hasOwnProperty("byteOffset") ? q.byteOffset : 0), q.byteLength), l(p,
                        q))
                }.bind(null, c, n))
            }
        };
    gd.parseAsync = function(a, b, c, d, e, f, g) {
        Im(a, c, function(k, h) {
            k ? g(k) : Hm(h.gltfChunk, function(l, n) {
                l ? g(l) : Fp(n, h.binaryChunk, b, f, function(p, q) {
                    p ? g(p) : Jm(n, q, f, function(r, t) {
                        r ? g(r) : Ep(n, t, b, e, f, function(u, x) {
                            u ? g(u) : Gm(d, n, t, x, f, g)
                        })
                    })
                })
            })
        })
    };
    gd.parse = function(a, b, c, d) {
        var e = null;
        d = d || {};
        Im(a, b, function(f, g) {
            f ? console.error(f) : Hm(g.gltfChunk, function(k, h) {
                k ? console.error(k) : Jm(h, [g.binaryChunk], d, function(l, n) {
                    l ? console.error(l) : Gm(c, h, n, [], d, function(p, q) {
                        p ? console.error(p) : e = q
                    })
                })
            })
        });
        return e
    };
    gd.createModel = function(a, b) {
        var c = new tb,
            d, e = [];
        for (d = 0; d < a.skins.length; d++) {
            var f = new Ic(a.skins[d]);
            f.bones = a.skins[d].bones;
            e.push(f)
        }
        if (1 === a.scenes.length) c.graph = a.scenes[0];
        else
            for (c.graph = new Z("SceneGroup"), d = 0; d < a.scenes.length; d++) c.graph.addChild(a.scenes[d]);
        for (d = 0; d < a.nodes.length; d++)
            if (f = a.nodes[d], f.root === c.graph) {
                var g = a.gltf.nodes[d];
                if (g.hasOwnProperty("mesh"))
                    for (var k = a.meshes[g.mesh], h = 0; h < k.length; h++) {
                        var l = c,
                            n = k[h],
                            p = a.skins,
                            q = e,
                            r = g,
                            t = new va(f, n, void 0 === n.materialIndex ?
                                b : a.materials[n.materialIndex]);
                        if (n.morph) {
                            var u = new uf(n.morph);
                            if (n.weights)
                                for (var x = 0; x < n.weights.length; x++) u.setWeight(x, n.weights[x]);
                            t.morphInstance = u;
                            l.morphInstances.push(u)
                        }
                        r.hasOwnProperty("skin") && (r = r.skin, n.skin = p[r], n = q[r], t.skinInstance = n, l.skinInstances.push(n));
                        l.meshInstances.push(t)
                    }
            }
        return c
    };
    Object.assign(zi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            };
            a.load.startsWith("blob:") && (".glb" ===
                ca.getExtension(a.original).toLowerCase() ? c.responseType = da.ResponseType.ARRAY_BUFFER : c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                d ? b("Error loading animation resource: " + a.original + " [" + d + "]") : b(null, e)
            })
        },
        open: function(a, b) {
            return ".glb" === ca.getExtension(a).toLowerCase() ? (a = gd.parse("filename.glb", b, null)) ? a.animations : null : this["_parseAnimationV" + b.animation.version](b)
        },
        _parseAnimationV3: function(a) {
            a = a.animation;
            var b = new Rb;
            b.setName(a.name);
            b.duration = a.duration;
            for (var c =
                    0; c < a.nodes.length; c++) {
                var d = new Jg,
                    e = a.nodes[c];
                d._name = e.name;
                for (var f = 0; f < e.keys.length; f++) {
                    var g = e.keys[f],
                        k = g.time,
                        h = g.pos,
                        l = g.rot;
                    g = g.scale;
                    h = new z(h[0], h[1], h[2]);
                    l = (new Y).setFromEulerAngles(l[0], l[1], l[2]);
                    g = new z(g[0], g[1], g[2]);
                    k = new Ig(k, h, l, g);
                    d._keys.push(k)
                }
                b.addNode(d)
            }
            return b
        },
        _parseAnimationV4: function(a) {
            a = a.animation;
            var b = new Rb;
            b.setName(a.name);
            b.duration = a.duration;
            for (var c = 0; c < a.nodes.length; c++) {
                var d = new Jg,
                    e = a.nodes[c];
                d._name = e.name;
                for (var f = e.defaults.p, g = e.defaults.r,
                        k = e.defaults.s, h = 0; h < e.keys.length; h++) {
                    var l = e.keys[h],
                        n = l.t,
                        p = f ? f : l.p,
                        q = g ? g : l.r;
                    l = k ? k : l.s;
                    p = new z(p[0], p[1], p[2]);
                    q = (new Y).setFromEulerAngles(q[0], q[1], q[2]);
                    l = new z(l[0], l[1], l[2]);
                    n = new Ig(n, p, q, l);
                    d._keys.push(n)
                }
                b.addNode(d)
            }
            return b
        }
    });
    Object.assign(Ai.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            };
            a.load.startsWith("blob:") && (c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                d ? b("Error loading animation clip resource: " +
                    a.original + " [" + d + "]") : b(null, e)
            })
        },
        open: function(a, b) {
            a = b.name;
            var c = b.duration,
                d = b.inputs.map(function(f) {
                    return new xf(1, f)
                }),
                e = b.outputs.map(function(f) {
                    return new xf(f.components, f.data)
                });
            b = b.curves.map(function(f) {
                return new Lg([f.path], f.inputIndex, f.outputIndex, f.interpolation)
            });
            return new Md(a, c, d, e, b)
        }
    });
    Object.defineProperties(Af.prototype, {
        parameters: {
            get: function() {
                return Object.assign({}, this._parameters)
            }
        },
        layers: {
            get: function() {
                return this._layers
            }
        }
    });
    Object.assign(Bi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            };
            a.load.startsWith("blob:") && (c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                d ? b("Error loading animation state graph resource: " + a.original + " [" + d + "]") : b(null, e)
            })
        },
        open: function(a, b) {
            return new Af(b)
        }
    });
    Object.defineProperty(Ng.prototype, "duration", {
        get: function() {
            var a = 0;
            this.buffer ? a = this.buffer.duration : this.audio && (a = this.audio.duration);
            return a || 0
        }
    });
    var jk = function() {
        if ("undefined" === typeof window) return !1;
        var a = window.navigator.userAgent,
            b = a.indexOf("MSIE ");
        return 0 < b ? parseInt(a.substring(b + 5, a.indexOf(".", b)), 10) : 0 < a.indexOf("Trident/") ? (b = a.indexOf("rv:"), parseInt(a.substring(b + 3, a.indexOf(".", b)), 10)) : !1
    }();
    Object.assign(Bf.prototype, {
        _isSupported: function(a) {
            return {
                ".ogg": "audio/ogg",
                ".mp3": "audio/mpeg",
                ".wav": "audio/x-wav",
                ".mp4a": "audio/mp4",
                ".m4a": "audio/mp4",
                ".mp4": "audio/mp4",
                ".aac": "audio/aac"
            }[ca.getExtension(a)] ? !0: !1
        },
        load: function(a,
            b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = function(e) {
                    b(null, new Ng(e))
                },
                d = function(e) {
                    var f = "Error loading audio url: " + a.original;
                    e && (f += ": " + (e.message || e));
                    console.warn(f);
                    b(f)
                };
            this._createSound ? this._isSupported(a.original) ? this._createSound(a.load, c, d) : d("Audio format for " + a.original + " not supported") : d(null)
        },
        open: function(a, b) {
            return b
        }
    });
    fd() ? Bf.prototype._createSound = function(a, b, c) {
        var d = this.manager;
        if (d.context) {
            var e = {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            };
            a.startsWith("blob:") && (e.responseType = da.ResponseType.ARRAY_BUFFER);
            wa.get(a, e, function(f, g) {
                f ? c(f) : d.context.decodeAudioData(g, b, c)
            })
        } else c("Audio manager has no audio context")
    } : we() && (Bf.prototype._createSound = function(a, b, c) {
        var d = null;
        try {
            d = new Audio
        } catch (f) {
            c("No support for Audio element");
            return
        }
        jk && document.body.appendChild(d);
        var e = function() {
            d.removeEventListener("canplaythrough", e);
            jk && document.body.removeChild(d);
            b(d)
        };
        d.onerror = function() {
            d.onerror = null;
            jk && document.body.removeChild(d);
            c()
        };
        d.addEventListener("canplaythrough", e);
        d.src = a
    });
    Object.assign(Ci.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                responseType: da.ResponseType.ARRAY_BUFFER,
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(c, d) {
                c ? b("Error loading binary resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    Cf.prototype.hasBlobUrl = function(a) {
        return !!this._blobUrls[a]
    };
    Cf.prototype.getBlobUrl = function(a) {
        return this._blobUrls[a]
    };
    Cf.prototype.destroy = function() {
        for (var a in this._blobUrls) URL.revokeObjectURL(this._blobUrls[a]);
        this._blobUrls = null
    };
    var $k, Di = null;
    Df.prototype._onMessage = function(a) {
        var b = a.data.id;
        if (this._pendingRequests[b]) {
            var c = this._pendingRequests[b];
            delete this._pendingRequests[b];
            if (a.data.error) c(a.data.error);
            else {
                b = a.data.arrayBuffer;
                for (var d = 0, e = a.data.files.length; d < e; d++) {
                    var f = a.data.files[d],
                        g = new Blob([b.slice(f.start, f.start + f.size)]);
                    f.url = URL.createObjectURL(g)
                }
                c(null, a.data.files)
            }
        }
    };
    Df.prototype.untar = function(a, b) {
        var c = this._requestId++;
        this._pendingRequests[c] = b;
        this._worker.postMessage({
            id: c,
            prefix: this._filenamePrefix,
            arrayBuffer: a
        }, [a])
    };
    Df.prototype.hasPendingRequests = function() {
        for (var a in this._pendingRequests) return !0;
        return !1
    };
    Df.prototype.destroy = function() {
        this._worker && (this._worker.terminate(), this._pendingRequests = this._worker = null)
    };
    Zk();
    Object.assign(Ei.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this;
            wa.get(a.load, {
                responseType: da.ResponseType.ARRAY_BUFFER,
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(d, e) {
                if (d) b("Error loading bundle resource " + a.original + ": " + d);
                else try {
                    c._untar(e, b)
                } catch (f) {
                    b("Error loading bundle resource " + a.original + ": " + f)
                }
            })
        },
        _untar: function(a, b) {
            var c = this;
            Da.workers ? (c._worker || (c._worker = new Df(c._assets.prefix)), c._worker.untar(a, function(d, e) {
                b(d, e);
                c._worker.hasPendingRequests() || (c._worker.destroy(), c._worker = null)
            })) : (a = (new $k(a)).untar(c._assets.prefix), b(null, a))
        },
        open: function(a, b) {
            return new Cf(b)
        },
        patch: function(a, b) {}
    });
    Object.assign(Fi.prototype, {
        destroy: function() {
            var a = this.registry,
                b = function(d) {
                    a.remove(d);
                    d.unload()
                },
                c = function(d) {
                    d.forEach(function(e) {
                        b(e)
                    })
                };
            this.animations && (c(this.animations), this.animations = null);
            this.textures && (c(this.textures), this.textures = null);
            this.materials && (c(this.materials), this.materials = null);
            this.model && (b(this.model), this.model = null);
            this.assets = this.data = null
        }
    });
    Object.assign(Gi.prototype, {
        _getUrlWithoutParams: function(a) {
            return 0 <= a.indexOf("?") ?
                a.split("?")[0] : a
        },
        load: function(a, b, c) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var d = {
                    responseType: da.ResponseType.ARRAY_BUFFER,
                    retry: 0 < this.maxRetries,
                    maxRetries: this.maxRetries
                },
                e = this,
                f = function(g) {
                    gd.parseAsync(e._getUrlWithoutParams(a.original), ca.extractPath(a.load), g, e._device, c.registry, c.options, function(k, h) {
                        k ? b(k) : b(null, new Fi(h))
                    })
                };
            c && c.file && c.file.contents ? f(c.file.contents) : wa.get(a.load, d, function(g, k) {
                b && (g ? b("Error loading model: " + a.original + " [" + g + "]") : f(k))
            })
        },
        open: function(a,
            b, c) {
            return b
        },
        patch: function(a, b) {
            var c = a.resource,
                d = c && c.data;
            if (d) {
                var e = function(l, n, p) {
                        l = new aa(a.name + "/" + l + "/" + p, l, {
                            url: ""
                        });
                        l.resource = n;
                        l.loaded = !0;
                        b.add(l);
                        return l
                    },
                    f, g = e("model", gd.createModel(d, this._defaultMaterial), 0),
                    k = [];
                for (f = 0; f < d.materials.length; ++f) k.push(e("material", d.materials[f], f));
                var h = [];
                for (f = 0; f < d.animations.length; ++f) h.push(e("animation", d.animations[f], f));
                c.data = null;
                c.model = g;
                c.materials = k;
                c.textures = d.textures;
                c.animations = h;
                c.registry = b
            }
        }
    });
    Object.assign(Hi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(c, d) {
                c ? b("Error loading css resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    Object.assign(Ii.prototype, {
        load: function(a, b, c) {
            this.loadAssets(c, b)
        },
        open: function(a, b, c) {
            return c ? c.resource : null
        },
        patch: function(a, b) {
            this.loadAssets(a, function(c, d) {
                c && (b.fire("error", a), b.fire("error:" + a.id, c, a), a.fire("error",
                    a))
            })
        },
        getAssetIds: function(a) {
            var b = [];
            b[0] = a.file;
            if ((a.loadFaces || !a.file) && a.data && a.data.textures)
                for (var c = 0; 6 > c; ++c) b[c + 1] = a.data.textures[c];
            else b[1] = b[2] = b[3] = b[4] = b[5] = b[6] = null;
            return b
        },
        compareAssetIds: function(a, b) {
            return a && b ? parseInt(a, 10) === a || "string" === typeof a ? a === b : a.url === b.url : null !== a === (null !== b)
        },
        update: function(a, b, c) {
            var d = a.data || {},
                e = a._handlerState.assets,
                f = a._resources,
                g, k, h = [null, null, null, null, null, null, null],
                l = function() {
                    return d.hasOwnProperty("type") ? d.type : d.hasOwnProperty("rgbm") ?
                        d.rgbm ? "rgbm" : "default" : null
                };
            if (a.loaded && c[0] === e[0]) h[1] = f[1] || null, h[2] = f[2] || null, h[3] = f[3] || null, h[4] = f[4] || null, h[5] = f[5] || null, h[6] = f[6] || null;
            else if (c[0]) {
                var n = c[0].resource;
                for (k = 0; 6 > k; ++k) {
                    var p = [n._levels[k]];
                    if (0 === k && this._device.useTexCubeLod)
                        for (g = 1; g < n._levels.length; ++g) p[g] = n._levels[g];
                    p = new V(this._device, {
                        name: a.name + "_prelitCubemap" + (n.width >> k),
                        cubemap: !0,
                        type: l() || n.type,
                        width: n.width >> k,
                        height: n.height >> k,
                        format: n.format,
                        levels: p,
                        fixCubemapSeams: !0,
                        addressU: 1,
                        addressV: 1
                    });
                    h[k + 1] = p
                }
            }
            n = c.slice(1);
            if (a.loaded && this.cmpArrays(n, e.slice(1))) h[0] = f[0] || null;
            else if (-1 === n.indexOf(null)) {
                n = n.map(function(q) {
                    return q.resource
                });
                k = [];
                for (g = 0; g < n[0]._levels.length; ++g) k.push(n.map(function(q) {
                    return q._levels[g]
                }));
                l = new V(this._device, {
                    name: a.name + "_faces",
                    cubemap: !0,
                    type: l() || n[0].type,
                    width: n[0].width,
                    height: n[0].height,
                    format: n[0].format,
                    levels: k,
                    minFilter: d.hasOwnProperty("minFilter") ? d.minFilter : n[0].minFilter,
                    magFilter: d.hasOwnProperty("magFilter") ? d.magFilter : n[0].magFilter,
                    anisotropy: d.hasOwnProperty("anisotropy") ? d.anisotropy : 1,
                    addressU: 1,
                    addressV: 1,
                    fixCubemapSeams: !!c[0]
                });
                h[0] = l
            }
            if (!this.cmpArrays(h, f))
                for (a.resources = h, a._handlerState.assetIds = b, a._handlerState.assets = c, k = 0; k < f.length; ++k) null !== f[k] && -1 === h.indexOf(f[k]) && f[k].destroy();
            for (k = 0; k < e.length; ++k) null !== e[k] && -1 === c.indexOf(e[k]) && e[k].unload()
        },
        cmpArrays: function(a, b) {
            if (a.length !== b.length) return !1;
            for (var c = 0; c < a.length; ++c)
                if (a[c] !== b[c]) return !1;
            return !0
        },
        resolveId: function(a) {
            var b = parseInt(a,
                10);
            return b === a || b.toString() === a ? b : a
        },
        loadAssets: function(a, b) {
            a.hasOwnProperty("_handlerState") || (a._handlerState = {
                assetIds: [null, null, null, null, null, null, null],
                assets: [null, null, null, null, null, null, null]
            });
            for (var c = this, d = c.getAssetIds(a), e = [null, null, null, null, null, null, null], f = a._handlerState.assetIds, g = a._handlerState.assets, k = c._registry, h = 7, l = function(x, v) {
                    e[x] = v;
                    h--;
                    0 === h && (c.update(a, d, e), b(null, a.resources))
                }, n = function(x, v) {
                    var w = v && v.resource && v.resource._levels[0];
                    w && "undefined" !==
                        typeof ImageBitmap && w instanceof ImageBitmap ? createImageBitmap(w, {
                            premultiplyAlpha: "none",
                            imageOrientation: "flipY"
                        }).then(function(y) {
                            v.resource._levels[0] = y;
                            l(x, v)
                        }).catch(function(y) {
                            b(y)
                        }) : l(x, v)
                }, p = function(x, v, w) {
                    b(v)
                }, q = function(x, v) {
                    v.loaded ? n(x, v) : (k.once("load:" + v.id, n.bind(c, x)), k.once("error:" + v.id, p.bind(c, x)), v.loading || k.load(v))
                }, r, t = 0; 7 > t; ++t) {
                var u = this.resolveId(d[t]);
                u ? c.compareAssetIds(u, f[t]) ? l(t, g[t]) : parseInt(u, 10) === u ? (r = k.get(u)) ? q(t, r) : setTimeout(function(x, v) {
                    var w = k.get(v);
                    w ? q(x, w) : b("failed to find dependent cubemap asset=" + v)
                }.bind(null, t, u)) : (r = new aa(a.name + "_part_" + t, "texture", "string" === typeof u ? {
                    url: u,
                    filename: u
                } : u), k.add(r), k.once("load:" + r.id, n.bind(c, t)), k.once("error:" + r.id, p.bind(c, t)), k.load(r)) : l(t, null)
            }
        }
    });
    Object.assign(Ji.prototype, {
        load: function(a, b) {
            b(null, null)
        },
        open: function(a, b) {
            return b
        }
    });
    Object.defineProperty(Og.prototype, "data", {
        get: function() {
            return this._data
        },
        set: function(a) {
            if (this._data = a)
                if (void 0 !== this._data.intensity && (this.intensity =
                        this._data.intensity), this._data.info || (this._data.info = {}), !this._data.version || 2 > this._data.version)
                    if (this._data.info.maps = [{
                            width: this._data.info.width,
                            height: this._data.info.height
                        }], this._data.chars)
                        for (var b in this._data.chars) this._data.chars[b].map = 0
        }
    });
    Object.assign(Li.prototype, {
        load: function(a, b, c) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var d = this;
            ".json" === ca.getExtension(a.original) ? wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(e, f) {
                if (e) b("Error loading font resource: " +
                    a.original + " [" + e + "]");
                else {
                    var g = Ki(f);
                    d._loadTextures(a.load.replace(".json", ".png"), g, function(k, h) {
                        if (k) return b(k);
                        b(null, {
                            data: g,
                            textures: h
                        })
                    })
                }
            }) : (c && c.data && (c.data = Ki(c.data)), this._loadTextures(a.load, c && c.data, b))
        },
        _loadTextures: function(a, b, c) {
            var d = b.info.maps.length,
                e = 0,
                f = null,
                g = Array(d),
                k = this._loader;
            b = function(l) {
                var n = function(p, q) {
                    if (!f) {
                        if (p) return f = p, c(p);
                        q.upload();
                        g[l] = q;
                        e++;
                        e === d && c(null, g)
                    }
                };
                0 === l ? k.load(a, "texture", n) : k.load(a.replace(".png", l + ".png"), "texture", n)
            };
            for (var h =
                    0; h < d; h++) b(h)
        },
        open: function(a, b, c) {
            return b.textures ? new Og(b.textures, b.data) : new Og(b, null)
        },
        patch: function(a, b) {
            b = a.resource;
            !b.data && a.data ? b.data = a.data : !a.data && b.data && (a.data = b.data);
            a.data && (a.data = Ki(a.data))
        }
    });
    Eb.prototype = Object.create(M.prototype);
    Eb.prototype.constructor = Eb;
    Eb.prototype.destroy = function() {
        var a = this;
        this._registry.off("load", this._onLoad);
        this._registry.off("error", this._onError);
        this._waitingAssets.forEach(function(b) {
            a._registry.off("add:" + b, this._onAddAsset)
        });
        this.off("progress");
        this.off("load")
    };
    Eb.prototype.load = function(a, b) {
        var c = this._assets.length;
        this._count = 0;
        this._failed = [];
        this._callback = a;
        this._scope = b;
        this._registry.on("load", this._onLoad, this);
        this._registry.on("error", this._onError, this);
        for (a = 0; a < c; a++) b = this._assets[a], b.loading || b.loaded || (this._registry.load(b), this._total++)
    };
    Eb.prototype.ready = function(a, b) {
        b = b || this;
        if (this._loaded) a.call(b, this._assets);
        else this.once("load", function(c) {
            a.call(b, c)
        })
    };
    Eb.prototype._loadingComplete =
        function() {
            this._loaded = !0;
            this._registry.off("load", this._onLoad, this);
            this._registry.off("error", this._onError, this);
            this._failed && this._failed.length ? (this._callback && this._callback.call(this._scope, "Failed to load some assets", this._failed), this.fire("error", this._failed)) : (this._callback && this._callback.call(this._scope), this.fire("load", this._assets))
        };
    Eb.prototype._onLoad = function(a) {
        var b = this;
        0 <= this._assets.indexOf(a) && (this._count++, this.fire("progress", a));
        this._count === this._total && setTimeout(function() {
                b._loadingComplete(b._failed)
            },
            0)
    };
    Eb.prototype._onError = function(a, b) {
        var c = this;
        0 <= this._assets.indexOf(b) && (this._count++, this._failed.push(b));
        this._count === this._total && setTimeout(function() {
            c._loadingComplete(c._failed)
        }, 0)
    };
    Eb.prototype._onAddAsset = function(a) {
        var b = this._waitingAssets.indexOf(a);
        0 <= b && this._waitingAssets.splice(b, 1);
        this._assets.push(a);
        var c = this._assets.length;
        for (b = 0; b < c; b++) a = this._assets[b], a.loading || a.loaded || this._registry.load(a)
    };
    Eb.prototype._waitForAsset = function(a) {
        this._waitingAssets.push(a);
        this._registry.once("add:" + a, this._onAddAsset, this)
    };
    var Zc = {
            waitForTemplatesInScene: function(a, b, c) {
                if (a.collapsedInstances) {
                    var d = Zc._getAllCollapsedEntities(a);
                    Zc.waitForTemplateAssets(d, b, c, a)
                } else c(null, a)
            },
            waitForTemplateAssets: function(a, b, c, d) {
                a = Zc._extractTemplateIds(a);
                (new Eb(a, b)).load(function(e) {
                    c(e, d)
                })
            },
            _getAllCollapsedEntities: function(a) {
                var b = {};
                a.collapsedInstances.forEach(function(c) {
                    Object.assign(b, c.instanceEntities)
                });
                return b
            },
            _extractTemplateIds: function(a) {
                var b = [],
                    c;
                for (c in a) {
                    var d =
                        a[c].template_id;
                    d && b.push(d)
                }
                return b
            },
            expandTemplateEntities: function(a, b) {
                var c = {},
                    d;
                for (d in b) {
                    var e = b[d];
                    c[d] = e.collapsed_entity ? Zc.expandEntity(a, e) : e
                }
                return c
            },
            expandEntity: function(a, b) {}
        },
        kk = {
            setCompressedPRS: function(a, b, c) {
                var d = c.singleVecs,
                    e = b.___1;
                if (!e) {
                    var f = c.tripleVecs;
                    var g = b.___2
                }
                b = e ? e[0] : f[g];
                a.setLocalPosition(d[b], d[b + 1], d[b + 2]);
                b = e ? e[1] : f[g + 1];
                a.setLocalEulerAngles(d[b], d[b + 1], d[b + 2]);
                b = e ? e[2] : f[g + 2];
                a.setLocalScale(d[b], d[b + 1], d[b + 2])
            },
            oneCharToKey: function(a, b) {
                a = a.charCodeAt(0) -
                    b.fieldFirstCode;
                return b.fieldArray[a]
            },
            multCharToKey: function(a, b) {
                for (var c = 0, d = 0; d < a.length; d++) c = c * b.fieldCodeBase + a.charCodeAt(d) - b.fieldFirstCode;
                return b.fieldArray[c]
            }
        };
    Object.assign(Pg.prototype, {
        run: function() {
            var a = Object.prototype.toString.call(this._node);
            "[object Object]" === a ? this._handleMap() : "[object Array]" === a ? this._handleArray() : this._result = this._node;
            return this._result
        },
        _handleMap: function() {
            this._result = {};
            Object.keys(this._node).forEach(this._handleKey, this)
        },
        _handleKey: function(a) {
            var b =
                a,
                c = a.length;
            1 === c ? b = kk.oneCharToKey(a, this._data) : 2 === c && (b = kk.multCharToKey(a, this._data));
            this._result[b] = (new Pg(this._node[a], this._data)).run()
        },
        _handleArray: function() {
            this._result = [];
            this._node.forEach(this._handleArElt, this)
        },
        _handleArElt: function(a) {
            a = (new Pg(a, this._data)).run();
            this._result.push(a)
        }
    });
    Object.assign(Qg.prototype, {
        parse: function(a) {
            var b = {},
                c, d, e = null;
            if (d = a.compressedFormat) a.entities = (new Pg(a.entities, d)).run();
            a.collapsedInstances && this._addCollapsedToEntities(this._app,
                a);
            for (c in a.entities) {
                var f = a.entities[c];
                var g = this._createEntity(f, d);
                b[c] = g;
                null === f.parent && (e = g)
            }
            for (c in a.entities) {
                g = b[c];
                f = a.entities[c].children;
                var k = f.length;
                for (d = 0; d < k; d++) {
                    var h = b[f[d]];
                    h && g.addChild(h)
                }
            }
            this._openComponentData(e, a.entities);
            delete a.compressedFormat;
            return e
        },
        _createEntity: function(a, b) {
            var c = new fa;
            c.name = a.name;
            c.setGuid(a.resource_id);
            this._setPosRotScale(c, a, b);
            c._enabled = void 0 !== a.enabled ? a.enabled : !0;
            this._isTemplate ? c._template = !0 : c._enabledInHierarchy = c._enabled;
            c.template = a.template;
            if (a.tags)
                for (b = 0; b < a.tags.length; b++) c.tags.add(a.tags[b]);
            a.labels && a.labels.forEach(function(d) {
                c.addLabel(d)
            });
            return c
        },
        _setPosRotScale: function(a, b, c) {
            if (c) kk.setCompressedPRS(a, b, c);
            else {
                c = b.position;
                var d = b.rotation;
                b = b.scale;
                a.setLocalPosition(c[0], c[1], c[2]);
                a.setLocalEulerAngles(d[0], d[1], d[2]);
                a.setLocalScale(b[0], b[1], b[2])
            }
        },
        _openComponentData: function(a, b) {
            var c = this._app.systems.list,
                d, e = c.length,
                f = b[a.getGuid()];
            for (d = 0; d < e; d++) {
                var g = c[d],
                    k = f.components[g.id];
                k && g.addComponent(a, k)
            }
            e = f.children.length;
            c = a._children;
            for (d = 0; d < e; d++) c[d] = this._openComponentData(c[d], b);
            return a
        },
        _addCollapsedToEntities: function(a, b) {
            b.collapsedInstances.forEach(function(c) {
                c = Zc.expandTemplateEntities(a, c.instanceEntities);
                Object.assign(b.entities, c)
            })
        }
    });
    Object.assign(Mi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this._app.assets;
            wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(d, e) {
                d ? (e = "Error while loading scene " +
                    a.original, d.message ? (e += ": " + d.message, d.stack && (e += "\n" + d.stack)) : e += ": " + d, b(e)) : Zc.waitForTemplatesInScene(e, c, b)
            })
        },
        open: function(a, b) {
            this._app.systems.script.preloading = !0;
            a = (new Qg(this._app, !1)).parse(b);
            this._app.systems.script.preloading = !1;
            return a
        }
    });
    Object.assign(Ni.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(c, d) {
                c ? b("Error loading html resource: " + a.original + " [" + c + "]") : b(null,
                    d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    Object.assign(Oi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            };
            a.load.startsWith("blob:") && (c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                d ? b("Error loading JSON resource: " + a.original + " [" + d + "]") : b(null, e)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    var kf = {
            name: "string",
            chunks: "chunks",
            mappingFormat: "string",
            _engine: "boolean",
            ambient: "rgb",
            ambientTint: "boolean",
            aoVertexColor: "boolean",
            aoVertexColorChannel: "string",
            aoMap: "texture",
            aoMapChannel: "string",
            aoMapUv: "number",
            aoMapTiling: "vec2",
            aoMapOffset: "vec2",
            diffuse: "rgb",
            diffuseTint: "boolean",
            diffuseVertexColor: "boolean",
            diffuseVertexColorChannel: "string",
            diffuseMap: "texture",
            diffuseMapChannel: "string",
            diffuseMapUv: "number",
            diffuseMapTiling: "vec2",
            diffuseMapOffset: "vec2",
            diffuseDetailMap: "texture",
            diffuseDetailMapChannel: "string",
            diffuseDetailMapUv: "number",
            diffuseDetailMapTiling: "vec2",
            diffuseDetailMapOffset: "vec2",
            diffuseDetailMode: "string",
            specular: "rgb",
            specularTint: "boolean",
            specularVertexColor: "boolean",
            specularVertexColorChannel: "string",
            specularMap: "texture",
            specularMapChannel: "string",
            specularMapUv: "number",
            specularMapTiling: "vec2",
            specularMapOffset: "vec2",
            specularAntialias: "boolean",
            occludeSpecular: "enum:occludeSpecular",
            useMetalness: "boolean",
            metalness: "number",
            enableGGXSpecular: "boolean",
            anisotropy: "number",
            metalnessTint: "boolean",
            metalnessVertexColor: "boolean",
            metalnessVertexColorChannel: "string",
            metalnessMap: "texture",
            metalnessMapChannel: "string",
            metalnessMapUv: "number",
            metalnessMapTiling: "vec2",
            metalnessMapOffset: "vec2",
            conserveEnergy: "boolean",
            shininess: "number",
            glossVertexColor: "boolean",
            glossVertexColorChannel: "string",
            glossMap: "texture",
            glossMapChannel: "string",
            glossMapUv: "number",
            glossMapTiling: "vec2",
            glossMapOffset: "vec2",
            clearCoat: "number",
            clearCoatVertexColor: "boolean",
            clearCoatVertexColorChannel: "string",
            clearCoatMap: "texture",
            clearCoatMapChannel: "string",
            clearCoatMapUv: "number",
            clearCoatMapTiling: "vec2",
            clearCoatMapOffset: "vec2",
            clearCoatGlossiness: "number",
            clearCoatGlossVertexColor: "boolean",
            clearCoatGlossVertexColorChannel: "string",
            clearCoatGlossMap: "texture",
            clearCoatGlossMapChannel: "string",
            clearCoatGlossMapUv: "number",
            clearCoatGlossMapTiling: "vec2",
            clearCoatGlossMapOffset: "vec2",
            clearCoatBumpiness: "number",
            clearCoatNormalMap: "texture",
            clearCoatNormalMapUv: "number",
            clearCoatNormalMapTiling: "vec2",
            clearCoatNormalMapOffset: "vec2",
            fresnelModel: "number",
            emissive: "rgb",
            emissiveTint: "boolean",
            emissiveVertexColor: "boolean",
            emissiveVertexColorChannel: "string",
            emissiveMap: "texture",
            emissiveMapChannel: "string",
            emissiveMapUv: "number",
            emissiveMapTiling: "vec2",
            emissiveMapOffset: "vec2",
            emissiveIntensity: "number",
            normalMap: "texture",
            normalMapTiling: "vec2",
            normalMapOffset: "vec2",
            normalMapUv: "number",
            bumpiness: "number",
            normalDetailMap: "texture",
            normalDetailMapTiling: "vec2",
            normalDetailMapOffset: "vec2",
            normalDetailMapUv: "number",
            normalDetailMapBumpiness: "number",
            heightMap: "texture",
            heightMapChannel: "string",
            heightMapUv: "number",
            heightMapTiling: "vec2",
            heightMapOffset: "vec2",
            heightMapFactor: "number",
            alphaToCoverage: "boolean",
            alphaTest: "number",
            alphaFade: "number",
            opacity: "number",
            opacityVertexColor: "boolean",
            opacityVertexColorChannel: "string",
            opacityMap: "texture",
            opacityMapChannel: "string",
            opacityMapUv: "number",
            opacityMapTiling: "vec2",
            opacityMapOffset: "vec2",
            opacityFadesSpecular: "boolean",
            reflectivity: "number",
            refraction: "number",
            refractionIndex: "number",
            sphereMap: "texture",
            cubeMap: "cubemap",
            cubeMapProjection: "number",
            cubeMapProjectionBox: "boundingbox",
            lightVertexColor: "boolean",
            lightVertexColorChannel: "string",
            lightMap: "texture",
            lightMapChannel: "string",
            lightMapUv: "number",
            lightMapTiling: "vec2",
            lightMapOffset: "vec2",
            depthTest: "boolean",
            depthWrite: "boolean",
            depthBias: "number",
            slopeDepthBias: "number",
            cull: "enum:cull",
            blendType: "enum:blendType",
            shadingModel: "enum:shadingModel",
            useFog: "boolean",
            useLighting: "boolean",
            useSkybox: "boolean",
            useGammaTonemap: "boolean",
            prefilteredCubeMap128: "texture",
            prefilteredCubeMap64: "texture",
            prefilteredCubeMap32: "texture",
            prefilteredCubeMap16: "texture",
            prefilteredCubeMap8: "texture",
            prefilteredCubeMap4: "texture"
        },
        lf, mf = [];
    for (lf in kf) {
        var lk = kf[lf];
        "texture" === lk && mf.push(lf)
    }
    var Jh = [];
    for (lf in kf) lk = kf[lf], "cubemap" === lk && Jh.push(lf);
    wc.prototype._bind = function() {
        if (this.id) {
            if (this._onAssetLoad) this._registry.on("load:" + this.id, this._onLoad, this);
            if (this._onAssetAdd) this._registry.once("add:" + this.id, this._onAdd, this);
            if (this._onAssetRemove) this._registry.on("remove:" + this.id, this._onRemove,
                this)
        }
        if (this.url) {
            if (this._onAssetLoad) this._registry.on("load:url:" + this.url, this._onLoad, this);
            if (this._onAssetAdd) this._registry.once("add:url:" + this.url, this._onAdd, this);
            if (this._onAssetRemove) this._registry.on("remove:url:" + this.url, this._onRemove, this)
        }
    };
    wc.prototype._unbind = function() {
        this.id && (this._onAssetLoad && this._registry.off("load:" + this.id, this._onLoad, this), this._onAssetAdd && this._registry.off("add:" + this.id, this._onAdd, this), this._onAssetRemove && this._registry.off("remove:" + this.id,
            this._onRemove, this));
        this.url && (this._onAssetLoad && this._registry.off("load:" + this.url, this._onLoad, this), this._onAssetAdd && this._registry.off("add:" + this.url, this._onAdd, this), this._onAssetRemove && this._registry.off("remove:" + this.url, this._onRemove, this))
    };
    wc.prototype._onLoad = function(a) {
        this._onAssetLoad.call(this._scope, this.propertyName, this.parent, a)
    };
    wc.prototype._onAdd = function(a) {
        this._onAssetAdd.call(this._scope, this.propertyName, this.parent, a)
    };
    wc.prototype._onRemove = function(a) {
        this._onAssetRemove.call(this._scope,
            this.propertyName, this.parent, a)
    };
    Object.defineProperty(wc.prototype, "id", {
        get: function() {
            return this._id
        },
        set: function(a) {
            if (this.url) throw Error("Can't set id and url");
            this._unbind();
            this._id = a;
            this.asset = this._registry.get(this._id);
            this._bind()
        }
    });
    Object.defineProperty(wc.prototype, "url", {
        get: function() {
            return this._url
        },
        set: function(a) {
            if (this.id) throw Error("Can't set id and url");
            this._unbind();
            this._url = a;
            this.asset = this._registry.getByUrl(this._url);
            this._bind()
        }
    });
    Ef.prototype.setInvalid =
        function(a, b) {
            this.valid = !1;
            this.removeInvalid && delete b[a]
        };
    Ef.prototype.validate = function(a) {
        var b, c = "path" === a.mappingFormat,
            d;
        for (d in a)
            if (b = kf[d])
                if (b.startsWith("enum")) b = b.split(":")[1], this.enumValidators[b] && (this.enumValidators[b](a[d]) || this.setInvalid(d, a));
                else if ("number" === b) "number" !== typeof a[d] && this.setInvalid(d, a);
        else if ("boolean" === b) "boolean" !== typeof a[d] && this.setInvalid(d, a);
        else if ("string" === b) "string" !== typeof a[d] && this.setInvalid(d, a);
        else if ("vec2" === b) a[d] instanceof
        Array && 2 === a[d].length || this.setInvalid(d, a);
        else if ("rgb" === b) a[d] instanceof Array && 3 === a[d].length || this.setInvalid(d, a);
        else if ("texture" === b) c ? "string" === typeof a[d] || a[null === d] || a[d] instanceof V || this.setInvalid(d, a) : "number" !== typeof a[d] && null !== a[d] && (a[d] instanceof V || this.setInvalid(d, a));
        else if ("boundingbox" === b) a[d].center && a[d].center instanceof Array && 3 === a[d].center.length || this.setInvalid(d, a), a[d].halfExtents && a[d].halfExtents instanceof Array && 3 === a[d].halfExtents.length || this.setInvalid(d,
            a);
        else if ("cubemap" === b) "number" !== typeof a[d] && null !== a[d] && void 0 !== a[d] && (a[d] instanceof V && a[d].cubemap || this.setInvalid(d, a));
        else if ("chunks" === b) {
            var e = Object.keys(a[d]);
            for (b = 0; b < e.length; b++) "string" !== typeof a[d][e[b]] && this.setInvalid(e[b], a[d])
        } else console.error("Unknown material type: " + b);
        else this.valid = !1;
        a.validated = !0;
        return this.valid
    };
    Ef.prototype._createEnumValidator = function(a) {
        return function(b) {
            return 0 <= a.indexOf(b)
        }
    };
    xe.prototype.parse = function(a) {
        a = this.migrate(a);
        a = this._validate(a);
        var b = new ma;
        this.initialize(b, a);
        return b
    };
    xe.prototype.initialize = function(a, b) {
        b.validated || (this._validator || (this._validator = new Ef), this._validator.validate(b));
        b.chunks && a.chunks.copy(b.chunks);
        for (var c in b) {
            var d = kf[c],
                e = b[c];
            "vec2" === d ? a[c] = new P(e[0], e[1]) : "rgb" === d ? a[c] = new L(e[0], e[1], e[2]) : "texture" === d ? e instanceof V ? a[c] = e : a[c] instanceof V && "number" === typeof e && 0 < e || (a[c] = null) : "cubemap" === d ? e instanceof V ? a[c] = e : a[c] instanceof V && "number" === typeof e && 0 < e || (a[c] = null) : "boundingbox" ===
                d ? (d = new z(e.center[0], e.center[1], e.center[2]), e = new z(e.halfExtents[0], e.halfExtents[1], e.halfExtents[2]), a[c] = new oa(d, e)) : a[c] = b[c]
        }
        a.update()
    };
    xe.prototype.migrate = function(a) {
        void 0 === a.shadingModel && (a.shadingModel = "blinn" === a.shader ? 1 : 0);
        a.shader && delete a.shader;
        a.mapping_format && (a.mappingFormat = a.mapping_format, delete a.mapping_format);
        var b, c = [
            ["bumpMapFactor", "bumpiness"],
            ["aoUvSet", "aoMapUv"],
            ["aoMapVertexColor", "aoVertexColor"],
            ["diffuseMapVertexColor", "diffuseVertexColor"],
            ["emissiveMapVertexColor",
                "emissiveVertexColor"
            ],
            ["specularMapVertexColor", "specularVertexColor"],
            ["metalnessMapVertexColor", "metalnessVertexColor"],
            ["opacityMapVertexColor", "opacityVertexColor"],
            ["glossMapVertexColor", "glossVertexColor"],
            ["lightMapVertexColor", "lightVertexColor"],
            ["diffuseMapTint", "diffuseTint"],
            ["specularMapTint", "specularTint"],
            ["emissiveMapTint", "emissiveTint"],
            ["metalnessMapTint", "metalnessTint"]
        ];
        for (b = 0; b < c.length; b++) {
            var d = c[b][0],
                e = c[b][1];
            void 0 !== a[d] && void 0 === a[e] && (a[e] = a[d], delete a[d])
        }
        c = ["fresnelFactor", "shadowSampleType"];
        for (b = 0; b < c.length; b++) d = c[b], a.hasOwnProperty(d) && delete a[d];
        return a
    };
    xe.prototype._validate = function(a) {
        this._validator || (this._validator = new Ef);
        this._validator.validate(a);
        return a
    };
    var Gp = {
        aoMap: "white",
        diffuseMap: "gray",
        specularMap: "gray",
        metalnessMap: "black",
        glossMap: "gray",
        emissiveMap: "gray",
        normalMap: "normal",
        heightMap: "gray",
        opacityMap: "gray",
        sphereMap: "gray",
        lightMap: "white"
    };
    Object.assign(Pi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(c, d) {
                c ? b && b("Error loading material: " + a.original + " [" + c + "]") : b && (d._engine = !0, b(null, d))
            })
        },
        open: function(a, b) {
            a = this._parser.parse(b);
            b._engine && (a._data = b, delete b._engine);
            return a
        },
        _createPlaceholders: function() {
            this._placeholderTextures = {};
            var a = {
                    white: [255, 255, 255, 255],
                    gray: [128, 128, 128, 255],
                    black: [0, 0, 0, 255],
                    normal: [128, 128, 255, 255]
                },
                b;
            for (b in a)
                if (a.hasOwnProperty(b)) {
                    this._placeholderTextures[b] = new V(this._device, {
                        width: 2,
                        height: 2,
                        format: 7
                    });
                    this._placeholderTextures[b].name = "placeholder";
                    for (var c = this._placeholderTextures[b].lock(), d = 0; 4 > d; d++)
                        for (var e = 0; 4 > e; e++) c[4 * d + e] = a[b][e];
                    this._placeholderTextures[b].unlock()
                }
        },
        patch: function(a, b) {
            a.resource._data && (a._data = a.resource._data, delete a.resource._data);
            a.data.name = a.name;
            a.resource.name = a.name;
            this._bindAndAssignAssets(a, b);
            a.off("unload", this._onAssetUnload, this);
            a.on("unload", this._onAssetUnload, this)
        },
        _onAssetUnload: function(a) {
            delete a.data.parameters;
            delete a.data.chunks;
            delete a.data.name
        },
        _assignTexture: function(a, b, c) {
            b.data[a] = c;
            b.resource[a] = c
        },
        _assignPlaceholderTexture: function(a, b) {
            this._placeholderTextures || this._createPlaceholders();
            b.resource[a] = this._placeholderTextures[Gp[a]]
        },
        _onTextureLoad: function(a, b, c) {
            this._assignTexture(a, b, c.resource);
            b.resource.update()
        },
        _onTextureAdd: function(a, b, c) {
            this._assets.load(c)
        },
        _onTextureRemove: function(a, b, c) {
            var d = b.resource;
            d[a] === c.resource && (this._assignTexture(a, b, null), d.update())
        },
        _assignCubemap: function(a,
            b, c) {
            b.data[a] = c[0];
            7 === c.length && (b.data.prefilteredCubeMap128 = c[1], b.data.prefilteredCubeMap64 = c[2], b.data.prefilteredCubeMap32 = c[3], b.data.prefilteredCubeMap16 = c[4], b.data.prefilteredCubeMap8 = c[5], b.data.prefilteredCubeMap4 = c[6])
        },
        _onCubemapLoad: function(a, b, c) {
            this._assignCubemap(a, b, c.resources);
            this._parser.initialize(b.resource, b.data)
        },
        _onCubemapAdd: function(a, b, c) {
            0 === b.data.shadingModel && (b.loadFaces = !0);
            this._assets.load(c)
        },
        _onCubemapRemove: function(a, b, c) {
            var d = b.resource;
            d[a] === c.resource &&
                (this._assignCubemap(a, b, [null, null, null, null, null, null, null]), d.update())
        },
        _bindAndAssignAssets: function(a, b) {
            var c = this._parser.migrate(a.data),
                d = a.resource,
                e = "path" === c.mappingFormat,
                f;
            for (f = 0; f < mf.length; f++) {
                var g = mf[f];
                var k = d._assetReferences[g];
                !c[g] || c[g] instanceof V ? k && (e ? k.url = null : k.id = null) : (k || (k = new wc(g, a, b, {
                    load: this._onTextureLoad,
                    add: this._onTextureAdd,
                    remove: this._onTextureRemove
                }, this), d._assetReferences[g] = k), e ? k.url = a.getAbsoluteUrl(c[g]) : k.id = c[g], k.asset && (k.asset.resource ?
                    this._assignTexture(g, a, k.asset.resource) : this._assignPlaceholderTexture(g, a), b.load(k.asset)))
            }
            for (f = 0; f < Jh.length; f++) g = Jh[f], k = d._assetReferences[g], !c[g] || c[g] instanceof V || (k || (k = new wc(g, a, b, {
                load: this._onCubemapLoad,
                add: this._onCubemapAdd,
                remove: this._onCubemapRemove
            }, this), d._assetReferences[g] = k), e ? k.url = c[g] : k.id = c[g], k.asset && (k.asset.loaded && this._assignCubemap(g, a, k.asset.resources), b.load(k.asset)));
            this._parser.initialize(d, c)
        }
    });
    Object.assign(al.prototype, {
        parse: function(a) {
            return (a =
                gd.parse("filename.glb", a, this._device)) ? gd.createModel(a, this._defaultMaterial) : null
        }
    });
    Object.assign(bl.prototype, {
        addVertex: function(a, b, c) {
            if (void 0 !== this.indexMap[b]) c = this.indexMap[b], this.indices.push(c);
            else {
                for (var d = 0; 4 > d; d++) 0 !== c.blendWeight.data[4 * b + d] && (a.boneIndices[d] = this.getBoneRemap(c.blendIndices.data[4 * a.index + d]));
                c = this.vertices.length;
                this.indices.push(c);
                this.vertices.push(a);
                this.indexMap[b] = c
            }
        },
        addPrimitive: function(a, b, c, d) {
            var e, f, g = [],
                k = 0,
                h = a.length;
            for (e = 0; e < h; e++)
                for (var l =
                        a[e].index, n = 0; 4 > n; n++)
                    if (0 < c.blendWeight.data[4 * l + n]) {
                        var p = c.blendIndices.data[4 * l + n],
                            q = !0;
                        for (f = 0; f < k; f++)
                            if (g[f] == p) {
                                q = !1;
                                break
                            }
                        q && (g[k] = p, f = this.getBoneRemap(p), k += -1 === f ? 1 : 0)
                    }
            if (this.boneIndices.length + k > d) return !1;
            for (e = 0; e < k; e++) this.boneIndices.push(g[e]);
            for (e = 0; e < h; e++) this.addVertex(a[e], b[e], c);
            return !0
        },
        getBoneRemap: function(a) {
            for (var b = 0; b < this.boneIndices.length; b++)
                if (this.boneIndices[b] === a) return b;
            return -1
        }
    });
    var Hp = {
            points: 0,
            lines: 1,
            lineloop: 2,
            linestrip: 3,
            triangles: 4,
            trianglestrip: 5,
            trianglefan: 6
        },
        Ip = {
            int8: 0,
            uint8: 1,
            int16: 2,
            uint16: 3,
            int32: 4,
            uint32: 5,
            float32: 6
        };
    Object.assign(dl.prototype, {
        parse: function(a) {
            var b = a.model;
            if (!b || 1 >= b.version) return null;
            b = this._parseNodes(a);
            var c = this._parseSkins(a, b),
                d = this._parseVertexBuffers(a),
                e = this._parseIndexBuffers(a, d),
                f = this._parseMorphs(a, b, d);
            d = this._parseMeshes(a, c.skins, f.morphs, d, e.buffer, e.data);
            a = this._parseMeshInstances(a, b, d, c.skins, c.instances, f.morphs, f.instances);
            d = new tb;
            d.graph = b[0];
            d.meshInstances = a;
            d.skinInstances = c.instances;
            d.morphInstances = f.instances;
            d.getGraph().syncHierarchy();
            return d
        },
        _parseNodes: function(a) {
            a = a.model;
            var b = [],
                c;
            for (c = 0; c < a.nodes.length; c++) {
                var d = a.nodes[c],
                    e = new Z(d.name);
                e.setLocalPosition(d.position[0], d.position[1], d.position[2]);
                e.setLocalEulerAngles(d.rotation[0], d.rotation[1], d.rotation[2]);
                e.setLocalScale(d.scale[0], d.scale[1], d.scale[2]);
                e.scaleCompensation = !!d.scaleCompensation;
                b.push(e)
            }
            for (c = 1; c < a.parents.length; c++) b[a.parents[c]].addChild(b[c]);
            return b
        },
        _parseSkins: function(a, b) {
            a =
                a.model;
            var c = [],
                d = [],
                e;
            if (!this._device.supportsBoneTextures && 0 < a.skins.length) {
                var f = this._device.getBoneLimit();
                cl(a, null, f)
            }
            for (f = 0; f < a.skins.length; f++) {
                var g = a.skins[f],
                    k = [];
                for (e = 0; e < g.inverseBindMatrices.length; e++) {
                    var h = g.inverseBindMatrices[e];
                    k[e] = (new J).set(h)
                }
                g = new Kg(this._device, k, g.boneNames);
                c.push(g);
                k = new Ic(g);
                h = [];
                for (e = 0; e < g.boneNames.length; e++) {
                    var l = b[0].findByName(g.boneNames[e]);
                    h.push(l)
                }
                k.bones = h;
                d.push(k)
            }
            return {
                skins: c,
                instances: d
            }
        },
        _getMorphVertexCount: function(a,
            b, c) {
            for (var d = 0; d < a.meshes.length; d++) {
                var e = a.meshes[d];
                if (e.morph === b) return c[e.vertices].numVertices
            }
        },
        _parseMorphs: function(a, b, c) {
            a = a.model;
            b = [];
            var d = [],
                e, f;
            if (a.morphs) {
                var g = function(t, u, x) {
                    x = new Float32Array(3 * x);
                    for (var v = 0; v < u.length; v++) {
                        var w = 3 * u[v];
                        x[w] = t[3 * v];
                        x[w + 1] = t[3 * v + 1];
                        x[w + 2] = t[3 * v + 2]
                    }
                    return x
                };
                for (e = 0; e < a.morphs.length; e++) {
                    var k = a.morphs[e].targets;
                    var h = [];
                    var l = this._getMorphVertexCount(a, e, c);
                    for (f = 0; f < k.length; f++) {
                        var n = k[f].aabb;
                        var p = n.min;
                        n = n.max;
                        p = new oa(new z(.5 *
                            (n[0] + p[0]), .5 * (n[1] + p[1]), .5 * (n[2] + p[2])), new z(.5 * (n[0] - p[0]), .5 * (n[1] - p[1]), .5 * (n[2] - p[2])));
                        n = k[f].indices;
                        var q = k[f].deltaPositions,
                            r = k[f].deltaNormals;
                        n && (q = g(q, n, l), r = g(r, n, l));
                        p = new vf({
                            deltaPositions: q,
                            deltaNormals: r,
                            name: k[f].name,
                            aabb: p
                        });
                        h.push(p)
                    }
                    f = new Db(h, this._device);
                    b.push(f);
                    f = new uf(f);
                    d.push(f)
                }
            }
            return {
                morphs: b,
                instances: d
            }
        },
        _parseVertexBuffers: function(a) {
            a = a.model;
            var b = [],
                c, d = {
                    position: "POSITION",
                    normal: "NORMAL",
                    tangent: "TANGENT",
                    blendWeight: "BLENDWEIGHT",
                    blendIndices: "BLENDINDICES",
                    color: "COLOR",
                    texCoord0: "TEXCOORD0",
                    texCoord1: "TEXCOORD1",
                    texCoord2: "TEXCOORD2",
                    texCoord3: "TEXCOORD3",
                    texCoord4: "TEXCOORD4",
                    texCoord5: "TEXCOORD5",
                    texCoord6: "TEXCOORD6",
                    texCoord7: "TEXCOORD7"
                },
                e, f;
            for (e = 0; e < a.vertices.length; e++) {
                var g = a.vertices[e],
                    k = [];
                for (c in g) {
                    var h = g[c];
                    k.push({
                        semantic: d[c],
                        components: h.components,
                        type: Ip[h.type],
                        normalize: "COLOR" === d[c]
                    })
                }
                h = new Na(this._device, k);
                k = g.position.data.length / g.position.components;
                var l = new ab(this._device, h, k),
                    n = new Pb(l);
                for (f = 0; f < k; f++) {
                    for (c in g) switch (h =
                        g[c], h.components) {
                        case 1:
                            n.element[d[c]].set(h.data[f]);
                            break;
                        case 2:
                            n.element[d[c]].set(h.data[2 * f], h.data[2 * f + 1]);
                            break;
                        case 3:
                            n.element[d[c]].set(h.data[3 * f], h.data[3 * f + 1], h.data[3 * f + 2]);
                            break;
                        case 4:
                            n.element[d[c]].set(h.data[4 * f], h.data[4 * f + 1], h.data[4 * f + 2], h.data[4 * f + 3])
                    }
                    n.next()
                }
                n.end();
                b.push(l)
            }
            return b
        },
        _parseIndexBuffers: function(a, b) {
            var c = a.model,
                d = a = null,
                e, f = 0;
            for (e = 0; e < c.meshes.length; e++) {
                var g = c.meshes[e];
                void 0 !== g.indices && (f += g.indices.length)
            }
            for (e = c = 0; e < b.length; e++) c = Math.max(c,
                b[e].numVertices);
            0 < f && (65535 < c && this._device.extUintElement ? (a = new dc(this._device, 2, f), d = new Uint32Array(a.lock())) : (a = new dc(this._device, 1, f), d = new Uint16Array(a.lock())));
            return {
                buffer: a,
                data: d
            }
        },
        _parseMeshes: function(a, b, c, d, e, f) {
            a = a.model;
            var g = [],
                k = 0,
                h;
            for (h = 0; h < a.meshes.length; h++) {
                var l = a.meshes[h],
                    n = l.aabb,
                    p = n.min;
                n = n.max;
                p = new oa(new z(.5 * (n[0] + p[0]), .5 * (n[1] + p[1]), .5 * (n[2] + p[2])), new z(.5 * (n[0] - p[0]), .5 * (n[1] - p[1]), .5 * (n[2] - p[2])));
                n = void 0 !== l.indices;
                var q = new sb(this._device);
                q.vertexBuffer =
                    d[l.vertices];
                q.indexBuffer[0] = n ? e : null;
                q.primitive[0].type = Hp[l.type];
                q.primitive[0].base = n ? l.base + k : l.base;
                q.primitive[0].count = l.count;
                q.primitive[0].indexed = n;
                q.skin = void 0 !== l.skin ? b[l.skin] : null;
                q.morph = void 0 !== l.morph ? c[l.morph] : null;
                q.aabb = p;
                n && (f.set(l.indices, k), k += l.indices.length);
                g.push(q)
            }
            null !== e && e.unlock();
            return g
        },
        _parseMeshInstances: function(a, b, c, d, e, f, g) {
            a = a.model;
            var k = [],
                h;
            for (h = 0; h < a.meshInstances.length; h++) {
                var l = a.meshInstances[h],
                    n = c[l.mesh];
                l = new va(b[l.node], n, this._defaultMaterial);
                if (n.skin) {
                    var p = d.indexOf(n.skin);
                    l.skinInstance = e[p]
                }
                n.morph && (n = f.indexOf(n.morph), l.morphInstance = g[n]);
                k.push(l)
            }
            return k
        }
    });
    Object.assign(Qi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            };
            a.load.startsWith("blob:") && (".glb" === ca.getExtension(a.original).toLowerCase() ? c.responseType = da.ResponseType.ARRAY_BUFFER : c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                b && (d ? b("Error loading model: " +
                    a.original + " [" + d + "]") : b(null, e))
            })
        },
        open: function(a, b) {
            for (var c = 0; c < this._parsers.length; c++) {
                var d = this._parsers[c];
                if (d.decider(a, b)) return d.parser.parse(b)
            }
            return null
        },
        patch: function(a, b) {
            if (a.resource) {
                var c = a.data,
                    d = this;
                a.resource.meshInstances.forEach(function(e, f) {
                    if (c.mapping) {
                        var g = function(l) {
                            l.resource ? e.material = l.resource : (l.once("load", g), b.load(l));
                            l.once("remove", function(n) {
                                e.material === n.resource && (e.material = d._defaultMaterial)
                            })
                        };
                        if (c.mapping[f]) {
                            var k = c.mapping[f].material,
                                h = c.mapping[f].path;
                            if (void 0 !== k)
                                if (k)
                                    if (f = b.get(k)) g(f);
                                    else b.once("add:" + k, g);
                            else e.material = d._defaultMaterial;
                            else if (h)
                                if (k = a.getAbsoluteUrl(c.mapping[f].path), f = b.getByUrl(k)) g(f);
                                else b.once("add:url:" + k, g)
                        } else e.material = d._defaultMaterial
                    }
                })
            }
        },
        addParser: function(a, b) {
            this._parsers.push({
                parser: a,
                decider: b
            })
        }
    });
    Object.assign(Ri.prototype, {
        addHandler: function(a, b) {
            this._handlers[a] = b;
            b._loader = this
        },
        removeHandler: function(a) {
            delete this._handlers[a]
        },
        getHandler: function(a) {
            return this._handlers[a]
        },
        load: function(a, b, c, d) {
            var e = this._handlers[b];
            if (e)
                if (a) {
                    var f = a + b;
                    if (void 0 !== this._cache[f]) c(null, this._cache[f]);
                    else if (this._requests[f]) this._requests[f].push(c);
                    else {
                        this._requests[f] = [c];
                        var g = this,
                            k = function(l, n) {
                                l ? g._onFailure(f, l) : e.load(n, function(p, q, r) {
                                    if (g._requests[f])
                                        if (p) g._onFailure(f, p);
                                        else try {
                                            g._onSuccess(f, e.open(n.original, q, d), r)
                                        } catch (t) {
                                            g._onFailure(f, t)
                                        }
                                }, d)
                            },
                            h = a.split("?")[0];
                        this._app.enableBundles && this._app.bundles.hasUrl(h) ? this._app.bundles.canLoadUrl(h) ? this._app.bundles.loadUrl(h,
                            function(l, n) {
                                k(l, {
                                    load: n,
                                    original: h
                                })
                            }) : k("Bundle for " + a + " not loaded yet") : k(null, {
                            load: a,
                            original: d && d.getPreferredFile().filename || a
                        })
                    }
                } else this._loadNull(e, c, d);
            else c("No handler for asset type: " + b)
        },
        _loadNull: function(a, b, c) {
            a.load(null, function(d, e, f) {
                if (d) b(d);
                else try {
                    b(null, a.open(null, e, c), f)
                } catch (g) {
                    b(g)
                }
            }, c)
        },
        _onSuccess: function(a, b, c) {
            this._cache[a] = b;
            for (var d = 0; d < this._requests[a].length; d++) this._requests[a][d](null, b, c);
            delete this._requests[a]
        },
        _onFailure: function(a, b) {
            console.error(b);
            if (this._requests[a]) {
                for (var c = 0; c < this._requests[a].length; c++) this._requests[a][c](b);
                delete this._requests[a]
            }
        },
        open: function(a, b) {
            var c = this._handlers[a];
            return c ? c.open(null, b) : (console.warn("No resource handler found for: " + a), b)
        },
        patch: function(a, b) {
            var c = this._handlers[a.type];
            c ? c.patch && c.patch(a, b) : console.warn("No resource handler found for: " + a.type)
        },
        clearCache: function(a, b) {
            delete this._cache[a + b]
        },
        getFromCache: function(a, b) {
            if (this._cache[a + b]) return this._cache[a + b]
        },
        enableRetry: function(a) {
            void 0 ===
                a && (a = 5);
            a = Math.max(0, a) || 0;
            for (var b in this._handlers) this._handlers[b].maxRetries = a
        },
        disableRetry: function() {
            for (var a in this._handlers) this._handlers[a].maxRetries = 0
        },
        destroy: function() {
            this._handlers = {};
            this._requests = {};
            this._cache = {}
        }
    });
    Object.assign(Si.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this._app.assets;
            wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(d, e) {
                d ? (e = "Error while loading scene " + a.original, d.message ? (e += ": " +
                    d.message, d.stack && (e += "\n" + d.stack)) : e += ": " + d, b(e)) : Zc.waitForTemplatesInScene(e, c, b)
            })
        },
        open: function(a, b) {
            this._app.systems.script.preloading = !0;
            a = (new Qg(this._app, !1)).parse(b);
            var c = this._app.scene;
            c.root = a;
            this._app.applySceneSettings(b.settings);
            this._app.systems.script.preloading = !1;
            return c
        },
        patch: function(a, b) {}
    });
    Object.assign(Ti.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(c, d) {
                c ?
                    (d = "Error while loading scene settings " + a.original, c.message ? (d += ": " + c.message, c.stack && (d += "\n" + c.stack)) : d += ": " + c, b(d)) : b(null, d)
            })
        },
        open: function(a, b) {
            return b.settings
        }
    });
    var mk = !1,
        Km = !1,
        vb = {
            app: null,
            create: function(a, b) {
                if (mk) {
                    var c = b(vb.app);
                    c._pcScriptName = a;
                    ub._push(c);
                    this.fire("created", a, b)
                }
            },
            attribute: function(a, b, c, d) {},
            createLoadingScreen: function(a) {
                if (!Km) {
                    Km = !0;
                    var b = ea.getApplication();
                    a(b)
                }
            }
        };
    Object.defineProperty(vb, "legacy", {
        get: function() {
            return mk
        },
        set: function(a) {
            mk = a
        }
    });
    Rf.attach(vb);
    ub._types = [];
    ub._push = function(a) {
        vb.legacy && 0 < ub._types.length ? console.assert("Script Ordering Error. Contact support@playcanvas.com") : ub._types.push(a)
    };
    Object.assign(ub.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this;
            vb.app = this._app;
            this._loadScript(a.load, function(d, e, f) {
                if (d) b(d);
                else if (vb.legacy) d = null, ub._types.length && (d = ub._types.pop()), d ? this._scripts[e] = d : d = null, b(null, d, f);
                else {
                    d = {};
                    for (var g = 0; g < ub._types.length; g++) d[ub._types[g].name] =
                        ub._types[g];
                    ub._types.length = 0;
                    b(null, d, f);
                    delete c._loader._cache[e + "script"]
                }
            }.bind(this))
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {},
        _loadScript: function(a, b) {
            var c = document.head,
                d = document.createElement("script");
            this._cache[a] = d;
            d.async = !1;
            d.addEventListener("error", function(f) {
                b("Script: " + f.target.src + " failed to load")
            }, !1);
            var e = !1;
            d.onload = d.onreadystatechange = function() {
                e || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (e = !0, b(null, a, d))
            };
            d.src = a;
            c.appendChild(d)
        }
    });
    Object.assign(Ui.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(c, d) {
                c ? b("Error loading shader resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    var Jp = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
        Kp = [0, 1, 3, 2, 3, 1];
    Sa.prototype = Object.create(M.prototype);
    Sa.prototype.constructor = Sa;
    Sa.prototype._createMeshes = function() {
        var a;
        var b = 0;
        for (a = this._meshes.length; b < a; b++) {
            var c =
                this._meshes[b];
            if (c) {
                c.vertexBuffer.destroy();
                for (var d = 0, e = c.indexBuffer.length; d < e; d++) c.indexBuffer[d].destroy()
            }
        }
        a = this._frameKeys.length;
        this._meshes = Array(a);
        c = 1 === this.renderMode || 2 === this._renderMode ? this._create9SliceMesh : this._createSimpleMesh;
        for (b = 0; b < a; b++) d = this._atlas.frames[this._frameKeys[b]], this._meshes[b] = d ? c.call(this, d) : null;
        this.fire("set:meshes")
    };
    Sa.prototype._createSimpleMesh = function(a) {
        var b = a.rect,
            c = this._atlas.texture.width,
            d = this._atlas.texture.height,
            e = b.z / this._pixelsPerUnit,
            f = b.w / this._pixelsPerUnit,
            g = a.pivot.x;
        a = a.pivot.y;
        var k = b.x / c,
            h = b.y / d;
        c = (b.x + b.z) / c;
        b = (b.y + b.w) / d;
        return Qb(this._device, [-g * e, -a * f, 0, (1 - g) * e, -a * f, 0, (1 - g) * e, (1 - a) * f, 0, -g * e, (1 - a) * f, 0], {
            uvs: [k, h, c, h, c, b, k, b],
            normals: Jp,
            indices: Kp
        })
    };
    Sa.prototype._create9SliceMesh = function() {
        var a = P.ONE,
            b, c, d = [],
            e = [],
            f = [],
            g = [],
            k = 0;
        for (b = 0; 3 >= b; b++) {
            var h = 0 === b || 3 === b ? 0 : 1;
            for (c = 0; 3 >= c; c++) {
                var l = -a.x + 2 * a.x * (1 >= b ? 0 : 3) / 3;
                var n = -(-a.y + 2 * a.y * (1 >= c ? 0 : 3) / 3);
                var p = 0 === c || 3 === c ? 0 : 1;
                d.push(-l, 0, n);
                e.push(0, 1, 0);
                f.push(h, p);
                3 >
                    b && 3 > c && (g.push(k + 3 + 1, k + 1, k), g.push(k + 3 + 1, k + 3 + 2, k + 1));
                k++
            }
        }
        return Qb(this._device, d, {
            normals: e,
            uvs: f,
            indices: g
        })
    };
    Sa.prototype._onSetFrames = function(a) {
        this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()
    };
    Sa.prototype._onFrameChanged = function(a, b) {
        a = this._frameKeys.indexOf(a);
        0 > a || (b ? 0 === this.renderMode && (this._meshes[a] = this._createSimpleMesh(b)) : this._meshes[a] = null, this.fire("set:meshes"))
    };
    Sa.prototype._onFrameRemoved = function(a) {
        a = this._frameKeys.indexOf(a);
        0 > a || (this._meshes[a] =
            null, this.fire("set:meshes"))
    };
    Sa.prototype.startUpdate = function() {
        this._updatingProperties = !0;
        this._meshesDirty = !1
    };
    Sa.prototype.endUpdate = function() {
        this._updatingProperties = !1;
        this._meshesDirty && this._atlas && this._frameKeys && this._createMeshes();
        this._meshesDirty = !1
    };
    Sa.prototype.destroy = function() {
        var a;
        var b = 0;
        for (a = this._meshes.length; b < a; b++) {
            var c = this._meshes[b];
            if (c) {
                c.vertexBuffer.destroy();
                for (var d = 0, e = c.indexBuffer.length; d < e; d++) c.indexBuffer[d].destroy()
            }
        }
        this._meshes.length = 0
    };
    Object.defineProperty(Sa.prototype,
        "frameKeys", {
            get: function() {
                return this._frameKeys
            },
            set: function(a) {
                this._frameKeys = a;
                this._atlas && this._frameKeys && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes());
                this.fire("set:frameKeys", a)
            }
        });
    Object.defineProperty(Sa.prototype, "atlas", {
        get: function() {
            return this._atlas
        },
        set: function(a) {
            a !== this._atlas && (this._atlas && (this._atlas.off("set:frames", this._onSetFrames, this), this._atlas.off("set:frame", this._onFrameChanged, this), this._atlas.off("remove:frame", this._onFrameRemoved,
                this)), (this._atlas = a) && this._frameKeys && (this._atlas.on("set:frames", this._onSetFrames, this), this._atlas.on("set:frame", this._onFrameChanged, this), this._atlas.on("remove:frame", this._onFrameRemoved, this), this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()), this.fire("set:atlas", a))
        }
    });
    Object.defineProperty(Sa.prototype, "pixelsPerUnit", {
        get: function() {
            return this._pixelsPerUnit
        },
        set: function(a) {
            this._pixelsPerUnit !== a && (this._pixelsPerUnit = a, this.fire("set:pixelsPerUnit", a), this._atlas &&
                this._frameKeys && 0 === this.renderMode && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()))
        }
    });
    Object.defineProperty(Sa.prototype, "renderMode", {
        get: function() {
            return this._renderMode
        },
        set: function(a) {
            if (this._renderMode !== a) {
                var b = this._renderMode;
                this._renderMode = a;
                this.fire("set:renderMode", a);
                (0 === b || 0 === a) && this._atlas && this._frameKeys && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes())
            }
        }
    });
    Object.defineProperty(Sa.prototype, "meshes", {
        get: function() {
            return this._meshes
        }
    });
    Object.assign(Vi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            ".json" === ca.getExtension(a.original) && wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(c, d) {
                c ? b(c) : b(null, d)
            })
        },
        open: function(a, b) {
            var c = new Sa(this._device);
            a && (c.__data = b);
            return c
        },
        patch: function(a, b) {
            var c = a.resource;
            c.__data && (a.data.pixelsPerUnit = c.__data.pixelsPerUnit, a.data.renderMode = c.__data.renderMode, a.data.frameKeys = c.__data.frameKeys, c.__data.textureAtlasAsset && ((b =
                b.getByUrl(c.__data.textureAtlasAsset)) ? a.data.textureAtlasAsset = b.id : console.warn("Could not find textureatlas with url: " + c.__data.textureAtlasAsset)));
            c.startUpdate();
            c.renderMode = a.data.renderMode;
            c.pixelsPerUnit = a.data.pixelsPerUnit;
            c.frameKeys = a.data.frameKeys;
            this._updateAtlas(a);
            c.endUpdate();
            a.off("change", this._onAssetChange, this);
            a.on("change", this._onAssetChange, this)
        },
        _updateAtlas: function(a) {
            var b = a.resource;
            if (a.data.textureAtlasAsset) {
                this._assets.off("load:" + a.data.textureAtlasAsset,
                    Wi, a);
                this._assets.on("load:" + a.data.textureAtlasAsset, Wi, a);
                var c = this._assets.get(a.data.textureAtlasAsset);
                c && c.resource ? b.atlas = c.resource : c ? this._assets.load(c) : (this._assets.off("add:" + a.data.textureAtlasAsset, Xi, a), this._assets.on("add:" + a.data.textureAtlasAsset, Xi, a))
            } else b.atlas = null
        },
        _onAssetChange: function(a, b, c, d) {
            "data" === b && c && c.textureAtlasAsset && d && c.textureAtlasAsset !== d.textureAtlasAsset && (this._assets.off("load:" + d.textureAtlasAsset, Wi, a), this._assets.off("add:" + d.textureAtlasAsset,
                Xi, a))
        }
    });
    Rg.prototype.instantiate = function() {
        this._templateRoot || this._parseTemplate();
        return this._templateRoot.clone()
    };
    Rg.prototype._parseTemplate = function() {
        this._templateRoot = (new Qg(this._app, !0)).parse(this._data)
    };
    Object.assign(Yi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this._app.assets;
            wa.get(a.load, function(d, e) {
                d ? b("Error requesting template: " + a.original) : Zc.waitForTemplateAssets(e.entities, c, b, e)
            })
        },
        open: function(a, b) {
            return new Rg(this._app,
                b)
        }
    });
    Object.assign(Zi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(c, d) {
                c ? b("Error loading text resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    xc.prototype = Object.create(M.prototype);
    xc.prototype.constructor = xc;
    xc.prototype.setFrame = function(a, b) {
        var c = this._frames[a];
        c ? (c.rect.copy(b.rect), c.pivot.copy(b.pivot), c.border.copy(b.border)) : (c = {
            rect: b.rect.clone(),
            pivot: b.pivot.clone(),
            border: b.border.clone()
        }, this._frames[a] = c);
        this.fire("set:frame", a.toString(), c)
    };
    xc.prototype.removeFrame = function(a) {
        var b = this._frames[a];
        b && (delete this._frames[a], this.fire("remove:frame", a.toString(), b))
    };
    xc.prototype.destroy = function() {
        this._texture && this._texture.destroy()
    };
    Object.defineProperty(xc.prototype, "texture", {
        get: function() {
            return this._texture
        },
        set: function(a) {
            this._texture = a;
            this.fire("set:texture", a)
        }
    });
    Object.defineProperty(xc.prototype,
        "frames", {
            get: function() {
                return this._frames
            },
            set: function(a) {
                this._frames = a;
                this.fire("set:frames", a)
            }
        });
    var Kh = {
            repeat: 0,
            clamp: 1,
            mirror: 2
        },
        Lh = {
            nearest: 0,
            linear: 1,
            nearest_mip_nearest: 2,
            linear_mip_nearest: 4,
            nearest_mip_linear: 3,
            linear_mip_linear: 5
        },
        Lp = /^data\.frames\.(\d+)$/;
    Object.assign($i.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this,
                d = this._loader.getHandler("texture");
            if (".json" === ca.getExtension(a.original)) wa.get(a.load, {
                    retry: 0 < this.maxRetries,
                    maxRetries: this.maxRetries
                },
                function(e, f) {
                    e ? b(e) : (e = a.original.replace(".json", ".png"), c._loader.load(e, "texture", function(g, k) {
                        g ? b(g) : b(null, {
                            data: f,
                            texture: k
                        })
                    }))
                });
            else return d.load(a, b)
        },
        open: function(a, b) {
            var c = new xc;
            if (b.texture && b.data) c.texture = b.texture, c.__data = b.data;
            else {
                a = this._loader.getHandler("texture").open(a, b);
                if (!a) return null;
                c.texture = a
            }
            return c
        },
        patch: function(a, b) {
            a.resource.__data && (void 0 !== a.resource.__data.minfilter && (a.data.minfilter = a.resource.__data.minfilter), void 0 !== a.resource.__data.magfilter &&
                (a.data.magfilter = a.resource.__data.magfilter), void 0 !== a.resource.__data.addressu && (a.data.addressu = a.resource.__data.addressu), void 0 !== a.resource.__data.addressv && (a.data.addressv = a.resource.__data.addressv), void 0 !== a.resource.__data.mipmaps && (a.data.mipmaps = a.resource.__data.mipmaps), void 0 !== a.resource.__data.anisotropy && (a.data.anisotropy = a.resource.__data.anisotropy), void 0 !== a.resource.__data.rgbm && (a.data.rgbm = !!a.resource.__data.rgbm), a.data.frames = a.resource.__data.frames, delete a.resource.__data);
            if (b = a.resource.texture)
                if (b.name = a.name, a.data.hasOwnProperty("minfilter") && b.minFilter !== Lh[a.data.minfilter] && (b.minFilter = Lh[a.data.minfilter]), a.data.hasOwnProperty("magfilter") && b.magFilter !== Lh[a.data.magfilter] && (b.magFilter = Lh[a.data.magfilter]), a.data.hasOwnProperty("addressu") && b.addressU !== Kh[a.data.addressu] && (b.addressU = Kh[a.data.addressu]), a.data.hasOwnProperty("addressv") && b.addressV !== Kh[a.data.addressv] && (b.addressV = Kh[a.data.addressv]), a.data.hasOwnProperty("mipmaps") && b.mipmaps !==
                    a.data.mipmaps && (b.mipmaps = a.data.mipmaps), a.data.hasOwnProperty("anisotropy") && b.anisotropy !== a.data.anisotropy && (b.anisotropy = a.data.anisotropy), a.data.hasOwnProperty("rgbm")) {
                    var c = a.data.rgbm ? "rgbm" : "default";
                    b.type !== c && (b.type = c)
                }
            a.resource.texture = b;
            b = {};
            for (var d in a.data.frames) c = a.data.frames[d], b[d] = {
                rect: new X(c.rect),
                pivot: new P(c.pivot),
                border: new X(c.border)
            };
            a.resource.frames = b;
            a.off("change", this._onAssetChange, this);
            a.on("change", this._onAssetChange, this)
        },
        _onAssetChange: function(a,
            b, c) {
            if ("data" === b || "data.frames" === b) {
                var d = {};
                for (e in c.frames) b = c.frames[e], d[e] = {
                    rect: new X(b.rect),
                    pivot: new P(b.pivot),
                    border: new X(b.border)
                };
                a.resource.frames = d
            } else if (b = b.match(Lp)) {
                var e = b[1];
                c ? (a.resource.frames[e] ? (b = a.resource.frames[e], b.rect.set(c.rect[0], c.rect[1], c.rect[2], c.rect[3]), b.pivot.set(c.pivot[0], c.pivot[1]), b.border.set(c.border[0], c.border[1], c.border[2], c.border[3])) : a.resource.frames[e] = {
                    rect: new X(c.rect),
                    pivot: new P(c.pivot),
                    border: new X(c.border)
                }, a.resource.fire("set:frame",
                    e, a.resource.frames[e])) : a.resource.frames[e] && (delete a.resource.frames[e], a.resource.fire("remove:frame", e))
            }
        }
    });
    var bo = function() {
            try {
                if ("object" === typeof WebAssembly && "function" === typeof WebAssembly.instantiate) {
                    var a = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
                    if (a instanceof WebAssembly.Module) return new WebAssembly.Instance(a) instanceof WebAssembly.Instance
                }
            } catch (b) {}
            return !1
        }(),
        fj = !1,
        Gf = null,
        Ff = {},
        bj = null,
        dj = [],
        Hf = null;
    Object.assign(gj.prototype, {
        load: function(a, b, c) {
            wa.get(a.load, {
                cache: !0,
                responseType: "arraybuffer",
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(d, e) {
                if (d) b(d, e);
                else {
                    if (d = "pvr" === aj() && c && c.file && c.file.variants && c.file.variants.basis && 0 !== (c.file.variants.basis.opt & 8)) c.file.variants.basis.opt &= -9;
                    gl(a.load, e, b, {
                        unswizzleGGGR: d
                    })
                }
            })
        },
        open: function(a, b, c) {
            a = new V(c, {
                name: a,
                addressU: b.cubemap ? 1 : 0,
                addressV: b.cubemap ? 1 : 0,
                width: b.width,
                height: b.height,
                format: b.format,
                cubemap: b.cubemap,
                levels: b.levels
            });
            a.upload();
            return a
        }
    });
    Object.assign(hj.prototype, {
        load: function(a, b, c) {
            if (c && c.options && c.options.hasOwnProperty("crossOrigin")) var d = c.options.crossOrigin;
            else hf.test(a.load) && (d = this.crossOrigin);
            this.useImageBitmap ? this._loadImageBitmap(a.load, a.original, d, b) : this._loadImage(a.load, a.original, d, b)
        },
        open: function(a, b, c) {
            var d = ca.getExtension(a).toLowerCase();
            a = new V(c, {
                name: a,
                width: b.width,
                height: b.height,
                format: ".jpg" === d || ".jpeg" === d ? 6 : 7
            });
            a.setSource(b);
            return a
        },
        _loadImage: function(a, b, c, d) {
            var e = new Image; e.crossOrigin="anonymous";
            c && (e.crossOrigin = "Anonymous");
            var f = 0,
                g =
                this.maxRetries,
                k;
            e.onload = function() {
                d(null, e)
            };
            e.onerror = function() {
                if (!k)
                    if (0 < g && ++f <= g) {
                        var h = 100 * Math.pow(2, f);
                        console.log("Error loading Texture from: '" + b + "' - Retrying in " + h + "ms...");
                        var l = 0 <= a.indexOf("?") ? "&" : "?";
                        k = setTimeout(function() {
                            e.src = a + l + "retry=" + Date.now();
                            k = null
                        }, h)
                    } else d("Error loading Texture from: '" + b + "'")
            };
            e.src = a
        },
        _loadImageBitmap: function(a, b, c, d) {
            wa.get(a, {
                cache: !0,
                responseType: "blob",
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, function(e, f) {
                e ? d(e) : createImageBitmap(f, {
                    premultiplyAlpha: "none",
                    imageOrientation: "flipY"
                }).then(function(g) {
                    d(null, g)
                }).catch(function(g) {
                    d(g)
                })
            })
        }
    });
    var nk = [1481919403, 3140563232, 169478669],
        Lm = {
            33776: 8,
            33778: 9,
            33779: 10,
            36196: 21,
            37492: 22,
            37496: 23,
            35840: 26,
            35841: 24,
            35842: 27,
            35843: 25
        };
    Object.assign(ij.prototype, {
        load: function(a, b, c) {
            wa.get(a.load, {
                cache: !0,
                responseType: "arraybuffer",
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, b)
        },
        open: function(a, b, c) {
            b = this.parse(b);
            if (!b) return null;
            a = new V(c, {
                name: a,
                addressU: b.cubemap ? 1 : 0,
                addressV: b.cubemap ?
                    1 : 0,
                width: b.width,
                height: b.height,
                format: b.format,
                cubemap: b.cubemap,
                levels: b.levels
            });
            a.upload();
            return a
        },
        parse: function(a) {
            var b = new Uint32Array(a, 0, 16);
            if (nk[0] !== b[0] || nk[1] !== b[1] || nk[2] !== b[2]) return null;
            var c = b[6],
                d = b[7],
                e = b[9],
                f = b[10],
                g = b[12],
                k = b[13],
                h = b[14];
            if (1 < b[11] || 1 < g || 0 !== c || !Lm[d]) return null;
            b = 64 + b[15];
            c = [];
            g = !1;
            for (var l = 0; l < (h || 1); l++) {
                var n = (new Uint32Array(a.slice(b, b + 4)))[0];
                b += 4;
                n /= k || 1;
                1 < k && (g = !0, c.push([]));
                for (var p = 0; p < k; p++) {
                    var q = new Uint8Array(a, b, n);
                    1 < k ? c[l].push(q) :
                        c.push(q);
                    b += n
                }
                b += 3 - (b + 3) % 4
            }
            return {
                format: Lm[d],
                width: e,
                height: f,
                levels: c,
                cubemap: g
            }
        }
    });
    Object.assign(jj.prototype, {
        load: function(a, b, c) {
            wa.get(a.load, {
                cache: !0,
                responseType: "arraybuffer",
                retry: 0 < this.maxRetries,
                maxRetries: this.maxRetries
            }, b)
        },
        open: function(a, b, c) {
            var d = new Uint32Array(b, 0, 32),
                e = d[4],
                f = d[3],
                g = Math.max(d[7], 1),
                k = d[21],
                h = d[22],
                l = 65024 === d[28],
                n = !1,
                p = !1,
                q = !1,
                r = !1,
                t = !1,
                u = null;
            if (4 === d[20])
                if (827611204 === k) u = 8, n = !0;
                else if (894720068 === k) u = 10, n = !0;
            else if (116 === k) u = 14, p = !0;
            else if (826496069 ===
                k) u = 21, q = n = !0;
            else if (825438800 === k || 825504336 === k) u = 825438800 === k ? 24 : 25, r = n = !0;
            else {
                if (825439312 === k || 825504848 === k) u = 825439312 === k ? 26 : 27, t = n = !0
            } else 32 === h && (u = 7);
            if (!u) return a = new V(c, {
                width: 4,
                height: 4,
                format: 6
            }), a.name = "dds-legacy-empty", a;
            a = new V(c, {
                name: a,
                addressU: l ? 1 : 0,
                addressV: l ? 1 : 0,
                width: e,
                height: f,
                format: u,
                cubemap: l
            });
            c = 128;
            d = l ? 6 : 1;
            k = 827611204 === k ? 8 : 16;
            for (h = 0; h < d; h++) {
                u = e;
                for (var x = f, v = 0; v < g; v++) {
                    if (n)
                        if (q) var w = Math.floor((u + 3) / 4) * Math.floor((x + 3) / 4) * 8;
                        else if (r) w = Math.max(u, 16) * Math.max(x,
                        8) / 4;
                    else if (t) w = Math.max(u, 8) * Math.max(x, 8) / 2;
                    else {
                        w = Math.floor((u + 4 - 1) / 4);
                        var y = Math.floor((x + 4 - 1) / 4);
                        w *= y;
                        w *= k
                    } else w = u * x * 4;
                    y = p ? new Float32Array(b, c, w) : new Uint8Array(b, c, w);
                    l ? (a._levels[v] || (a._levels[v] = []), a._levels[v][h] = y) : a._levels[v] = y;
                    c += p ? 4 * w : w;
                    u = Math.max(.5 * u, 1);
                    x = Math.max(.5 * x, 1)
                }
            }
            a.upload();
            return a
        }
    });
    var Mm = {
            repeat: 0,
            clamp: 1,
            mirror: 2
        },
        Nm = {
            nearest: 0,
            linear: 1,
            nearest_mip_nearest: 2,
            linear_mip_nearest: 4,
            nearest_mip_linear: 3,
            linear_mip_linear: 5
        },
        Mp = {
            "default": "default",
            rgbm: "rgbm",
            rgbe: "rgbe",
            swizzleGGGR: "swizzleGGGR"
        };
    Object.assign(hl.prototype, {
        load: function(a, b, c) {
            throw Error("not implemented");
        },
        open: function(a, b, c) {
            throw Error("not implemented");
        }
    });
    var Np = function(a) {
        var b = Math.log2(Math.max(a._width, a._height)) + 1,
            c = function(h) {
                return h instanceof HTMLCanvasElement || h instanceof HTMLImageElement || h instanceof HTMLVideoElement
            };
        if (!(7 !== a._format && 14 !== a._format || a._volume || a._compressed || 1 === a._levels.length || a._levels.length === b || c(a._cubemap ? a._levels[0][0] : a._levels[0]))) {
            c = function(h,
                l, n) {
                var p = Math.max(1, h >> 1),
                    q = Math.max(1, l >> 1),
                    r = new n.constructor(p * q * 4),
                    t = Math.floor(h / p);
                l = Math.floor(l / q);
                for (var u = t * l, x = 0; x < q; ++x)
                    for (var v = 0; v < p; ++v)
                        for (var w = 0; 4 > w; ++w) {
                            for (var y = 0, A = 0; A < l; ++A)
                                for (var B = 0; B < t; ++B) y += n[4 * (v * t + B + (x * l + A) * h) + w];
                            r[4 * (v + x * p) + w] = y / u
                        }
                return r
            };
            for (var d = a._levels.length; d < b; ++d) {
                var e = Math.max(1, a._width >> d - 1),
                    f = Math.max(1, a._height >> d - 1);
                if (a._cubemap) {
                    for (var g = [], k = 0; 6 > k; ++k) g.push(c(e, f, a._levels[d - 1][k]));
                    a._levels.push(g)
                } else a._levels.push(c(e, f, a._levels[d -
                    1]))
            }
            a._levelsUpdated = a._cubemap ? [
                [!0, !0, !0, !0, !0, !0]
            ] : [!0]
        }
    };
    Object.defineProperties(Sg.prototype, {
        crossOrigin: {
            get: function() {
                return this.imgParser.crossOrigin
            },
            set: function(a) {
                this.imgParser.crossOrigin = a
            }
        },
        maxRetries: {
            get: function() {
                return this.imgParser.maxRetries
            },
            set: function(a) {
                this.imgParser.maxRetries = a;
                for (var b in this.parsers) this.parsers.hasOwnProperty(b) && (this.parsers[b].maxRetries = a)
            }
        }
    });
    Object.assign(Sg.prototype, {
        _getUrlWithoutParams: function(a) {
            return 0 <= a.indexOf("?") ? a.split("?")[0] :
                a
        },
        _getParser: function(a) {
            a = ca.getExtension(this._getUrlWithoutParams(a)).toLowerCase().replace(".", "");
            return this.parsers[a] || this.imgParser
        },
        load: function(a, b, c) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            this._getParser(a.original).load(a, b, c)
        },
        open: function(a, b, c) {
            if (a) return a = this._getParser(a).open(a, b, this._device), null === a ? a = new V(this._device, {
                width: 4,
                height: 4,
                format: 6
            }) : Np(a), a
        },
        patch: function(a, b) {
            if (b = a.resource) {
                a.name && 0 < a.name.length && (b.name = a.name);
                var c = a.data;
                c.hasOwnProperty("minfilter") &&
                    (b.minFilter = Nm[c.minfilter]);
                c.hasOwnProperty("magfilter") && (b.magFilter = Nm[c.magfilter]);
                b.cubemap || (c.hasOwnProperty("addressu") && (b.addressU = Mm[c.addressu]), c.hasOwnProperty("addressv") && (b.addressV = Mm[c.addressv]));
                c.hasOwnProperty("mipmaps") && (b.mipmaps = c.mipmaps);
                c.hasOwnProperty("anisotropy") && (b.anisotropy = c.anisotropy);
                c.hasOwnProperty("flipY") && (b.flipY = !!c.flipY);
                c.hasOwnProperty("type") ? b.type = Mp[c.type] : c.hasOwnProperty("rgbm") && c.rgbm ? b.type = "rgbm" : a.file && a.getPreferredFile && (a = a.getPreferredFile()) &&
                    a.opt && 0 !== (a.opt & 8) && (b.type = "swizzleGGGR")
            }
        }
    });
    Nd.prototype = Object.create(M.prototype);
    Nd.prototype.constructor = Nd;
    Object.assign(Nd.prototype, {
        list: function(a) {
            a = a || {};
            return this._assets.filter(function(b) {
                var c = !0;
                void 0 !== a.preload && (c = b.preload === a.preload);
                return c
            })
        },
        add: function(a) {
            var b = this._assets.push(a) - 1;
            this._cache[a.id] = b;
            this._names[a.name] || (this._names[a.name] = []);
            this._names[a.name].push(b);
            if (a.file) {
                var c = a.file.url;
                this._urls[c] = b
            }
            a.registry = this;
            this._tags.addItem(a);
            a.tags.on("add",
                this._onTagAdd, this);
            a.tags.on("remove", this._onTagRemove, this);
            this.fire("add", a);
            this.fire("add:" + a.id, a);
            c && this.fire("add:url:" + c, a);
            a.preload && this.load(a)
        },
        remove: function(a) {
            var b = this._cache[a.id],
                c = a.file ? a.file.url : null;
            if (void 0 !== b) {
                this._assets.splice(b, 1);
                delete this._cache[a.id];
                this._names = {};
                this._urls = [];
                b = 0;
                for (var d = this._assets.length; b < d; b++) {
                    var e = this._assets[b];
                    this._cache[e.id] = b;
                    this._names[e.name] || (this._names[e.name] = []);
                    this._names[e.name].push(b);
                    e.file && (this._urls[e.file.url] =
                        b)
                }
                this._tags.removeItem(a);
                a.tags.off("add", this._onTagAdd, this);
                a.tags.off("remove", this._onTagRemove, this);
                a.fire("remove", a);
                this.fire("remove", a);
                this.fire("remove:" + a.id, a);
                c && this.fire("remove:url:" + c, a);
                return !0
            }
            return !1
        },
        get: function(a) {
            return this._assets[this._cache[a]]
        },
        getByUrl: function(a) {
            return this._assets[this._urls[a]]
        },
        load: function(a) {
            if (!a.loading && !a.loaded) {
                var b = this,
                    c = a.getPreferredFile(),
                    d = function(f) {
                        f instanceof Array ? a.resources = f : a.resource = f;
                        b._loader.patch(a, b);
                        b.fire("load",
                            a);
                        b.fire("load:" + a.id, a);
                        c && c.url && b.fire("load:url:" + c.url, a);
                        a.fire("load", a)
                    },
                    e = function(f, g, k) {
                        a.loaded = !0;
                        a.loading = !1;
                        f ? (b.fire("error", f, a), b.fire("error:" + a.id, f, a), a.fire("error", f, a)) : (vb.legacy || "script" !== a.type || (f = b._loader.getHandler("script"), f._cache[a.id] && f._cache[a.id].parentNode === document.head && document.head.removeChild(f._cache[a.id]), f._cache[a.id] = k), d(g))
                    };
                c || "cubemap" === a.type ? (this.fire("load:start", a), this.fire("load:" + a.id + ":start", a), a.loading = !0, b._loader.load(a.getFileUrl(),
                    a.type, e, a)) : (e = b._loader.open(a.type, a.data), a.loaded = !0, d(e))
            }
        },
        loadFromUrl: function(a, b, c) {
            this.loadFromUrlAndFilename(a, null, b, c)
        },
        loadFromUrlAndFilename: function(a, b, c, d) {
            var e = this,
                f = ca.getBasename(b || a);
            b = {
                filename: b || f,
                url: a
            };
            a = e.getByUrl(a);
            a || (a = new aa(f, c, b), e.add(a));
            f = function(g) {
                g.once("load", function(k) {
                    "material" === c ? e._loadTextures(k, function(h, l) {
                        d(h, k)
                    }) : d(null, k)
                });
                g.once("error", function(k) {
                    d(k)
                });
                e.load(g)
            };
            a.resource ? d(null, a) : "model" === c ? e._loadModel(a, f) : f(a)
        },
        _loadModel: function(a,
            b) {
            var c = this,
                d = a.getFileUrl(),
                e = ca.getExtension(d);
            if (".json" === e || ".glb" === e) {
                var f = ca.getDirectory(d);
                d = ca.getBasename(d);
                e = ca.join(f, d.replace(e, ".mapping.json"));
                this._loader.load(e, "json", function(g, k) {
                    g ? (a.data = {
                        mapping: []
                    }, b(a)) : c._loadMaterials(a, k, function(h, l) {
                        a.data = k;
                        b(a)
                    })
                })
            } else b(a)
        },
        _loadMaterials: function(a, b, c) {
            for (var d = this, e = [], f = 0, g = function(l, n) {
                    d._loadTextures(n, function(p, q) {
                        e.push(n);
                        e.length === f && c(null, e)
                    })
                }, k = 0; k < b.mapping.length; k++) {
                var h = b.mapping[k].path;
                h && (f++,
                    d.loadFromUrl(a.getAbsoluteUrl(h), "material", g))
            }
            0 === f && c(null, e)
        },
        _loadTextures: function(a, b) {
            var c = [],
                d = 0,
                e = a.data;
            if ("path" !== e.mappingFormat) b(null, c);
            else {
                for (var f = function(h, l) {
                        h && console.error(h);
                        c.push(l);
                        c.length === d && b(null, c)
                    }, g = 0; g < mf.length; g++) {
                    var k = e[mf[g]];
                    k && "string" === typeof k && (d++, this.loadFromUrl(a.getAbsoluteUrl(k), "texture", f))
                }
                0 === d && b(null, c)
            }
        },
        findAll: function(a, b) {
            var c = this;
            return (a = this._names[a]) ? (a = a.map(function(d) {
                return c._assets[d]
            }), b ? a.filter(function(d) {
                return d.type ===
                    b
            }) : a) : []
        },
        _onTagAdd: function(a, b) {
            this._tags.add(a, b)
        },
        _onTagRemove: function(a, b) {
            this._tags.remove(a, b)
        },
        findByTag: function() {
            return this._tags.find(arguments)
        },
        filter: function(a) {
            for (var b = [], c = 0, d = this._assets.length; c < d; c++) a(this._assets[c]) && b.push(this._assets[c]);
            return b
        },
        find: function(a, b) {
            return (a = this.findAll(a, b)) ? a[0] : null
        }
    });
    Object.assign(kj.prototype, {
        _onAssetAdded: function(a) {
            if ("bundle" === a.type) {
                this._bundleAssets[a.id] = a;
                this._registerBundleEventListeners(a.id);
                for (var b = 0, c =
                        a.data.assets.length; b < c; b++) this._indexAssetInBundle(a.data.assets[b], a)
            } else this._assetsInBundles[a.id] && this._indexAssetFileUrls(a)
        },
        _registerBundleEventListeners: function(a) {
            this._assets.on("load:" + a, this._onBundleLoaded, this);
            this._assets.on("error:" + a, this._onBundleError, this)
        },
        _unregisterBundleEventListeners: function(a) {
            this._assets.off("load:" + a, this._onBundleLoaded, this);
            this._assets.off("error:" + a, this._onBundleError, this)
        },
        _indexAssetInBundle: function(a, b) {
            if (this._assetsInBundles[a]) {
                var c =
                    this._assetsInBundles[a]; - 1 === c.indexOf(b) && c.push(b)
            } else this._assetsInBundles[a] = [b];
            (a = this._assets.get(a)) && this._indexAssetFileUrls(a)
        },
        _indexAssetFileUrls: function(a) {
            var b = this._getAssetFileUrls(a);
            if (b)
                for (var c = 0, d = b.length; c < d; c++) this._urlsInBundles[b[c]] = this._assetsInBundles[a.id]
        },
        _getAssetFileUrls: function(a) {
            var b = a.getFileUrl();
            if (!b) return null;
            b = this._normalizeUrl(b);
            var c = [b];
            if ("font" === a.type) {
                a = a.data.info.maps.length;
                for (var d = 1; d < a; d++) c.push(b.replace(".png", d + ".png"))
            }
            return c
        },
        _normalizeUrl: function(a) {
            return a && a.split("?")[0]
        },
        _onAssetRemoved: function(a) {
            if ("bundle" === a.type) {
                delete this._bundleAssets[a.id];
                this._unregisterBundleEventListeners(a.id);
                var b;
                for (b in this._assetsInBundles) {
                    var c = this._assetsInBundles[b];
                    var d = c.indexOf(a);
                    if (-1 !== d && (c.splice(d, 1), !c.length)) {
                        delete this._assetsInBundles[b];
                        for (var e in this._urlsInBundles) this._urlsInBundles[e] === c && delete this._urlsInBundles[e]
                    }
                }
                this._onBundleError("Bundle " + a.id + " was removed", a)
            } else if (this._assetsInBundles[a.id])
                for (delete this._assetsInBundles[a.id],
                    a = this._getAssetFileUrls(a), d = 0, b = a.length; d < b; d++) delete this._urlsInBundles[a[d]]
        },
        _onBundleLoaded: function(a) {
            a.resource ? requestAnimationFrame(function() {
                    if (this._fileRequests)
                        for (var b in this._fileRequests) {
                            var c = this._urlsInBundles[b];
                            if (c && -1 !== c.indexOf(a)) {
                                c = decodeURIComponent(b);
                                var d = null;
                                a.resource.hasBlobUrl(c) || (d = "Bundle " + a.id + " does not contain URL " + b);
                                for (var e = this._fileRequests[b], f = 0, g = e.length; f < g; f++)
                                    if (d) e[f](d);
                                    else e[f](null, a.resource.getBlobUrl(c));
                                delete this._fileRequests[b]
                            }
                        }
                }.bind(this)) :
                this._onBundleError("Bundle " + a.id + " failed to load", a)
        },
        _onBundleError: function(a, b) {
            for (var c in this._fileRequests)
                if (!this._findLoadedOrLoadingBundleForUrl(c)) {
                    b = this._fileRequests[c];
                    for (var d = 0, e = b.length; d < e; d++) b[d](a);
                    delete this._fileRequests[c]
                }
        },
        _findLoadedOrLoadingBundleForUrl: function(a) {
            a = this._urlsInBundles[a];
            if (!a) return null;
            var b = a.length,
                c;
            for (c = 0; c < b; c++)
                if (a[c].loaded && a[c].resource) return a[c];
            for (c = 0; c < b; c++)
                if (a[c].loading) return a[c];
            return null
        },
        listBundlesForAsset: function(a) {
            return this._assetsInBundles[a.id] ||
                null
        },
        list: function() {
            var a = [],
                b;
            for (b in this._bundleAssets) a.push(this._bundleAssets[b]);
            return a
        },
        hasUrl: function(a) {
            return !!this._urlsInBundles[a]
        },
        canLoadUrl: function(a) {
            return !!this._findLoadedOrLoadingBundleForUrl(a)
        },
        loadUrl: function(a, b) {
            var c = this._findLoadedOrLoadingBundleForUrl(a);
            if (c)
                if (c.loaded) {
                    var d = decodeURIComponent(a);
                    c.resource.hasBlobUrl(d) ? b(null, c.resource.getBlobUrl(d)) : b("Bundle " + c.id + " does not contain URL " + a)
                } else this._fileRequests.hasOwnProperty(a) ? this._fileRequests[a].push(b) :
                    this._fileRequests[a] = [b];
            else b("URL " + a + " not found in any bundles")
        },
        destroy: function() {
            this._assets.off("add", this._onAssetAdded, this);
            this._assets.off("remove", this._onAssetRemoved, this);
            for (var a in this._bundleAssets) this._unregisterBundleEventListeners(a);
            this._fileRequests = this._urlsInBundles = this._assetsInBundles = this._bundleAssets = this._assets = null
        }
    });
    fc.prototype = Object.create(M.prototype);
    fc.prototype.constructor = fc;
    fc.prototype.destroy = function() {
        this.app = null;
        this.off()
    };
    fc.prototype.add =
        function(a) {
            var b = this,
                c = a.__name;
            if (this._scripts.hasOwnProperty(c)) return setTimeout(function() {
                if (a.prototype.swap) {
                    var d = b._list.indexOf(b._scripts[c]);
                    b._list[d] = a;
                    b._scripts[c] = a;
                    b.fire("swap", c, a);
                    b.fire("swap:" + c, a)
                } else console.warn("script registry already has '" + c + "' script, define 'swap' method for new script type to enable code hot swapping")
            }), !1;
            this._scripts[c] = a;
            this._list.push(a);
            this.fire("add", c, a);
            this.fire("add:" + c, a);
            setTimeout(function() {
                if (b._scripts.hasOwnProperty(c) && b.app &&
                    b.app.systems && b.app.systems.script) {
                    var d = b.app.systems.script._components,
                        e = [],
                        f = [];
                    for (d.loopIndex = 0; d.loopIndex < d.length; d.loopIndex++) {
                        var g = d.items[d.loopIndex];
                        if (g._scriptsIndex[c] && g._scriptsIndex[c].awaiting) {
                            if (g._scriptsData && g._scriptsData[c]) var k = g._scriptsData[c].attributes;
                            (g = g.create(c, {
                                preloading: !0,
                                ind: g._scriptsIndex[c].ind,
                                attributes: k
                            })) && e.push(g)
                        }
                    }
                    for (d = 0; d < e.length; d++) e[d].__initializeAttributes();
                    for (d = 0; d < e.length; d++) e[d].enabled && (e[d]._initialized = !0, f.push(e[d]), e[d].initialize &&
                        e[d].initialize());
                    for (d = 0; d < f.length; d++) f[d].enabled && !f[d]._postInitialized && (f[d]._postInitialized = !0, f[d].postInitialize && f[d].postInitialize())
                }
            });
            return !0
        };
    fc.prototype.remove = function(a) {
        var b = a;
        "string" !== typeof a ? a = b.__name : b = this.get(a);
        if (this.get(a) !== b) return !1;
        delete this._scripts[a];
        var c = this._list.indexOf(b);
        this._list.splice(c, 1);
        this.fire("remove", a, b);
        this.fire("remove:" + a, b);
        return !0
    };
    fc.prototype.get = function(a) {
        return this._scripts[a] || null
    };
    fc.prototype.has = function(a) {
        return "string" ===
            typeof a ? this._scripts.hasOwnProperty(a) : a ? this._scripts[a.__name] === a : !1
    };
    fc.prototype.list = function() {
        return this._list
    };
    var bh = "KEEP_ASPECT",
        zj = "FIXED";
    Od.prototype = Object.create(M.prototype);
    Od.prototype.constructor = Od;
    Object.assign(Od.prototype, {
        destroy: function() {
            window.removeEventListener("vrdisplaypresentchange", self._presentChange);
            this._camera && (this._camera.vrDisplay = null);
            this._camera = null
        },
        poll: function() {
            if (this.display) {
                this.display.getFrameData(this._frameData);
                this.leftProj.data =
                    this._frameData.leftProjectionMatrix;
                this.rightProj.data = this._frameData.rightProjectionMatrix;
                var a = this.display.stageParameters;
                a ? (this.sitToStandInv.set(a.sittingToStandingTransform).invert(), this.combinedView.set(this._frameData.leftViewMatrix), this.leftView.mul2(this.combinedView, this.sitToStandInv), this.combinedView.set(this._frameData.rightViewMatrix), this.rightView.mul2(this.combinedView, this.sitToStandInv)) : (this.leftView.set(this._frameData.leftViewMatrix), this.rightView.set(this._frameData.rightViewMatrix));
                var b = this.leftProj.data[3] + this.leftProj.data[0],
                    c = this.leftProj.data[11] + this.leftProj.data[8],
                    d = 1 / Math.sqrt(b * b + c * c);
                a = -Math.atan2(c * d, b * d);
                b = this.rightProj.data[3] + this.rightProj.data[0];
                c = this.rightProj.data[11] + this.rightProj.data[8];
                d = 1 / Math.sqrt(b * b + c * c);
                a = Math.max(a, -Math.atan2(c * d, b * d));
                this.combinedFov = a *= 2;
                this.combinedAspect = b = this.rightProj.data[5] / this.rightProj.data[0];
                c = this.combinedView;
                c.copy(this.leftView);
                c.invert();
                this.leftViewInv.copy(c);
                d = this.combinedPos;
                d.x = this.leftPos.x =
                    c.data[12];
                d.y = this.leftPos.y = c.data[13];
                d.z = this.leftPos.z = c.data[14];
                c.copy(this.rightView);
                c.invert();
                this.rightViewInv.copy(c);
                var e = d.x - c.data[12],
                    f = d.y - c.data[13],
                    g = d.z - c.data[14];
                e = Math.sqrt(e * e + f * f + g * g);
                this.rightPos.x = c.data[12];
                this.rightPos.y = c.data[13];
                this.rightPos.z = c.data[14];
                d.x += c.data[12];
                d.y += c.data[13];
                d.z += c.data[14];
                d.x *= .5;
                d.y *= .5;
                d.z *= .5;
                e = .5 * e * Math.sin(Math.PI - (.5 * Math.PI + .5 * a));
                f = c.data[9];
                g = c.data[10];
                c.data[12] = d.x + c.data[8] * e;
                c.data[13] = d.y + f * e;
                c.data[14] = d.z + g * e;
                this.combinedViewInv.copy(c);
                c.invert();
                this.combinedProj.setPerspective(a * N.RAD_TO_DEG, b, this.display.depthNear + e, this.display.depthFar + e, !0)
            }
        },
        requestPresent: function(a) {
            this.display ? this.presenting ? a && a(Error("VrDisplay already presenting")) : this.display.requestPresent([{
                source: this._device.canvas
            }]).then(function() {
                a && a()
            }, function(b) {
                a && a(b)
            }) : a && a(Error("No VrDisplay to requestPresent"))
        },
        exitPresent: function(a) {
            this.display || a && a(Error("No VrDisplay to exitPresent"));
            this.presenting ? this.display.exitPresent().then(function() {
                a &&
                    a()
            }, function() {
                a && a(Error("exitPresent failed"))
            }) : a && a(Error("VrDisplay not presenting"))
        },
        requestAnimationFrame: function(a) {
            this.display && this.display.requestAnimationFrame(a)
        },
        submitFrame: function() {
            this.display && this.display.submitFrame()
        },
        reset: function() {
            this.display && this.display.resetPose()
        },
        setClipPlanes: function(a, b) {
            this.display && (this.display.depthNear = a, this.display.depthFar = b)
        },
        getFrameData: function() {
            if (this.display) return this._frameData
        }
    });
    Object.defineProperty(Od.prototype, "capabilities", {
        get: function() {
            return this.display ? this.display.capabilities : {}
        }
    });
    hd.prototype = Object.create(M.prototype);
    hd.prototype.constructor = hd;
    hd.isSupported = "undefined" !== typeof navigator ? !!navigator.getVRDisplays : !1;
    Object.assign(hd.prototype, {
        _attach: function() {
            window.addEventListener("vrdisplayconnect", this._onDisplayConnect);
            window.addEventListener("vrdisplaydisconnect", this._onDisplayDisconnect)
        },
        _detach: function() {
            window.removeEventListener("vrdisplayconnect", this._onDisplayConnect);
            window.removeEventListener("vrdisplaydisconnect",
                this._onDisplayDisconnect)
        },
        destroy: function() {
            this._detach()
        },
        poll: function() {
            var a = this.displays.length;
            if (a)
                for (var b = 0; b < a; b++) this.displays[b]._camera && this.displays[b].poll()
        },
        _getDisplays: function(a) {
            navigator.getVRDisplays ? navigator.getVRDisplays().then(function(b) {
                a && a(null, b)
            }) : a && a(Error("WebVR not supported"))
        },
        _addDisplay: function(a) {
            this._index[a.displayId] || (a = new Od(this._app, a), this._index[a.id] = a, this.displays.push(a), this.display || (this.display = a), this.fire("displayconnect", a))
        },
        _onDisplayConnect: function(a) {
            a.detail && a.detail.display ? this._addDisplay(a.detail.display) : this._addDisplay(a.display)
        },
        _onDisplayDisconnect: function(a) {
            if (a = this._index[a.detail && a.detail.display ? a.detail.display.displayId : a.display.displayId]) {
                a.destroy();
                delete this._index[a.id];
                var b = this.displays.indexOf(a);
                this.displays.splice(b, 1);
                this.display === a && (this.display = this.displays.length ? this.displays[0] : null);
                this.fire("displaydisconnect", a)
            }
        }
    });
    var jl = "inline",
        lj = "immersive-vr",
        Pd = "immersive-ar",
        Om = [],
        Pm = [];
    Kc.prototype = Object.create(M.prototype);
    Kc.prototype.constructor = Kc;
    Kc.prototype.remove = function() {
        if (this._xrHitTestSource) {
            var a = this.manager.hitTest.sources,
                b = a.indexOf(this); - 1 !== b && a.splice(b, 1);
            this.onStop()
        }
    };
    Kc.prototype.onStop = function() {
        this._xrHitTestSource.cancel();
        this._xrHitTestSource = null;
        this.fire("remove");
        this.manager.hitTest.fire("remove", this)
    };
    Kc.prototype.update = function(a) {
        if (this._transient) {
            a = a.getHitTestResultsForTransientInput(this._xrHitTestSource);
            for (var b =
                    0; b < a.length; b++) {
                var c = a[b],
                    d;
                c.inputSource && (d = this.manager.input._getByInputSource(c.inputSource));
                this.updateHitResults(c.results, d)
            }
        } else this.updateHitResults(a.getHitTestResults(this._xrHitTestSource))
    };
    Kc.prototype.updateHitResults = function(a, b) {
        for (var c = 0; c < a.length; c++) {
            var d = a[c].getPose(this.manager._referenceSpace),
                e = Om.pop();
            e || (e = new z);
            e.copy(d.transform.position);
            var f = Pm.pop();
            f || (f = new Y);
            f.copy(d.transform.orientation);
            this.fire("result", e, f, b);
            this.manager.hitTest.fire("result",
                this, e, f, b);
            Om.push(e);
            Pm.push(f)
        }
    };
    Sb.prototype = Object.create(M.prototype);
    Sb.prototype.constructor = Sb;
    Sb.prototype._onSessionStart = function() {
        this.manager.type === Pd && (this._session = this.manager.session)
    };
    Sb.prototype._onSessionEnd = function() {
        if (this._session) {
            this._session = null;
            for (var a = 0; a < this.sources.length; a++) this.sources[a].onStop();
            this.sources = []
        }
    };
    Sb.prototype.isAvailable = function(a, b) {
        var c;
        this._supported || (c = Error("XR HitTest is not supported"));
        this._session || (c = Error("XR Session is not started (1)"));
        this.manager.type !== Pd && (c = Error("XR HitTest is available only for AR"));
        return c ? (a && a(c), b && b.fire("error", c), !1) : !0
    };
    Sb.prototype.start = function(a) {
        var b = this;
        a = a || {};
        if (this.isAvailable(a.callback, this)) {
            a.profile || a.spaceType || (a.spaceType = "viewer");
            var c, d = a.offsetRay;
            d && (c = new XRRay(new DOMPoint(d.origin.x, d.origin.y, d.origin.z), new DOMPoint(d.direction.x, d.direction.y, d.direction.z)));
            var e = a.callback;
            a.spaceType ? this._session.requestReferenceSpace(a.spaceType).then(function(f) {
                b._session ?
                    b._session.requestHitTestSource({
                        space: f,
                        entityTypes: a.entityTypes || void 0,
                        offsetRay: c
                    }).then(function(g) {
                        b._onHitTestSource(g, !1, e)
                    }).catch(function(g) {
                        e && e(g);
                        b.fire("error", g)
                    }) : (f = Error("XR Session is not started (2)"), e && e(f), b.fire("error", f))
            }).catch(function(f) {
                e && e(f);
                b.fire("error", f)
            }) : this._session.requestHitTestSourceForTransientInput({
                profile: a.profile,
                entityTypes: a.entityTypes || void 0,
                offsetRay: c
            }).then(function(f) {
                b._onHitTestSource(f, !0, e)
            }).catch(function(f) {
                e && e(f);
                b.fire("error",
                    f)
            })
        }
    };
    Sb.prototype._onHitTestSource = function(a, b, c) {
        this._session ? (a = new Kc(this.manager, a, b), this.sources.push(a), c && c(null, a), this.fire("add", a)) : (a.cancel(), a = Error("XR Session is not started (3)"), c && c(a), this.fire("error", a))
    };
    Sb.prototype.update = function(a) {
        for (var b = 0; b < this.sources.length; b++) this.sources[b].update(a)
    };
    Object.defineProperty(Sb.prototype, "supported", {
        get: function() {
            return this._supported
        }
    });
    Object.defineProperty(If.prototype, "index", {
        get: function() {
            return this._index
        }
    });
    Object.defineProperty(If.prototype,
        "hand", {
            get: function() {
                return this._hand
            }
        });
    Object.defineProperty(If.prototype, "joints", {
        get: function() {
            return this._joints
        }
    });
    Object.defineProperty(If.prototype, "tip", {
        get: function() {
            return this._tip
        }
    });
    for (var Qm = window.XRHand ? [XRHand.THUMB_PHALANX_TIP, XRHand.INDEX_PHALANX_TIP, XRHand.MIDDLE_PHALANX_TIP, XRHand.RING_PHALANX_TIP, XRHand.LITTLE_PHALANX_TIP] : [], il = {}, ok = 0; ok < Qm.length; ok++) il[Qm[ok]] = !0;
    Tb.prototype.update = function(a) {
        this._dirtyLocal = !0;
        this._radius = a.radius;
        this._localPosition.copy(a.transform.position);
        this._localRotation.copy(a.transform.orientation)
    };
    Tb.prototype._updateTransforms = function() {
        this._dirtyLocal && (this._dirtyLocal = !1, this._localTransform.setTRS(this._localPosition, this._localRotation, z.ONE));
        var a = this._hand._manager.camera.parent;
        a ? this._worldTransform.mul2(a.getWorldTransform(), this._localTransform) : this._worldTransform.copy(this._localTransform)
    };
    Tb.prototype.getPosition = function() {
        this._updateTransforms();
        this._worldTransform.getTranslation(this._position);
        return this._position
    };
    Tb.prototype.getRotation = function() {
        this._updateTransforms();
        this._rotation.setFromMat4(this._worldTransform);
        return this._rotation
    };
    Object.defineProperty(Tb.prototype, "index", {
        get: function() {
            return this._index
        }
    });
    Object.defineProperty(Tb.prototype, "hand", {
        get: function() {
            return this._hand
        }
    });
    Object.defineProperty(Tb.prototype, "finger", {
        get: function() {
            return this._finger
        }
    });
    Object.defineProperty(Tb.prototype, "wrist", {
        get: function() {
            return this._wrist
        }
    });
    Object.defineProperty(Tb.prototype, "tip", {
        get: function() {
            return this._tip
        }
    });
    Object.defineProperty(Tb.prototype, "radius", {
        get: function() {
            return this._radius || .005
        }
    });
    var Tg = [],
        me = new z,
        Rm = new z,
        Sm = new z;
    window.XRHand && (Tg = [
        [XRHand.THUMB_METACARPAL, XRHand.THUMB_PHALANX_PROXIMAL, XRHand.THUMB_PHALANX_DISTAL, XRHand.THUMB_PHALANX_TIP],
        [XRHand.INDEX_METACARPAL, XRHand.INDEX_PHALANX_PROXIMAL, XRHand.INDEX_PHALANX_INTERMEDIATE, XRHand.INDEX_PHALANX_DISTAL, XRHand.INDEX_PHALANX_TIP],
        [XRHand.MIDDLE_METACARPAL, XRHand.MIDDLE_PHALANX_PROXIMAL, XRHand.MIDDLE_PHALANX_INTERMEDIATE, XRHand.MIDDLE_PHALANX_DISTAL,
            XRHand.MIDDLE_PHALANX_TIP
        ],
        [XRHand.RING_METACARPAL, XRHand.RING_PHALANX_PROXIMAL, XRHand.RING_PHALANX_INTERMEDIATE, XRHand.RING_PHALANX_DISTAL, XRHand.RING_PHALANX_TIP],
        [XRHand.LITTLE_METACARPAL, XRHand.LITTLE_PHALANX_PROXIMAL, XRHand.LITTLE_PHALANX_INTERMEDIATE, XRHand.LITTLE_PHALANX_DISTAL, XRHand.LITTLE_PHALANX_TIP]
    ]);
    gc.prototype = Object.create(M.prototype);
    gc.prototype.constructor = gc;
    gc.prototype.update = function(a) {
        for (var b = this._inputSource._xrInputSource, c = 0; c < this._joints.length; c++) {
            var d = this._joints[c],
                e = b.hand[d._id];
            if (e)
                if (e = a.getJointPose(e, this._manager._referenceSpace)) d.update(e), d.wrist && !this._tracking && (this._tracking = !0, this.fire("tracking"));
                else if (d.wrist) {
                this._tracking && (this._tracking = !1, this.fire("trackinglost"));
                break
            }
        }
        e = this._jointsById[XRHand.THUMB_METACARPAL];
        a = this._jointsById[XRHand.THUMB_PHALANX_TIP];
        b = this._jointsById[XRHand.INDEX_PHALANX_PROXIMAL];
        c = this._jointsById[XRHand.INDEX_PHALANX_TIP];
        d = this._jointsById[XRHand.RING_PHALANX_PROXIMAL];
        var f = this._jointsById[XRHand.LITTLE_PHALANX_PROXIMAL];
        if (e && a && b && c && d && f) {
            this._inputSource._dirtyRay = !0;
            this._inputSource._rayLocal.origin.lerp(a._localPosition, c._localPosition, .5);
            if ("left" === this._inputSource.handedness) {
                var g = e;
                e = f;
                f = g
            }
            me.sub2(e._localPosition, this._wrist._localPosition);
            Rm.sub2(f._localPosition, this._wrist._localPosition);
            Sm.cross(me, Rm).normalize();
            me.lerp(b._localPosition, d._localPosition, .5);
            me.sub(this._wrist._localPosition).normalize();
            this._inputSource._rayLocal.direction.lerp(Sm, me, .5).normalize()
        }
        a && c && (me.copy(a._localPosition),
            .015 > me.distance(c._localPosition) ? this._inputSource._selecting || (this._inputSource._selecting = !0, this._inputSource.fire("selectstart"), this._manager.input.fire("selectstart", this._inputSource)) : this._inputSource._selecting && (this._inputSource._selecting = !1, this._inputSource.fire("select"), this._manager.input.fire("select", this._inputSource), this._inputSource.fire("selectend"), this._manager.input.fire("selectend", this._inputSource)))
    };
    gc.prototype.getJointById = function(a) {
        return this._jointsById[a] ||
            null
    };
    Object.defineProperty(gc.prototype, "fingers", {
        get: function() {
            return this._fingers
        }
    });
    Object.defineProperty(gc.prototype, "joints", {
        get: function() {
            return this._joints
        }
    });
    Object.defineProperty(gc.prototype, "tips", {
        get: function() {
            return this._tips
        }
    });
    Object.defineProperty(gc.prototype, "wrist", {
        get: function() {
            return this._wrist
        }
    });
    Object.defineProperty(gc.prototype, "tracking", {
        get: function() {
            return this._tracking
        }
    });
    var Tm = new Y,
        co = 0;
    ta.prototype = Object.create(M.prototype);
    ta.prototype.constructor =
        ta;
    ta.prototype.update = function(a) {
        if (this._hand) this._hand.update(a);
        else {
            if (this._xrInputSource.gripSpace) {
                var b = a.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);
                b && (this._grip || (this._grip = !0, this._localTransform = new J, this._worldTransform = new J, this._localPosition = new z, this._localRotation = new Y), this._dirtyLocal = !0, this._localPosition.copy(b.transform.position), this._localRotation.copy(b.transform.orientation))
            }
            if (a = a.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace)) this._dirtyRay = !0, this._rayLocal.origin.copy(a.transform.position), this._rayLocal.direction.set(0, 0, -1), Tm.copy(a.transform.orientation), Tm.transformVector(this._rayLocal.direction, this._rayLocal.direction)
        }
    };
    ta.prototype._updateTransforms = function() {
        this._dirtyLocal && (this._dirtyLocal = !1, this._localTransform.setTRS(this._localPosition, this._localRotation, z.ONE));
        var a = this._manager.camera.parent;
        a ? this._worldTransform.mul2(a.getWorldTransform(), this._localTransform) : this._worldTransform.copy(this._localTransform)
    };
    ta.prototype._updateRayTransforms = function() {
        var a = this._dirtyRay;
        this._dirtyRay = !1;
        this._manager.camera.parent ? (a = this._manager.camera.parent.getWorldTransform(), a.getTranslation(this._position), this._rotation.setFromMat4(a), this._rotation.transformVector(this._rayLocal.origin, this._ray.origin), this._ray.origin.add(this._position), this._rotation.transformVector(this._rayLocal.direction, this._ray.direction)) : a && (this._ray.origin.copy(this._rayLocal.origin), this._ray.direction.copy(this._rayLocal.direction))
    };
    ta.prototype.getPosition = function() {
        if (!this._position) return null;
        this._updateTransforms();
        this._worldTransform.getTranslation(this._position);
        return this._position
    };
    ta.prototype.getLocalPosition = function() {
        return this._localPosition
    };
    ta.prototype.getRotation = function() {
        if (!this._rotation) return null;
        this._updateTransforms();
        this._rotation.setFromMat4(this._worldTransform);
        return this._rotation
    };
    ta.prototype.getLocalRotation = function() {
        return this._localRotation
    };
    ta.prototype.getOrigin = function() {
        this._updateRayTransforms();
        return this._ray.origin
    };
    ta.prototype.getDirection = function() {
        this._updateRayTransforms();
        return this._ray.direction
    };
    ta.prototype.hitTestStart = function(a) {
        var b = this;
        a = a || {};
        a.profile = this._xrInputSource.profiles[0];
        var c = a.callback;
        a.callback = function(d, e) {
            if (e) b.onHitTestSourceAdd(e);
            c && c(d, e)
        };
        this._manager.hitTest.start(a)
    };
    ta.prototype.onHitTestSourceAdd = function(a) {
        this._hitTestSources.push(a);
        this.fire("hittest:add", a);
        a.on("result", function(b, c, d) {
            d === this && this.fire("hittest:result", a, b,
                c)
        }, this);
        a.once("remove", function() {
            this.onHitTestSourceRemove(a);
            this.fire("hittest:remove", a)
        }, this)
    };
    ta.prototype.onHitTestSourceRemove = function(a) {
        a = this._hitTestSources.indexOf(a); - 1 !== a && this._hitTestSources.splice(a, 1)
    };
    Object.defineProperty(ta.prototype, "id", {
        get: function() {
            return this._id
        }
    });
    Object.defineProperty(ta.prototype, "inputSource", {
        get: function() {
            return this._xrInputSource
        }
    });
    Object.defineProperty(ta.prototype, "targetRayMode", {
        get: function() {
            return this._xrInputSource.targetRayMode
        }
    });
    Object.defineProperty(ta.prototype, "handedness", {
        get: function() {
            return this._xrInputSource.handedness
        }
    });
    Object.defineProperty(ta.prototype, "profiles", {
        get: function() {
            return this._xrInputSource.profiles
        }
    });
    Object.defineProperty(ta.prototype, "grip", {
        get: function() {
            return this._grip
        }
    });
    Object.defineProperty(ta.prototype, "hand", {
        get: function() {
            return this._hand
        }
    });
    Object.defineProperty(ta.prototype, "gamepad", {
        get: function() {
            return this._xrInputSource.gamepad || null
        }
    });
    Object.defineProperty(ta.prototype,
        "selecting", {
            get: function() {
                return this._selecting
            }
        });
    Object.defineProperty(ta.prototype, "elementInput", {
        get: function() {
            return this._elementInput
        },
        set: function(a) {
            this._elementInput !== a && (this._elementInput = a, this._elementInput || (this._elementEntity = null))
        }
    });
    Object.defineProperty(ta.prototype, "elementEntity", {
        get: function() {
            return this._elementEntity
        }
    });
    Object.defineProperty(ta.prototype, "hitTestSources", {
        get: function() {
            return this._hitTestSources
        }
    });
    Fb.prototype = Object.create(M.prototype);
    Fb.prototype.constructor =
        Fb;
    Fb.prototype._onSessionStart = function() {
        this._session = this.manager.session;
        this._session.addEventListener("inputsourceschange", this._onInputSourcesChangeEvt);
        var a = this;
        this._session.addEventListener("select", function(d) {
            var e = a._getByInputSource(d.inputSource);
            e.update(d.frame);
            e.fire("select", d);
            a.fire("select", e, d)
        });
        this._session.addEventListener("selectstart", function(d) {
            var e = a._getByInputSource(d.inputSource);
            e.update(d.frame);
            e._selecting = !0;
            e.fire("selectstart", d);
            a.fire("selectstart",
                e, d)
        });
        this._session.addEventListener("selectend", function(d) {
            var e = a._getByInputSource(d.inputSource);
            e.update(d.frame);
            e._selecting = !1;
            e.fire("selectend", d);
            a.fire("selectend", e, d)
        });
        for (var b = this._session.inputSources, c = 0; c < b.length; c++) this._addInputSource(b[c])
    };
    Fb.prototype._onSessionEnd = function() {
        for (var a = this._inputSources.length; a--;) {
            var b = this._inputSources[a];
            this._inputSources.splice(a, 1);
            b.fire("remove");
            this.fire("remove", b)
        }
        this._session.removeEventListener("inputsourceschange",
            this._onInputSourcesChangeEvt);
        this._session = null
    };
    Fb.prototype._onInputSourcesChange = function(a) {
        var b;
        for (b = 0; b < a.removed.length; b++) this._removeInputSource(a.removed[b]);
        for (b = 0; b < a.added.length; b++) this._addInputSource(a.added[b])
    };
    Fb.prototype._getByInputSource = function(a) {
        for (var b = 0; b < this._inputSources.length; b++)
            if (this._inputSources[b].inputSource === a) return this._inputSources[b];
        return null
    };
    Fb.prototype._addInputSource = function(a) {
        this._getByInputSource(a) || (a = new ta(this.manager, a), this._inputSources.push(a),
            this.fire("add", a))
    };
    Fb.prototype._removeInputSource = function(a) {
        for (var b = 0; b < this._inputSources.length; b++)
            if (this._inputSources[b].inputSource === a) {
                a = this._inputSources[b];
                this._inputSources.splice(b, 1);
                for (b = a.hitTestSources.length; b--;) a.hitTestSources[b].remove();
                a.fire("remove");
                this.fire("remove", a);
                break
            }
    };
    Fb.prototype.update = function(a) {
        for (var b = 0; b < this._inputSources.length; b++) this._inputSources[b].update(a)
    };
    Object.defineProperty(Fb.prototype, "inputSources", {
        get: function() {
            return this._inputSources
        }
    });
    var nf = new z,
        Um = new z,
        pk = new J,
        Vm = new J;
    ib.prototype = Object.create(M.prototype);
    ib.prototype.constructor = ib;
    ib.prototype._onSessionStart = function() {
        this._manager.session.requestLightProbe && (this._supported = !0)
    };
    ib.prototype._onSessionEnd = function() {
        this._lightProbeRequested = this._available = this._supported = !1;
        this._lightProbe = null
    };
    ib.prototype.start = function() {
        var a;
        this._manager.session || (a = Error("XR session is not running"));
        a || this._manager.type === Pd || (a = Error("XR session type is not AR"));
        a ||
            this._supported || (a = Error("light-estimation is not supported"));
        if (!a && this._lightProbe || this._lightProbeRequested) a = Error("light estimation is already requested");
        if (a) this.fire("error", a);
        else {
            var b = this;
            this._lightProbeRequested = !0;
            this._manager.session.requestLightProbe().then(function(c) {
                var d = b._lightProbeRequested;
                b._lightProbeRequested = !1;
                b._manager.active ? d && (b._lightProbe = c) : b.fire("error", Error("XR session is not active"))
            }).catch(function(c) {
                b._lightProbeRequested = !1;
                b.fire("error", c)
            })
        }
    };
    ib.prototype.end = function() {
        this._lightProbeRequested = !1;
        this._lightProbe = null;
        this._available = !1
    };
    ib.prototype.update = function(a) {
        if (this._lightProbe && (a = a.getLightEstimate(this._lightProbe))) {
            this._available || (this._available = !0, this.fire("available"));
            var b = a.primaryLightIntensity;
            this._intensity = Math.max(1, Math.max(b.x, Math.max(b.y, b.z)));
            nf.copy(b).scale(1 / this._intensity);
            this._color.set(nf.x, nf.y, nf.z);
            nf.set(0, 0, 0);
            Um.copy(a.primaryLightDirection);
            pk.setLookAt(Um, nf, z.UP);
            Vm.setFromAxisAngle(z.RIGHT,
                90);
            pk.mul(Vm);
            this._rotation.setFromMat4(pk);
            this._sphericalHarmonics.set(a.sphericalHarmonicsCoefficients)
        }
    };
    Object.defineProperty(ib.prototype, "supported", {
        get: function() {
            return this._supported
        }
    });
    Object.defineProperty(ib.prototype, "available", {
        get: function() {
            return !!this._available
        }
    });
    Object.defineProperty(ib.prototype, "intensity", {
        get: function() {
            return this._available ? this._intensity : null
        }
    });
    Object.defineProperty(ib.prototype, "color", {
        get: function() {
            return this._available ? this._color : null
        }
    });
    Object.defineProperty(ib.prototype, "rotation", {
        get: function() {
            return this._available ? this._rotation : null
        }
    });
    Object.defineProperty(ib.prototype, "sphericalHarmonics", {
        get: function() {
            return this._available ? this._sphericalHarmonics : null
        }
    });
    Pa.prototype = Object.create(M.prototype);
    Pa.prototype.constructor = Pa;
    Pa.prototype.start = function(a, b, c, d) {
        var e = this,
            f = d;
        "object" === typeof d && (f = d.callback);
        this._available[b] ? this._session ? f && f(Error("XR session is already started")) : (this._camera = a, this._camera.camera.xr =
            this, this._type = b, this._spaceType = c, this._setClipPlanes(a.nearClip, a.farClip), a = [], b === Pd ? (a.push("light-estimation"), a.push("hit-test")) : b === lj && a.push("hand-tracking"), d && d.optionalFeatures && (a = a.concat(d.optionalFeatures)), navigator.xr.requestSession(b, {
                requiredFeatures: [c],
                optionalFeatures: a
            }).then(function(g) {
                e._onSessionStart(g, c, f)
            }).catch(function(g) {
                e._camera.camera.xr = null;
                e._camera = null;
                e._type = null;
                e._spaceType = null;
                f && f(g);
                e.fire("error", g)
            })) : f && f(Error("XR is not available"))
    };
    Pa.prototype.end =
        function(a) {
            if (this._session) {
                if (a) this.once("end", a);
                this._session.end()
            } else a && a(Error("XR Session is not initialized"))
        };
    Pa.prototype.isAvailable = function(a) {
        return this._available[a]
    };
    Pa.prototype._deviceAvailabilityCheck = function() {
        for (var a in this._available) this._sessionSupportCheck(a)
    };
    Pa.prototype._sessionSupportCheck = function(a) {
        var b = this;
        navigator.xr.isSessionSupported(a).then(function(c) {
            b._available[a] !== c && (b._available[a] = c, b.fire("available", a, c), b.fire("available:" + a, c))
        }).catch(function(c) {
            b.fire("error",
                c)
        })
    };
    Pa.prototype._onSessionStart = function(a, b, c) {
        var d = this,
            e = !1;
        this._session = a;
        var f = function() {
                d.fire("visibility:change", a.visibilityState)
            },
            g = function() {
                d._setClipPlanes(d._camera.nearClip, d._camera.farClip)
            },
            k = function() {
                d._session = null;
                d._referenceSpace = null;
                d.views = [];
                d._width = 0;
                d._height = 0;
                d._type = null;
                d._spaceType = null;
                d._camera && (d._camera.off("set_nearClip", g), d._camera.off("set_farClip", g), d._camera.camera.xr = null, d._camera = null);
                a.removeEventListener("end", k);
                a.removeEventListener("visibilitychange",
                    f);
                e || d.fire("end");
                d.app.tick()
            };
        a.addEventListener("end", k);
        a.addEventListener("visibilitychange", f);
        this._camera.on("set_nearClip", g);
        this._camera.on("set_farClip", g);
        this._baseLayer = new XRWebGLLayer(a, this.app.graphicsDevice.gl);
        a.updateRenderState({
            baseLayer: this._baseLayer,
            depthNear: this._depthNear,
            depthFar: this._depthFar
        });
        a.requestReferenceSpace(b).then(function(h) {
            d._referenceSpace = h;
            d.app.tick();
            c && c(null);
            d.fire("start")
        }).catch(function(h) {
            e = !0;
            a.end();
            c && c(h);
            d.fire("error", h)
        })
    };
    Pa.prototype._setClipPlanes =
        function(a, b) {
            if (this._depthNear !== a || this._depthFar !== b) this._depthNear = a, this._depthFar = b, this._session && this._session.updateRenderState({
                depthNear: this._depthNear,
                depthFar: this._depthFar
            })
        };
    Pa.prototype.update = function(a) {
        if (this._session) {
            var b, c = a.session.renderState.baseLayer.framebufferWidth;
            var d = a.session.renderState.baseLayer.framebufferHeight;
            if (this._width !== c || this._height !== d) this._width = c, this._height = d, this.app.graphicsDevice.setResolution(c, d);
            var e = (c = a.getViewerPose(this._referenceSpace)) ?
                c.views.length : 0;
            if (e > this.views.length)
                for (d = 0; d <= e - this.views.length; d++)(b = this.viewsPool.pop()) || (b = {
                    viewport: new X,
                    projMat: new J,
                    viewMat: new J,
                    viewOffMat: new J,
                    viewInvMat: new J,
                    viewInvOffMat: new J,
                    projViewOffMat: new J,
                    viewMat3: new rb,
                    position: new Float32Array(3),
                    rotation: new Y
                }), this.views.push(b);
            else if (e <= this.views.length)
                for (d = 0; d < this.views.length - e; d++) this.viewsPool.push(this.views.pop());
            if (c) {
                d = c.transform.position;
                b = c.transform.orientation;
                this._localPosition.set(d.x, d.y, d.z);
                this._localRotation.set(b.x,
                    b.y, b.z, b.w);
                var f = a.session.renderState.baseLayer;
                for (d = 0; d < c.views.length; d++) {
                    e = c.views[d];
                    b = this.views[d];
                    var g = f.getViewport(e);
                    b.viewport.x = g.x;
                    b.viewport.y = g.y;
                    b.viewport.z = g.width;
                    b.viewport.w = g.height;
                    b.projMat.set(e.projectionMatrix);
                    b.viewMat.set(e.transform.inverse.matrix);
                    b.viewInvMat.set(e.transform.matrix)
                }
            }
            this._camera.camera._node.setLocalPosition(this._localPosition);
            this._camera.camera._node.setLocalRotation(this._localRotation);
            this.input.update(a);
            this._type === Pd && (this.hitTest.supported &&
                this.hitTest.update(a), this.lightEstimation.supported && this.lightEstimation.update(a));
            this.fire("update", a)
        }
    };
    Object.defineProperty(Pa.prototype, "supported", {
        get: function() {
            return this._supported
        }
    });
    Object.defineProperty(Pa.prototype, "active", {
        get: function() {
            return !!this._session
        }
    });
    Object.defineProperty(Pa.prototype, "type", {
        get: function() {
            return this._type
        }
    });
    Object.defineProperty(Pa.prototype, "spaceType", {
        get: function() {
            return this._spaceType
        }
    });
    Object.defineProperty(Pa.prototype, "session", {
        get: function() {
            return this._session
        }
    });
    Object.defineProperty(Pa.prototype, "visibilityState", {
        get: function() {
            return this._session ? this._session.visibilityState : null
        }
    });
    Object.defineProperty(Pa.prototype, "camera", {
        get: function() {
            return this._camera ? this._camera.entity : null
        }
    });
    O.prototype = Object.create(M.prototype);
    O.prototype.constructor = O;
    O._buildAccessors = function(a, b) {
        b.forEach(function(c) {
            var d = "object" === typeof c ? c.name : c;
            Object.defineProperty(a, d, {
                get: function() {
                    return this.data[d]
                },
                set: function(e) {
                    var f = this.data,
                        g = f[d];
                    f[d] = e;
                    this.fire("set",
                        d, g, e)
                },
                configurable: !0
            })
        });
        a._accessorsBuilt = !0
    };
    Object.assign(O.prototype, {
        buildAccessors: function(a) {
            O._buildAccessors(this, a)
        },
        onSetEnabled: function(a, b, c) {
            if (b !== c && this.entity.enabled)
                if (c) this.onEnable();
                else this.onDisable()
        },
        onEnable: function() {},
        onDisable: function() {},
        onPostStateChange: function() {}
    });
    Object.defineProperty(O.prototype, "data", {
        get: function() {
            var a = this.system.store[this.entity.getGuid()];
            return a ? a.data : null
        }
    });
    H.prototype = Object.create(M.prototype);
    H.prototype.constructor =
        H;
    Object.assign(H, {
        _helper: function(a, b) {
            for (var c = 0, d = a.length; c < d; c++) a[c].f.call(a[c].s, b)
        },
        initialize: function(a) {
            this._helper(this._init, a)
        },
        postInitialize: function(a) {
            this._helper(this._postInit, a);
            this.fire("postinitialize", a)
        },
        update: function(a, b) {
            this._helper(b ? this._toolsUpdate : this._update, a)
        },
        animationUpdate: function(a, b) {
            this._helper(this._animationUpdate, a)
        },
        fixedUpdate: function(a, b) {
            this._helper(this._fixedUpdate, a)
        },
        postUpdate: function(a, b) {
            this._helper(this._postUpdate, a)
        },
        _init: [],
        _postInit: [],
        _toolsUpdate: [],
        _update: [],
        _animationUpdate: [],
        _fixedUpdate: [],
        _postUpdate: [],
        bind: function(a, b, c) {
            switch (a) {
                case "initialize":
                    this._init.push({
                        f: b,
                        s: c
                    });
                    break;
                case "postInitialize":
                    this._postInit.push({
                        f: b,
                        s: c
                    });
                    break;
                case "update":
                    this._update.push({
                        f: b,
                        s: c
                    });
                    break;
                case "animationUpdate":
                    this._animationUpdate.push({
                        f: b,
                        s: c
                    });
                    break;
                case "postUpdate":
                    this._postUpdate.push({
                        f: b,
                        s: c
                    });
                    break;
                case "fixedUpdate":
                    this._fixedUpdate.push({
                        f: b,
                        s: c
                    });
                    break;
                case "toolsUpdate":
                    this._toolsUpdate.push({
                        f: b,
                        s: c
                    });
                    break;
                default:
                    console.error("Component System does not support event", a)
            }
        },
        _erase: function(a, b, c) {
            for (var d = 0; d < a.length; d++) a[d].f === b && a[d].s === c && a.splice(d--, 1)
        },
        unbind: function(a, b, c) {
            switch (a) {
                case "initialize":
                    this._erase(this._init, b, c);
                    break;
                case "postInitialize":
                    this._erase(this._postInit, b, c);
                    break;
                case "update":
                    this._erase(this._update, b, c);
                    break;
                case "animationUpdate":
                    this._erase(this._animationUpdate, b, c);
                    break;
                case "postUpdate":
                    this._erase(this._postUpdate, b, c);
                    break;
                case "fixedUpdate":
                    this._erase(this._fixedUpdate,
                        b, c);
                    break;
                case "toolsUpdate":
                    this._erase(this._toolsUpdate, b, c);
                    break;
                default:
                    console.error("Component System does not support event", a)
            }
        }
    });
    Object.assign(H.prototype, {
        addComponent: function(a, b) {
            var c = new this.ComponentType(this, a),
                d = new this.DataType;
            b = b || {};
            this.store[a.getGuid()] = {
                entity: a,
                data: d
            };
            a[this.id] = c;
            a.c[this.id] = c;
            this.initializeComponentData(c, b, []);
            this.fire("add", a, c);
            return c
        },
        removeComponent: function(a) {
            var b = this.store[a.getGuid()];
            this.fire("beforeremove", a, a.c[this.id]);
            delete this.store[a.getGuid()];
            delete a[this.id];
            delete a.c[this.id];
            this.fire("remove", a, b.data)
        },
        cloneComponent: function(a, b) {
            a = this.store[a.getGuid()];
            return this.addComponent(b, a.data)
        },
        initializeComponentData: function(a, b, c) {
            b = b || {};
            for (var d, e, f, g = 0, k = c.length; g < k; g++) d = c[g], "object" === typeof d ? (e = d.name, d = d.type) : (e = d, d = void 0), f = b[e], void 0 !== f ? (void 0 !== d && (f = eo(f, d)), a[e] = f) : a[e] = a.data[e];
            if (a.enabled && a.entity.enabled) a.onEnable()
        },
        getPropertiesOfType: function(a) {
            var b = [];
            (this.schema || []).forEach(function(c) {
                c && "object" ===
                    typeof c && c.type === a && b.push(c)
            });
            return b
        },
        destroy: function() {
            this.off()
        }
    });
    Rf.attach(H);
    H.destroy = function() {
        H.off("initialize");
        H.off("postInitialize");
        H.off("toolsUpdate");
        H.off("update");
        H.off("animationUpdate");
        H.off("fixedUpdate");
        H.off("postUpdate");
        H._init = [];
        H._postInit = [];
        H._toolsUpdate = [];
        H._update = [];
        H._animationUpdate = [];
        H._fixedUpdate = [];
        H._postUpdate = []
    };
    Object.assign(kl.prototype, {
        getTarget: function() {
            return this._targetNode
        },
        setTarget: function(a) {
            this._targetNode = a
        }
    });
    Ta.prototype.addTime =
        function(a) {
            if (null !== this._animation) {
                var b = this._animation._nodes;
                var c = this._animation.duration;
                if (this._time !== c || this.looping) {
                    this._time += a;
                    if (this._time > c)
                        for (this._time = this.looping ? 0 : c, c = 0; c < b.length; c++) {
                            var d = b[c];
                            var e = d._name;
                            this._currKeyIndices[e] = 0
                        } else if (0 > this._time)
                            for (this._time = this.looping ? c : 0, c = 0; c < b.length; c++) d = b[c], e = d._name, this._currKeyIndices[e] = d._keys.length - 2;
                    a = 0 <= a ? 1 : -1;
                    for (c = 0; c < b.length; c++) {
                        d = b[c];
                        e = d._name;
                        d = d._keys;
                        var f = this._interpolatedKeyDict[e];
                        if (void 0 !==
                            f) {
                            var g = !1;
                            if (1 !== d.length)
                                for (var k = this._currKeyIndices[e]; k < d.length - 1 && 0 <= k; k += a) {
                                    var h = d[k];
                                    var l = d[k + 1];
                                    if (h.time <= this._time && l.time >= this._time) {
                                        g = (this._time - h.time) / (l.time - h.time);
                                        f._pos.lerp(h.position, l.position, g);
                                        f._quat.slerp(h.rotation, l.rotation, g);
                                        f._scale.lerp(h.scale, l.scale, g);
                                        f._written = !0;
                                        this._currKeyIndices[e] = k;
                                        g = !0;
                                        break
                                    }
                                }
                            if (1 === d.length || !g && 0 === this._time && this.looping) f._pos.copy(d[0].position), f._quat.copy(d[0].rotation), f._scale.copy(d[0].scale), f._written = !0
                        }
                    }
                }
            }
        };
    Ta.prototype.blend = function(a, b, c) {
        for (var d = this._interpolatedKeys.length, e = 0; e < d; e++) {
            var f = a._interpolatedKeys[e],
                g = b._interpolatedKeys[e],
                k = this._interpolatedKeys[e];
            f._written && g._written ? (k._quat.slerp(f._quat, b._interpolatedKeys[e]._quat, c), k._pos.lerp(f._pos, b._interpolatedKeys[e]._pos, c), k._scale.lerp(f._scale, g._scale, c), k._written = !0) : f._written ? (k._quat.copy(f._quat), k._pos.copy(f._pos), k._scale.copy(f._scale), k._written = !0) : g._written && (k._quat.copy(g._quat), k._pos.copy(g._pos), k._scale.copy(g._scale),
                k._written = !0)
        }
    };
    Object.defineProperty(Ta.prototype, "animation", {
        get: function() {
            return this._animation
        },
        set: function(a) {
            this._animation = a;
            this.currentTime = 0
        }
    });
    Ta.prototype.getAnimation = function() {
        return this._animation
    };
    Object.defineProperty(Ta.prototype, "currentTime", {
        get: function() {
            return this._time
        },
        set: function(a) {
            this._time = a;
            a = this._interpolatedKeys.length;
            for (var b = 0; b < a; b++) this._currKeyIndices[this._interpolatedKeys[b]._name] = 0;
            this.addTime(0);
            this.updateGraph()
        }
    });
    Ta.prototype.getCurrentTime =
        function() {
            return this._time
        };
    Ta.prototype.setCurrentTime = function(a) {
        this.currentTime = a
    };
    Object.defineProperty(Ta.prototype, "numNodes", {
        get: function() {
            return this._interpolatedKeys.length
        }
    });
    Ta.prototype.getNumNodes = function() {
        return this._interpolatedKeys.length
    };
    Ta.prototype.setAnimation = function(a) {
        this.animation = a
    };
    Ta.prototype.setGraph = function(a) {
        var b;
        if (this.graph = a)
            for (b = 0; b < this._interpolatedKeys.length; b++) {
                var c = a.findByName(this._interpolatedKeys[b]._name);
                this._interpolatedKeys[b].setTarget(c)
            } else
                for (b =
                    0; b < this._interpolatedKeys.length; b++) this._interpolatedKeys[b].setTarget(null)
    };
    Ta.prototype.updateGraph = function() {
        if (this.graph)
            for (var a = 0; a < this._interpolatedKeys.length; a++) {
                var b = this._interpolatedKeys[a];
                if (b._written) {
                    var c = b.getTarget();
                    c.localPosition.copy(b._pos);
                    c.localRotation.copy(b._quat);
                    c.localScale.copy(b._scale);
                    c._dirtyLocal || c._dirtifyLocal();
                    b._written = !1
                }
            }
    };
    Ta.prototype.setLooping = function(a) {
        this.looping = a
    };
    Ta.prototype.getLooping = function() {
        return this.looping
    };
    id.prototype =
        Object.create(O.prototype);
    id.prototype.constructor = id;
    Object.assign(id.prototype, {
        play: function(a, b) {
            if (this.enabled && this.entity.enabled) {
                var c = this.data;
                if (c.animations[a]) {
                    b = b || 0;
                    c.prevAnim = c.currAnim;
                    c.currAnim = a;
                    if (c.model) {
                        c.skeleton || c.animEvaluator || this._createAnimationController();
                        a = c.animations[c.prevAnim];
                        var d = c.animations[c.currAnim];
                        c.blending = 0 < b && c.prevAnim;
                        c.blending && (c.blend = 0, c.blendSpeed = 1 / b);
                        c.skeleton && (c.blending ? (c.fromSkel.animation = a, c.fromSkel.addTime(c.skeleton._time),
                            c.toSkel.animation = d) : c.skeleton.animation = d);
                        if (c.animEvaluator) {
                            b = c.animEvaluator;
                            if (c.blending)
                                for (; 1 < b.clips.length;) b.removeClip(0);
                            else c.animEvaluator.removeClips();
                            b = new yf(c.animations[c.currAnim], 0, 1, !0, c.loop);
                            b.name = c.currAnim;
                            b.blendWeight = c.blending ? 0 : 1;
                            b.reset();
                            c.animEvaluator.addClip(b)
                        }
                    }
                    c.playing = !0
                }
            }
        },
        getAnimation: function(a) {
            return this.data.animations[a]
        },
        setModel: function(a) {
            var b = this.data;
            a !== b.model && (this._resetAnimationController(), b.model = a, b.animations && b.currAnim && b.animations[b.currAnim] &&
                this.play(b.currAnim))
        },
        _resetAnimationController: function() {
            var a = this.data;
            a.skeleton = null;
            a.fromSkel = null;
            a.toSkel = null;
            a.animEvaluator = null
        },
        _createAnimationController: function() {
            var a = this.data,
                b = a.model,
                c = a.animations,
                d = !1,
                e = !1,
                f;
            for (f in c) c.hasOwnProperty(f) && (c[f].constructor === Md ? e = !0 : d = !0);
            b = b.getGraph();
            d ? (a.fromSkel = new Ta(b), a.toSkel = new Ta(b), a.skeleton = new Ta(b), a.skeleton.looping = a.loop, a.skeleton.setGraph(b)) : e && (a.animEvaluator = new Ja(new zf(b)))
        },
        loadAnimationAssets: function(a) {
            if (a &&
                a.length) {
                var b = this,
                    c = this.system.app.assets,
                    d, e = a.length,
                    f = function(h) {
                        if (1 < h.resources.length)
                            for (var l = 0; l < h.resources.length; l++) b.animations[h.resources[l].name] = h.resources[l], b.animationsIndex[h.id] = h.resources[l].name;
                        else b.animations[h.name] = h.resource, b.animationsIndex[h.id] = h.name;
                        b.animations = b.animations
                    },
                    g = function(h) {
                        h.off("change", b.onAssetChanged, b);
                        h.on("change", b.onAssetChanged, b);
                        h.off("remove", b.onAssetRemoved, b);
                        h.on("remove", b.onAssetRemoved, b);
                        h.resource ? f(h) : (h.once("load",
                            f, b), b.enabled && b.entity.enabled && c.load(h))
                    };
                for (d = 0; d < e; d++) {
                    var k = c.get(a[d]);
                    if (k) g(k);
                    else c.on("add:" + a[d], g)
                }
            }
        },
        onAssetChanged: function(a, b, c, d) {
            if ("resource" === b || "resources" === b)
                if ("resources" === b && c && 0 === c.length && (c = null), c) {
                    if (1 < c.length) {
                        if (d && 1 < d.length)
                            for (b = 0; b < d.length; b++) delete this.animations[d[b].name];
                        else delete this.animations[a.name];
                        d = !1;
                        for (b = 0; b < c.length; b++) this.animations[c[b].name] = c[b], !d && this.data.currAnim === c[b].name && this.data.playing && this.data.enabled && this.entity.enabled &&
                            (d = !0, this.play(c[b].name, 0))
                    } else {
                        if (d && 1 < d.length)
                            for (b = 0; b < d.length; b++) delete this.animations[d[b].name];
                        this.animations[a.name] = c[0] || c;
                        d = !1;
                        this.data.currAnim === a.name && this.data.playing && this.data.enabled && this.entity.enabled && (d = !0, this.play(a.name, 0))
                    }
                    d || (this._stopCurrentAnimation(), this.onSetAnimations());
                    this.animationsIndex[a.id] = a.name
                } else {
                    if (1 < d.length)
                        for (b = 0; b < d.length; b++) delete this.animations[d[b].name], this.data.currAnim === d[b].name && this._stopCurrentAnimation();
                    else delete this.animations[a.name],
                        this.data.currAnim === a.name && this._stopCurrentAnimation();
                    delete this.animationsIndex[a.id]
                }
        },
        onAssetRemoved: function(a) {
            a.off("remove", this.onAssetRemoved, this);
            if (this.animations) {
                if (1 < a.resources.length)
                    for (var b = 0; b < a.resources.length; b++) delete this.animations[a.resources[b].name], this.data.currAnim === a.resources[b].name && this._stopCurrentAnimation();
                else delete this.animations[a.name], this.data.currAnim === a.name && this._stopCurrentAnimation();
                delete this.animationsIndex[a.id]
            }
        },
        _stopCurrentAnimation: function() {
            var a =
                this.data;
            a.currAnim = null;
            a.playing = !1;
            a.skeleton && (a.skeleton.currentTime = 0, a.skeleton.animation = null);
            if (a.animEvaluator) {
                for (var b = 0; b < a.animEvaluator.clips.length; ++b) a.animEvaluator.clips[b].stop();
                a.animEvaluator.update(0);
                a.animEvaluator.removeClips()
            }
        },
        onSetAnimations: function(a, b, c) {
            a = this.data;
            (b = this.entity.model) && (b = b.model) && b !== a.model && this.setModel(b);
            if (!a.currAnim && a.activate && a.enabled && this.entity.enabled)
                for (var d in a.animations) {
                    this.play(d, 0);
                    break
                }
        },
        onSetAssets: function(a,
            b, c) {
            if (b && b.length)
                for (a = 0; a < b.length; a++)
                    if (b[a]) {
                        var d = this.system.app.assets.get(b[a]);
                        if (d) {
                            d.off("change", this.onAssetChanged, this);
                            d.off("remove", this.onAssetRemoved, this);
                            var e = this.animationsIndex[d.id];
                            this.data.currAnim === e && this._stopCurrentAnimation();
                            delete this.animations[e];
                            delete this.animationsIndex[d.id]
                        }
                    }
            b = c.map(function(f) {
                return f instanceof aa ? f.id : f
            });
            this.loadAnimationAssets(b)
        },
        onSetLoop: function(a, b, c) {
            a = this.data;
            a.skeleton && (a.skeleton.looping = a.loop);
            if (a.animEvaluator)
                for (b =
                    0; b < a.animEvaluator.clips.length; ++b) a.animEvaluator.clips[b].loop = a.loop
        },
        onSetCurrentTime: function(a, b, c) {
            a = this.data;
            a.skeleton && (b = a.skeleton, b.currentTime = c, b.addTime(0), b.updateGraph());
            if (a.animEvaluator)
                for (a = a.animEvaluator, b = 0; b < a.clips.length; ++b) a.clips[b].time = c
        },
        onEnable: function() {
            O.prototype.onEnable.call(this);
            var a = this.data,
                b = a.assets,
                c = this.system.app.assets;
            if (b)
                for (var d = 0, e = b.length; d < e; d++) {
                    var f = b[d];
                    f instanceof aa || (f = c.get(f));
                    f && !f.resource && c.load(f)
                }
            if (a.activate && !a.currAnim)
                for (var g in a.animations) {
                    this.play(g,
                        0);
                    break
                }
        },
        onBeforeRemove: function() {
            for (var a = 0; a < this.assets.length; a++) {
                var b = this.system.app.assets.get(this.assets[a]);
                b && (b.off("change", this.onAssetChanged, this), b.off("remove", this.onAssetRemoved, this))
            }
            a = this.data;
            delete a.animation;
            delete a.skeleton;
            delete a.fromSkel;
            delete a.toSkel;
            delete a.animEvaluator
        }
    });
    Object.defineProperties(id.prototype, {
        currentTime: {
            get: function() {
                var a = this.data;
                return a.skeleton ? this.data.skeleton._time : a.animEvaluator && (a = a.animEvaluator.clips, 0 < a.length) ? a[a.length -
                    1].time : 0
            },
            set: function(a) {
                var b = this.data;
                if (b.skeleton) {
                    var c = b.skeleton;
                    c.currentTime = a;
                    c.addTime(0);
                    c.updateGraph()
                }
                if (b.animEvaluator)
                    for (b = b.animEvaluator, c = 0; c < b.clips.length; ++c) b.clips[c].time = a
            }
        },
        duration: {
            get: function() {
                return this.data.animations[this.data.currAnim].duration
            }
        }
    });
    var ll = "enabled assets speed loop activate animations skeleton model prevAnim currAnim fromSkel toSkel blending blendTimeRemaining playing".split(" ");
    ye.prototype = Object.create(H.prototype);
    ye.prototype.constructor =
        ye;
    O._buildAccessors(id.prototype, ll);
    Object.assign(ye.prototype, {
        initializeComponentData: function(a, b, c) {
            c = ["activate", "enabled", "loop", "speed", "assets"];
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            var c;
            this.addComponent(b, {});
            b.animation.assets = a.animation.assets.slice();
            b.animation.data.speed = a.animation.speed;
            b.animation.data.loop = a.animation.loop;
            b.animation.data.activate = a.animation.activate;
            b.animation.data.enabled = a.animation.enabled;
            var d = {},
                e = a.animation.animations;
            for (c in e) e.hasOwnProperty(c) && (d[c] = e[c]);
            b.animation.animations = d;
            d = {};
            a = a.animation.animationsIndex;
            for (c in a) a.hasOwnProperty(c) && (d[c] = a[c]);
            b.animation.animationsIndex = d
        },
        onBeforeRemove: function(a, b) {
            b.onBeforeRemove()
        },
        onUpdate: function(a) {
            var b = this.store,
                c;
            for (c in b)
                if (b.hasOwnProperty(c)) {
                    var d = b[c],
                        e = d.data;
                    if (e.enabled && d.entity.enabled) {
                        e.blending && (e.blend += a * e.blendSpeed, 1 <= e.blend && (e.blend = 1));
                        e.playing && (d = e.skeleton, null !== d && null !== e.model && (e.blending ? d.blend(e.fromSkel, e.toSkel,
                            e.blend) : (d.addTime(a * e.speed), 0 < e.speed && d._time === d._animation.duration && !e.loop ? e.playing = !1 : 0 > e.speed && 0 === d._time && !e.loop && (e.playing = !1)), e.blending && 1 === e.blend && (d.animation = e.toSkel._animation), d.updateGraph()));
                        if (d = e.animEvaluator) {
                            for (var f = 0; f < d.clips.length; ++f) {
                                var g = d.clips[f];
                                g.speed = e.speed;
                                e.playing ? g.resume() : g.pause()
                            }
                            e.blending && (d.clips[1].blendWeight = e.blend);
                            d.update(a)
                        }
                        e.blending && 1 === e.blend && (e.blending = !1)
                    }
                }
        }
    });
    Ua.prototype = Object.create(zf.prototype);
    Ua.prototype.constructor =
        Ua;
    Ua._packFloat = function(a) {
        return a[0]
    };
    Ua._packBoolean = function(a) {
        return !!a[0]
    };
    Ua._packVec2 = function() {
        var a = new P;
        return function(b) {
            a.x = b[0];
            a.y = b[1];
            return a
        }
    }();
    Ua._packVec3 = function() {
        var a = new z;
        return function(b) {
            a.x = b[0];
            a.y = b[1];
            a.z = b[2];
            return a
        }
    }();
    Ua._packVec4 = function() {
        var a = new X;
        return function(b) {
            a.x = b[0];
            a.y = b[1];
            a.z = b[2];
            a.w = b[3];
            return a
        }
    }();
    Ua._packColor = function() {
        var a = new L;
        return function(b) {
            a.r = b[0];
            a.g = b[1];
            a.b = b[2];
            a.a = b[3];
            return a
        }
    }();
    Ua._packQuat = function() {
        var a =
            new Y;
        return function(b) {
            a.x = b[0];
            a.y = b[1];
            a.z = b[2];
            a.w = b[3];
            return a
        }
    }();
    Object.assign(Ua.prototype, {
        resolve: function(a) {
            var b = this.propertyLocator.decode(a);
            a = b[0];
            var c = b[1];
            b = b[2];
            var d = this._getEntityFromHierarchy(a);
            if (!d) return null;
            switch (c) {
                case "entity":
                    a = d;
                    break;
                case "graph":
                    if (!this.nodes || !this.nodes[a[0]]) return null;
                    a = this.nodes[a[0]].node;
                    break;
                default:
                    if (a = d.findComponent(c), !a) return null
            }
            return this._createAnimTargetForProperty(a, b)
        },
        update: function(a) {
            if (a = this.activeNodes)
                for (var b =
                        0; b < a.length; b++) a[b]._dirtifyLocal()
        },
        _getEntityFromHierarchy: function(a) {
            if (!this.animComponent.entity.name === a[0]) return null;
            var b = this.animComponent.entity;
            return 1 === a.length ? b : b._parent.findByPath(a.join("/"))
        },
        _resolvePath: function(a, b, c) {
            c = b.length - (c ? 0 : 1);
            for (var d = 0; d < c; d++) a = a[b[d]];
            return a
        },
        _setter: function(a, b, c) {
            var d = this._resolvePath(a, b),
                e = b[b.length - 1],
                f = "set" + e.substring(0, 1).toUpperCase() + e.substring(1);
            if (d[f]) {
                var g = d[f].bind(d);
                return function(n) {
                    g(c(n))
                }
            }
            var k = d[e];
            if ("object" ===
                typeof k && k.hasOwnProperty("copy")) return function(n) {
                k.copy(c(n))
            };
            if (-1 !== [P, z, X, L, Y].indexOf(d.constructor) && 1 < b.length) {
                var h = 2 < b.length ? this._resolvePath(a, b.slice(0, -1)) : a,
                    l = b[b.length - 2];
                return function(n) {
                    d[e] = c(n);
                    h[l] = d
                }
            }
            return function(n) {
                d[e] = c(n)
            }
        },
        _createAnimTargetForProperty: function(a, b) {
            if (this.handlers && "weights" === b[0]) return this.handlers.weights(a);
            if (this.handlers && "material" === b[0] && 2 === b.length) {
                var c = b[1];
                if (c.indexOf("Map") === c.length - 3) return this.handlers.materialTexture(a,
                    c)
            }
            c = this._resolvePath(a, b, !0);
            if ("undefined" === typeof c) return null;
            if ("number" === typeof c) {
                var d = this._setter(a, b, Ua._packFloat);
                var e = "vector";
                var f = 1
            } else if ("boolean" === typeof c) d = this._setter(a, b, Ua._packBoolean), e = "vector", f = 1;
            else if ("object" === typeof c) switch (c.constructor) {
                case P:
                    d = this._setter(a, b, Ua._packVec2);
                    e = "vector";
                    f = 2;
                    break;
                case z:
                    d = this._setter(a, b, Ua._packVec3);
                    e = "vector";
                    f = 3;
                    break;
                case X:
                    d = this._setter(a, b, Ua._packVec4);
                    e = "vector";
                    f = 4;
                    break;
                case L:
                    d = this._setter(a, b, Ua._packColor);
                    e = "vector";
                    f = 4;
                    break;
                case Y:
                    d = this._setter(a, b, Ua._packQuat);
                    e = "quaternion";
                    f = 4;
                    break;
                default:
                    return null
            }
            return -1 !== b.indexOf("material") ? new Jc(function(g) {
                d(g);
                a.material.update()
            }, e, f) : new Jc(d, e, f)
        }
    });
    Object.assign(Ug.prototype, {
        play: function(a) {
            this._controller.play(a)
        },
        pause: function() {
            this._controller.pause()
        },
        reset: function() {
            this._controller.reset()
        },
        update: function(a) {
            this._controller.update(a)
        },
        assignAnimation: function(a, b) {
            b.constructor === Md && (this._controller.assignAnimation(a, b), this._component.activate &&
                this._component.playable && (this._component.playing = !0))
        },
        removeNodeAnimations: function(a) {
            this._controller.removeNodeAnimations(a);
            this._component.playing = !1
        }
    });
    Object.defineProperties(Ug.prototype, {
        name: {
            get: function() {
                return this._name
            }
        },
        playing: {
            get: function() {
                return this._controller.playing
            },
            set: function(a) {
                this._controller.playing = a
            }
        },
        playable: {
            get: function() {
                return this._controller.playable
            }
        },
        activeState: {
            get: function() {
                return this._controller.activeStateName
            }
        },
        previousState: {
            get: function() {
                return this._controller.previousStateName
            }
        },
        activeStateProgress: {
            get: function() {
                return this._controller.activeStateProgress
            }
        },
        activeStateDuration: {
            get: function() {
                return this._controller.activeStateDuration
            }
        },
        activeStateCurrentTime: {
            get: function() {
                return this._controller.activeStateCurrentTime
            },
            set: function(a) {
                this._controller.activeStateCurrentTime = a
            }
        },
        transitioning: {
            get: function() {
                return this._controller.transitioning
            }
        },
        transitionProgress: {
            get: function() {
                return this.transitioning ? this._controller.transitionProgress : null
            }
        },
        states: {
            get: function() {
                return this._controller.states
            }
        }
    });
    Object.defineProperties(Jf.prototype, {
        parent: {
            get: function() {
                return this._parent
            }
        },
        name: {
            get: function() {
                return this._name
            }
        },
        path: {
            get: function() {
                return this._parent ? this._parent.path + "." + this._name : this._name
            }
        },
        point: {
            get: function() {
                return this._point
            }
        },
        weight: {
            get: function() {
                return this._parent ? this._parent.weight * this._weight : this._weight
            },
            set: function(a) {
                this._weight = a
            }
        },
        normalizedWeight: {
            get: function() {
                var a = this._state.totalWeight;
                return 0 === a ? 0 : this.weight / a
            }
        },
        speed: {
            get: function() {
                return this._speed
            }
        },
        animTrack: {
            get: function() {
                return this._animTrack
            },
            set: function(a) {
                this._animTrack = a
            }
        }
    });
    yc.prototype = Object.create(Jf.prototype);
    yc.prototype.constructor = yc;
    Object.defineProperties(yc.prototype, {
        parent: {
            get: function() {
                return this._parent
            }
        },
        name: {
            get: function() {
                return this._name
            }
        },
        point: {
            get: function() {
                return this._point
            }
        },
        weight: {
            get: function() {
                this.calculateWeights();
                return this._parent ? this._parent.weight * this._weight : this._weight
            },
            set: function(a) {
                this._weight = a
            }
        },
        speed: {
            get: function() {
                return this._speed
            }
        }
    });
    Object.assign(yc.prototype, {
        getChild: function(a) {
            for (var b = 0; b < this._children.length; b++)
                if (this._children[b].name === a) return this._children[b]
        },
        calculateWeights: function() {
            var a, b;
            switch (this._type) {
                case "1D":
                    var c = this._findParameter(this._parameters[0]).value;
                    if (this._parameterValues && this._parameterValues[0] === c) break;
                    this._parameterValues = [c];
                    for (a = this._children[0].weight = 0; a < this._children.length - 1; a++) {
                        var d = this._children[a];
                        var e = this._children[a + 1];
                        if (go(c, d.point, e.point, !0)) {
                            var f = Math.abs(d.point -
                                e.point);
                            f = (f - Math.abs(d.point - c)) / f;
                            d.weight = f;
                            e.weight = 1 - f
                        } else e.weight = 0
                    }
                    break;
                case "2D_CARTESIAN":
                    a = this._parameters.map(function(l) {
                        return this._findParameter(l).value
                    }.bind(this));
                    if (this._parameterValues && this._parameterValues.equals(a)) break;
                    this._parameterValues = a;
                    d = new pc.Vec2(this._parameterValues);
                    for (a = b = 0; a < this._children.length; a++) {
                        e = this._children[a].point.clone();
                        f = Number.MAX_VALUE;
                        for (c = 0; c < this._children.length; c++)
                            if (a !== c) {
                                var g = this._children[c].point.clone();
                                var k = g.clone().sub(e);
                                g = d.clone().sub(e);
                                g = Vg(1 - g.clone().dot(k) / k.lengthSq(), 0, 1);
                                g < f && (f = g)
                            }
                        this._children[a].weight = f;
                        b += f
                    }
                    for (a = 0; a < this._children.length; a++) this._children[a].weight = this._children[a]._weight / b;
                    break;
                case "2D_DIRECTIONAL":
                    a = this._parameters.map(function(l) {
                        return this._findParameter(l).value
                    }.bind(this));
                    if (this._parameterValues && this._parameterValues.equals(a)) break;
                    this._parameterValues = a;
                    d = new pc.Vec2(this._parameterValues);
                    for (a = b = 0; a < this._children.length; a++) {
                        e = this._children[a].point.clone();
                        f = Number.MAX_VALUE;
                        for (c = 0; c < this._children.length; c++)
                            if (a !== c) {
                                g = this._children[c].point.clone();
                                var h = ml(e, d);
                                k = ml(e, g);
                                k = new pc.Vec2((g.length() - e.length()) / ((g.length() + e.length()) / 2), 2 * k);
                                g = new pc.Vec2((d.length() - e.length()) / ((g.length() + e.length()) / 2), 2 * h);
                                g = Vg(1 - Math.abs(g.clone().dot(k) / k.lengthSq()), 0, 1);
                                g < f && (f = g)
                            }
                        this._children[a].weight = f;
                        b += f
                    }
                    for (a = 0; a < this._children.length; a++) this._children[a].weight = this._children[a]._weight / b;
                    break;
                case "DIRECT":
                    if (a = this._parameters.map(function(l) {
                            return this._findParameter(l).value
                        }.bind(this)),
                        this._parameterValues !== a) {
                        this._parameterValues = a;
                        for (a = b = 0; a < this._children.length; a++) b += Vg(this._parameterValues[a], 0, Number.MAX_VALUE);
                        for (a = 0; a < this._children.length; a++) this._children[a].weight = Vg(this._parameterValues[a], 0, Number.MAX_VALUE) / b
                    }
            }
        },
        getNodeCount: function() {
            for (var a = 0, b = 0; b < this._children.length; b++) this._children[b].constructor === yc ? a += this._children[b].getNodeCount() : a++;
            return a
        }
    });
    Object.assign(mj.prototype, {
        _getNodeFromPath: function(a) {
            for (var b = this._blendTree, c = 1; c < a.length; c++) b =
                b.getChild(a[c]);
            return b
        },
        addAnimation: function(a, b) {
            var c = this._animationList.findIndex(function(d) {
                return d.path === a
            });
            0 <= c ? this._animationList[c].animTrack = b : (c = this._getNodeFromPath(a), c.animTrack = b, this._animationList.push(c))
        }
    });
    Object.defineProperties(mj.prototype, {
        name: {
            get: function() {
                return this._name
            }
        },
        animations: {
            get: function() {
                return this._animationList
            },
            set: function(a) {
                this._animationList = a
            }
        },
        speed: {
            get: function() {
                return this._speed
            }
        },
        loop: {
            get: function() {
                return this._loop
            }
        },
        nodeCount: {
            get: function() {
                return this._blendTree &&
                    this._blendTree.constructor === yc ? this._blendTree.getNodeCount() : 1
            }
        },
        playable: {
            get: function() {
                return "START" === this.name || "END" === this.name || "ANY" === this.name || this.animations.length === this.nodeCount
            }
        },
        looping: {
            get: function() {
                if (0 < this.animations.length) {
                    var a = this._controller.animEvaluator.findClip(this.name + "." + this.animations[0].animTrack.name);
                    if (a) return a.loop
                }
                return !1
            }
        },
        totalWeight: {
            get: function() {
                var a = 0,
                    b;
                for (b = 0; b < this.animations.length; b++) a += this.animations[b].weight;
                return a
            }
        },
        timelineDuration: {
            get: function() {
                var a =
                    0,
                    b;
                for (b = 0; b < this.animations.length; b++) {
                    var c = this.animations[b];
                    c.animTrack.duration > a && (a = c.animTrack.duration)
                }
                return a
            }
        }
    });
    Object.defineProperties(nj.prototype, {
        from: {
            get: function() {
                return this._from
            }
        },
        to: {
            get: function() {
                return this._to
            }
        },
        time: {
            get: function() {
                return this._time
            }
        },
        priority: {
            get: function() {
                return this._priority
            }
        },
        conditions: {
            get: function() {
                return this._conditions
            }
        },
        exitTime: {
            get: function() {
                return this._exitTime
            }
        },
        transitionOffset: {
            get: function() {
                return this._transitionOffset
            }
        },
        interruptionSource: {
            get: function() {
                return this._interruptionSource
            }
        },
        hasExitTime: {
            get: function() {
                return !!this.exitTime
            }
        },
        hasConditionsMet: {
            get: function() {
                var a = !0,
                    b;
                for (b = 0; b < this.conditions.length; b++) {
                    var c = this.conditions[b],
                        d = this._controller.findParameter(c.parameterName);
                    switch (c.predicate) {
                        case "GREATER_THAN":
                            a = a && d.value > c.value;
                            break;
                        case "LESS_THAN":
                            a = a && d.value < c.value;
                            break;
                        case "GREATER_THAN_EQUAL_TO":
                            a = a && d.value >= c.value;
                            break;
                        case "LESS_THAN_EQUAL_TO":
                            a = a && d.value <= c.value;
                            break;
                        case "EQUAL_TO":
                            a =
                                a && d.value === c.value;
                            break;
                        case "NOT_EQUAL_TO":
                            a = a && d.value !== c.value
                    }
                    if (!a) break
                }
                return a
            }
        }
    });
    Object.defineProperties(Wg.prototype, {
        animEvaluator: {
            get: function() {
                return this._animEvaluator
            }
        },
        activeState: {
            get: function() {
                return this._findState(this._activeStateName)
            },
            set: function(a) {
                this._activeStateName = a
            }
        },
        activeStateName: {
            get: function() {
                return this._activeStateName
            }
        },
        activeStateAnimations: {
            get: function() {
                return this.activeState.animations
            }
        },
        previousState: {
            get: function() {
                return this._findState(this._previousStateName)
            },
            set: function(a) {
                this._previousStateName = a
            }
        },
        previousStateName: {
            get: function() {
                return this._previousStateName
            }
        },
        playable: {
            get: function() {
                var a = !0,
                    b;
                for (b = 0; b < this._stateNames.length; b++) this._states[this._stateNames[b]].playable || (a = !1);
                return a
            }
        },
        playing: {
            get: function() {
                return this._playing
            },
            set: function(a) {
                this._playing = a
            }
        },
        activeStateProgress: {
            get: function() {
                return this._getActiveStateProgressForTime(this._timeInState)
            }
        },
        activeStateDuration: {
            get: function() {
                if ("START" === this.activeStateName || "END" ===
                    this.activeStateName) return 0;
                for (var a = 0, b = 0; b < this.activeStateAnimations.length; b++) {
                    var c = this._animEvaluator.findClip(this.activeStateAnimations[b].name);
                    a = Math.max(a, c.track.duration)
                }
                return a
            }
        },
        activeStateCurrentTime: {
            get: function() {
                return this._timeInState
            },
            set: function(a) {
                this._timeInState = this._timeInStateBefore = a;
                for (var b = 0; b < this.activeStateAnimations.length; b++) {
                    var c = this.animEvaluator.findClip(this.activeStateAnimations[b].name);
                    c && (c.time = a)
                }
            }
        },
        transitioning: {
            get: function() {
                return this._isTransitioning
            }
        },
        transitionProgress: {
            get: function() {
                return this._currTransitionTime / this._totalTransitionTime
            }
        },
        states: {
            get: function() {
                return this._stateNames
            }
        }
    });
    Object.assign(Wg.prototype, {
        _findState: function(a) {
            return this._states[a]
        },
        _getActiveStateProgressForTime: function(a) {
            if ("START" === this.activeStateName || "END" === this.activeStateName || "ANY" === this.activeStateName) return 1;
            var b = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
            return b ? a / b.track.duration : null
        },
        _findTransitionsFromState: function(a) {
            var b =
                this._findTransitionsFromStateCache[a];
            b || (b = this._transitions.filter(function(c) {
                return c.from === a
            }), b.sort(function(c, d) {
                return c.priority < d.priority
            }), this._findTransitionsFromStateCache[a] = b);
            return b
        },
        _findTransitionsBetweenStates: function(a, b) {
            var c = this._findTransitionsBetweenStatesCache[a + "->" + b];
            c || (c = this._transitions.filter(function(d) {
                return d.from === a && d.to === b
            }), c.sort(function(d, e) {
                return d.priority < e.priority
            }), this._findTransitionsBetweenStatesCache[a + "->" + b] = c);
            return c
        },
        _findTransition: function(a,
            b) {
            var c = [];
            if (a && b) c.concat(this._findTransitionsBetweenStates(a, b));
            else if (this._isTransitioning) switch (this._transitionInterruptionSource) {
                case "PREV_STATE":
                    c = c.concat(this._findTransitionsFromState(this._previousStateName));
                    c = c.concat(this._findTransitionsFromState("ANY"));
                    break;
                case "NEXT_STATE":
                    c = c.concat(this._findTransitionsFromState(this._activeStateName));
                    c = c.concat(this._findTransitionsFromState("ANY"));
                    break;
                case "PREV_STATE_NEXT_STATE":
                    c = c.concat(this._findTransitionsFromState(this._previousStateName));
                    c = c.concat(this._findTransitionsFromState(this._activeStateName));
                    c = c.concat(this._findTransitionsFromState("ANY"));
                    break;
                case "NEXT_STATE_PREV_STATE":
                    c = c.concat(this._findTransitionsFromState(this._activeStateName)), c = c.concat(this._findTransitionsFromState(this._previousStateName)), c = c.concat(this._findTransitionsFromState("ANY"))
            } else c = c.concat(this._findTransitionsFromState(this._activeStateName)), c = c.concat(this._findTransitionsFromState("ANY"));
            c = c.filter(function(d) {
                if (d.to === this.activeStateName) return !1;
                if (d.hasExitTime) {
                    var e = this._getActiveStateProgressForTime(this._timeInStateBefore),
                        f = this._getActiveStateProgressForTime(this._timeInState);
                    1 > d.exitTime && this.activeState.looping && (e -= Math.floor(e), f -= Math.floor(f));
                    if (!(d.exitTime > e && d.exitTime <= f)) return null
                }
                return d.hasConditionsMet
            }.bind(this));
            return 0 < c.length ? c[0] : null
        },
        _updateStateFromTransition: function(a) {
            var b, c;
            this.previousState = a.from;
            this.activeState = a.to;
            for (b = 0; b < a.conditions.length; b++) {
                var d = this.findParameter(a.conditions[b].parameterName);
                "TRIGGER" === d.type && (d.value = !1)
            }
            if (this.previousState) {
                this._isTransitioning || (this._transitionPreviousStates = []);
                this._transitionPreviousStates.push({
                    name: this._previousStateName,
                    weight: 1
                });
                var e = Math.min(this._currTransitionTime / this._totalTransitionTime, 1);
                for (b = 0; b < this._transitionPreviousStates.length; b++) {
                    this._transitionPreviousStates[b].weight = this._isTransitioning ? b !== this._transitionPreviousStates.length - 1 ? this._transitionPreviousStates[b].weight * (1 - e) : e : 1;
                    var f = this._findState(this._transitionPreviousStates[b].name);
                    for (c = 0; c < f.animations.length; c++) {
                        var g = f.animations[c];
                        d = this._animEvaluator.findClip(g.name + ".previous." + b);
                        d || (d = this._animEvaluator.findClip(g.name), d.name = g.name + ".previous." + b);
                        b !== this._transitionPreviousStates.length - 1 && d.pause()
                    }
                }
            }
            0 < a.time && (this._isTransitioning = !0, this._totalTransitionTime = a.time, this._currTransitionTime = 0, this._transitionInterruptionSource = a.interruptionSource);
            c = a.transitionOffset && 0 < a.transitionOffset && 1 > a.transitionOffset;
            f = this.activeState;
            for (b = 0; b < f.animations.length; b++)(d =
                this._animEvaluator.findClip(f.animations[b].name)) ? d.reset() : (d = Number.isFinite(f.animations[b].speed) ? f.animations[b].speed : f.speed, d = new yf(f.animations[b].animTrack, 0, d, !0, f.loop), d.name = f.animations[b].name, this._animEvaluator.addClip(d)), d.blendWeight = 0 < a.time ? 0 : f.animations[b].normalizedWeight, d.play(), d.time = c ? f.timelineDuration * a.transitionOffset : 0 <= f.speed ? 0 : this.activeStateDuration;
            d = b = 0;
            c && (d = b = a = f.timelineDuration * a.transitionOffset);
            this._timeInState = b;
            this._timeInStateBefore = d
        },
        _transitionToState: function(a) {
            if (a !==
                this._activeStateName && this._findState(a)) {
                var b = this._findTransition(this._activeStateName, a);
                b || (this._animEvaluator.removeClips(), b = new nj(this, null, a, 0, 0));
                this._updateStateFromTransition(b)
            }
        },
        assignAnimation: function(a, b) {
            a = a.split(".");
            var c = this._findState(a[0]);
            c && (c.addAnimation(a, b), !this._playing && this._activate && this.playable && this.play())
        },
        removeNodeAnimations: function(a) {
            if (a = this._findState(a)) a.animations = []
        },
        play: function(a) {
            a && this._transitionToState(a);
            this._playing = !0
        },
        pause: function() {
            this._playing = !1
        },
        reset: function() {
            this._previousStateName = null;
            this._activeStateName = "START";
            this._playing = !1;
            this._totalTransitionTime = this._currTransitionTime = 1;
            this._isTransitioning = !1;
            this._timeInStateBefore = this._timeInState = 0;
            this._animEvaluator.removeClips()
        },
        update: function(a) {
            if (this._playing) {
                var b, c, d;
                this._timeInStateBefore = this._timeInState;
                this._timeInState += a;
                (b = this._findTransition(this._activeStateName)) && this._updateStateFromTransition(b);
                if (this._isTransitioning)
                    if (this._currTransitionTime +=
                        a, this._currTransitionTime <= this._totalTransitionTime) {
                        var e = this._currTransitionTime / this._totalTransitionTime;
                        for (b = 0; b < this._transitionPreviousStates.length; b++) {
                            var f = this._findState(this._transitionPreviousStates[b].name);
                            var g = this._transitionPreviousStates[b].weight;
                            for (c = 0; c < f.animations.length; c++) {
                                var k = f.animations[c];
                                if (d = this._animEvaluator.findClip(k.name + ".previous." + b)) d.blendWeight = (1 - e) * k.normalizedWeight * g
                            }
                        }
                        f = this.activeState;
                        for (b = 0; b < f.animations.length; b++) k = f.animations[b],
                            this._animEvaluator.findClip(k.name).blendWeight = e * k.normalizedWeight
                    } else {
                        this._isTransitioning = !1;
                        c = this.activeStateAnimations.length;
                        f = this._animEvaluator.clips.length;
                        for (b = 0; b < f - c; b++) this._animEvaluator.removeClip(0);
                        this._transitionPreviousStates = [];
                        f = this.activeState;
                        for (b = 0; b < f.animations.length; b++)
                            if (k = f.animations[b], d = this._animEvaluator.findClip(k.name)) d.blendWeight = k.normalizedWeight
                    }
                else if (this.activeState._blendTree.constructor === yc)
                    for (f = this.activeState, b = 0; b < f.animations.length; b++)
                        if (k =
                            f.animations[b], d = this._animEvaluator.findClip(k.name)) d.blendWeight = k.normalizedWeight;
                this._animEvaluator.update(a)
            }
        },
        findParameter: function(a) {
            return this._parameters[a]
        }
    });
    jd.prototype = Object.create(O.prototype);
    jd.prototype.constructor = jd;
    Object.assign(jd.prototype, {
        loadStateGraph: function(a) {
            function b(g, k, h, l) {
                var n = new Ua(this, d);
                n = new Ja(n);
                k = new Wg(n, k, h, c.parameters, c.activate);
                c.layers.push(new Ug(g, k, this));
                c.layerIndices[g] = l
            }
            var c = this.data;
            c.stateGraph = a;
            c.parameters = a.parameters;
            c.layers = [];
            var d, e = this.entity.model;
            e && (e = e.model) && (d = e.getGraph());
            for (e = 0; e < a.layers.length; e++) {
                var f = a.layers[e];
                b.bind(this)(f.name, f.states, f.transitions, e)
            }
            this.setupAnimationAssets()
        },
        setupAnimationAssets: function() {
            for (var a = 0; a < this.data.layers.length; a++)
                for (var b = this.data.layers[a], c = b.name, d = 0; d < b.states.length; d++) {
                    var e = b.states[d];
                    "START" !== e && "END" !== e && "ANY" !== e && (e = c + ":" + e, this.data.animationAssets[e] || (this.data.animationAssets[e] = {
                        asset: null
                    }))
                }
            this.loadAnimationAssets()
        },
        loadAnimationAssets: function() {
            for (var a = 0; a < this.data.layers.length; a++)
                for (var b = this.data.layers[a], c = 0; c < b.states.length; c++) {
                    var d = b.states[c],
                        e = this.data.animationAssets[b.name + ":" + d];
                    e && e.asset ? (e = this.system.app.assets.get(e.asset), e.resource ? this.assignAnimation(d, e.resource, b.name) : (e.once("load", function(f, g) {
                        return function(k) {
                            this.assignAnimation(g, k.resource, f)
                        }.bind(this)
                    }.call(this, b.name, d)), this.system.app.assets.load(e))) : this.removeNodeAnimations(d, b.name)
                }
        },
        removeStateGraph: function() {
            this.data.stateGraph =
                null;
            this.data.stateGraphAsset = null;
            this.data.animationAssets = {};
            this.data.layers = [];
            this.data.layerIndices = {};
            this.data.parameters = {};
            this.data.playing = !1
        },
        resetStateGraph: function() {
            if (this.stateGraphAsset) {
                var a = this.system.app.assets.get(this.stateGraphAsset).resource;
                this.loadStateGraph(a)
            } else this.removeStateGraph()
        },
        reset: function() {
            this.data.parameters = Object.assign({}, this.data.stateGraph.parameters);
            for (var a = 0; a < this.data.layers.length; a++) {
                var b = this.data.layers[a].playing;
                this.data.layers[a].reset();
                this.data.layers[a].playing = b
            }
        },
        findAnimationLayer: function(a) {
            return this.data.layers[this.data.layerIndices[a]] || null
        },
        assignAnimation: function(a, b, c) {
            this.data.stateGraph && (c = c ? this.findAnimationLayer(c) : this.baseLayer) && c.assignAnimation(a, b)
        },
        removeNodeAnimations: function(a, b) {
            (b = b ? this.findAnimationLayer(b) : this.baseLayer) && b.removeNodeAnimations(a)
        },
        getParameterValue: function(a, b) {
            if ((a = this.data.parameters[a]) && a.type === b) return a.value
        },
        setParameterValue: function(a, b, c) {
            (a = this.data.parameters[a]) &&
            a.type === b && (a.value = c)
        },
        getFloat: function(a) {
            return this.getParameterValue(a, "FLOAT")
        },
        setFloat: function(a, b) {
            this.setParameterValue(a, "FLOAT", b)
        },
        getInteger: function(a) {
            return this.getParameterValue(a, "INTEGER")
        },
        setInteger: function(a, b) {
            "number" === typeof b && 0 === b % 1 && this.setParameterValue(a, "INTEGER", b)
        },
        getBoolean: function(a) {
            return this.getParameterValue(a, "BOOLEAN")
        },
        setBoolean: function(a, b) {
            this.setParameterValue(a, "BOOLEAN", !!b)
        },
        getTrigger: function(a) {
            return this.getParameterValue(a, "TRIGGER")
        },
        setTrigger: function(a) {
            this.setParameterValue(a, "TRIGGER", !0)
        },
        resetTrigger: function(a) {
            this.setParameterValue(a, "TRIGGER", !1)
        }
    });
    Object.defineProperties(jd.prototype, {
        stateGraphAsset: {
            get: function() {
                return this.data.stateGraphAsset
            },
            set: function(a) {
                if (null === a) this.removeStateGraph();
                else {
                    if (a instanceof aa) {
                        var b = a.id;
                        var c = this.system.app.assets.get(b);
                        c || (this.system.app.assets.add(a), c = this.system.app.assets.get(b))
                    } else b = a, c = this.system.app.assets.get(b);
                    c && this.data.stateGraphAsset !== b && (c.resource ?
                        (this.data.stateGraph = c.resource, this.loadStateGraph(this.data.stateGraph), c.on("change", function(d) {
                            this.data.stateGraph = new Af(d._data);
                            this.loadStateGraph(this.data.stateGraph)
                        }.bind(this))) : (c.once("load", function(d) {
                            this.data.stateGraph = d.resource;
                            this.loadStateGraph(this.data.stateGraph)
                        }.bind(this)), c.on("change", function(d) {
                            this.data.stateGraph = new Af(d._data);
                            this.loadStateGraph(this.data.stateGraph)
                        }.bind(this)), this.system.app.assets.load(c)), this.data.stateGraphAsset = b)
                }
            }
        },
        animationAssets: {
            get: function() {
                return this.data.animationAssets
            },
            set: function(a) {
                this.data.animationAssets = a;
                this.loadAnimationAssets()
            }
        },
        playable: {
            get: function() {
                for (var a = 0; a < this.data.layers.length; a++)
                    if (!this.data.layers[a].playable) return !1;
                return !0
            }
        },
        baseLayer: {
            get: function() {
                return 0 < this.data.layers.length ? this.data.layers[0] : null
            }
        }
    });
    var nl = ["enabled", "speed", "activate", "playing"];
    ze.prototype = Object.create(H.prototype);
    ze.prototype.constructor = ze;
    O._buildAccessors(jd.prototype, nl);
    Object.assign(ze.prototype, {
        initializeComponentData: function(a, b, c) {
            c = ["activate", "enabled", "speed", "playing"];
            H.prototype.initializeComponentData.call(this, a, b, c);
            b.stateGraphAsset && (a.stateGraphAsset = b.stateGraphAsset);
            b.animationAssets && (a.animationAssets = Object.assign(a.data.animationAssets, b.animationAssets))
        },
        onAnimationUpdate: function(a) {
            var b = this.store,
                c;
            for (c in b)
                if (b.hasOwnProperty(c)) {
                    var d = b[c],
                        e = d.data;
                    if (e.enabled && d.entity.enabled && e.playing)
                        for (d = 0; d < e.layers.length; d++) e.layers[d].update(a * e.speed)
                }
        }
    });
    Qd.prototype = Object.create(O.prototype);
    Qd.prototype.constructor =
        Qd;
    Object.assign(Qd.prototype, {
        setCurrentListener: function() {
            if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
                this.system.current = this.entity;
                var a = this.system.current.getPosition();
                this.system.manager.listener.setPosition(a)
            }
        },
        onEnable: function() {
            this.setCurrentListener()
        },
        onDisable: function() {
            this.system.current === this.entity && (this.system.current = null)
        }
    });
    var ol = ["enabled"];
    Ae.prototype = Object.create(H.prototype);
    Ae.prototype.constructor = Ae;
    O._buildAccessors(Qd.prototype, ol);
    Object.assign(Ae.prototype, {
        initializeComponentData: function(a, b, c) {
            c = ["enabled"];
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        onUpdate: function(a) {
            this.current && (a = this.current.getPosition(), this.manager.listener.setPosition(a), a = this.current.getWorldTransform(), this.manager.listener.setOrientation(a))
        }
    });
    Rd.prototype = Object.create(O.prototype);
    Rd.prototype.constructor = Rd;
    Object.assign(Rd.prototype, {
        play: function(a) {
            if (this.enabled && this.entity.enabled) {
                this.channel && this.stop();
                var b = this.data;
                if (b.sources[a]) {
                    if (b["3d"]) {
                        var c =
                            this.entity.getPosition();
                        c = this.system.manager.playSound3d(b.sources[a], c, b)
                    } else c = this.system.manager.playSound(b.sources[a], b);
                    b.currentSource = a;
                    b.channel = c
                }
            }
        },
        pause: function() {
            this.channel && this.channel.pause()
        },
        unpause: function() {
            this.channel && this.channel.paused && this.channel.unpause()
        },
        stop: function() {
            this.channel && (this.channel.stop(), this.channel = null)
        },
        onSetAssets: function(a, b, c) {
            a = [];
            var d, e = c.length;
            if (b && b.length)
                for (d = 0; d < b.length; d++)
                    if (b[d]) {
                        var f = this.system.app.assets.get(b[d]);
                        f && (f.off("change", this.onAssetChanged, this), f.off("remove", this.onAssetRemoved, this), this.currentSource === f.name && this.stop())
                    }
            if (e)
                for (d = 0; d < e; d++) 0 > b.indexOf(c[d]) && (c[d] instanceof aa ? a.push(c[d].id) : a.push(c[d]));
            !this.system._inTools && a.length && this.loadAudioSourceAssets(a)
        },
        onAssetChanged: function(a, b, c, d) {
            "resource" === b && this.data.sources && (this.data.sources[a.name] = c, this.data.currentSource === a.name && this.channel && (this.channel.paused ? (this.play(a.name), this.pause()) : this.play(a.name)))
        },
        onAssetRemoved: function(a) {
            a.off("remove", this.onAssetRemoved, this);
            this.data.sources[a.name] && (delete this.data.sources[a.name], this.data.currentSource === a.name && (this.stop(), this.data.currentSource = null))
        },
        onSetLoop: function(a, b, c) {
            b != c && this.channel && this.channel.setLoop(c)
        },
        onSetVolume: function(a, b, c) {
            b != c && this.channel && this.channel.setVolume(c)
        },
        onSetPitch: function(a, b, c) {
            b != c && this.channel && this.channel.setPitch(c)
        },
        onSetMaxDistance: function(a, b, c) {
            b != c && this.channel instanceof $a && this.channel.setMaxDistance(c)
        },
        onSetMinDistance: function(a, b, c) {
            b != c && this.channel instanceof $a && this.channel.setMinDistance(c)
        },
        onSetRollOffFactor: function(a, b, c) {
            b != c && this.channel instanceof $a && this.channel.setRollOffFactor(c)
        },
        onSetDistanceModel: function(a, b, c) {
            b !== c && this.channel instanceof $a && this.channel.setDistanceModel(c)
        },
        onSet3d: function(a, b, c) {
            b !== c && this.system.initialized && this.currentSource && (b = a = !1, this.channel && (a = this.channel.paused, b = this.channel.suspended), this.play(this.currentSource), this.channel && (this.channel.paused =
                a, this.channel.suspended = b))
        },
        onEnable: function() {
            var a = this.data.assets;
            if (a)
                for (var b = this.system.app.assets, c = 0, d = a.length; c < d; c++) {
                    var e = a[c];
                    e instanceof aa || (e = b.get(e));
                    e && !e.resource && b.load(e)
                }
            this.system.initialized && (this.data.activate && !this.channel ? this.play(this.currentSource) : this.unpause())
        },
        onDisable: function() {
            this.pause()
        },
        loadAudioSourceAssets: function(a) {
            var b = this,
                c = a.map(function(h) {
                    return this.system.app.assets.get(h)
                }, this),
                d = {},
                e = null,
                f = c.length,
                g = function(h) {
                    f--
                },
                k = function() {
                    this.data.sources =
                        d;
                    this.data.currentSource = e;
                    if (this.enabled && this.activate && e) this.onEnable()
                }.bind(this);
            c.forEach(function(h, l) {
                h ? (e = e || h.name, h.off("change", this.onAssetChanged, this), h.on("change", this.onAssetChanged, this), h.off("remove", this.onAssetRemoved, this), h.on("remove", this.onAssetRemoved, this), h.off("error", g, this), h.on("error", g, this), h.ready(function(n) {
                    d[n.name] = n.resource;
                    f--;
                    0 === f && k()
                }), !h.resource && b.enabled && b.entity.enabled && this.system.app.assets.load(h)) : (f--, 0 === f && k(), this.system.app.assets.on("add:" +
                    a[l],
                    function(n) {
                        n.ready(function(p) {
                            b.data.sources[p.name] = p.resource
                        });
                        n.resource || b.system.app.assets.load(n)
                    }))
            }, this)
        }
    });
    var pl = "enabled assets volume pitch loop activate 3d minDistance maxDistance rollOffFactor distanceModel sources currentSource channel".split(" ");
    Be.prototype = Object.create(H.prototype);
    Be.prototype.constructor = Be;
    O._buildAccessors(Rd.prototype, pl);
    Object.assign(Be.prototype, {
        initializeComponentData: function(a, b, c) {
            c = "activate volume pitch loop 3d minDistance maxDistance rollOffFactor distanceModel enabled assets".split(" ");
            H.prototype.initializeComponentData.call(this, a, b, c);
            a.paused = !(a.enabled && a.activate)
        },
        onInitialize: function(a) {
            a.audiosource && a.enabled && a.audiosource.enabled && a.audiosource.activate && a.audiosource.play(a.audiosource.currentSource);
            a = a._children;
            var b, c = a.length;
            for (b = 0; b < c; b++)
                if (a[b] instanceof fa) this.onInitialize(a[b]);
            this.initialized = !0
        },
        onUpdate: function(a) {
            a = this.store;
            for (var b in a)
                if (a.hasOwnProperty(b)) {
                    var c = a[b],
                        d = c.entity;
                    c = c.data;
                    c.enabled && d.enabled && c.channel instanceof $a && (d =
                        d.getPosition(), c.channel.setPosition(d))
                }
        },
        onRemove: function(a, b) {
            b.channel && (b.channel.stop(), b.channel = null)
        },
        setVolume: function(a) {
            this.manager.setVolume(a)
        }
    });
    Object.assign(Lc.prototype, {
        _configureEventListeners: function(a, b) {
            a = this._parseEventListenerConfig(a, "external", this._parentComponent);
            b = this._parseEventListenerConfig(b, "internal", this);
            this._eventListenerConfigs = a.concat(b);
            this._listenerStatusFlags = {};
            this._gainListeners = {};
            this._loseListeners = {}
        },
        _parseEventListenerConfig: function(a,
            b, c) {
            return Object.keys(a).map(function(d, e) {
                var f = d.split("#"),
                    g = f[0],
                    k = f[1],
                    h = a[d];
                if (2 !== f.length || "string" !== typeof g || 0 === g.length || "string" !== typeof k || 0 === k.length) throw Error("Invalid event listener description: `" + d + "`");
                if ("function" !== typeof h) throw Error("Invalid or missing callback for event listener `" + d + "`");
                return {
                    id: b + "_" + e + "_" + d,
                    sourceName: g,
                    eventName: k,
                    callback: h,
                    scope: c
                }
            }, this)
        },
        _toggleLifecycleListeners: function(a) {
            this._parentComponent[a]("set_" + this._entityPropertyName, this._onSetEntity,
                this);
            this._parentComponent.system[a]("beforeremove", this._onParentComponentRemove, this);
            H[a]("postinitialize", this._onPostInitialize, this);
            this._app[a]("tools:sceneloaded", this._onSceneLoaded, this);
            for (var b = [], c = 0; c < this._eventListenerConfigs.length; ++c) {
                var d = this._eventListenerConfigs[c],
                    e = this._app.systems[d.sourceName];
                e && (-1 === b.indexOf(e) && b.push(e), e && "gain" === d.eventName && (this._gainListeners[d.sourceName] = d), e && "lose" === d.eventName && (this._loseListeners[d.sourceName] = d))
            }
            for (c = 0; c < b.length; ++c) b[c][a]("add",
                this._onComponentAdd, this), b[c][a]("beforeremove", this._onComponentRemove, this)
        },
        _onSetEntity: function(a, b, c) {
            c instanceof fa ? this._updateEntityReference() : null !== c && void 0 !== c && "string" !== typeof c ? console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof c + "'") : b !== c && this._updateEntityReference()
        },
        _onPostInitialize: function() {
            this._updateEntityReference()
        },
        onParentComponentEnable: function() {
            this._entity || this._updateEntityReference()
        },
        _onSceneLoaded: function() {
            this._updateEntityReference()
        },
        _updateEntityReference: function() {
            var a = this._parentComponent.data[this._entityPropertyName];
            if (a instanceof fa) {
                var b = a;
                a = b.getGuid();
                this._parentComponent.data[this._entityPropertyName] = a
            } else b = this._parentComponent.system.app.root, b = this._parentComponent.entity.isDescendantOf(b) && a ? b.findByGuid(a) : null;
            this._entity !== b && (this._entity && this._onBeforeEntityChange(), (this._entity = b) && this._onAfterEntityChange())
        },
        _onBeforeEntityChange: function() {
            this._toggleEntityListeners("off");
            this._callAllGainOrLoseListeners(this._loseListeners)
        },
        _onAfterEntityChange: function() {
            this._toggleEntityListeners("on");
            this._callAllGainOrLoseListeners(this._gainListeners)
        },
        _onComponentAdd: function(a, b) {
            b = b.system.id;
            a === this._entity && (this._callGainOrLoseListener(b, this._gainListeners), this._toggleComponentListeners("on", b))
        },
        _onComponentRemove: function(a, b) {
            b = b.system.id;
            a === this._entity && (this._callGainOrLoseListener(b, this._loseListeners), this._toggleComponentListeners("off", b, !0))
        },
        _callAllGainOrLoseListeners: function(a) {
            for (var b in this._entity.c) this._callGainOrLoseListener(b,
                a)
        },
        _callGainOrLoseListener: function(a, b) {
            this._entity.c.hasOwnProperty(a) && b[a] && (a = b[a], a.callback.call(a.scope))
        },
        _toggleEntityListeners: function(a, b) {
            if (this._entity)
                for (var c = 0; c < this._eventListenerConfigs.length; ++c) this._safeToggleListener(a, this._eventListenerConfigs[c], b)
        },
        _toggleComponentListeners: function(a, b, c) {
            for (var d = 0; d < this._eventListenerConfigs.length; ++d) {
                var e = this._eventListenerConfigs[d];
                e.sourceName === b && this._safeToggleListener(a, e, c)
            }
        },
        _safeToggleListener: function(a, b, c) {
            var d =
                "on" === a;
            if (!d || !this._listenerStatusFlags[b.id])
                if (c = this._getEventSource(b.sourceName, c)) c[a](b.eventName, b.callback, b.scope), this._listenerStatusFlags[b.id] = d
        },
        _getEventSource: function(a, b) {
            if ("entity" === a) return this._entity;
            var c = this._entity[a];
            if (c) return c;
            b || console.warn("Entity has no component with name " + a);
            return null
        },
        _onEntityDestroy: function(a) {
            this._entity === a && (this._toggleEntityListeners("off", !0), this._entity = null)
        },
        _onParentComponentRemove: function(a, b) {
            b === this._parentComponent &&
                (this._toggleLifecycleListeners("off"), this._toggleEntityListeners("off", !0))
        },
        hasComponent: function(a) {
            return this._entity && this._entity.c ? !!this._entity.c[a] : !1
        }
    });
    Object.defineProperty(Lc.prototype, "entity", {
        get: function() {
            return this._entity
        }
    });
    var Xg = 0,
        Ma = {
            DEFAULT: "DEFAULT",
            HOVER: "HOVER",
            PRESSED: "PRESSED",
            INACTIVE: "INACTIVE"
        },
        eg = {};
    eg[Ma.DEFAULT] = "_defaultTint";
    eg[Ma.HOVER] = "hoverTint";
    eg[Ma.PRESSED] = "pressedTint";
    eg[Ma.INACTIVE] = "inactiveTint";
    var fg = {};
    fg[Ma.DEFAULT] = "_defaultSpriteAsset";
    fg[Ma.HOVER] = "hoverSpriteAsset";
    fg[Ma.PRESSED] = "pressedSpriteAsset";
    fg[Ma.INACTIVE] = "inactiveSpriteAsset";
    var gg = {};
    gg[Ma.DEFAULT] = "_defaultSpriteFrame";
    gg[Ma.HOVER] = "hoverSpriteFrame";
    gg[Ma.PRESSED] = "pressedSpriteFrame";
    gg[Ma.INACTIVE] = "inactiveSpriteFrame";
    Sd.prototype = Object.create(O.prototype);
    Sd.prototype.constructor = Sd;
    Object.assign(Sd.prototype, {
        _toggleLifecycleListeners: function(a, b) {
            this[a]("set_active", this._onSetActive, this);
            this[a]("set_transitionMode", this._onSetTransitionMode, this);
            this[a]("set_hoverTint", this._onSetTransitionValue, this);
            this[a]("set_pressedTint", this._onSetTransitionValue, this);
            this[a]("set_inactiveTint", this._onSetTransitionValue, this);
            this[a]("set_hoverSpriteAsset", this._onSetTransitionValue, this);
            this[a]("set_hoverSpriteFrame", this._onSetTransitionValue, this);
            this[a]("set_pressedSpriteAsset", this._onSetTransitionValue, this);
            this[a]("set_pressedSpriteFrame", this._onSetTransitionValue, this);
            this[a]("set_inactiveSpriteAsset", this._onSetTransitionValue, this);
            this[a]("set_inactiveSpriteFrame", this._onSetTransitionValue, this);
            b.app.systems.element[a]("add", this._onElementComponentAdd, this);
            b.app.systems.element[a]("beforeremove", this._onElementComponentRemove, this)
        },
        _onSetActive: function(a, b, c) {
            b !== c && this._updateVisualState()
        },
        _onSetTransitionMode: function(a, b, c) {
            b !== c && (this._cancelTween(), this._resetToDefaultVisualState(b), this._forceReapplyVisualState())
        },
        _onSetTransitionValue: function(a, b, c) {
            b !== c && this._forceReapplyVisualState()
        },
        _onElementComponentRemove: function(a) {
            this.entity ===
                a && this._toggleHitElementListeners("off")
        },
        _onElementComponentAdd: function(a) {
            this.entity === a && this._toggleHitElementListeners("on")
        },
        _onImageElementLose: function() {
            this._cancelTween();
            this._resetToDefaultVisualState(this.transitionMode)
        },
        _onImageElementGain: function() {
            this._storeDefaultVisualState();
            this._forceReapplyVisualState()
        },
        _toggleHitElementListeners: function(a) {
            if (this.entity.element) {
                var b = "on" === a;
                b && this._hasHitElementListeners || (this.entity.element[a]("mouseenter", this._onMouseEnter,
                    this), this.entity.element[a]("mouseleave", this._onMouseLeave, this), this.entity.element[a]("mousedown", this._onMouseDown, this), this.entity.element[a]("mouseup", this._onMouseUp, this), this.entity.element[a]("touchstart", this._onTouchStart, this), this.entity.element[a]("touchend", this._onTouchEnd, this), this.entity.element[a]("touchleave", this._onTouchLeave, this), this.entity.element[a]("touchcancel", this._onTouchCancel, this), this.entity.element[a]("selectstart", this._onSelectStart, this), this.entity.element[a]("selectend",
                    this._onSelectEnd, this), this.entity.element[a]("selectenter", this._onSelectEnter, this), this.entity.element[a]("selectleave", this._onSelectLeave, this), this.entity.element[a]("click", this._onClick, this), this._hasHitElementListeners = b)
            }
        },
        _storeDefaultVisualState: function() {
            this._imageReference.hasComponent("element") && (this._storeDefaultColor(this._imageReference.entity.element.color), this._storeDefaultOpacity(this._imageReference.entity.element.opacity), this._storeDefaultSpriteAsset(this._imageReference.entity.element.spriteAsset),
                this._storeDefaultSpriteFrame(this._imageReference.entity.element.spriteFrame))
        },
        _storeDefaultColor: function(a) {
            this._defaultTint.r = a.r;
            this._defaultTint.g = a.g;
            this._defaultTint.b = a.b
        },
        _storeDefaultOpacity: function(a) {
            this._defaultTint.a = a
        },
        _storeDefaultSpriteAsset: function(a) {
            this._defaultSpriteAsset = a
        },
        _storeDefaultSpriteFrame: function(a) {
            this._defaultSpriteFrame = a
        },
        _onSetColor: function(a) {
            this._isApplyingTint || (this._storeDefaultColor(a), this._forceReapplyVisualState())
        },
        _onSetOpacity: function(a) {
            this._isApplyingTint ||
                (this._storeDefaultOpacity(a), this._forceReapplyVisualState())
        },
        _onSetSpriteAsset: function(a) {
            this._isApplyingSprite || (this._storeDefaultSpriteAsset(a), this._forceReapplyVisualState())
        },
        _onSetSpriteFrame: function(a) {
            this._isApplyingSprite || (this._storeDefaultSpriteFrame(a), this._forceReapplyVisualState())
        },
        _onMouseEnter: function(a) {
            this._isHovering = !0;
            this._updateVisualState();
            this._fireIfActive("mouseenter", a)
        },
        _onMouseLeave: function(a) {
            this._isPressed = this._isHovering = !1;
            this._updateVisualState();
            this._fireIfActive("mouseleave", a)
        },
        _onMouseDown: function(a) {
            this._isPressed = !0;
            this._updateVisualState();
            this._fireIfActive("mousedown", a)
        },
        _onMouseUp: function(a) {
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("mouseup", a)
        },
        _onTouchStart: function(a) {
            this._isPressed = !0;
            this._updateVisualState();
            this._fireIfActive("touchstart", a)
        },
        _onTouchEnd: function(a) {
            a.event.preventDefault();
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("touchend", a)
        },
        _onTouchLeave: function(a) {
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("touchleave", a)
        },
        _onTouchCancel: function(a) {
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("touchcancel", a)
        },
        _onSelectStart: function(a) {
            this._isPressed = !0;
            this._updateVisualState();
            this._fireIfActive("selectstart", a)
        },
        _onSelectEnd: function(a) {
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("selectend", a)
        },
        _onSelectEnter: function(a) {
            this._hoveringCounter++;
            1 === this._hoveringCounter && (this._isHovering = !0, this._updateVisualState());
            this._fireIfActive("selectenter", a)
        },
        _onSelectLeave: function(a) {
            this._hoveringCounter--;
            0 === this._hoveringCounter && (this._isPressed = this._isHovering = !1, this._updateVisualState());
            this._fireIfActive("selectleave", a)
        },
        _onClick: function(a) {
            this._fireIfActive("click", a)
        },
        _fireIfActive: function(a, b) {
            this.data.active && this.fire(a, b)
        },
        _updateVisualState: function(a) {
            var b = this._visualState,
                c = this._determineVisualState();
            if ((b !== c || a) && this.enabled) switch (this._visualState = c, b === Ma.HOVER && this._fireIfActive("hoverend"),
                b === Ma.PRESSED && this._fireIfActive("pressedend"), c === Ma.HOVER && this._fireIfActive("hoverstart"), c === Ma.PRESSED && this._fireIfActive("pressedstart"), this.transitionMode) {
                case Xg:
                    this._applyTint(this[eg[this._visualState]]);
                    break;
                case 1:
                    this._applySprite(this[fg[this._visualState]], this[gg[this._visualState]])
            }
        },
        _forceReapplyVisualState: function() {
            this._updateVisualState(!0)
        },
        _resetToDefaultVisualState: function(a) {
            if (this._imageReference.hasComponent("element")) switch (a) {
                case Xg:
                    this._cancelTween();
                    this._applyTintImmediately(this._defaultTint);
                    break;
                case 1:
                    this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame)
            }
        },
        _determineVisualState: function() {
            if (this.active) {
                if (this._isPressed) return Ma.PRESSED;
                if (this._isHovering) return Ma.HOVER
            } else return Ma.INACTIVE;
            return Ma.DEFAULT
        },
        _applySprite: function(a, b) {
            b = b || 0;
            this._imageReference.hasComponent("element") && (this._isApplyingSprite = !0, this._imageReference.entity.element.spriteAsset = a, this._imageReference.entity.element.spriteFrame = b,
                this._isApplyingSprite = !1)
        },
        _applyTint: function(a) {
            this._cancelTween();
            0 === this.fadeDuration ? this._applyTintImmediately(a) : this._applyTintWithTween(a)
        },
        _applyTintImmediately: function(a) {
            this._imageReference.hasComponent("element") && a && (this._isApplyingTint = !0, this._imageReference.entity.element.color = new L(a.r, a.g, a.b), this._imageReference.entity.element.opacity = a.a, this._isApplyingTint = !1)
        },
        _applyTintWithTween: function(a) {
            if (this._imageReference.hasComponent("element") && a) {
                var b = this._imageReference.entity.element.color,
                    c = this._imageReference.entity.element.opacity;
                this._tweenInfo = {
                    startTime: Lb(),
                    from: new L(b.r, b.g, b.b, c),
                    to: a.clone(),
                    lerpColor: new L
                }
            }
        },
        _updateTintTween: function() {
            var a = Lb() - this._tweenInfo.startTime;
            a = 0 === this.fadeDuration ? 1 : a / this.fadeDuration;
            a = N.clamp(a, 0, 1);
            if (1E-5 < Math.abs(a - 1)) {
                var b = this._tweenInfo.lerpColor;
                b.lerp(this._tweenInfo.from, this._tweenInfo.to, a);
                this._applyTintImmediately(new L(b.r, b.g, b.b, b.a))
            } else this._applyTintImmediately(this._tweenInfo.to), this._cancelTween()
        },
        _cancelTween: function() {
            delete this._tweenInfo
        },
        onUpdate: function() {
            this._tweenInfo && this._updateTintTween()
        },
        onEnable: function() {
            this._isHovering = !1;
            this._hoveringCounter = 0;
            this._isPressed = !1;
            this._imageReference.onParentComponentEnable();
            this._toggleHitElementListeners("on");
            this._forceReapplyVisualState()
        },
        onDisable: function() {
            this._toggleHitElementListeners("off");
            this._resetToDefaultVisualState(this.transitionMode)
        },
        onRemove: function() {
            this._toggleLifecycleListeners("off", this.system);
            this.onDisable()
        }
    });
    var oj = ["enabled", "active", {
        name: "imageEntity",
        type: "entity"
    }, {
        name: "hitPadding",
        type: "vec4"
    }, "transitionMode", {
        name: "hoverTint",
        type: "rgba"
    }, {
        name: "pressedTint",
        type: "rgba"
    }, {
        name: "inactiveTint",
        type: "rgba"
    }, "fadeDuration", "hoverSpriteAsset", "hoverSpriteFrame", "pressedSpriteAsset", "pressedSpriteFrame", "inactiveSpriteAsset", "inactiveSpriteFrame"];
    Ce.prototype = Object.create(H.prototype);
    Ce.prototype.constructor = Ce;
    O._buildAccessors(Sd.prototype, oj);
    Object.assign(Ce.prototype, {
        initializeComponentData: function(a, b, c) {
            H.prototype.initializeComponentData.call(this,
                a, b, oj)
        },
        onUpdate: function(a) {
            a = this.store;
            for (var b in a) {
                var c = a[b].entity,
                    d = c.button;
                if (d.enabled && c.enabled) d.onUpdate()
            }
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        }
    });
    var of ;
    Object.assign(Yg.prototype, {
        _createOffscreenTarget: function(a, b) {
            var c = this.camera.rect,
                d = Math.floor(c.z * this.app.graphicsDevice.width * this.renderTargetScale);
            c = Math.floor(c.w * this.app.graphicsDevice.height * this.renderTargetScale);
            var e = this.app.graphicsDevice,
                f = b ? e.getHdrFormat() : 7;
            b = this.app.graphicsDevice.supportsStencil;
            var g = a ? e.samples : 1;
            d = new V(e, {
                format: f,
                width: d,
                height: c
            });
            d.name = "posteffect #" + this.effects.length;
            d.minFilter = 0;
            d.magFilter = 0;
            d.addressU = 1;
            d.addressV = 1;
            return new sa(this.app.graphicsDevice, d, {
                depth: a,
                stencil: b,
                samples: g
            })
        },
        _resizeOffscreenTarget: function(a) {
            var b = this.camera.rect,
                c = Math.floor(b.z * this.app.graphicsDevice.width * this.renderTargetScale);
            b = Math.floor(b.w * this.app.graphicsDevice.height * this.renderTargetScale);
            var d = this.app.graphicsDevice,
                e = a.colorBuffer.format;
            a._colorBuffer.destroy();
            c = new V(d, {
                format: e,
                width: c,
                height: b
            });
            c.name = "posteffect";
            c.minFilter = 0;
            c.magFilter = 0;
            c.addressU = 1;
            c.addressV = 1;
            a._colorBuffer = c;
            a.destroy()
        },
        _destroyOffscreenTarget: function(a) {
            a._colorBuffer && a._colorBuffer.destroy();
            a._depthBuffer && a._depthBuffer.destroy();
            a.destroy()
        },
        setRenderTargetScale: function(a) {
            this.renderTargetScale = a;
            this.resizeRenderTargets()
        },
        addEffect: function(a) {
            var b = this.effects,
                c = {
                    effect: a,
                    inputTarget: this._createOffscreenTarget(0 === this.effects.length, a.hdr),
                    outputTarget: null
                };
            if (!this.layer) {
                this.layer = new ka({
                    opaqueSortMode: 0,
                    transparentSortMode: 0,
                    passThrough: !0,
                    name: "PostEffectQueue",
                    renderTarget: this.camera.renderTarget,
                    clear: !1,
                    onPostRender: function() {
                        for (var l = 0; l < this._commandList.length; l++) this._commandList[l]()
                    }
                });
                var d = this.app.scene.layers.layerList,
                    e = 0,
                    f, g = d.length - 1;
                for (f = g; 0 <= f; f--)
                    if (4 === d[f].id) {
                        g = f - 1;
                        this._origOverrideClear = d[f].overrideClear;
                        this._origClearColorBuffer = d[f].clearColorBuffer;
                        this._origDepthColorBuffer = d[f].clearDepthBuffer;
                        this._origStencilColorBuffer =
                            d[f].clearStencilBuffer;
                        d[f].overrideClear = !0;
                        d[f].clearColorBuffer = !1;
                        d[f].clearDepthBuffer = this.camera.clearDepthBuffer;
                        d[f].clearStencilBuffer = this.camera.clearStencilBuffer;
                        break
                    }
                this._sourceLayers = [];
                for (f = 0; f < this.camera.layers.length; f++) {
                    d = this.camera.layers[f];
                    var k = this.app.scene.layers.getLayerById(d),
                        h = this.app.scene.layers.layerList.indexOf(k);
                    h <= g && (1 != d && (k.renderTarget = c.inputTarget, this._sourceLayers.push(k)), h > e && (e = h))
                }
                this.app.scene.layers.insertOpaque(this.layer, e + 1);
                this._sourceTarget =
                    c.inputTarget;
                this.layer._commandList = [];
                this.layer.isPostEffect = !0
            }
            b.push(c);
            e = b.length;
            1 < e && (b[e - 2].outputTarget = c.inputTarget);
            this._newPostEffect = a;
            a.needsDepthBuffer && this._requestDepthMap();
            this.enable();
            this._newPostEffect = void 0
        },
        removeEffect: function(a) {
            var b, c = -1;
            var d = 0;
            for (b = this.effects.length; d < b; d++)
                if (this.effects[d].effect === a) {
                    c = d;
                    break
                }
            if (0 <= c) {
                if (0 < c) this.effects[c - 1].outputTarget = c + 1 < this.effects.length ? this.effects[c + 1].inputTarget : null;
                else if (1 < this.effects.length)
                    for (this.effects[1].inputTarget._depth ||
                        (this._destroyOffscreenTarget(this.effects[1].inputTarget), this.effects[1].inputTarget = this._createOffscreenTarget(!0, this.effects[1].hdr), this._sourceTarget = this.effects[1].inputTarget), d = 0; d < this._sourceLayers.length; d++) this._sourceLayers[d].renderTarget = this.effects[1].inputTarget;
                this._destroyOffscreenTarget(this.effects[c].inputTarget);
                this.effects.splice(c, 1)
            }
            this.enabled && a.needsDepthBuffer && this._releaseDepthMap();
            0 === this.effects.length && this.disable()
        },
        _requestDepthMaps: function() {
            for (var a =
                    0, b = this.effects.length; a < b; a++) {
                var c = this.effects[a].effect;
                this._newPostEffect !== c && c.needsDepthBuffer && this._requestDepthMap()
            }
        },
        _releaseDepthMaps: function() {
            for (var a = 0, b = this.effects.length; a < b; a++) this.effects[a].effect.needsDepthBuffer && this._releaseDepthMap()
        },
        _requestDepthMap: function() { of || ( of = this.app.scene.layers.getLayerById(1)); of && of .incrementCounter()
        },
        _releaseDepthMap: function() { of && of .decrementCounter()
        },
        destroy: function() {
            for (var a = 0, b = this.effects.length; a < b; a++) this.effects[a].inputTarget.destroy();
            this.effects.length = 0;
            this.disable()
        },
        enable: function() {
            if (!this.enabled && this.effects.length) {
                this.enabled = !0;
                var a = this;
                this._requestDepthMaps();
                this.app.graphicsDevice.on("resizecanvas", this._onCanvasResized, this);
                this.command = function() {
                    if (a.enabled) {
                        var b = null,
                            c = a.effects.length;
                        if (c) {
                            a.layer.renderTarget = a.effects[0].inputTarget;
                            for (var d = 0; d < c; d++) {
                                var e = a.effects[d];
                                d === c - 1 && (b = a.camera.rect);
                                e.effect.render(e.inputTarget, e.outputTarget, b)
                            }
                        }
                    }
                };
                this.layer._commandList.push(this.command)
            }
        },
        disable: function() {
            if (this.enabled) {
                this.enabled = !1;
                this.app.graphicsDevice.off("resizecanvas", this._onCanvasResized, this);
                this._releaseDepthMaps();
                this._destroyOffscreenTarget(this._sourceTarget);
                var a = this.layer._commandList.indexOf(this.command);
                0 <= a && this.layer._commandList.splice(a, 1);
                var b = this.app.scene.layers.layerList,
                    c = b.length - 1;
                for (a = 0; a <= b.length; a++)
                    if (4 === b[a].id) {
                        c = a - 1;
                        b[a].overrideClear = this._origOverrideClear;
                        b[a].clearColorBuffer = this._origClearColorBuffer;
                        b[a].clearDepthBuffer =
                            this._origDepthColorBuffer;
                        b[a].clearStencilBuffer = this._origStencilColorBuffer;
                        break
                    }
                for (a = c; 0 <= a; a--) 0 <= b[a].cameras.indexOf(this.camera) && (b[a].renderTarget = void 0);
                this.app.scene.layers.removeOpaque(this.layer);
                this.layer = null
            }
        },
        _onCanvasResized: function(a, b) {
            a = this.camera.rect;
            b = this.app.graphicsDevice;
            this.camera.camera.aspectRatio = b.width * a.z / (b.height * a.w);
            this.resizeTimeout || (100 < Lb() - this.resizeLast ? this.resizeRenderTargets() : this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100))
        },
        resizeRenderTargets: function() {
            this.resizeTimeout && (clearTimeout(this.resizeTimeout), this.resizeTimeout = null);
            this.resizeLast = Lb();
            var a = this.camera.rect,
                b = Math.floor(a.z * this.app.graphicsDevice.width * this.renderTargetScale);
            a = Math.floor(a.w * this.app.graphicsDevice.height * this.renderTargetScale);
            for (var c = this.effects, d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                f.inputTarget.width === b && f.inputTarget.height === a || this._resizeOffscreenTarget(f.inputTarget)
            }
        },
        onCameraRectChanged: function(a, b, c) {
            this.enabled &&
                this.resizeRenderTargets()
        }
    });
    var Ob = function(a, b) {
        O.call(this, a, b);
        this._camera = new pa;
        this._camera.node = b;
        this._priority = 0;
        this._postEffects = new Yg(a.app, this)
    };
    Ob.prototype = Object.create(O.prototype);
    Ob.prototype.constructor = Ob;
    [{
        name: "aspectRatio",
        readonly: !1
    }, {
        name: "aspectRatioMode",
        readonly: !1
    }, {
        name: "calculateProjection",
        readonly: !1
    }, {
        name: "calculateTransform",
        readonly: !1
    }, {
        name: "clearColor",
        readonly: !1
    }, {
        name: "clearColorBuffer",
        readonly: !1
    }, {
        name: "clearDepthBuffer",
        readonly: !1
    }, {
        name: "clearStencilBuffer",
        readonly: !1
    }, {
        name: "cullFaces",
        readonly: !1
    }, {
        name: "farClip",
        readonly: !1
    }, {
        name: "flipFaces",
        readonly: !1
    }, {
        name: "fov",
        readonly: !1
    }, {
        name: "frustum",
        readonly: !0
    }, {
        name: "frustumCulling",
        readonly: !1
    }, {
        name: "horizontalFov",
        readonly: !1
    }, {
        name: "nearClip",
        readonly: !1
    }, {
        name: "orthoHeight",
        readonly: !1
    }, {
        name: "projection",
        readonly: !1
    }, {
        name: "projectionMatrix",
        readonly: !0
    }, {
        name: "rect",
        readonly: !1
    }, {
        name: "renderTarget",
        readonly: !1
    }, {
        name: "scissorRect",
        readonly: !1
    }, {
        name: "viewMatrix",
        readonly: !0
    }, {
        name: "vrDisplay",
        readonly: !1
    }].forEach(function(a) {
        var b = a.name,
            c = {
                get: function() {
                    return this._camera[b]
                }
            };
        a.readonly || (c.set = function(d) {
            this._camera[b] = d
        });
        Object.defineProperty(Ob.prototype, b, c)
    });
    Object.defineProperty(Ob.prototype, "camera", {
        get: function() {
            return this._camera
        }
    });
    Object.defineProperty(Ob.prototype, "layers", {
        get: function() {
            return this._camera.layers
        },
        set: function(a) {
            var b, c, d = this._camera.layers;
            for (b = 0; b < d.length; b++)(c = this.system.app.scene.layers.getLayerById(d[b])) && c.removeCamera(this);
            this._camera.layers =
                a;
            if (this.enabled && this.entity.enabled)
                for (b = 0; b < a.length; b++)(c = this.system.app.scene.layers.getLayerById(a[b])) && c.addCamera(this)
        }
    });
    Object.defineProperty(Ob.prototype, "postEffects", {
        get: function() {
            return this._postEffects
        }
    });
    Object.defineProperty(Ob.prototype, "priority", {
        get: function() {
            return this._priority
        },
        set: function(a) {
            this._priority = a;
            a = this.layers;
            for (var b = 0; b < a.length; b++) {
                var c = this.system.app.scene.layers.getLayerById(a[b]);
                c && c._sortCameras()
            }
        }
    });
    Object.assign(Ob.prototype, {
        screenToWorld: function(a,
            b, c, d) {
            var e = this.system.app.graphicsDevice;
            return this._camera.screenToWorld(a, b, c, e.clientRect.width, e.clientRect.height, d)
        },
        worldToScreen: function(a, b) {
            var c = this.system.app.graphicsDevice;
            return this._camera.worldToScreen(a, c.clientRect.width, c.clientRect.height, b)
        },
        onPrerender: function() {
            this._camera._viewMatDirty = !0;
            this._camera._viewProjMatDirty = !0
        },
        addCameraToLayers: function() {
            for (var a = this.layers, b = 0; b < a.length; b++) {
                var c = this.system.app.scene.layers.getLayerById(a[b]);
                c && c.addCamera(this)
            }
        },
        removeCameraFromLayers: function() {
            for (var a = this.layers, b = 0; b < a.length; b++) {
                var c = this.system.app.scene.layers.getLayerById(a[b]);
                c && c.removeCamera(this)
            }
        },
        onLayersChanged: function(a, b) {
            this.addCameraToLayers();
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || a.addCamera(this)
        },
        onLayerRemoved: function(a) {
            0 > this.layers.indexOf(a.id) || a.removeCamera(this)
        },
        onEnable: function() {
            var a = this.system,
                b = a.app.scene,
                c = b.layers;
            a.addCamera(this);
            b.on("set:layers", this.onLayersChanged, this);
            c && (c.on("add", this.onLayerAdded, this), c.on("remove", this.onLayerRemoved, this));
            this.enabled && this.entity.enabled && this.addCameraToLayers();
            this.postEffects.enable()
        },
        onDisable: function() {
            var a = this.system,
                b = a.app.scene,
                c = b.layers;
            this.postEffects.disable();
            this.removeCameraFromLayers();
            b.off("set:layers", this.onLayersChanged, this);
            c && (c.off("add", this.onLayerAdded, this), c.off("remove",
                this.onLayerRemoved, this));
            a.removeCamera(this)
        },
        onRemove: function() {
            this.onDisable();
            this.off()
        },
        calculateAspectRatio: function(a) {
            a = a ? a : this.system.app.graphicsDevice;
            var b = this.rect;
            return a.width * b.z / (a.height * b.w)
        },
        frameBegin: function(a) {
            0 === this.aspectRatioMode && (this.aspectRatio = this.calculateAspectRatio(a))
        },
        frameEnd: function() {},
        enterVr: function(a, b) {
            a instanceof Function && !b && (b = a, a = null);
            if (this.system.app.vr)
                if (a || (a = this.system.app.vr.display), a) {
                    var c = this;
                    a.capabilities.canPresent ? a.requestPresent(function(d) {
                        d ||
                            (c.vrDisplay = a, c.vrDisplay.once("beforepresentchange", function(e) {
                                e.presenting || (c.vrDisplay = null)
                            }));
                        b(d)
                    }) : (c.vrDisplay = a, b())
                } else b("No pc.VrDisplay to present");
            else b("VrManager not created. Enable VR in project settings.")
        },
        exitVr: function(a) {
            if (this.vrDisplay)
                if (this.vrDisplay.capabilities.canPresent) {
                    var b = this.vrDisplay;
                    this.vrDisplay = null;
                    b.exitPresent(a)
                } else this.vrDisplay = null, a();
            else a("Not presenting VR")
        },
        startXr: function(a, b, c) {
            this.system.app.xr.start(this, a, b, c)
        },
        endXr: function(a) {
            this._camera.xr ?
                this._camera.xr.end(a) : a && a(Error("Camera is not in XR"))
        }
    });
    var Wm = ["enabled"],
        Oe = function(a) {
            H.call(this, a);
            this.id = "camera";
            this.ComponentType = Ob;
            this.DataType = lo;
            this.schema = Wm;
            this.cameras = [];
            this.on("beforeremove", this.onBeforeRemove, this);
            this.app.on("prerender", this.onPrerender, this);
            H.bind("update", this.onUpdate, this)
        };
    Oe.prototype = Object.create(H.prototype);
    Oe.prototype.constructor = Oe;
    O._buildAccessors(Ob.prototype, Wm);
    Object.assign(Oe.prototype, {
        initializeComponentData: function(a, b, c) {
            c =
                "aspectRatio aspectRatioMode calculateProjection calculateTransform clearColor clearColorBuffer clearDepthBuffer clearStencilBuffer cullFaces farClip flipFaces fov frustumCulling horizontalFov layers renderTarget nearClip orthoHeight projection priority rect scissorRect".split(" ");
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                if (b.hasOwnProperty(e)) {
                    var f = b[e];
                    switch (e) {
                        case "rect":
                        case "scissorRect":
                            Array.isArray(f) ? a[e] = new X(f[0], f[1], f[2], f[3]) : a[e] = f;
                            break;
                        case "clearColor":
                            Array.isArray(f) ? a[e] = new L(f[0],
                                f[1], f[2], f[3]) : a[e] = f;
                            break;
                        default:
                            a[e] = f
                    }
                }
            }
            H.prototype.initializeComponentData.call(this, a, b, ["enabled"])
        },
        cloneComponent: function(a, b) {
            a = a.camera;
            this.addComponent(b, {
                aspectRatio: a.aspectRatio,
                aspectRatioMode: a.aspectRatioMode,
                calculateProjection: a.calculateProjection,
                calculateTransform: a.calculateTransform,
                clearColor: a.clearColor,
                clearColorBuffer: a.clearColorBuffer,
                clearDepthBuffer: a.clearDepthBuffer,
                clearStencilBuffer: a.clearStencilBuffer,
                cullFaces: a.cullFaces,
                farClip: a.farClip,
                flipFaces: a.flipFaces,
                fov: a.fov,
                frustumCulling: a.frustumCulling,
                horizontalFov: a.horizontalFov,
                layers: a.layers,
                renderTarget: a.renderTarget,
                nearClip: a.nearClip,
                orthoHeight: a.orthoHeight,
                projection: a.projection,
                priority: a.priority,
                rect: a.rect,
                scissorRect: a.scissorRect
            })
        },
        onBeforeRemove: function(a, b) {
            this.removeCamera(b)
        },
        onUpdate: function(a) {
            if (this.app.vr) {
                a = this.store;
                for (var b in a) {
                    var c = a[b];
                    if (c.data.enabled && c.entity.enabled) {
                        var d = c.entity.camera,
                            e = d.vrDisplay;
                        e && (e.setClipPlanes(d.nearClip, d.farClip), c.entity && (c.entity.localTransform.copy(e.combinedViewInv),
                            c.entity._dirtyLocal = !1, c.entity._dirtifyWorld()))
                    }
                }
            }
        },
        onPrerender: function() {
            for (var a = 0, b = this.cameras.length; a < b; a++) this.cameras[a].onPrerender()
        },
        addCamera: function(a) {
            this.cameras.push(a);
            this.sortCamerasByPriority()
        },
        removeCamera: function(a) {
            a = this.cameras.indexOf(a);
            0 <= a && (this.cameras.splice(a, 1), this.sortCamerasByPriority())
        },
        sortCamerasByPriority: function() {
            this.cameras.sort(function(a, b) {
                return a.priority - b.priority
            })
        }
    });
    var ne = function(a, b) {
        O.call(this, a, b);
        this._compoundParent = null;
        this.entity.on("insert", this._onInsert, this);
        this.on("set_type", this.onSetType, this);
        this.on("set_halfExtents", this.onSetHalfExtents, this);
        this.on("set_radius", this.onSetRadius, this);
        this.on("set_height", this.onSetHeight, this);
        this.on("set_axis", this.onSetAxis, this);
        this.on("set_asset", this.onSetAsset, this);
        this.on("set_model", this.onSetModel, this)
    };
    ne.prototype = Object.create(O.prototype);
    ne.prototype.constructor = ne;
    Object.assign(ne.prototype, {
        onSetType: function(a, b, c) {
            b !== c && this.system.changeType(this,
                b, c)
        },
        onSetHalfExtents: function(a, b, c) {
            a = this.data.type;
            this.data.initialized && "box" === a && this.system.recreatePhysicalShapes(this)
        },
        onSetRadius: function(a, b, c) {
            a = this.data.type;
            !this.data.initialized || "sphere" !== a && "capsule" !== a && "cylinder" !== a && "cone" !== a || this.system.recreatePhysicalShapes(this)
        },
        onSetHeight: function(a, b, c) {
            a = this.data.type;
            !this.data.initialized || "capsule" !== a && "cylinder" !== a && "cone" !== a || this.system.recreatePhysicalShapes(this)
        },
        onSetAxis: function(a, b, c) {
            a = this.data.type;
            !this.data.initialized ||
                "capsule" !== a && "cylinder" !== a && "cone" !== a || this.system.recreatePhysicalShapes(this)
        },
        onSetAsset: function(a, b, c) {
            a = this.system.app.assets;
            b && (b = a.get(b)) && b.off("remove", this.onAssetRemoved, this);
            c && (c instanceof aa && (this.data.asset = c.id), b = a.get(this.data.asset)) && (b.off("remove", this.onAssetRemoved, this), b.on("remove", this.onAssetRemoved, this));
            this.data.initialized && "mesh" === this.data.type && (c || (this.data.model = null), this.system.recreatePhysicalShapes(this))
        },
        onSetModel: function(a, b, c) {
            this.data.initialized &&
                "mesh" === this.data.type && this.system.implementations.mesh.doRecreatePhysicalShape(this)
        },
        onAssetRemoved: function(a) {
            a.off("remove", this.onAssetRemoved, this);
            this.data.asset === a.id && (this.asset = null)
        },
        _getCompoundChildShapeIndex: function(a) {
            for (var b = this.data.shape, c = b.getNumChildShapes(), d = 0; d < c; d++)
                if (b.getChildShape(d).ptr === a.ptr) return d;
            return null
        },
        _onInsert: function(a) {
            if ("undefined" !== typeof Ammo)
                if (this._compoundParent) this.system.recreatePhysicalShapes(this);
                else if (!this.entity.rigidbody)
                for (a =
                    this.entity.parent; a;) {
                    if (a.collision && "compound" === a.collision.type) {
                        0 === a.collision.shape.getNumChildShapes() ? this.system.recreatePhysicalShapes(a.collision) : this.system.recreatePhysicalShapes(this);
                        break
                    }
                    a = a.parent
                }
        },
        _updateCompound: function() {
            var a = this.entity;
            if (a._dirtyWorld) {
                for (var b = a._dirtyLocal, c = a; c && !b && (!c.collision || c.collision !== this._compoundParent);) c._dirtyLocal && (b = !0), c = c.parent;
                b && (a.forEach(this.system.implementations.compound._updateEachDescendantTransform, a), (a = this._compoundParent.entity.rigidbody) &&
                    a.activate())
            }
        },
        onEnable: function() {
            if ("mesh" === this.data.type && this.data.asset && this.data.initialized) {
                var a = this.system.app.assets.get(this.data.asset);
                if (a && (!a.resource || !this.data.shape)) {
                    this.system.recreatePhysicalShapes(this);
                    return
                }
            }
            this.entity.rigidbody ? this.entity.rigidbody.enabled && this.entity.rigidbody.enableSimulation() : this._compoundParent && this !== this._compoundParent ? 0 === this._compoundParent.shape.getNumChildShapes() ? this.system.recreatePhysicalShapes(this._compoundParent) : (a = this.system._getNodeTransform(this.entity,
                this._compoundParent.entity), this._compoundParent.shape.addChildShape(a, this.data.shape), Ammo.destroy(a), this._compoundParent.entity.rigidbody && this._compoundParent.entity.rigidbody.activate()) : this.entity.trigger && this.entity.trigger.enable()
        },
        onDisable: function() {
            this.entity.rigidbody ? this.entity.rigidbody.disableSimulation() : this._compoundParent && this !== this._compoundParent ? this._compoundParent.entity._destroying || (this.system._removeCompoundChild(this._compoundParent, this.data.shape), this._compoundParent.entity.rigidbody &&
                this._compoundParent.entity.rigidbody.activate()) : this.entity.trigger && this.entity.trigger.disable()
        },
        onBeforeRemove: function() {
            this.asset && (this.asset = null);
            this.entity.off("insert", this._onInsert, this);
            this.off()
        }
    });
    var Je = "static",
        wj = 2,
        $g = 65533,
        Mc, Lf, De;
    Object.assign(pj.prototype, {
        initialize: function(a) {
            var b = this.entity;
            if ((a = a.shape) && "undefined" !== typeof Ammo) {
                b.trigger && b.trigger.destroy();
                var c = b.getPosition(),
                    d = b.getRotation();
                Mc.setValue(c.x, c.y, c.z);
                Lf.setValue(d.x, d.y, d.z, d.w);
                De.setOrigin(Mc);
                De.setRotation(Lf);
                a = this.app.systems.rigidbody.createBody(1, a, De);
                a.setRestitution(0);
                a.setFriction(0);
                a.setDamping(0, 0);
                Mc.setValue(0, 0, 0);
                a.setLinearFactor(Mc);
                a.setAngularFactor(Mc);
                a.setCollisionFlags(a.getCollisionFlags() | 4);
                a.entity = b;
                this.body = a;
                this.component.enabled && b.enabled && this.enable()
            }
        },
        destroy: function() {
            var a = this.body;
            a && (this.disable(), this.app.systems.rigidbody.destroyBody(a))
        },
        _getEntityTransform: function(a) {
            var b = this.entity.getPosition(),
                c = this.entity.getRotation();
            Mc.setValue(b.x,
                b.y, b.z);
            Lf.setValue(c.x, c.y, c.z, c.w);
            a.setOrigin(Mc);
            a.setRotation(Lf)
        },
        updateTransform: function() {
            this._getEntityTransform(De);
            var a = this.body;
            a.setWorldTransform(De);
            a.activate()
        },
        enable: function() {
            var a = this.body;
            if (a) {
                var b = this.app.systems;
                b.rigidbody.addBody(a, 16, $g ^ 16);
                b.rigidbody._triggers.push(this);
                a.forceActivationState(1);
                this.updateTransform()
            }
        },
        disable: function() {
            var a = this.body;
            if (a) {
                var b = this.app.systems,
                    c = b.rigidbody._triggers.indexOf(this); - 1 < c && b.rigidbody._triggers.splice(c,
                    1);
                b.rigidbody.removeBody(a);
                a.forceActivationState(5)
            }
        }
    });
    var Mh = new J,
        Op = new z,
        Pp = new Y,
        Xm = "enabled type halfExtents radius axis height asset shape model".split(" "),
        Fc = function(a) {
            this.system = a
        };
    Object.assign(Fc.prototype, {
        beforeInitialize: function(a, b) {
            b.shape = null;
            b.model = new tb;
            b.model.graph = new Z
        },
        afterInitialize: function(a, b) {
            this.recreatePhysicalShapes(a);
            a.data.initialized = !0
        },
        reset: function(a, b) {
            this.beforeInitialize(a, b);
            this.afterInitialize(a, b)
        },
        recreatePhysicalShapes: function(a) {
            var b =
                a.entity,
                c = a.data;
            if ("undefined" !== typeof Ammo) {
                b.trigger && (b.trigger.destroy(), delete b.trigger);
                c.shape && (a._compoundParent && (this.system._removeCompoundChild(a._compoundParent, c.shape), a._compoundParent.entity.rigidbody && a._compoundParent.entity.rigidbody.activate()), Ammo.destroy(c.shape), c.shape = null);
                c.shape = this.createPhysicalShape(a.entity, c);
                var d = !a._compoundParent;
                if ("compound" === c.type && (!a._compoundParent || a === a._compoundParent)) a._compoundParent = a, b.forEach(this._addEachDescendant, a);
                else if ("compound" !== c.type && (a._compoundParent && a === a._compoundParent && b.forEach(this.system.implementations.compound._updateEachDescendant, a), !a.rigidbody)) {
                    a._compoundParent = null;
                    for (var e = b.parent; e;) {
                        if (e.collision && "compound" === e.collision.type) {
                            a._compoundParent = e.collision;
                            break
                        }
                        e = e.parent
                    }
                }
                a._compoundParent && a !== a._compoundParent && (d && 0 === a._compoundParent.shape.getNumChildShapes() ? this.system.recreatePhysicalShapes(a._compoundParent) : (this.system.updateCompoundChildTransform(b), a._compoundParent.entity.rigidbody &&
                    a._compoundParent.entity.rigidbody.activate()));
                b.rigidbody ? (b.rigidbody.disableSimulation(), b.rigidbody.createBody(), b.enabled && b.rigidbody.enabled && b.rigidbody.enableSimulation()) : a._compoundParent || (b.trigger ? b.trigger.initialize(c) : b.trigger = new pj(this.system.app, a, c))
            }
        },
        createPhysicalShape: function(a, b) {},
        updateTransform: function(a, b, c, d) {
            a.entity.trigger && a.entity.trigger.updateTransform()
        },
        beforeRemove: function(a, b) {
            b.data.shape && (b._compoundParent && !b._compoundParent.entity._destroying &&
                (this.system._removeCompoundChild(b._compoundParent, b.data.shape), b._compoundParent.entity.rigidbody && b._compoundParent.entity.rigidbody.activate()), b._compoundParent = null, Ammo.destroy(b.data.shape), b.data.shape = null)
        },
        remove: function(a, b) {
            var c = this.system.app;
            a.rigidbody && a.rigidbody.body && (c.systems.rigidbody.removeBody(a.rigidbody.body), a.rigidbody.disableSimulation());
            a.trigger && (a.trigger.destroy(), delete a.trigger);
            c.scene.containsModel(b.model) && (c.root.removeChild(b.model.graph), c.scene.removeModel(b.model))
        },
        clone: function(a, b) {
            a = this.system.store[a.getGuid()];
            return this.system.addComponent(b, {
                enabled: a.data.enabled,
                type: a.data.type,
                halfExtents: [a.data.halfExtents.x, a.data.halfExtents.y, a.data.halfExtents.z],
                radius: a.data.radius,
                axis: a.data.axis,
                height: a.data.height,
                asset: a.data.asset,
                model: a.data.model
            })
        }
    });
    var hg = function(a) {
        this.system = a
    };
    hg.prototype = Object.create(Fc.prototype);
    hg.prototype.constructor = hg;
    Object.assign(hg.prototype, {
        createPhysicalShape: function(a, b) {
            if ("undefined" !== typeof Ammo) return a =
                b.halfExtents, a = new Ammo.btVector3(a ? a.x : .5, a ? a.y : .5, a ? a.z : .5), b = new Ammo.btBoxShape(a), Ammo.destroy(a), b
        }
    });
    var ig = function(a) {
        this.system = a
    };
    ig.prototype = Object.create(Fc.prototype);
    ig.prototype.constructor = ig;
    Object.assign(ig.prototype, {
        createPhysicalShape: function(a, b) {
            if ("undefined" !== typeof Ammo) return new Ammo.btSphereShape(b.radius)
        }
    });
    var jg = function(a) {
        this.system = a
    };
    jg.prototype = Object.create(Fc.prototype);
    jg.prototype.constructor = jg;
    Object.assign(jg.prototype, {
        createPhysicalShape: function(a,
            b) {
            a = null;
            var c = void 0 !== b.axis ? b.axis : 1,
                d = b.radius || .5;
            b = Math.max((b.height || 2) - 2 * d, 0);
            if ("undefined" !== typeof Ammo) switch (c) {
                case 0:
                    a = new Ammo.btCapsuleShapeX(d, b);
                    break;
                case 1:
                    a = new Ammo.btCapsuleShape(d, b);
                    break;
                case 2:
                    a = new Ammo.btCapsuleShapeZ(d, b)
            }
            return a
        }
    });
    var kg = function(a) {
        this.system = a
    };
    kg.prototype = Object.create(Fc.prototype);
    kg.prototype.constructor = kg;
    Object.assign(kg.prototype, {
        createPhysicalShape: function(a, b) {
            var c = a = null,
                d = void 0 !== b.axis ? b.axis : 1,
                e = void 0 !== b.radius ? b.radius :
                .5;
            b = void 0 !== b.height ? b.height : 1;
            if ("undefined" !== typeof Ammo) switch (d) {
                case 0:
                    a = new Ammo.btVector3(.5 * b, e, e);
                    c = new Ammo.btCylinderShapeX(a);
                    break;
                case 1:
                    a = new Ammo.btVector3(e, .5 * b, e);
                    c = new Ammo.btCylinderShape(a);
                    break;
                case 2:
                    a = new Ammo.btVector3(e, e, .5 * b), c = new Ammo.btCylinderShapeZ(a)
            }
            a && Ammo.destroy(a);
            return c
        }
    });
    var lg = function(a) {
        this.system = a
    };
    lg.prototype = Object.create(Fc.prototype);
    lg.prototype.constructor = lg;
    Object.assign(lg.prototype, {
        createPhysicalShape: function(a, b) {
            a = null;
            var c = void 0 !==
                b.axis ? b.axis : 1,
                d = void 0 !== b.radius ? b.radius : .5;
            b = void 0 !== b.height ? b.height : 1;
            if ("undefined" !== typeof Ammo) switch (c) {
                case 0:
                    a = new Ammo.btConeShapeX(d, b);
                    break;
                case 1:
                    a = new Ammo.btConeShape(d, b);
                    break;
                case 2:
                    a = new Ammo.btConeShapeZ(d, b)
            }
            return a
        }
    });
    var mg = function(a) {
        this.system = a
    };
    mg.prototype = Object.create(Fc.prototype);
    mg.prototype.constructor = mg;
    Object.assign(mg.prototype, {
        beforeInitialize: function(a, b) {},
        createPhysicalShape: function(a, b) {
            if ("undefined" !== typeof Ammo && b.model) {
                var c = b.model;
                b =
                    new Ammo.btCompoundShape;
                var d, e;
                for (d = 0; d < c.meshInstances.length; d++) {
                    var f = c.meshInstances[d],
                        g = f.mesh;
                    if (this.system._triMeshCache[g.id]) var k = this.system._triMeshCache[g.id];
                    else {
                        k = g.indexBuffer[0];
                        var h = g.vertexBuffer,
                            l = h.getFormat(),
                            n = l.size / 4,
                            p;
                        for (e = 0; e < l.elements.length; e++) {
                            var q = l.elements[e];
                            "POSITION" === q.name && (p = new Float32Array(h.lock(), q.offset))
                        }
                        h = new Uint16Array(k.lock());
                        l = g.primitive[0].count / 3;
                        q = new Ammo.btVector3;
                        var r = new Ammo.btVector3,
                            t = new Ammo.btVector3,
                            u = g.primitive[0].base;
                        k = new Ammo.btTriangleMesh;
                        this.system._triMeshCache[g.id] = k;
                        for (e = 0; e < l; e++) {
                            g = h[u + 3 * e] * n;
                            var x = h[u + 3 * e + 1] * n;
                            var v = h[u + 3 * e + 2] * n;
                            q.setValue(p[g], p[g + 1], p[g + 2]);
                            r.setValue(p[x], p[x + 1], p[x + 2]);
                            t.setValue(p[v], p[v + 1], p[v + 2]);
                            k.addTriangle(q, r, t, !0)
                        }
                        Ammo.destroy(q);
                        Ammo.destroy(r);
                        Ammo.destroy(t)
                    }
                    e = new Ammo.btBvhTriangleMeshShape(k, !0);
                    n = this.system._getNodeScaling(f.node);
                    e.setLocalScaling(n);
                    Ammo.destroy(n);
                    f = this.system._getNodeTransform(f.node);
                    b.addChildShape(f, e);
                    Ammo.destroy(f)
                }
                a = a.getWorldTransform().getScale();
                a = new Ammo.btVector3(a.x, a.y, a.z);
                b.setLocalScaling(a);
                Ammo.destroy(a);
                return b
            }
        },
        recreatePhysicalShapes: function(a) {
            null !== a.data.asset && a.enabled && a.entity.enabled ? this.loadModelAsset(a) : this.doRecreatePhysicalShape(a)
        },
        loadModelAsset: function(a) {
            var b = this,
                c = a.data.asset,
                d = a.data,
                e = this.system.app.assets,
                f = e.get(c);
            if (f) f.ready(function(g) {
                d.model = g.resource;
                b.doRecreatePhysicalShape(a)
            }), e.load(f);
            else e.once("add:" + c, function(g) {
                g.ready(function(k) {
                    d.model = k.resource;
                    b.doRecreatePhysicalShape(a)
                });
                e.load(g)
            })
        },
        doRecreatePhysicalShape: function(a) {
            var b = a.entity,
                c = a.data;
            c.model ? (this.destroyShape(c), c.shape = this.createPhysicalShape(b, c), b.rigidbody ? (b.rigidbody.disableSimulation(), b.rigidbody.createBody(), b.enabled && b.rigidbody.enabled && b.rigidbody.enableSimulation()) : b.trigger ? b.trigger.initialize(c) : b.trigger = new pj(this.system.app, a, c)) : (this.beforeRemove(b, a), this.remove(b, c))
        },
        updateTransform: function(a, b, c, d) {
            if (a.shape) {
                var e = a.entity.getWorldTransform().getScale(),
                    f = a.shape.getLocalScaling();
                e.x === f.x() && e.y === f.y() && e.z === f.z() || this.doRecreatePhysicalShape(a)
            }
            Fc.prototype.updateTransform.call(this, a, b, c, d)
        },
        destroyShape: function(a) {
            if (a.shape) {
                for (var b = a.shape.getNumChildShapes(), c = 0; c < b; c++) {
                    var d = a.shape.getChildShape(c);
                    Ammo.destroy(d)
                }
                Ammo.destroy(a.shape);
                a.shape = null
            }
        },
        remove: function(a, b) {
            this.destroyShape(b);
            Fc.prototype.remove.call(this, a, b)
        }
    });
    var ng = function(a) {
        this.system = a
    };
    ng.prototype = Object.create(Fc.prototype);
    ng.prototype.constructor = ng;
    Object.assign(ng.prototype, {
        createPhysicalShape: function(a, b) {
            if ("undefined" !== typeof Ammo) return new Ammo.btCompoundShape
        },
        _addEachDescendant: function(a) {
            a.collision && !a.rigidbody && (a.collision._compoundParent = this, a !== this.entity && a.collision.system.recreatePhysicalShapes(a.collision))
        },
        _updateEachDescendant: function(a) {
            a.collision && a.collision._compoundParent === this && (a.collision._compoundParent = null, a === this.entity || a.rigidbody || a.collision.system.recreatePhysicalShapes(a.collision))
        },
        _updateEachDescendantTransform: function(a) {
            a.collision &&
                a.collision._compoundParent === this.collision._compoundParent && this.collision.system.updateCompoundChildTransform(a)
        }
    });
    var Ne = function(a) {
        H.call(this, a);
        this.id = "collision";
        this.ComponentType = ne;
        this.DataType = mo;
        this.schema = Xm;
        this.implementations = {};
        this._triMeshCache = {};
        this.on("beforeremove", this.onBeforeRemove, this);
        this.on("remove", this.onRemove, this)
    };
    Ne.prototype = Object.create(H.prototype);
    Ne.prototype.constructor = Ne;
    O._buildAccessors(ne.prototype, Xm);
    Object.assign(Ne.prototype, {
        initializeComponentData: function(a,
            b, c) {
            c = "type halfExtents radius axis height shape model asset enabled".split(" ");
            for (var d = {}, e = 0, f = c.length; e < f; e++) {
                var g = c[e];
                d[g] = b[g]
            }
            b.hasOwnProperty("asset") ? (b = c.indexOf("model"), -1 !== b && c.splice(b, 1)) : b.hasOwnProperty("model") && (b = c.indexOf("asset"), -1 !== b && c.splice(b, 1));
            d.type || (d.type = a.data.type);
            a.data.type = d.type;
            d.halfExtents && Array.isArray(d.halfExtents) && (d.halfExtents = new z(d.halfExtents[0], d.halfExtents[1], d.halfExtents[2]));
            b = this._createImplementation(d.type);
            b.beforeInitialize(a,
                d);
            H.prototype.initializeComponentData.call(this.system, a, d, c);
            b.afterInitialize(a, d)
        },
        _createImplementation: function(a) {
            if (void 0 === this.implementations[a]) {
                switch (a) {
                    case "box":
                        var b = new hg(this);
                        break;
                    case "sphere":
                        b = new ig(this);
                        break;
                    case "capsule":
                        b = new jg(this);
                        break;
                    case "cylinder":
                        b = new kg(this);
                        break;
                    case "cone":
                        b = new lg(this);
                        break;
                    case "mesh":
                        b = new mg(this);
                        break;
                    case "compound":
                        b = new ng(this)
                }
                this.implementations[a] = b
            }
            return this.implementations[a]
        },
        _getImplementation: function(a) {
            return this.implementations[a.collision.data.type]
        },
        cloneComponent: function(a, b) {
            return this._getImplementation(a).clone(a, b)
        },
        onBeforeRemove: function(a, b) {
            this.implementations[b.data.type].beforeRemove(a, b);
            b.onBeforeRemove()
        },
        onRemove: function(a, b) {
            this.implementations[b.type].remove(a, b)
        },
        updateCompoundChildTransform: function(a) {
            this._removeCompoundChild(a.collision._compoundParent, a.collision.data.shape);
            if (a.enabled && a.collision.enabled) {
                var b = this._getNodeTransform(a, a.collision._compoundParent.entity);
                a.collision._compoundParent.shape.addChildShape(b,
                    a.collision.data.shape);
                Ammo.destroy(b)
            }
        },
        _removeCompoundChild: function(a, b) {
            a.shape.removeChildShape ? a.shape.removeChildShape(b) : (b = a._getCompoundChildShapeIndex(b), null !== b && a.shape.removeChildShapeByIndex(b))
        },
        onTransformChanged: function(a, b, c, d) {
            this.implementations[a.data.type].updateTransform(a, b, c, d)
        },
        changeType: function(a, b, c) {
            this.implementations[b].beforeRemove(a.entity, a);
            this.implementations[b].remove(a.entity, a.data);
            this._createImplementation(c).reset(a, a.data)
        },
        recreatePhysicalShapes: function(a) {
            this.implementations[a.data.type].recreatePhysicalShapes(a)
        },
        _calculateNodeRelativeTransform: function(a, b) {
            a === b ? (a = a.getWorldTransform().getScale(), Mh.setScale(a.x, a.y, a.z)) : (this._calculateNodeRelativeTransform(a.parent, b), Mh.mul(a.getLocalTransform()))
        },
        _getNodeScaling: function(a) {
            a = a.getWorldTransform().getScale();
            return new Ammo.btVector3(a.x, a.y, a.z)
        },
        _getNodeTransform: function(a, b) {
            b ? (this._calculateNodeRelativeTransform(a, b), b = Op, a = Pp, Mh.getTranslation(b), a.setFromMat4(Mh)) : (b = a.getPosition(), a = a.getRotation());
            var c = new Ammo.btTransform;
            c.setIdentity();
            var d = c.getOrigin();
            d.setValue(b.x, b.y, b.z);
            b = new Ammo.btQuaternion;
            b.setValue(a.x, a.y, a.z, a.w);
            c.setRotation(b);
            Ammo.destroy(b);
            Ammo.destroy(d);
            return c
        },
        destroy: function() {
            for (var a in this._triMeshCache) Ammo.destroy(this._triMeshCache[a]);
            this._triMeshCache = null;
            H.prototype.destroy.call(this)
        }
    });
    Object.assign(qj.prototype, {
        add: function(a) {
            var b = a.id;
            if (this[b]) throw Error("ComponentSystem name '" + b + "' already registered or not allowed");
            this[b] = a;
            this.list.push(a)
        },
        remove: function(a) {
            a = a.id;
            if (!this[a]) throw Error("No ComponentSystem named '" +
                a + "' registered");
            delete this[a];
            a = this.list.indexOf(this[a]); - 1 !== a && this.list.splice(a, 1)
        }
    });
    var ul = "group";
    Td.prototype.clone = function() {
        return new Td({
            func: this.func,
            ref: this.ref,
            readMask: this.readMask,
            writeMask: this.writeMask,
            fail: this.fail,
            zfail: this.zfail,
            zpass: this.zpass
        })
    };
    yb.prototype.destroy = function() {
        this.setMaterial(null);
        this._element.removeModelFromLayers(this.model);
        this.model.destroy();
        this._element = this._entity = this.meshInstance = this.mesh = this.node = this.model = null
    };
    yb.prototype.setMesh =
        function(a) {
            this.meshInstance && (this.mesh = a, this.meshInstance.mesh = a, this.meshInstance.visible = !!a, this.unmaskMeshInstance && (this.unmaskMeshInstance.mesh = a), this.forceUpdateAabb())
        };
    yb.prototype.setMask = function(a) {
        if (this.meshInstance) {
            if (a) {
                this.unmaskMeshInstance = new va(this.node, this.mesh, this.meshInstance.material);
                this.unmaskMeshInstance.name = "Unmask: " + this._entity.name;
                this.unmaskMeshInstance.castShadow = !1;
                this.unmaskMeshInstance.receiveShadow = !1;
                this.unmaskMeshInstance.pick = !1;
                this.model.meshInstances.push(this.unmaskMeshInstance);
                for (var b in this.meshInstance.parameters) this.unmaskMeshInstance.setParameter(b, this.meshInstance.parameters[b].data)
            } else a = this.model.meshInstances.indexOf(this.unmaskMeshInstance), 0 <= a && this.model.meshInstances.splice(a, 1), this.unmaskMeshInstance = null;
            this._entity.enabled && this._element.enabled && (this._element.removeModelFromLayers(this.model), this._element.addModelToLayers(this.model))
        }
    };
    yb.prototype.setMaterial = function(a) {
        this.meshInstance && (this.meshInstance.material = a, this.unmaskMeshInstance &&
            (this.unmaskMeshInstance.material = a))
    };
    yb.prototype.setParameter = function(a, b) {
        this.meshInstance && (this.meshInstance.setParameter(a, b), this.unmaskMeshInstance && this.unmaskMeshInstance.setParameter(a, b))
    };
    yb.prototype.deleteParameter = function(a) {
        this.meshInstance && (this.meshInstance.deleteParameter(a), this.unmaskMeshInstance && this.unmaskMeshInstance.deleteParameter(a))
    };
    yb.prototype.setUnmaskDrawOrder = function() {
        if (this.meshInstance) {
            var a = function(c) {
                var d;
                c = c.children;
                var e = c.length;
                if (e) {
                    for (var f =
                            0; f < e; f++) c[f].element && (d = c[f]);
                    return d ? (c = a(d)) ? c : d : null
                }
                return null
            };
            if (this.unmaskMeshInstance) {
                var b = a(this._entity);
                this.unmaskMeshInstance.drawOrder = b && b.element ? b.element.drawOrder + b.element.getMaskOffset() : this.meshInstance.drawOrder + this._element.getMaskOffset()
            }
        }
    };
    yb.prototype.setDrawOrder = function(a) {
        this.meshInstance && (this.meshInstance.drawOrder = a)
    };
    yb.prototype.setCull = function(a) {
        if (this.meshInstance) {
            var b = this._element,
                c = null;
            a && b._isScreenCulled() && (c = function(d) {
                return b.isVisibleForCamera(d)
            });
            this.meshInstance.cull = a;
            this.meshInstance.isVisibleFunc = c;
            this.unmaskMeshInstance && (this.unmaskMeshInstance.cull = a, this.unmaskMeshInstance.isVisibleFunc = c)
        }
    };
    yb.prototype.setScreenSpace = function(a) {
        this.meshInstance && (this.meshInstance.screenSpace = a, this.unmaskMeshInstance && (this.unmaskMeshInstance.screenSpace = a))
    };
    yb.prototype.setLayer = function(a) {
        this.meshInstance && (this.meshInstance.layer = a, this.unmaskMeshInstance && (this.unmaskMeshInstance.layer = a))
    };
    yb.prototype.forceUpdateAabb = function(a) {
        this.meshInstance &&
            (this.meshInstance._aabbVer = -1, this.unmaskMeshInstance && (this.unmaskMeshInstance._aabbVer = -1))
    };
    yb.prototype.setAabbFunc = function(a) {
        this.meshInstance && (this.meshInstance._updateAabbFunc = a, this.unmaskMeshInstance && (this.unmaskMeshInstance._updateAabbFunc = a))
    };
    Object.assign(cb.prototype, {
        destroy: function() {
            this.materialAsset = this.spriteAsset = this.textureAsset = null;
            this._renderable.setMesh(this._defaultMesh);
            this._renderable.destroy();
            this._defaultMesh = null;
            this._element.off("resize", this._onParentResizeOrPivotChange,
                this);
            this._element.off("set:pivot", this._onParentResizeOrPivotChange, this);
            this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this);
            this._element.off("set:screen", this._onScreenChange, this);
            this._element.off("set:draworder", this._onDrawOrderChange, this);
            this._element.off("screen:set:resolution", this._onResolutionChange, this)
        },
        _onResolutionChange: function(a) {},
        _onParentResizeOrPivotChange: function() {
            this._renderable.mesh && this._updateMesh(this._renderable.mesh)
        },
        _onScreenSpaceChange: function(a) {
            this._updateMaterial(a)
        },
        _onScreenChange: function(a, b) {
            a ? this._updateMaterial(a.screen.screenSpace) : this._updateMaterial(!1)
        },
        _onDrawOrderChange: function(a) {
            this._renderable.setDrawOrder(a);
            if (this.mask && this._element.screen) this._element.screen.screen.once("syncdraworder", function() {
                this._renderable.setUnmaskDrawOrder()
            }, this)
        },
        _hasUserMaterial: function() {
            return !!this._materialAsset || !!this._material && -1 === this._system.defaultImageMaterials.indexOf(this._material)
        },
        _use9Slicing: function() {
            return this.sprite && (1 === this.sprite.renderMode ||
                2 === this.sprite.renderMode)
        },
        _updateMaterial: function(a) {
            var b = !!this._mask,
                c = !(!this.sprite || 1 !== this.sprite.renderMode),
                d = !(!this.sprite || 2 !== this.sprite.renderMode);
            this._hasUserMaterial() || (this._material = this._system.getImageElementMaterial(a, b, c, d));
            this._renderable && (this._renderable.setCull(!0), this._renderable.setMaterial(this._material), this._renderable.setScreenSpace(a), this._renderable.setLayer(a ? 0 : 15))
        },
        _createMesh: function() {
            var a = this._element,
                b = a.calculatedWidth;
            a = a.calculatedHeight;
            var c = this._rect,
                d = new ArrayBuffer(128),
                e = new Float32Array(d);
            e[5] = 1;
            e[6] = c.x;
            e[7] = c.y;
            e[8] = b;
            e[13] = 1;
            e[14] = c.x + c.z;
            e[15] = c.y;
            e[16] = b;
            e[17] = a;
            e[21] = 1;
            e[22] = c.x + c.z;
            e[23] = c.y + c.w;
            e[25] = a;
            e[29] = 1;
            e[30] = c.x;
            e[31] = c.y + c.w;
            c = this._system.app.graphicsDevice;
            e = new Na(c, [{
                semantic: "POSITION",
                components: 3,
                type: 6
            }, {
                semantic: "NORMAL",
                components: 3,
                type: 6
            }, {
                semantic: "TEXCOORD0",
                components: 2,
                type: 6
            }]);
            d = new ab(c, e, 4, 0, d);
            c = new sb(c);
            c.vertexBuffer = d;
            c.primitive[0].type = 6;
            c.primitive[0].base = 0;
            c.primitive[0].count =
                4;
            c.primitive[0].indexed = !1;
            c.aabb.setMinMax(z.ZERO, new z(b, a, 0));
            this._updateMesh(c);
            return c
        },
        _updateMesh: function(a) {
            var b = this._element,
                c = b.calculatedWidth,
                d = b.calculatedHeight,
                e = b._isScreenSpace();
            this._updateMaterial(e);
            this._renderable && this._renderable.forceUpdateAabb();
            if (!this.sprite || 1 !== this.sprite.renderMode && 2 !== this.sprite.renderMode) {
                var f = a.vertexBuffer,
                    g = new Float32Array(f.lock());
                e = b.pivot.x;
                b = b.pivot.y;
                g[0] = -(e * c);
                g[1] = -(b * d);
                g[8] = c - e * c;
                g[9] = -(b * d);
                g[16] = c - e * c;
                g[17] = d - b * d;
                g[24] = -(e * c);
                g[25] = d - b * d;
                var k = 1,
                    h = 1,
                    l = this._rect;
                if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
                    var n = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
                    n && (l = n.rect, k = this._sprite.atlas.texture.width, h = this._sprite.atlas.texture.height)
                }
                g[6] = l.x / k;
                g[7] = l.y / h;
                g[14] = (l.x + l.z) / k;
                g[15] = l.y / h;
                g[22] = (l.x + l.z) / k;
                g[23] = (l.y + l.w) / h;
                g[30] = l.x / k;
                g[31] = (l.y + l.w) / h;
                f.unlock();
                f = new z(-(e * c), -(b * d), 0);
                c = new z(c - e * c, d - b * d, 0);
                a.aabb.setMinMax(f, c);
                this._renderable &&
                    (this._renderable.node.setLocalScale(1, 1, 1), this._renderable.node.setLocalPosition(0, 0, 0), this._renderable.setAabbFunc(null))
            } else a = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]], e = 2 / a.rect.z, f = 2 / a.rect.w, this._innerOffset.set(a.border.x * e, a.border.y * f, a.border.z * e, a.border.w * f), e = this.sprite.atlas.texture, this._atlasRect.set(a.rect.x / e.width, a.rect.y / e.height, a.rect.z / e.width, a.rect.w / e.height), f = null !== this._pixelsPerUnit ? this._pixelsPerUnit : this.sprite.pixelsPerUnit, e = a.rect.z /
                f, a = a.rect.w / f, this._outerScale.set(Math.max(c, this._innerOffset.x * e), Math.max(d, this._innerOffset.y * a)), f = a, this._outerScale.x /= e, this._outerScale.y /= a, e *= N.clamp(c / (this._innerOffset.x * e), 1E-4, 1), f *= N.clamp(d / (this._innerOffset.y * a), 1E-4, 1), this._renderable && (this._innerOffsetUniform[0] = this._innerOffset.x, this._innerOffsetUniform[1] = this._innerOffset.y, this._innerOffsetUniform[2] = this._innerOffset.z, this._innerOffsetUniform[3] = this._innerOffset.w, this._renderable.setParameter("innerOffset", this._innerOffsetUniform),
                    this._atlasRectUniform[0] = this._atlasRect.x, this._atlasRectUniform[1] = this._atlasRect.y, this._atlasRectUniform[2] = this._atlasRect.z, this._atlasRectUniform[3] = this._atlasRect.w, this._renderable.setParameter("atlasRect", this._atlasRectUniform), this._outerScaleUniform[0] = this._outerScale.x, this._outerScaleUniform[1] = this._outerScale.y, this._renderable.setParameter("outerScale", this._outerScaleUniform), this._renderable.setAabbFunc(this._updateAabbFunc), this._renderable.node.setLocalScale(e, f, 1), this._renderable.node.setLocalPosition((.5 -
                        b.pivot.x) * c, (.5 - b.pivot.y) * d, 0));
            this._meshDirty = !1
        },
        _updateSprite: function() {
            var a = !1,
                b = null;
            this._sprite && this._sprite.atlas && (b = this._sprite.meshes[this.spriteFrame], a = 1 === this._sprite.renderMode || 2 === this._sprite.renderMode);
            if (this.mesh = a ? b : this._defaultMesh) this._element._beingInitialized ? this._meshDirty = !0 : this._updateMesh(this.mesh)
        },
        _updateAabb: function(a) {
            a.center.set(0, 0, 0);
            a.halfExtents.set(.5 * this._outerScale.x, .5 * this._outerScale.y, .001);
            a.setFromTransformedAabb(a, this._renderable.node.getWorldTransform());
            return a
        },
        _toggleMask: function() {
            this._element._dirtifyMask();
            var a = this._element._isScreenSpace();
            this._updateMaterial(a);
            this._renderable.setMask(!!this._mask)
        },
        _onMaterialLoad: function(a) {
            this.material = a.resource
        },
        _onMaterialAdded: function(a) {
            this._system.app.assets.off("add:" + a.id, this._onMaterialAdded, this);
            this._materialAsset === a.id && this._bindMaterialAsset(a)
        },
        _bindMaterialAsset: function(a) {
            this._entity.enabled && (a.on("load", this._onMaterialLoad, this), a.on("change", this._onMaterialChange, this),
                a.on("remove", this._onMaterialRemove, this), a.resource ? this._onMaterialLoad(a) : this._system.app.assets.load(a))
        },
        _unbindMaterialAsset: function(a) {
            a.off("load", this._onMaterialLoad, this);
            a.off("change", this._onMaterialChange, this);
            a.off("remove", this._onMaterialRemove, this)
        },
        _onMaterialChange: function() {},
        _onMaterialRemove: function() {},
        _onTextureAdded: function(a) {
            this._system.app.assets.off("add:" + a.id, this._onTextureAdded, this);
            this._textureAsset === a.id && this._bindTextureAsset(a)
        },
        _bindTextureAsset: function(a) {
            this._entity.enabled &&
                (a.on("load", this._onTextureLoad, this), a.on("change", this._onTextureChange, this), a.on("remove", this._onTextureRemove, this), a.resource ? this._onTextureLoad(a) : this._system.app.assets.load(a))
        },
        _unbindTextureAsset: function(a) {
            a.off("load", this._onTextureLoad, this);
            a.off("change", this._onTextureChange, this);
            a.off("remove", this._onTextureRemove, this)
        },
        _onTextureLoad: function(a) {
            this.texture = a.resource
        },
        _onTextureChange: function(a) {},
        _onTextureRemove: function(a) {},
        _onSpriteAssetAdded: function(a) {
            this._system.app.assets.off("add:" +
                a.id, this._onSpriteAssetAdded, this);
            this._spriteAsset === a.id && this._bindSpriteAsset(a)
        },
        _bindSpriteAsset: function(a) {
            this._entity.enabled && (a.on("load", this._onSpriteAssetLoad, this), a.on("change", this._onSpriteAssetChange, this), a.on("remove", this._onSpriteAssetRemove, this), a.resource ? this._onSpriteAssetLoad(a) : this._system.app.assets.load(a))
        },
        _unbindSpriteAsset: function(a) {
            a.off("load", this._onSpriteAssetLoad, this);
            a.off("change", this._onSpriteAssetChange, this);
            a.off("remove", this._onSpriteAssetRemove,
                this);
            a.data.textureAtlasAsset && this._system.app.assets.off("load:" + a.data.textureAtlasAsset, this._onTextureAtlasLoad, this)
        },
        _onSpriteAssetLoad: function(a) {
            if (a && a.resource)
                if (a.resource.atlas) this.sprite = a.resource;
                else {
                    if (a = a.data.textureAtlasAsset) {
                        var b = this._system.app.assets;
                        b.off("load:" + a, this._onTextureAtlasLoad, this);
                        b.once("load:" + a, this._onTextureAtlasLoad, this)
                    }
                }
            else this.sprite = null
        },
        _onSpriteAssetChange: function(a) {
            this._onSpriteAssetLoad(a)
        },
        _onSpriteAssetRemove: function(a) {},
        _bindSprite: function(a) {
            a.on("set:meshes",
                this._onSpriteMeshesChange, this);
            a.on("set:pixelsPerUnit", this._onSpritePpuChange, this);
            a.on("set:atlas", this._onAtlasTextureChange, this);
            if (a.atlas) a.atlas.on("set:texture", this._onAtlasTextureChange, this)
        },
        _unbindSprite: function(a) {
            a.off("set:meshes", this._onSpriteMeshesChange, this);
            a.off("set:pixelsPerUnit", this._onSpritePpuChange, this);
            a.off("set:atlas", this._onAtlasTextureChange, this);
            a.atlas && a.atlas.off("set:texture", this._onAtlasTextureChange, this)
        },
        _onSpriteMeshesChange: function() {
            this._sprite &&
                (this._spriteFrame = N.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1));
            this._updateSprite()
        },
        _onSpritePpuChange: function() {
            0 !== this.sprite.renderMode && null === this._pixelsPerUnit && this._updateSprite()
        },
        _onAtlasTextureChange: function() {
            this.sprite && this.sprite.atlas && this.sprite.atlas.texture ? (this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture), this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture)) : (this._renderable.deleteParameter("texture_emissiveMap"),
                this._renderable.deleteParameter("texture_opacityMap"))
        },
        _onTextureAtlasLoad: function(a) {
            a = this._spriteAsset;
            a instanceof aa ? this._onSpriteAssetLoad(a) : this._onSpriteAssetLoad(this._system.app.assets.get(a))
        },
        onEnable: function() {
            var a;
            this._materialAsset && (a = this._system.app.assets.get(this._materialAsset)) && a.resource !== this._material && this._bindMaterialAsset(a);
            this._textureAsset && (a = this._system.app.assets.get(this._textureAsset)) && a.resource !== this._texture && this._bindTextureAsset(a);
            this._spriteAsset &&
                (a = this._system.app.assets.get(this._spriteAsset)) && a.resource !== this._sprite && this._bindSpriteAsset(a);
            this._element.addModelToLayers(this._renderable.model)
        },
        onDisable: function() {
            this._element.removeModelFromLayers(this._renderable.model)
        },
        _setStencil: function(a) {
            this._renderable.meshInstance.stencilFront = a;
            this._renderable.meshInstance.stencilBack = a;
            a = 0;
            this._element.maskedBy && (a = this._element.maskedBy.element._image._maskRef);
            this._renderable.unmaskMeshInstance && (a = new Td({
                    ref: a + 1,
                    func: 2,
                    zpass: 5
                }),
                this._renderable.unmaskMeshInstance.stencilFront = a, this._renderable.unmaskMeshInstance.stencilBack = a)
        }
    });
    Object.defineProperty(cb.prototype, "color", {
        get: function() {
            return this._color
        },
        set: function(a) {
            var b = a.r,
                c = a.g;
            a = a.b;
            if (this._color.r !== b || this._color.g !== c || this._color.b !== a) this._color.r = b, this._color.g = c, this._color.b = a, this._colorUniform[0] = b, this._colorUniform[1] = c, this._colorUniform[2] = a, this._renderable.setParameter("material_emissive", this._colorUniform), this._element && this._element.fire("set:color",
                this._color)
        }
    });
    Object.defineProperty(cb.prototype, "opacity", {
        get: function() {
            return this._color.a
        },
        set: function(a) {
            a !== this._color.a && (this._color.a = a, this._renderable.setParameter("material_opacity", a), this._element && this._element.fire("set:opacity", a))
        }
    });
    Object.defineProperty(cb.prototype, "rect", {
        get: function() {
            return this._rect
        },
        set: function(a) {
            if (a instanceof X) {
                var b = a.x;
                var c = a.y;
                var d = a.z;
                a = a.w
            } else b = a[0], c = a[1], d = a[2], a = a[3];
            if (b !== this._rect.x || c !== this._rect.y || d !== this._rect.z || a !== this._rect.w) this._rect.set(b,
                c, d, a), this._renderable.mesh && (this._element._beingInitialized ? this._meshDirty = !0 : this._updateMesh(this._renderable.mesh))
        }
    });
    Object.defineProperty(cb.prototype, "material", {
        get: function() {
            return this._material
        },
        set: function(a) {
            this._material !== a && (a || (a = this._element._isScreenSpace(), a = this.mask ? a ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial : a ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial), this._material = a) && (this._renderable.setMaterial(a),
                this._hasUserMaterial() ? (this._renderable.deleteParameter("material_opacity"), this._renderable.deleteParameter("material_emissive")) : (this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b, this._renderable.setParameter("material_emissive", this._colorUniform), this._renderable.setParameter("material_opacity", this._color.a)))
        }
    });
    Object.defineProperty(cb.prototype, "materialAsset", {
        get: function() {
            return this._materialAsset
        },
        set: function(a) {
            var b = this._system.app.assets,
                c = a;
            a instanceof aa && (c = a.id);
            this._materialAsset !== c && (this._materialAsset && (b.off("add:" + this._materialAsset, this._onMaterialAdded, this), a = b.get(this._materialAsset)) && (a.off("load", this._onMaterialLoad, this), a.off("change", this._onMaterialChange, this), a.off("remove", this._onMaterialRemove, this)), (this._materialAsset = c) ? (c = b.get(this._materialAsset)) ? this._bindMaterialAsset(c) : (this.material = null, b.on("add:" + this._materialAsset, this._onMaterialAdded, this)) : this.material = null)
        }
    });
    Object.defineProperty(cb.prototype,
        "texture", {
            get: function() {
                return this._texture
            },
            set: function(a) {
                if (this._texture !== a) {
                    if (this._textureAsset) {
                        var b = this._system.app.assets.get(this._textureAsset);
                        b && b.resource !== a && (this.textureAsset = null)
                    }(this._texture = a) ? (this._spriteAsset && (this.spriteAsset = null), this._renderable.setParameter("texture_emissiveMap", this._texture), this._renderable.setParameter("texture_opacityMap", this._texture), this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b,
                        this._renderable.setParameter("material_emissive", this._colorUniform), this._renderable.setParameter("material_opacity", this._color.a)) : (this._renderable.deleteParameter("texture_emissiveMap"), this._renderable.deleteParameter("texture_opacityMap"))
                }
            }
        });
    Object.defineProperty(cb.prototype, "textureAsset", {
        get: function() {
            return this._textureAsset
        },
        set: function(a) {
            var b = this._system.app.assets,
                c = a;
            a instanceof aa && (c = a.id);
            this._textureAsset !== c && (this._textureAsset && (b.off("add:" + this._textureAsset, this._onTextureAdded,
                this), a = b.get(this._textureAsset)) && (a.off("load", this._onTextureLoad, this), a.off("change", this._onTextureChange, this), a.off("remove", this._onTextureRemove, this)), (this._textureAsset = c) ? (c = b.get(this._textureAsset)) ? this._bindTextureAsset(c) : (this.texture = null, b.on("add:" + this._textureAsset, this._onTextureAdded, this)) : this.texture = null)
        }
    });
    Object.defineProperty(cb.prototype, "spriteAsset", {
        get: function() {
            return this._spriteAsset
        },
        set: function(a) {
            var b = this._system.app.assets,
                c = a;
            a instanceof aa && (c =
                a.id);
            this._spriteAsset !== c && (this._spriteAsset && (b.off("add:" + this._spriteAsset, this._onSpriteAssetAdded, this), (a = b.get(this._spriteAsset)) && this._unbindSpriteAsset(a)), (this._spriteAsset = c) ? (a = b.get(this._spriteAsset)) ? this._bindSpriteAsset(a) : (this.sprite = null, b.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this)) : this.sprite = null, this._element && this._element.fire("set:spriteAsset", c))
        }
    });
    Object.defineProperty(cb.prototype, "sprite", {
        get: function() {
            return this._sprite
        },
        set: function(a) {
            if (this._sprite !==
                a) {
                this._sprite && this._unbindSprite(this._sprite);
                if (this._spriteAsset) {
                    var b = this._system.app.assets.get(this._spriteAsset);
                    b && b.resource !== a && (this.spriteAsset = null)
                }
                if (this._sprite = a) this._bindSprite(this._sprite), this._textureAsset && (this.textureAsset = null);
                this._sprite && this._sprite.atlas && this._sprite.atlas.texture ? (this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture), this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture)) : (this._renderable.deleteParameter("texture_emissiveMap"),
                    this._renderable.deleteParameter("texture_opacityMap"));
                this._sprite && (this._spriteFrame = N.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1));
                this._updateSprite()
            }
        }
    });
    Object.defineProperty(cb.prototype, "spriteFrame", {
        get: function() {
            return this._spriteFrame
        },
        set: function(a) {
            var b = this._spriteFrame;
            this._spriteFrame = this._sprite ? N.clamp(a, 0, this._sprite.frameKeys.length - 1) : a;
            this._spriteFrame !== b && (this._updateSprite(), this._element && this._element.fire("set:spriteFrame", a))
        }
    });
    Object.defineProperty(cb.prototype,
        "mesh", {
            get: function() {
                return this._renderable.mesh
            },
            set: function(a) {
                this._renderable.setMesh(a);
                this._defaultMesh === a ? this._renderable.setAabbFunc(null) : this._renderable.setAabbFunc(this._updateAabbFunc)
            }
        });
    Object.defineProperty(cb.prototype, "mask", {
        get: function() {
            return this._mask
        },
        set: function(a) {
            this._mask !== a && (this._mask = a, this._toggleMask())
        }
    });
    Object.defineProperty(cb.prototype, "pixelsPerUnit", {
        get: function() {
            return this._pixelsPerUnit
        },
        set: function(a) {
            this._pixelsPerUnit !== a && (this._pixelsPerUnit =
                a, !this._sprite || 1 !== this._sprite.renderMode && 2 !== this._sprite.renderMode || this._updateSprite())
        }
    });
    Object.defineProperty(cb.prototype, "aabb", {
        get: function() {
            return this._renderable.meshInstance ? this._renderable.meshInstance.aabb : null
        }
    });
    Ha.prototype = Object.create(M.prototype);
    Ha.prototype.constructor = Ha;
    Ha.prototype._bindDefaultAsset = function() {
        var a = this._app.assets.get(this._defaultAsset);
        if (a) this._onDefaultAssetAdd(a);
        else this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd,
            this)
    };
    Ha.prototype._unbindDefaultAsset = function() {
        if (this._defaultAsset) {
            this._app.assets.off("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
            var a = this._app.assets.get(this._defaultAsset);
            a && (a.off("add:localized", this._onLocaleAdd, this), a.off("remove:localized", this._onLocaleRemove, this), a.off("remove", this._onDefaultAssetRemove, this))
        }
    };
    Ha.prototype._onDefaultAssetAdd = function(a) {
        this._defaultAsset === a.id && (a.on("add:localized", this._onLocaleAdd, this), a.on("remove:localized", this._onLocaleRemove,
            this), a.once("remove", this._onDefaultAssetRemove, this))
    };
    Ha.prototype._onDefaultAssetRemove = function(a) {
        this._defaultAsset === a.id && (a.off("add:localized", this._onLocaleAdd, this), a.off("remove:localized", this._onLocaleAdd, this), this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this))
    };
    Ha.prototype._bindLocalizedAsset = function() {
        if (this._autoLoad) {
            var a = this._app.assets.get(this._localizedAsset);
            a && (a.on("load", this._onLocalizedAssetLoad, this), a.on("change", this._onLocalizedAssetChange,
                this), a.on("remove", this._onLocalizedAssetRemove, this), a.resource ? this._onLocalizedAssetLoad(a) : this._app.assets.load(a))
        }
    };
    Ha.prototype._unbindLocalizedAsset = function() {
        var a = this._app.assets.get(this._localizedAsset);
        a && (a.off("load", this._onLocalizedAssetLoad, this), a.off("change", this._onLocalizedAssetChange, this), a.off("remove", this._onLocalizedAssetRemove, this))
    };
    Ha.prototype._onLocalizedAssetAdd = function(a) {
        this._localizedAsset === a.id && this._bindLocalizedAsset()
    };
    Ha.prototype._onLocalizedAssetLoad =
        function(a) {
            this.fire("load", a)
        };
    Ha.prototype._onLocalizedAssetChange = function(a, b, c, d) {
        this.fire("change", a, b, c, d)
    };
    Ha.prototype._onLocalizedAssetRemove = function(a) {
        this._localizedAsset === a.id && (this.localizedAsset = this._defaultAsset);
        this.fire("remove", a)
    };
    Ha.prototype._onLocaleAdd = function(a, b) {
        this._app.i18n.locale === a && this._onSetLocale(a)
    };
    Ha.prototype._onLocaleRemove = function(a, b) {
        this._app.i18n.locale === a && this._onSetLocale(a)
    };
    Ha.prototype._onSetLocale = function(a) {
        if (this._defaultAsset) {
            var b =
                this._app.assets.get(this._defaultAsset);
            this.localizedAsset = !b || this._disableLocalization ? this._defaultAsset : (a = b.getLocalizedAssetId(a)) ? a : this._defaultAsset
        } else this.localizedAsset = null
    };
    Ha.prototype.destroy = function() {
        this.defaultAsset = null;
        this._app.i18n.off("set:locale", this._onSetLocale, this);
        this.off()
    };
    Object.defineProperty(Ha.prototype, "defaultAsset", {
        get: function() {
            return this._defaultAsset
        },
        set: function(a) {
            a = a instanceof aa ? a.id : a;
            this._defaultAsset !== a && (this._defaultAsset && this._unbindDefaultAsset(),
                (this._defaultAsset = a) && this._bindDefaultAsset(), this._onSetLocale(this._app.i18n.locale))
        }
    });
    Object.defineProperty(Ha.prototype, "localizedAsset", {
        get: function() {
            return this._localizedAsset
        },
        set: function(a) {
            a = a instanceof aa ? a.id : a;
            if (this._localizedAsset !== a && (this._localizedAsset && (this._app.assets.off("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this), this._unbindLocalizedAsset(), this._localizedAsset = null), this._localizedAsset = a))
                if (this._app.assets.get(this._localizedAsset)) this._bindLocalizedAsset();
                else this._app.assets.once("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this)
        }
    });
    Object.defineProperty(Ha.prototype, "autoLoad", {
        get: function() {
            return this._autoLoad
        },
        set: function(a) {
            this._autoLoad !== a && (this._autoLoad = a) && this._localizedAsset && (this._unbindLocalizedAsset(), this._bindLocalizedAsset())
        }
    });
    Object.defineProperty(Ha.prototype, "disableLocalization", {
        get: function() {
            return this._disableLocalization
        },
        set: function(a) {
            this._disableLocalization !== a && (this._disableLocalization = a, this._onSetLocale(this._app.i18n.locale))
        }
    });
    Object.assign(ql.prototype, {
        EOF_TOKEN: 0,
        ERROR_TOKEN: 1,
        TEXT_TOKEN: 2,
        OPEN_BRACKET_TOKEN: 3,
        CLOSE_BRACKET_TOKEN: 4,
        EQUALS_TOKEN: 5,
        STRING_TOKEN: 6,
        IDENTIFIER_TOKEN: 7,
        WHITESPACE_TOKEN: 8,
        WHITESPACE_CHARS: " \t\n\r\v\f",
        IDENTIFIER_REGEX: /[A-Z|a-z|0-9|_|-|/]/,
        read: function() {
            for (var a = this._read(); a === this.WHITESPACE_TOKEN;) a = this._read();
            a !== this.EOF_TOKEN && a !== this.ERROR_TOKEN && (this._last = this._index);
            return a
        },
        buf: function() {
            return this._buf
        },
        last: function() {
            return this._last
        },
        error: function() {
            return this._error
        },
        debugPrint: function() {
            for (var a = "EOF ERROR TEXT OPEN_BRACKET CLOSE_BRACKET EQUALS STRING IDENTIFIER WHITESPACE".split(" "), b = this.read(), c = "";;) {
                c += (0 < c.length ? "\n" : "") + a[b] + " '" + this.buf().join("") + "'";
                if (b === this.EOF_TOKEN || b === this.ERROR_TOKEN) break;
                b = this.read()
            }
            return c
        },
        _read: function() {
            this._buf = [];
            return this._eof() ? this.EOF_TOKEN : "text" === this._mode ? this._text() : this._tag()
        },
        _text: function() {
            for (;;) switch (this._cur) {
                case null:
                    return 0 < this._buf.length ? this.TEXT_TOKEN : this.EOF_TOKEN;
                case "[":
                    return this._mode =
                        "tag", 0 < this._buf.length ? this.TEXT_TOKEN : this._tag();
                case "\\":
                    this._next();
                    switch (this._cur) {
                        case "[":
                            this._store();
                            break;
                        default:
                            this._output("\\")
                    }
                    break;
                default:
                    this._store()
            }
        },
        _tag: function() {
            for (;;) switch (this._cur) {
                case null:
                    return this._error = "unexpected end of input reading tag", this.ERROR_TOKEN;
                case "[":
                    return this._store(), this.OPEN_BRACKET_TOKEN;
                case "]":
                    return this._store(), this._mode = "text", this.CLOSE_BRACKET_TOKEN;
                case "=":
                    return this._store(), this.EQUALS_TOKEN;
                case " ":
                case "\t":
                case "\n":
                case "\r":
                case "\v":
                case "\f":
                    return this._whitespace();
                case '"':
                    return this._string();
                default:
                    return this._isIdentifierSymbol(this._cur) ? this._identifier() : (this._error = "unrecognized character", this.ERROR_TOKEN)
            }
        },
        _whitespace: function() {
            for (this._store(); - 1 !== this.WHITESPACE_CHARS.indexOf(this._cur);) this._store();
            return this.WHITESPACE_TOKEN
        },
        _string: function() {
            for (this._next();;) switch (this._cur) {
                case null:
                    return this._error = "unexpected end of input reading string", this.ERROR_TOKEN;
                case '"':
                    return this._next(), this.STRING_TOKEN;
                default:
                    this._store()
            }
        },
        _identifier: function() {
            for (this._store(); null !== this._cur && this._isIdentifierSymbol(this._cur);) this._store();
            return this.IDENTIFIER_TOKEN
        },
        _isIdentifierSymbol: function(a) {
            return 1 === a.length && null !== a.match(this.IDENTIFIER_REGEX)
        },
        _eof: function() {
            return null === this._cur
        },
        _next: function() {
            this._eof() || (this._index++, this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null);
            return this._cur
        },
        _store: function() {
            this._buf.push(this._cur);
            return this._next()
        },
        _output: function(a) {
            this._buf.push(a)
        }
    });
    var sl = function(a) {
        this._scanner = new ql(a);
        this._error = null
    };
    Object.assign(sl.prototype, {
        parse: function(a, b) {
            for (;;) switch (this._scanner.read()) {
                case this._scanner.EOF_TOKEN:
                    return !0;
                case this._scanner.ERROR_TOKEN:
                    return !1;
                case this._scanner.TEXT_TOKEN:
                    Array.prototype.push.apply(a, this._scanner.buf());
                    break;
                case this._scanner.OPEN_BRACKET_TOKEN:
                    if (!this._parseTag(a, b)) return !1;
                    break;
                default:
                    return !1
            }
        },
        error: function() {
            return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() ||
                this._error) + ")"
        },
        _parseTag: function(a, b) {
            var c = this._scanner.read();
            if (c !== this._scanner.IDENTIFIER_TOKEN) return this._error = "expected identifier", !1;
            c = this._scanner.buf().join("");
            if ("/" === c[0]) {
                for (var d = b.length - 1; 0 <= d; --d)
                    if (c === "/" + b[d].name && null === b[d].end) return b[d].end = a.length, c = this._scanner.read(), c !== this._scanner.CLOSE_BRACKET_TOKEN ? (this._error = "expected close bracket", !1) : !0;
                this._error = "failed to find matching tag";
                return !1
            }
            a = {
                name: c,
                value: null,
                attributes: {},
                start: a.length,
                end: null
            };
            c = this._scanner.read();
            if (c === this._scanner.EQUALS_TOKEN) {
                c = this._scanner.read();
                if (c !== this._scanner.STRING_TOKEN) return this._error = "expected string", !1;
                a.value = this._scanner.buf().join("");
                c = this._scanner.read()
            }
            for (;;) {
                switch (c) {
                    case this._scanner.CLOSE_BRACKET_TOKEN:
                        return b.push(a), !0;
                    case this._scanner.IDENTIFIER_TOKEN:
                        d = this._scanner.buf().join("");
                        c = this._scanner.read();
                        if (c !== this._scanner.EQUALS_TOKEN) return this._error = "expected equals", !1;
                        c = this._scanner.read();
                        if (c !== this._scanner.STRING_TOKEN) return this._error =
                            "expected string", !1;
                        c = this._scanner.buf().join("");
                        a.attributes[d] = c;
                        break;
                    default:
                        return this._error = "expected close bracket or identifier", !1
                }
                c = this._scanner.read()
            }
        }
    });
    tl.evaluate = function(a) {
        return po(a)
    };
    var Ym = /^[\r\n]$/,
        Qp = /^[ \t]$/,
        Rp = /^[ \t\-]$/,
        Sp = "\u061c\u200e\u200f\u202a\u202b\u202c\u202d\u202e\u2066\u2067\u2068\u2069".split(""),
        Tp = {
            width: 0,
            height: 0,
            xadvance: 0,
            xoffset: 0,
            yoffset: 0
        };
    Object.assign(na.prototype, {
        destroy: function() {
            this._setMaterial(null);
            this._model && (this._element.removeModelFromLayers(this._model),
                this._model.destroy(), this._model = null);
            this._fontAsset.destroy();
            this.font = null;
            this._element.off("resize", this._onParentResize, this);
            this._element.off("set:screen", this._onScreenChange, this);
            this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this);
            this._element.off("set:draworder", this._onDrawOrderChange, this);
            this._element.off("set:pivot", this._onPivotChange, this);
            this._system.app.i18n.off("set:locale", this._onLocaleSet, this);
            this._system.app.i18n.off("data:add", this._onLocalizationData,
                this);
            this._system.app.i18n.off("data:remove", this._onLocalizationData, this)
        },
        _onParentResize: function(a, b) {
            this._noResize || this._font && this._updateText()
        },
        _onScreenChange: function(a) {
            a ? this._updateMaterial(a.screen.screenSpace) : this._updateMaterial(!1)
        },
        _onScreenSpaceChange: function(a) {
            this._updateMaterial(a)
        },
        _onDrawOrderChange: function(a) {
            this._drawOrder = a;
            if (this._model) {
                var b;
                var c = 0;
                for (b = this._model.meshInstances.length; c < b; c++) this._model.meshInstances[c].drawOrder = a
            }
        },
        _onPivotChange: function(a) {
            this._font &&
                this._updateText()
        },
        _onLocaleSet: function(a) {
            this._i18nKey && (this.fontAsset && (a = this._system.app.assets.get(this.fontAsset), a && a.resource && a.resource === this._font || (this.font = null)), this._resetLocalizedText())
        },
        _onLocalizationData: function(a, b) {
            this._i18nKey && b[this._i18nKey] && this._resetLocalizedText()
        },
        _resetLocalizedText: function() {
            this._setText(this._system.app.i18n.getText(this._i18nKey))
        },
        _setText: function(a) {
            if (this.unicodeConverter) {
                var b = this._system.getUnicodeConverter();
                b ? a = b(a) : console.warn("Element created with unicodeConverter option but no unicodeConverter function registered")
            }
            this._text !==
                a && (this._font && this._updateText(a), this._text = a)
        },
        _updateText: function(a) {
            var b;
            void 0 === a && (a = this._text);
            this._symbols = vc.getSymbols(a);
            0 === this._symbols.length && (this._symbols = [" "]);
            if (this._enableMarkup) {
                a = tl.evaluate(this._symbols);
                this._symbols = a.symbols;
                var c = a.tags
            }
            this._rtlReorder ? (a = this._system.app.systems.element.getRtlReorder()) ? (a = a(this._symbols), this._rtl = a.rtl, this._symbols = a.mapping.map(function(q) {
                    return this._symbols[q]
                }, this), c && (c = a.mapping.map(function(q) {
                    return c[q]
                }))) :
                console.warn("Element created with rtlReorder option but no rtlReorder function registered") : this._rtl = !1;
            if (c) {
                var d = {};
                this._colorPalette = [Math.round(255 * this._color.r), Math.round(255 * this._color.g), Math.round(255 * this._color.b)];
                this._symbolColors = [];
                a = d[this._color.toString(!1).toLowerCase()] = 0;
                for (b = this._symbols.length; a < b; ++a) {
                    var e = c[a],
                        f = 0;
                    e && e.color && e.color.value && (e = e.color.value, 7 === e.length && "#" === e[0] && (e = e.substring(1).toLowerCase(), d.hasOwnProperty(e) ? f = d[e] : /^([0-9a-f]{2}){3}$/.test(e) &&
                        (f = this._colorPalette.length / 3, d[e] = f, this._colorPalette.push(parseInt(e.substring(0, 2), 16)), this._colorPalette.push(parseInt(e.substring(2, 4), 16)), this._colorPalette.push(parseInt(e.substring(4, 6), 16)))));
                    this._symbolColors.push(f)
                }
            } else this._colorPalette = [], this._symbolColors = null;
            d = this._calculateCharsPerTexture();
            f = !1;
            var g = this._element;
            e = g._isScreenSpace();
            var k = g._isScreenCulled(),
                h = function(q) {
                    return g.isVisibleForCamera(q)
                };
            a = 0;
            for (b = this._meshInfo.length; a < b; a++) {
                var l = d[a] || 0,
                    n = this._meshInfo[a];
                if (n.count !== l)
                    if (f || (g.removeModelFromLayers(this._model), f = !0), n.count = l, n.positions.length = n.normals.length = 12 * l, n.indices.length = 6 * l, n.uvs.length = 8 * l, n.colors.length = 16 * l, n.meshInstance && this._removeMeshInstance(n.meshInstance), 0 === l) n.meshInstance = null;
                    else {
                        for (var p = 0; p < l; p++) n.indices[6 * p] = 4 * p, n.indices[6 * p + 1] = 4 * p + 1, n.indices[6 * p + 2] = 4 * p + 3, n.indices[6 * p + 3] = 4 * p + 2, n.indices[6 * p + 4] = 4 * p + 3, n.indices[6 * p + 5] = 4 * p + 1, n.normals[12 * p] = 0, n.normals[12 * p + 1] = 0, n.normals[12 * p + 2] = -1, n.normals[12 * p + 3] = 0, n.normals[12 *
                            p + 4] = 0, n.normals[12 * p + 5] = -1, n.normals[12 * p + 6] = 0, n.normals[12 * p + 7] = 0, n.normals[12 * p + 8] = -1, n.normals[12 * p + 9] = 0, n.normals[12 * p + 10] = 0, n.normals[12 * p + 11] = -1;
                        l = Qb(this._system.app.graphicsDevice, n.positions, {
                            uvs: n.uvs,
                            normals: n.normals,
                            colors: n.colors,
                            indices: n.indices
                        });
                        l = new va(this._node, l, this._material);
                        l.name = "Text Element: " + this._entity.name;
                        l.castShadow = !1;
                        l.receiveShadow = !1;
                        l.cull = !e;
                        l.screenSpace = e;
                        l.drawOrder = this._drawOrder;
                        k && (l.cull = !0, l.isVisibleFunc = h);
                        this._setTextureParams(l, this._font.textures[a]);
                        this._symbolColors ? (this._colorUniform[0] = 1, this._colorUniform[1] = 1, this._colorUniform[2] = 1) : (this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b);
                        l.setParameter("material_emissive", this._colorUniform);
                        l.setParameter("material_opacity", this._color.a);
                        l.setParameter("font_sdfIntensity", this._font.intensity);
                        l.setParameter("font_pxrange", this._getPxRange(this._font));
                        l.setParameter("font_textureWidth", this._font.data.info.maps[a].width);
                        this._outlineColorUniform[0] =
                            this._outlineColor.r;
                        this._outlineColorUniform[1] = this._outlineColor.g;
                        this._outlineColorUniform[2] = this._outlineColor.b;
                        this._outlineColorUniform[3] = this._outlineColor.a;
                        l.setParameter("outline_color", this._outlineColorUniform);
                        l.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
                        this._shadowColorUniform[0] = this._shadowColor.r;
                        this._shadowColorUniform[1] = this._shadowColor.g;
                        this._shadowColorUniform[2] = this._shadowColor.b;
                        this._shadowColorUniform[3] = this._shadowColor.a;
                        l.setParameter("shadow_color", this._shadowColorUniform);
                        p = this._font.data.info.maps[a].width / this._font.data.info.maps[a].height;
                        this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
                        this._shadowOffsetUniform[1] = p * this._shadowOffsetScale * this._shadowOffset.y;
                        l.setParameter("shadow_offset", this._shadowOffsetUniform);
                        n.meshInstance = l;
                        this._model.meshInstances.push(l)
                    }
            }
            this._element.maskedBy && this._element._setMaskedBy(this._element.maskedBy);
            f && this._element.enabled && this._entity.enabled &&
                this._element.addModelToLayers(this._model);
            this._updateMeshes();
            this._rangeStart = 0;
            this._rangeEnd = this._symbols.length;
            this._updateRenderRange()
        },
        _removeMeshInstance: function(a) {
            a.material = null;
            var b = a.mesh;
            b && b.destroy();
            a = this._model.meshInstances.indexOf(a); - 1 !== a && this._model.meshInstances.splice(a, 1)
        },
        _setMaterial: function(a) {
            var b;
            this._material = a;
            if (this._model) {
                var c = 0;
                for (b = this._model.meshInstances.length; c < b; c++) this._model.meshInstances[c].material = a
            }
        },
        _updateMaterial: function(a) {
            var b =
                this._element,
                c = b._isScreenCulled(),
                d = function(k) {
                    return b.isVisibleForCamera(k)
                };
            this._material = this._system.getTextElementMaterial(a, this._font && "msdf" === this._font.type);
            if (this._model)
                for (var e = 0, f = this._model.meshInstances.length; e < f; e++) {
                    var g = this._model.meshInstances[e];
                    g.cull = !a;
                    g.material = this._material;
                    g.screenSpace = a;
                    c ? (g.cull = !0, g.isVisibleFunc = d) : g.isVisibleFunc = null
                }
        },
        _updateMeshes: function() {
            function a(qc, Uc, og) {
                c._lineWidths.push(Math.abs(og));
                qc = qc.slice(t > Uc ? Uc + 1 : t, t > Uc ? t + 1 : Uc);
                if (v)
                    for (og = qc.length; og-- && 0 < v;) Ym.test(qc[og]) && (qc.splice(og, 1), v--);
                c._lineContents.push(qc.join(""));
                k = 0;
                h -= c._scaledLineHeight;
                p++;
                q = v = x = u = 0;
                t = Uc
            }
            var b = this._font.data,
                c = this,
                d = Math.min(this._minFontSize, this._maxFontSize),
                e = this._maxFontSize,
                f = this._shouldAutoFit();
            f && (this._fontSize = this._maxFontSize);
            var g = this._symbols.length,
                k = 0,
                h = 0,
                l = 0,
                n = 0,
                p = 1,
                q = 0,
                r = 0,
                t = 0,
                u = 0,
                x = 0,
                v = 0,
                w = 1E-4 <= Math.abs(this._element.anchor.x - this._element.anchor.z),
                y = this._element.calculatedWidth;
            if (this.autoWidth && !w ||
                !this._wrapLines) y = Number.POSITIVE_INFINITY;
            var A = 0;
            w = 0;
            for (var B = 1, E, D, C, G = !0; G;) {
                G = !1;
                this._scaledLineHeight = f ? this._lineHeight * this._fontSize / (this._maxFontSize || 1E-4) : this._lineHeight;
                this.height = this.width = 0;
                this._lineWidths = [];
                this._lineContents = [];
                n = l = h = k = 0;
                p = 1;
                v = x = u = t = r = q = 0;
                B = this._fontSize / 32;
                A = this._fontMinY * B;
                w = this._fontMaxY * B;
                for (C = 0; C < this._meshInfo.length; C++) this._meshInfo[C].quad = 0, this._meshInfo[C].lines = {};
                var K = 255,
                    R = 255,
                    I = 255;
                for (C = 0; C < g; C++) {
                    E = this._symbols[C];
                    var T = 0,
                        S = 0,
                        ba =
                        0,
                        ha = 1;
                    D = b.chars[E];
                    if (!D)
                        if (-1 !== Sp.indexOf(E)) D = Tp;
                        else if (b.chars[" "]) D = b.chars[" "];
                    else
                        for (var W in b.chars) {
                            D = b.chars[W];
                            break
                        }
                    if (D) {
                        var Q = 0;
                        0 < x && (ba = this._font.data.kerning) && (ba = ba[vc.getCodePoint(this._symbols[C - 1]) || 0]) && (Q = ba[vc.getCodePoint(this._symbols[C]) || 0] || 0);
                        ba = D.scale || 1;
                        var Nb = (D.width + D.height) / 2;
                        ha = B * Nb / ba;
                        ba = (D.xadvance + Q) * B;
                        T = (D.xoffset - Q) * B;
                        S = D.yoffset * B
                    } else console.error("Couldn't substitute missing character: '" + E + "'");
                    if (Nb = Ym.test(E)) {
                        if (v++, 0 > this._maxLines || p < this._maxLines) a(this._symbols,
                            C, n), r = C + 1, t = C + 1
                    } else {
                        var df = Qp.test(E);
                        Q = this._meshInfo[D && D.map || 0];
                        var Ea = k + this._spacing * ba;
                        if (Ea > y && 0 < x && !df && (0 > this._maxLines || p < this._maxLines))
                            if (0 === u) r = C, a(this._symbols, C, n);
                            else {
                                D = Math.max(C - r, 0);
                                if (1 >= this._meshInfo.length) Q.lines[p - 1] -= D, Q.quad -= D;
                                else
                                    for (Q = C, E = r; E < Q; E++) ba = b.chars[this._symbols[E]], ba = this._meshInfo[ba && ba.map || 0], --ba.lines[p - 1], --ba.quad;
                                C -= D + 1;
                                a(this._symbols, r, q);
                                continue
                            }
                        D = Q.quad;
                        Q.lines[p - 1] = D;
                        var mb = k - T,
                            Dc = mb + ha;
                        S = h - S;
                        var Tc = S + ha;
                        this._rtl && (ha = ha - T - this._spacing *
                            ba - T, mb -= ha, Dc -= ha);
                        Q.positions[12 * D] = mb;
                        Q.positions[12 * D + 1] = S;
                        Q.positions[12 * D + 2] = l;
                        Q.positions[12 * D + 3] = Dc;
                        Q.positions[12 * D + 4] = S;
                        Q.positions[12 * D + 5] = l;
                        Q.positions[12 * D + 6] = Dc;
                        Q.positions[12 * D + 7] = Tc;
                        Q.positions[12 * D + 8] = l;
                        Q.positions[12 * D + 9] = mb;
                        Q.positions[12 * D + 10] = Tc;
                        Q.positions[12 * D + 11] = l;
                        this.width = Math.max(this.width, Ea);
                        if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth && (ha = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 1E-4)), ha = N.clamp(ha, d,
                                e), ha !== this._element.fontSize)) {
                            this._fontSize = ha;
                            G = !0;
                            break
                        }
                        this.height = Math.max(this.height, w - (h + A));
                        if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight && (ha = N.clamp(this._fontSize - 1, d, e), ha !== this._element.fontSize)) {
                            this._fontSize = ha;
                            G = !0;
                            break
                        }
                        k += this._spacing * ba;
                        df || Nb || (n = k);
                        Rp.test(E) && (u++, q = n, r = C + 1);
                        x++;
                        E = this._getUv(E);
                        Q.uvs[8 * D] = E[0];
                        Q.uvs[8 * D + 1] = E[1];
                        Q.uvs[8 * D + 2] = E[2];
                        Q.uvs[8 * D + 3] = E[1];
                        Q.uvs[8 * D + 4] = E[2];
                        Q.uvs[8 * D + 5] = E[3];
                        Q.uvs[8 * D + 6] = E[0];
                        Q.uvs[8 * D + 7] = E[3];
                        this._symbolColors &&
                            (I = 3 * this._symbolColors[C], K = this._colorPalette[I], R = this._colorPalette[I + 1], I = this._colorPalette[I + 2]);
                        Q.colors[16 * D] = K;
                        Q.colors[16 * D + 1] = R;
                        Q.colors[16 * D + 2] = I;
                        Q.colors[16 * D + 3] = 255;
                        Q.colors[16 * D + 4] = K;
                        Q.colors[16 * D + 5] = R;
                        Q.colors[16 * D + 6] = I;
                        Q.colors[16 * D + 7] = 255;
                        Q.colors[16 * D + 8] = K;
                        Q.colors[16 * D + 9] = R;
                        Q.colors[16 * D + 10] = I;
                        Q.colors[16 * D + 11] = 255;
                        Q.colors[16 * D + 12] = K;
                        Q.colors[16 * D + 13] = R;
                        Q.colors[16 * D + 14] = I;
                        Q.colors[16 * D + 15] = 255;
                        Q.quad++
                    }
                }
                G || t < g && a(this._symbols, g, k)
            }
            this._noResize = !0;
            this.autoWidth = this._autoWidth;
            this.autoHeight = this._autoHeight;
            this._noResize = !1;
            b = this._element.pivot.x;
            d = this._element.pivot.y;
            e = this._alignment.x;
            f = this._alignment.y;
            for (C = 0; C < this._meshInfo.length; C++)
                if (0 !== this._meshInfo[C].count) {
                    W = 0;
                    for (var nb in this._meshInfo[C].lines) {
                        g = this._meshInfo[C].lines[nb];
                        y = this._lineWidths[parseInt(nb, 10)];
                        y = -b * this._element.calculatedWidth + e * (this._element.calculatedWidth - y) * (this._rtl ? -1 : 1);
                        l = (1 - d) * this._element.calculatedHeight - w - (1 - f) * (this._element.calculatedHeight - this.height);
                        for (D =
                            W; D <= g; D++) this._meshInfo[C].positions[12 * D] += y, this._meshInfo[C].positions[12 * D + 3] += y, this._meshInfo[C].positions[12 * D + 6] += y, this._meshInfo[C].positions[12 * D + 9] += y, this._meshInfo[C].positions[12 * D + 1] += l, this._meshInfo[C].positions[12 * D + 4] += l, this._meshInfo[C].positions[12 * D + 7] += l, this._meshInfo[C].positions[12 * D + 10] += l;
                        if (this._rtl)
                            for (D = W; D <= g; D++) {
                                W = 12 * D;
                                for (l = 0; 4 > l; ++l) this._meshInfo[C].positions[W + 3 * l] = this._element.calculatedWidth - this._meshInfo[C].positions[W + 3 * l] + 2 * y;
                                l = this._meshInfo[C].positions[W +
                                    3];
                                n = this._meshInfo[C].positions[W + 6];
                                this._meshInfo[C].positions[W + 3] = this._meshInfo[C].positions[W + 0];
                                this._meshInfo[C].positions[W + 6] = this._meshInfo[C].positions[W + 9];
                                this._meshInfo[C].positions[W + 0] = l;
                                this._meshInfo[C].positions[W + 9] = n
                            }
                        W = g + 1
                    }
                    g = 4 * this._meshInfo[C].count;
                    y = 4 * this._meshInfo[C].quad;
                    D = new Pb(this._meshInfo[C].meshInstance.mesh.vertexBuffer);
                    for (W = 0; W < g; W++) W >= y ? (D.element.POSITION.set(0, 0, 0), D.element.TEXCOORD0.set(0, 0), D.element.COLOR.set(0, 0, 0, 0)) : (D.element.POSITION.set(this._meshInfo[C].positions[3 *
                        W], this._meshInfo[C].positions[3 * W + 1], this._meshInfo[C].positions[3 * W + 2]), D.element.TEXCOORD0.set(this._meshInfo[C].uvs[2 * W], this._meshInfo[C].uvs[2 * W + 1]), D.element.COLOR.set(this._meshInfo[C].colors[4 * W], this._meshInfo[C].colors[4 * W + 1], this._meshInfo[C].colors[4 * W + 2], this._meshInfo[C].colors[4 * W + 3])), D.next();
                    D.end();
                    this._meshInfo[C].meshInstance.mesh.aabb.compute(this._meshInfo[C].positions);
                    this._meshInfo[C].meshInstance._aabbVer = -1
                }
            this._aabbDirty = !0
        },
        _onFontRender: function() {
            this.font = this._font
        },
        _onFontLoad: function(a) {
            this.font !== a.resource && (this.font = a.resource)
        },
        _onFontChange: function(a, b, c, d) {
            if ("data" === b)
                for (this._font.data = c, a = this._font.data.info.maps.length, b = 0; b < a; b++) this._meshInfo[b] && (c = this._meshInfo[b].meshInstance) && (c.setParameter("font_sdfIntensity", this._font.intensity), c.setParameter("font_pxrange", this._getPxRange(this._font)), c.setParameter("font_textureWidth", this._font.data.info.maps[b].width))
        },
        _onFontRemove: function(a) {},
        _setTextureParams: function(a, b) {
            this._font &&
                ("msdf" === this._font.type ? (a.deleteParameter("texture_emissiveMap"), a.deleteParameter("texture_opacityMap"), a.setParameter("texture_msdfMap", b)) : "bitmap" === this._font.type && (a.deleteParameter("texture_msdfMap"), a.setParameter("texture_emissiveMap", b), a.setParameter("texture_opacityMap", b)))
        },
        _getPxRange: function(a) {
            a = Object.keys(this._font.data.chars);
            for (var b = 0; b < a.length; b++) {
                var c = this._font.data.chars[a[b]];
                if (c.range) return (c.scale || 1) * c.range
            }
            return 2
        },
        _getUv: function(a) {
            var b = this._font.data;
            if (!b.chars[a]) return b.chars[" "] ? this._getUv(" ") : [0, 0, 0, 0];
            var c = b.chars[a].map,
                d = b.info.maps[c].width;
            c = b.info.maps[c].height;
            var e = b.chars[a].x,
                f = b.chars[a].y,
                g = 1 - b.chars[a].height / c;
            return [e / d, g - f / c, (e + b.chars[a].width) / d, g - (f - b.chars[a].height) / c]
        },
        onEnable: function() {
            this._fontAsset.autoLoad = !0;
            this._model && this._element.addModelToLayers(this._model)
        },
        onDisable: function() {
            this._fontAsset.autoLoad = !1;
            this._model && this._element.removeModelFromLayers(this._model)
        },
        _setStencil: function(a) {
            if (this._model)
                for (var b =
                        this._model.meshInstances, c = 0; c < b.length; c++) b[c].stencilFront = a, b[c].stencilBack = a
        },
        _shouldAutoFitWidth: function() {
            return this._autoFitWidth && !this._autoWidth
        },
        _shouldAutoFitHeight: function() {
            return this._autoFitHeight && !this._autoHeight
        },
        _shouldAutoFit: function() {
            return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight
        },
        _calculateCharsPerTexture: function(a) {
            var b = {};
            void 0 === a && (a = this._symbols.length);
            var c;
            for (c = 0; c < a; c++) {
                var d = this._symbols[c];
                d = this._font.data.chars[d];
                d || (d = this._font.data.chars[" "]) || (d = this._font.data.chars[Object.keys(this._font.data.chars)[0]]);
                d = d.map;
                b[d] ? b[d]++ : b[d] = 1
            }
            return b
        },
        _updateRenderRange: function() {
            var a = 0 === this._rangeStart ? 0 : this._calculateCharsPerTexture(this._rangeStart),
                b = 0 === this._rangeEnd ? 0 : this._calculateCharsPerTexture(this._rangeEnd),
                c;
            var d = 0;
            for (c = this._meshInfo.length; d < c; d++) {
                var e = a[d] || 0,
                    f = b[d] || 0,
                    g = this._meshInfo[d].meshInstance;
                g && (g = g.mesh) && (g.primitive[0].base = 6 * e, g.primitive[0].count = 6 * (f - e))
            }
        }
    });
    Object.defineProperty(na.prototype,
        "text", {
            get: function() {
                return this._text
            },
            set: function(a) {
                this._i18nKey = null;
                this._setText(null != a && a.toString() || "")
            }
        });
    Object.defineProperty(na.prototype, "key", {
        get: function() {
            return this._i18nKey
        },
        set: function(a) {
            a = null !== a ? a.toString() : null;
            this._i18nKey !== a && ((this._i18nKey = a) ? (this._fontAsset.disableLocalization = !1, this._resetLocalizedText()) : this._fontAsset.disableLocalization = !0)
        }
    });
    Object.defineProperty(na.prototype, "color", {
        get: function() {
            return this._color
        },
        set: function(a) {
            var b = a.r,
                c =
                a.g;
            a = a.b;
            if (this._color.r !== b || this._color.g !== c || this._color.b !== a)
                if (this._color.r = b, this._color.g = c, this._color.b = a, this._symbolColors) this._font && this._updateText();
                else
                    for (this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b, b = 0, c = this._model.meshInstances.length; b < c; b++) this._model.meshInstances[b].setParameter("material_emissive", this._colorUniform)
        }
    });
    Object.defineProperty(na.prototype, "opacity", {
        get: function() {
            return this._color.a
        },
        set: function(a) {
            if (this._color.a !== a && (this._color.a = a, this._model))
                for (var b = 0, c = this._model.meshInstances.length; b < c; b++) this._model.meshInstances[b].setParameter("material_opacity", a)
        }
    });
    Object.defineProperty(na.prototype, "lineHeight", {
        get: function() {
            return this._lineHeight
        },
        set: function(a) {
            var b = this._lineHeight;
            this._scaledLineHeight = this._lineHeight = a;
            b !== a && this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "wrapLines", {
        get: function() {
            return this._wrapLines
        },
        set: function(a) {
            var b =
                this._wrapLines;
            this._wrapLines = a;
            b !== a && this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "lines", {
        get: function() {
            return this._lineContents
        }
    });
    Object.defineProperty(na.prototype, "spacing", {
        get: function() {
            return this._spacing
        },
        set: function(a) {
            var b = this._spacing;
            this._spacing = a;
            b !== a && this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "fontSize", {
        get: function() {
            return this._fontSize
        },
        set: function(a) {
            var b = this._fontSize;
            this._originalFontSize = this._fontSize = a;
            b !== a && this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "fontAsset", {
        get: function() {
            return this._fontAsset.localizedAsset
        },
        set: function(a) {
            this._fontAsset.defaultAsset = a
        }
    });
    Object.defineProperty(na.prototype, "font", {
        get: function() {
            return this._font
        },
        set: function(a) {
            if (this._font) {
                var b = this._font.type;
                this._font.off && this._font.off("render", this._onFontRender, this)
            }
            this._font = a;
            this._fontMaxY = this._fontMinY = 0;
            if (a) {
                var c = this._font.data,
                    d;
                for (d in c.chars) {
                    var e = c.chars[d];
                    e.bounds &&
                        (this._fontMinY = Math.min(this._fontMinY, e.bounds[1]), this._fontMaxY = Math.max(this._fontMaxY, e.bounds[3]))
                }
                if (this._font.on) this._font.on("render", this._onFontRender, this);
                this._fontAsset.localizedAsset && this._system.app.assets.get(this._fontAsset.localizedAsset).resource !== this._font && (this._fontAsset.defaultAsset = null);
                a.type !== b && (a = this._element._isScreenSpace(), this._updateMaterial(a));
                a = 0;
                for (b = this._font.textures.length; a < b; a++)
                    if (this._meshInfo[a]) {
                        if (c = this._meshInfo[a].meshInstance) c.setParameter("font_sdfIntensity",
                            this._font.intensity), c.setParameter("font_pxrange", this._getPxRange(this._font)), c.setParameter("font_textureWidth", this._font.data.info.maps[a].width), this._setTextureParams(c, this._font.textures[a])
                    } else this._meshInfo[a] = new qo;
                b = !1;
                for (a = this._font.textures.length; a < this._meshInfo.length; a++) this._meshInfo[a].meshInstance && (b || (this._element.removeModelFromLayers(this._model), b = !0), this._removeMeshInstance(this._meshInfo[a].meshInstance));
                this._meshInfo.length > this._font.textures.length && (this._meshInfo.length =
                    this._font.textures.length);
                this._updateText()
            }
        }
    });
    Object.defineProperty(na.prototype, "alignment", {
        get: function() {
            return this._alignment
        },
        set: function(a) {
            a instanceof P ? this._alignment.set(a.x, a.y) : this._alignment.set(a[0], a[1]);
            this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "autoWidth", {
        get: function() {
            return this._autoWidth
        },
        set: function(a) {
            var b = this._autoWidth;
            (this._autoWidth = a) && 1E-4 > Math.abs(this._element.anchor.x - this._element.anchor.z) && (this._element.width = this.width);
            b !== a && (a = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize, a !== this._fontSize && (this._fontSize = a, this._font && this._updateText()))
        }
    });
    Object.defineProperty(na.prototype, "autoHeight", {
        get: function() {
            return this._autoHeight
        },
        set: function(a) {
            var b = this._autoHeight;
            (this._autoHeight = a) && 1E-4 > Math.abs(this._element.anchor.y - this._element.anchor.w) && (this._element.height = this.height);
            b !== a && (a = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize, a !== this._fontSize && (this._fontSize =
                a, this._font && this._updateText()))
        }
    });
    Object.defineProperty(na.prototype, "rtlReorder", {
        get: function() {
            return this._rtlReorder
        },
        set: function(a) {
            this._rtlReorder !== a && (this._rtlReorder = a, this._font && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "unicodeConverter", {
        get: function() {
            return this._unicodeConverter
        },
        set: function(a) {
            this._unicodeConverter !== a && (this._unicodeConverter = a, this._setText(this._text))
        }
    });
    Object.defineProperty(na.prototype, "aabb", {
        get: function() {
            if (this._aabbDirty) {
                for (var a = !1, b = 0; b < this._meshInfo.length; b++) this._meshInfo[b].meshInstance && (a ? this._aabb.add(this._meshInfo[b].meshInstance.aabb) : (this._aabb.copy(this._meshInfo[b].meshInstance.aabb), a = !0));
                this._aabbDirty = !1
            }
            return this._aabb
        }
    });
    Object.defineProperty(na.prototype, "outlineColor", {
        get: function() {
            return this._outlineColor
        },
        set: function(a) {
            var b = a instanceof L ? a.r : a[0],
                c = a instanceof L ? a.g : a[1],
                d = a instanceof L ? a.b : a[2];
            a = a instanceof L ? a.a : a[3];
            if (this._outlineColor.r !== b || this._outlineColor.g !== c || this._outlineColor.b !==
                d || this._outlineColor.a !== a)
                if (this._outlineColor.r = b, this._outlineColor.g = c, this._outlineColor.b = d, this._outlineColor.a = a, this._model)
                    for (this._outlineColorUniform[0] = this._outlineColor.r, this._outlineColorUniform[1] = this._outlineColor.g, this._outlineColorUniform[2] = this._outlineColor.b, this._outlineColorUniform[3] = this._outlineColor.a, b = 0, c = this._model.meshInstances.length; b < c; b++) this._model.meshInstances[b].setParameter("outline_color", this._outlineColorUniform)
        }
    });
    Object.defineProperty(na.prototype,
        "outlineThickness", {
            get: function() {
                return this._outlineThickness
            },
            set: function(a) {
                var b = this._outlineThickness;
                this._outlineThickness = a;
                if (b !== a && this._font && this._model)
                    for (a = 0, b = this._model.meshInstances.length; a < b; a++) this._model.meshInstances[a].setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness)
            }
        });
    Object.defineProperty(na.prototype, "shadowColor", {
        get: function() {
            return this._shadowColor
        },
        set: function(a) {
            var b = a instanceof L ? a.r : a[0],
                c = a instanceof L ? a.g : a[1],
                d = a instanceof L ? a.b : a[2];
            a = a instanceof L ? a.a : a[3];
            if (this._shadowColor.r !== b || this._shadowColor.g !== c || this._shadowColor.b !== d || this._shadowColor.a !== a)
                if (this._shadowColor.r = b, this._shadowColor.g = c, this._shadowColor.b = d, this._shadowColor.a = a, this._model)
                    for (this._shadowColorUniform[0] = this._shadowColor.r, this._shadowColorUniform[1] = this._shadowColor.g, this._shadowColorUniform[2] = this._shadowColor.b, this._shadowColorUniform[3] = this._shadowColor.a, b = 0, c = this._model.meshInstances.length; b < c; b++) this._model.meshInstances[b].setParameter("shadow_color",
                        this._shadowColorUniform)
        }
    });
    Object.defineProperty(na.prototype, "shadowOffset", {
        get: function() {
            return this._shadowOffset
        },
        set: function(a) {
            var b = a instanceof P ? a.x : a[0];
            a = a instanceof P ? a.y : a[1];
            if (this._shadowOffset.x !== b || this._shadowOffset.y !== a)
                if (this._shadowOffset.set(b, a), this._font && this._model)
                    for (b = 0, a = this._model.meshInstances.length; b < a; b++) {
                        var c = this._font.data.info.maps[b].width / this._font.data.info.maps[b].height;
                        this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
                        this._shadowOffsetUniform[1] = c * this._shadowOffsetScale * this._shadowOffset.y;
                        this._model.meshInstances[b].setParameter("shadow_offset", this._shadowOffsetUniform)
                    }
        }
    });
    Object.defineProperty(na.prototype, "minFontSize", {
        get: function() {
            return this._minFontSize
        },
        set: function(a) {
            this._minFontSize !== a && (this._minFontSize = a, this.font && this._shouldAutoFit() && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "maxFontSize", {
        get: function() {
            return this._maxFontSize
        },
        set: function(a) {
            this._maxFontSize !== a &&
                (this._maxFontSize = a, this.font && this._shouldAutoFit() && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "autoFitWidth", {
        get: function() {
            return this._autoFitWidth
        },
        set: function(a) {
            this._autoFitWidth !== a && (this._autoFitWidth = a, this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize, this.font && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "autoFitHeight", {
        get: function() {
            return this._autoFitHeight
        },
        set: function(a) {
            this._autoFitHeight !== a && (this._autoFitHeight =
                a, this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize, this.font && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "maxLines", {
        get: function() {
            return this._maxLines
        },
        set: function(a) {
            this._maxLines === a || null === a && -1 === this._maxLines || (this._maxLines = null === a ? -1 : a, this.font && this._wrapLines && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "enableMarkup", {
        get: function() {
            return this._enableMarkup
        },
        set: function(a) {
            a = !!a;
            this._enableMarkup !== a && (this._enableMarkup =
                a, this.font && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "symbols", {
        get: function() {
            return this._symbols
        }
    });
    Object.defineProperty(na.prototype, "symbolColors", {
        get: function() {
            return null === this._symbolColors ? null : this._symbolColors.map(function(a) {
                return this._colorPalette.slice(3 * a, 3 * a + 3)
            }, this)
        }
    });
    Object.defineProperty(na.prototype, "rtl", {
        get: function() {
            return this._rtl
        }
    });
    Object.defineProperty(na.prototype, "rangeStart", {
        get: function() {
            return this._rangeStart
        },
        set: function(a) {
            a = Math.max(0,
                Math.min(a, this._symbols.length));
            a !== this._rangeStart && (this._rangeStart = a, this._updateRenderRange())
        }
    });
    Object.defineProperty(na.prototype, "rangeEnd", {
        get: function() {
            return this._rangeEnd
        },
        set: function(a) {
            a = Math.max(this._rangeStart, Math.min(a, this._symbols.length));
            a !== this._rangeEnd && (this._rangeEnd = a, this._updateRenderRange())
        }
    });
    var Gc = new z,
        oe = new z,
        bc = new J,
        Nh = new J,
        Oh = new J,
        pf = new J;
    ia.prototype = Object.create(O.prototype);
    ia.prototype.constructor = ia;
    Object.assign(ia.prototype, {
        _patch: function() {
            this.entity._sync =
                this._sync;
            this.entity.setPosition = this._setPosition;
            this.entity.setLocalPosition = this._setLocalPosition
        },
        _unpatch: function() {
            this.entity._sync = fa.prototype._sync;
            this.entity.setPosition = fa.prototype.setPosition;
            this.entity.setLocalPosition = fa.prototype.setLocalPosition
        },
        _setPosition: function() {
            var a = new z,
                b = new J;
            return function(c, d, e) {
                if (!this.element.screen) return fa.prototype.setPosition.call(this, c, d, e);
                c instanceof z ? a.copy(c) : a.set(c, d, e);
                this.getWorldTransform();
                b.copy(this.element._screenToWorld).invert();
                b.transformPoint(a, this.localPosition);
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        _setLocalPosition: function(a, b, c) {
            a instanceof z ? this.localPosition.copy(a) : this.localPosition.set(a, b, c);
            a = this.element;
            b = this.localPosition;
            c = a._pivot;
            a._margin.x = b.x - a._calculatedWidth * c.x;
            a._margin.z = a._localAnchor.z - a._localAnchor.x - a._calculatedWidth - a._margin.x;
            a._margin.y = b.y - a._calculatedHeight * c.y;
            a._margin.w = a._localAnchor.w - a._localAnchor.y - a._calculatedHeight - a._margin.y;
            this._dirtyLocal || this._dirtifyLocal()
        },
        _sync: function() {
            var a = this.element,
                b = a.screen;
            if (b) {
                if (a._anchorDirty) {
                    var c = 0,
                        d = 1;
                    if (this._parent && this._parent.element) {
                        var e = this._parent.element.calculatedWidth;
                        var f = this._parent.element.calculatedHeight;
                        c = this._parent.element.pivot.x;
                        d = this._parent.element.pivot.y
                    } else f = b.screen.resolution, e = f.x / b.screen.scale, f = f.y / b.screen.scale;
                    a._anchorTransform.setTranslate(e * (a.anchor.x - c), -(f * (d - a.anchor.y)), 0);
                    a._anchorDirty = !1;
                    a._calculateLocalAnchors()
                }
                a._sizeDirty && a._calculateSize(!1, !1)
            }
            this._dirtyLocal &&
                (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale), e = this.localPosition, c = a._pivot, a._margin.x = e.x - a._calculatedWidth * c.x, a._margin.z = a._localAnchor.z - a._localAnchor.x - a._calculatedWidth - a._margin.x, a._margin.y = e.y - a._calculatedHeight * c.y, a._margin.w = a._localAnchor.w - a._localAnchor.y - a._calculatedHeight - a._margin.y, this._dirtyLocal = !1);
            if (!b) return this._dirtyWorld && (a._cornersDirty = !0, a._canvasCornersDirty = !0, a._worldCornersDirty = !0), fa.prototype._sync.call(this);
            this._dirtyWorld && (null === this._parent ? this.worldTransform.copy(this.localTransform) : (this._parent.element ? a._screenToWorld.mul2(this._parent.element._modelTransform, a._anchorTransform) : a._screenToWorld.copy(a._anchorTransform), a._modelTransform.mul2(a._screenToWorld, this.localTransform), b ? (a._screenToWorld.mul2(b.screen._screenMatrix, a._screenToWorld), b.screen.screenSpace || a._screenToWorld.mul2(b.worldTransform, a._screenToWorld), this.worldTransform.mul2(a._screenToWorld, this.localTransform), e = a._parentWorldTransform,
                e.setIdentity(), (c = this._parent) && c.element && c !== b && (bc.setTRS(z.ZERO, c.getLocalRotation(), c.getLocalScale()), e.mul2(c.element._parentWorldTransform, bc)), Gc.set(0, 0, this.localPosition.z), oe.set(a._absLeft + a._pivot.x * a.calculatedWidth, a._absBottom + a._pivot.y * a.calculatedHeight, 0), bc.setTranslate(-oe.x, -oe.y, -oe.z), Nh.setTRS(Gc, this.getLocalRotation(), this.getLocalScale()), Oh.setTranslate(oe.x, oe.y, oe.z), a._screenTransform.mul2(a._parentWorldTransform, Oh).mul(Nh).mul(bc), a._cornersDirty = !0, a._canvasCornersDirty = !0, a._worldCornersDirty = !0) : this.worldTransform.copy(a._modelTransform)), this._dirtyWorld = !1)
        },
        _onInsert: function(a) {
            a = this._parseUpToScreen();
            this.entity._dirtifyWorld();
            this._updateScreen(a.screen);
            this._dirtifyMask()
        },
        _dirtifyMask: function() {
            for (var a = this.entity; a;) {
                var b = a.parent;
                if ((null === b || b.screen) && a.element) {
                    this.system._prerender && this.system._prerender.length || (this.system._prerender = [], this.system.app.once("prerender", this._onPrerender, this));
                    var c = this.system._prerender.indexOf(this.entity);
                    0 <= c && this.system._prerender.splice(c, 1);
                    0 > this.system._prerender.indexOf(a) && this.system._prerender.push(a)
                }
                a = b
            }
        },
        _onPrerender: function() {
            for (var a = 0; a < this.system._prerender.length; a++) {
                var b = this.system._prerender[a];
                b.element && b.element.syncMask(1)
            }
            this.system._prerender.length = 0
        },
        _bindScreen: function(a) {
            a.on("set:resolution", this._onScreenResize, this);
            a.on("set:referenceresolution", this._onScreenResize, this);
            a.on("set:scaleblend", this._onScreenResize, this);
            a.on("set:screenspace", this._onScreenSpaceChange,
                this);
            a.on("remove", this._onScreenRemove, this)
        },
        _unbindScreen: function(a) {
            a.off("set:resolution", this._onScreenResize, this);
            a.off("set:referenceresolution", this._onScreenResize, this);
            a.off("set:scaleblend", this._onScreenResize, this);
            a.off("set:screenspace", this._onScreenSpaceChange, this);
            a.off("remove", this._onScreenRemove, this)
        },
        _updateScreen: function(a) {
            this.screen && this.screen !== a && this._unbindScreen(this.screen.screen);
            var b = this.screen;
            (this.screen = a) && this._bindScreen(this.screen.screen);
            this._calculateSize(this._hasSplitAnchorsX,
                this._hasSplitAnchorsY);
            this.fire("set:screen", this.screen, b);
            this._anchorDirty = !0;
            b = this.entity.children;
            for (var c = 0, d = b.length; c < d; c++) b[c].element && b[c].element._updateScreen(a);
            this.screen && this.screen.screen.syncDrawOrder()
        },
        syncMask: function(a) {
            var b = this._parseUpToScreen();
            this._updateMask(b.mask, a)
        },
        _setMaskedBy: function(a) {
            var b = this._image || this._text;
            if (a) {
                var c = new Td({
                    ref: a.element._image._maskRef,
                    func: 2
                });
                b && b._setStencil && b._setStencil(c);
                this._maskedBy = a
            } else b && b._setStencil && b._setStencil(null),
                this._maskedBy = null
        },
        _updateMask: function(a, b) {
            var c;
            a ? (this._setMaskedBy(a), this.mask && (a = new Td({
                ref: a.element._image._maskRef,
                func: 2,
                zpass: 3
            }), this._image._setStencil(a), this._image._maskRef = b, b++, a = this.entity)) : (this._setMaskedBy(null), this.mask && (a = new Td({
                ref: b,
                func: 7,
                zpass: 2
            }), this._image._setStencil(a), this._image._maskRef = b, b++, a = this.entity));
            var d = this.entity.children;
            var e = 0;
            for (c = d.length; e < c; e++) d[e].element && d[e].element._updateMask(a, b)
        },
        _parseUpToScreen: function() {
            for (var a = {
                    screen: null,
                    mask: null
                }, b = this.entity._parent; b && !b.screen;) b.element && b.element.mask && !a.mask && (a.mask = b), b = b.parent;
            b && b.screen && (a.screen = b);
            return a
        },
        _onScreenResize: function(a) {
            this._worldCornersDirty = this._cornersDirty = this._anchorDirty = !0;
            this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
            this.fire("screen:set:resolution", a)
        },
        _onScreenSpaceChange: function() {
            this.fire("screen:set:screenspace", this.screen.screen.screenSpace)
        },
        _onScreenRemove: function() {
            this.screen && (this.screen._destroying ?
                this.screen = null : this._updateScreen(null))
        },
        _calculateLocalAnchors: function() {
            var a = 1E3,
                b = 1E3,
                c = this.entity._parent;
            c && c.element ? (a = c.element.calculatedWidth, b = c.element.calculatedHeight) : this.screen && (b = this.screen.screen.resolution, c = this.screen.screen.scale, a = b.x / c, b = b.y / c);
            this._localAnchor.set(this._anchor.x * a, this._anchor.y * b, this._anchor.z * a, this._anchor.w * b)
        },
        getOffsetPosition: function(a, b) {
            var c = this.entity.getLocalPosition().clone();
            c.x += a;
            c.y += b;
            this._screenToWorld.transformPoint(c, c);
            return c
        },
        onLayersChanged: function(a, b) {
            this.addModelToLayers(this._image ? this._image._model : this._text._model);
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || (this._image ? a.addMeshInstances(this._image._model.meshInstances) : this._text && a.addMeshInstances(this._text._model.meshInstances))
        },
        onLayerRemoved: function(a) {
            0 > this.layers.indexOf(a.id) ||
                (this._image ? a.removeMeshInstances(this._image._model.meshInstances) : this._text && a.removeMeshInstances(this._text._model.meshInstances))
        },
        onEnable: function() {
            if (this._image) this._image.onEnable();
            if (this._text) this._text.onEnable();
            if (this._group) this._group.onEnable();
            this.useInput && this.system.app.elementInput && this.system.app.elementInput.addElement(this);
            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded,
                this), this.system.app.scene.layers.on("remove", this.onLayerRemoved, this));
            0 <= this._batchGroupId && this.system.app.batcher.insert(bb.ELEMENT, this.batchGroupId, this.entity);
            this.fire("enableelement")
        },
        onDisable: function() {
            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this), this.system.app.scene.layers.off("remove", this.onLayerRemoved, this));
            if (this._image) this._image.onDisable();
            if (this._text) this._text.onDisable();
            if (this._group) this._group.onDisable();
            this.system.app.elementInput && this.useInput && this.system.app.elementInput.removeElement(this);
            0 <= this._batchGroupId && this.system.app.batcher.remove(bb.ELEMENT, this.batchGroupId, this.entity);
            this.fire("disableelement")
        },
        onRemove: function() {
            this.entity.off("insert", this._onInsert, this);
            this._unpatch();
            this._image && this._image.destroy();
            this._text && this._text.destroy();
            this.system.app.elementInput && this.useInput && this.system.app.elementInput.removeElement(this);
            this.screen && this.screen.screen && (this._unbindScreen(this.screen.screen), this.screen.screen.syncDrawOrder());
            this.off()
        },
        _calculateSize: function(a, b) {
            if (this.entity._parent || this.screen) {
                this._calculateLocalAnchors();
                var c = this._absRight - this._absLeft,
                    d = this._absTop - this._absBottom;
                a ? this._setWidth(c) : this._setCalculatedWidth(c, !1);
                b ? this._setHeight(d) : this._setCalculatedHeight(d, !1);
                a = this.entity.getLocalPosition();
                a.x = this._margin.x + this._calculatedWidth * this._pivot.x;
                a.y = this._margin.y + this._calculatedHeight *
                    this._pivot.y;
                this.entity.setLocalPosition(a);
                this._sizeDirty = !1
            }
        },
        _setWidth: function(a) {
            this._width = a;
            this._setCalculatedWidth(a, !1);
            this.fire("set:width", this._width)
        },
        _setHeight: function(a) {
            this._height = a;
            this._setCalculatedHeight(a, !1);
            this.fire("set:height", this._height)
        },
        _setCalculatedWidth: function(a, b) {
            1E-4 >= Math.abs(a - this._calculatedWidth) || (this._calculatedWidth = a, this.entity._dirtifyLocal(), b && (a = this.entity.getLocalPosition(), this._margin.x = a.x - this._calculatedWidth * this._pivot.x, this._margin.z =
                this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x), this._flagChildrenAsDirty(), this.fire("set:calculatedWidth", this._calculatedWidth), this.fire("resize", this._calculatedWidth, this._calculatedHeight))
        },
        _setCalculatedHeight: function(a, b) {
            1E-4 >= Math.abs(a - this._calculatedHeight) || (this._calculatedHeight = a, this.entity._dirtifyLocal(), b && (a = this.entity.getLocalPosition(), this._margin.y = a.y - this._calculatedHeight * this._pivot.y, this._margin.w = this._localAnchor.w - this._localAnchor.y -
                this._calculatedHeight - this._margin.y), this._flagChildrenAsDirty(), this.fire("set:calculatedHeight", this._calculatedHeight), this.fire("resize", this._calculatedWidth, this._calculatedHeight))
        },
        _flagChildrenAsDirty: function() {
            var a, b = this.entity._children;
            var c = 0;
            for (a = b.length; c < a; c++) b[c].element && (b[c].element._anchorDirty = !0, b[c].element._sizeDirty = !0)
        },
        addModelToLayers: function(a) {
            var b;
            this._addedModels.push(a);
            for (var c = 0; c < this.layers.length; c++)(b = this.system.app.scene.layers.getLayerById(this.layers[c])) &&
                b.addMeshInstances(a.meshInstances)
        },
        removeModelFromLayers: function(a) {
            var b = this._addedModels.indexOf(a);
            0 <= b && this._addedModels.splice(b, 1);
            for (var c = 0; c < this.layers.length; c++)(b = this.system.app.scene.layers.getLayerById(this.layers[c])) && b.removeMeshInstances(a.meshInstances)
        },
        getMaskOffset: function() {
            var a = this.system.app.frame;
            this._offsetReadAt !== a && (this._maskOffset = .5, this._offsetReadAt = a);
            a = this._maskOffset;
            this._maskOffset -= .001;
            return a
        },
        isVisibleForCamera: function(a) {
            if (this.maskedBy) {
                a =
                    this.maskedBy.element.screenCorners;
                var b = Math.min(Math.min(a[0].x, a[1].x), Math.min(a[2].x, a[3].x));
                var c = Math.max(Math.max(a[0].x, a[1].x), Math.max(a[2].x, a[3].x));
                var d = Math.min(Math.min(a[0].y, a[1].y), Math.min(a[2].y, a[3].y));
                a = Math.max(Math.max(a[0].y, a[1].y), Math.max(a[2].y, a[3].y))
            } else {
                b = this.system.app.graphicsDevice.width;
                var e = this.system.app.graphicsDevice.height;
                c = a._rect.z * b;
                d = a._rect.w * e;
                b *= a._rect.x;
                c = b + c;
                a = (1 - a._rect.y) * e;
                d = a - d
            }
            e = this.screenCorners;
            var f = Math.min(Math.min(e[0].x, e[1].x),
                    Math.min(e[2].x, e[3].x)),
                g = Math.min(Math.min(e[0].y, e[1].y), Math.min(e[2].y, e[3].y)),
                k = Math.max(Math.max(e[0].y, e[1].y), Math.max(e[2].y, e[3].y));
            return Math.max(Math.max(e[0].x, e[1].x), Math.max(e[2].x, e[3].x)) < b || f > c || g > a || k < d ? !1 : !0
        },
        _isScreenSpace: function() {
            return this.screen && this.screen.screen ? this.screen.screen.screenSpace : !1
        },
        _isScreenCulled: function() {
            return this.screen && this.screen.screen ? this.screen.screen.cull : !1
        }
    });
    Object.defineProperty(ia.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            a !== this._type && (this._type = a, this._image && (this._image.destroy(), this._image = null), this._text && (this._text.destroy(), this._text = null), "image" === a ? this._image = new cb(this) : "text" === a && (this._text = new na(this)))
        }
    });
    Object.defineProperty(ia.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            var b, c, d;
            if (this._addedModels.length)
                for (b = 0; b < this._layers.length; b++)
                    if (d = this.system.app.scene.layers.getLayerById(this._layers[b]))
                        for (c = 0; c < this._addedModels.length; c++) d.removeMeshInstances(this._addedModels[c].meshInstances);
            this._layers = a;
            if (this.enabled && this.entity.enabled && this._addedModels.length)
                for (b = 0; b < this._layers.length; b++)
                    if (d = this.system.app.scene.layers.getLayerById(this._layers[b]))
                        for (c = 0; c < this._addedModels.length; c++) d.addMeshInstances(this._addedModels[c].meshInstances)
        }
    });
    Object.defineProperty(ia.prototype, "drawOrder", {
        get: function() {
            return this._drawOrder
        },
        set: function(a) {
            var b = 0;
            this.screen && (b = this.screen.screen.priority);
            16777215 < a && (a = 16777215);
            this._drawOrder = (b << 24) + a;
            this.fire("set:draworder",
                this._drawOrder)
        }
    });
    Object.defineProperty(ia.prototype, "_absLeft", {
        get: function() {
            return this._localAnchor.x + this._margin.x
        }
    });
    Object.defineProperty(ia.prototype, "_absRight", {
        get: function() {
            return this._localAnchor.z - this._margin.z
        }
    });
    Object.defineProperty(ia.prototype, "_absTop", {
        get: function() {
            return this._localAnchor.w - this._margin.w
        }
    });
    Object.defineProperty(ia.prototype, "_absBottom", {
        get: function() {
            return this._localAnchor.y + this._margin.y
        }
    });
    Object.defineProperty(ia.prototype, "margin", {
        get: function() {
            return this._margin
        },
        set: function(a) {
            this._margin.copy(a);
            this._calculateSize(!0, !0);
            this.fire("set:margin", this._margin)
        }
    });
    Object.defineProperty(ia.prototype, "left", {
        get: function() {
            return this._margin.x
        },
        set: function(a) {
            this._margin.x = a;
            var b = this.entity.getLocalPosition();
            this._setWidth(this._absRight - (this._localAnchor.x + a));
            b.x = a + this._calculatedWidth * this._pivot.x;
            this.entity.setLocalPosition(b)
        }
    });
    Object.defineProperty(ia.prototype, "right", {
        get: function() {
            return this._margin.z
        },
        set: function(a) {
            this._margin.z = a;
            var b = this.entity.getLocalPosition();
            this._setWidth(this._localAnchor.z - a - this._absLeft);
            b.x = this._localAnchor.z - this._localAnchor.x - a - this._calculatedWidth * (1 - this._pivot.x);
            this.entity.setLocalPosition(b)
        }
    });
    Object.defineProperty(ia.prototype, "top", {
        get: function() {
            return this._margin.w
        },
        set: function(a) {
            this._margin.w = a;
            var b = this.entity.getLocalPosition();
            this._setHeight(this._localAnchor.w - a - this._absBottom);
            b.y = this._localAnchor.w - this._localAnchor.y - a - this._calculatedHeight * (1 - this._pivot.y);
            this.entity.setLocalPosition(b)
        }
    });
    Object.defineProperty(ia.prototype, "bottom", {
        get: function() {
            return this._margin.y
        },
        set: function(a) {
            this._margin.y = a;
            var b = this.entity.getLocalPosition();
            this._setHeight(this._absTop - (this._localAnchor.y + a));
            b.y = a + this._calculatedHeight * this._pivot.y;
            this.entity.setLocalPosition(b)
        }
    });
    Object.defineProperty(ia.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(a) {
            this._width = a;
            this._hasSplitAnchorsX || this._setCalculatedWidth(a, !0);
            this.fire("set:width",
                this._width)
        }
    });
    Object.defineProperty(ia.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(a) {
            this._height = a;
            this._hasSplitAnchorsY || this._setCalculatedHeight(a, !0);
            this.fire("set:height", this._height)
        }
    });
    Object.defineProperty(ia.prototype, "calculatedWidth", {
        get: function() {
            return this._calculatedWidth
        },
        set: function(a) {
            this._setCalculatedWidth(a, !0)
        }
    });
    Object.defineProperty(ia.prototype, "calculatedHeight", {
        get: function() {
            return this._calculatedHeight
        },
        set: function(a) {
            this._setCalculatedHeight(a, !0)
        }
    });
    Object.defineProperty(ia.prototype, "pivot", {
        get: function() {
            return this._pivot
        },
        set: function(a) {
            var b = this._pivot.x,
                c = this._pivot.y;
            a instanceof P ? this._pivot.set(a.x, a.y) : this._pivot.set(a[0], a[1]);
            a = this._margin.x + this._margin.z;
            b = this._pivot.x - b;
            this._margin.x += a * b;
            this._margin.z -= a * b;
            b = this._margin.y + this._margin.w;
            c = this._pivot.y - c;
            this._margin.y += b * c;
            this._margin.w -= b * c;
            this._worldCornersDirty = this._cornersDirty = this._anchorDirty = !0;
            this._calculateSize(!1, !1);
            this._flagChildrenAsDirty();
            this.fire("set:pivot", this._pivot)
        }
    });
    Object.defineProperty(ia.prototype, "anchor", {
        get: function() {
            return this._anchor
        },
        set: function(a) {
            a instanceof X ? this._anchor.set(a.x, a.y, a.z, a.w) : this._anchor.set(a[0], a[1], a[2], a[3]);
            this.entity._parent || this.screen ? this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY) : this._calculateLocalAnchors();
            this._anchorDirty = !0;
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:anchor", this._anchor)
        }
    });
    Object.defineProperty(ia.prototype,
        "_hasSplitAnchorsX", {
            get: function() {
                return .001 < Math.abs(this._anchor.x - this._anchor.z)
            }
        });
    Object.defineProperty(ia.prototype, "_hasSplitAnchorsY", {
        get: function() {
            return .001 < Math.abs(this._anchor.y - this._anchor.w)
        }
    });
    Object.defineProperty(ia.prototype, "aabb", {
        get: function() {
            return this._image ? this._image.aabb : this._text ? this._text.aabb : null
        }
    });
    Object.defineProperty(ia.prototype, "screenCorners", {
        get: function() {
            if (!this._cornersDirty || !this.screen) return this._screenCorners;
            var a = this.entity.parent &&
                this.entity.parent.element && this.entity.parent.element.screenCorners[0];
            this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
            this._screenCorners[1].set(this._absRight, this._absBottom, 0);
            this._screenCorners[2].set(this._absRight, this._absTop, 0);
            this._screenCorners[3].set(this._absLeft, this._absTop, 0);
            for (var b = this.screen.screen.screenSpace, c = 0; 4 > c; c++) this._screenTransform.transformPoint(this._screenCorners[c], this._screenCorners[c]), b && this._screenCorners[c].scale(this.screen.screen.scale),
                a && this._screenCorners[c].add(a);
            this._cornersDirty = !1;
            this._worldCornersDirty = this._canvasCornersDirty = !0;
            return this._screenCorners
        }
    });
    Object.defineProperty(ia.prototype, "canvasCorners", {
        get: function() {
            if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;
            for (var a = this.system.app.graphicsDevice, b = this.screenCorners, c = a.canvas.clientWidth / a.width, d = a.canvas.clientHeight / a.height, e = 0; 4 > e; e++) this._canvasCorners[e].set(b[e].x * c, (a.height - b[e].y) * d);
            this._canvasCornersDirty = !1;
            return this._canvasCorners
        }
    });
    Object.defineProperty(ia.prototype, "worldCorners", {
        get: function() {
            if (!this._worldCornersDirty) return this._worldCorners;
            if (this.screen) {
                var a = this.screenCorners;
                if (!this.screen.screen.screenSpace) {
                    bc.copy(this.screen.screen._screenMatrix);
                    bc.data[13] = -bc.data[13];
                    bc.mul2(this.screen.getWorldTransform(), bc);
                    for (var b = 0; 4 > b; b++) bc.transformPoint(a[b], this._worldCorners[b])
                }
            } else a = this.entity.getLocalPosition(), bc.setTranslate(-a.x, -a.y, -a.z),
                Nh.setTRS(z.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale()), Oh.setTranslate(a.x, a.y, a.z), pf.copy(this.entity.parent.getWorldTransform()), pf.mul(Oh).mul(Nh).mul(bc), Gc.set(a.x - this.pivot.x * this.calculatedWidth, a.y - this.pivot.y * this.calculatedHeight, a.z), pf.transformPoint(Gc, this._worldCorners[0]), Gc.set(a.x + (1 - this.pivot.x) * this.calculatedWidth, a.y - this.pivot.y * this.calculatedHeight, a.z), pf.transformPoint(Gc, this._worldCorners[1]), Gc.set(a.x + (1 - this.pivot.x) * this.calculatedWidth, a.y +
                    (1 - this.pivot.y) * this.calculatedHeight, a.z), pf.transformPoint(Gc, this._worldCorners[2]), Gc.set(a.x - this.pivot.x * this.calculatedWidth, a.y + (1 - this.pivot.y) * this.calculatedHeight, a.z), pf.transformPoint(Gc, this._worldCorners[3]);
            this._worldCornersDirty = !1;
            return this._worldCorners
        }
    });
    Object.defineProperty(ia.prototype, "textWidth", {
        get: function() {
            return this._text ? this._text.width : 0
        }
    });
    Object.defineProperty(ia.prototype, "textHeight", {
        get: function() {
            return this._text ? this._text.height : 0
        }
    });
    Object.defineProperty(ia.prototype,
        "useInput", {
            get: function() {
                return this._useInput
            },
            set: function(a) {
                this._useInput !== a && (this._useInput = a, this.system.app.elementInput ? a ? this.enabled && this.entity.enabled && this.system.app.elementInput.addElement(this) : this.system.app.elementInput.removeElement(this) : !0 === this._useInput && console.warn("Elements will not get any input events because this.system.app.elementInput is not created"), this.fire("set:useInput", a))
            }
        });
    Object.defineProperty(ia.prototype, "batchGroupId", {
        get: function() {
            return this._batchGroupId
        },
        set: function(a) {
            this._batchGroupId !== a && (this.entity.enabled && 0 <= this._batchGroupId && this.system.app.batcher.remove(bb.ELEMENT, this.batchGroupId, this.entity), this.entity.enabled && 0 <= a && this.system.app.batcher.insert(bb.ELEMENT, a, this.entity), 0 > a && 0 <= this._batchGroupId && this.enabled && this.entity.enabled && (this._image && this._image._renderable.model ? this.addModelToLayers(this._image._renderable.model) : this._text && this._text._model && this.addModelToLayers(this._text._model)), this._batchGroupId = a)
        }
    });
    Object.defineProperty(ia.prototype,
        "maskedBy", {
            get: function() {
                return this._maskedBy
            }
        });
    var ja = function(a) {
        Object.defineProperty(ia.prototype, a, {
            get: function() {
                return this._text ? this._text[a] : this._image ? this._image[a] : null
            },
            set: function(b) {
                this._text ? this._text[a] = b : this._image && (this._image[a] = b)
            }
        })
    };
    ja("fontSize");
    ja("minFontSize");
    ja("maxFontSize");
    ja("maxLines");
    ja("autoFitWidth");
    ja("autoFitHeight");
    ja("color");
    ja("font");
    ja("fontAsset");
    ja("spacing");
    ja("lineHeight");
    ja("wrapLines");
    ja("lines");
    ja("alignment");
    ja("autoWidth");
    ja("autoHeight");
    ja("rtlReorder");
    ja("unicodeConverter");
    ja("text");
    ja("key");
    ja("texture");
    ja("textureAsset");
    ja("material");
    ja("materialAsset");
    ja("sprite");
    ja("spriteAsset");
    ja("spriteFrame");
    ja("pixelsPerUnit");
    ja("opacity");
    ja("rect");
    ja("mask");
    ja("outlineColor");
    ja("outlineThickness");
    ja("shadowColor");
    ja("shadowOffset");
    ja("enableMarkup");
    ja("rangeStart");
    ja("rangeEnd");
    var vl = ["enabled"];
    Ee.prototype = Object.create(H.prototype);
    Ee.prototype.constructor = Ee;
    O._buildAccessors(ia.prototype, vl);
    Object.assign(Ee.prototype, {
        destroy: function() {
            this._defaultTexture.destroy()
        },
        initializeComponentData: function(a, b, c) {
            a._beingInitialized = !0;
            void 0 !== b.anchor && (b.anchor instanceof X ? a.anchor.copy(b.anchor) : a.anchor.set(b.anchor[0], b.anchor[1], b.anchor[2], b.anchor[3]));
            void 0 !== b.pivot && (b.pivot instanceof P ? a.pivot.copy(b.pivot) : a.pivot.set(b.pivot[0], b.pivot[1]));
            var d = .001 < Math.abs(a.anchor.x - a.anchor.z),
                e = .001 < Math.abs(a.anchor.y - a.anchor.w),
                f = !1;
            void 0 !== b.margin && (b.margin instanceof X ? a.margin.copy(b.margin) :
                a._margin.set(b.margin[0], b.margin[1], b.margin[2], b.margin[3]), f = !0);
            void 0 !== b.left && (a._margin.x = b.left, f = !0);
            void 0 !== b.bottom && (a._margin.y = b.bottom, f = !0);
            void 0 !== b.right && (a._margin.z = b.right, f = !0);
            void 0 !== b.top && (a._margin.w = b.top, f = !0);
            f && (a.margin = a._margin);
            f = !1;
            void 0 === b.width || d ? d && (f = !0) : a.width = b.width;
            void 0 === b.height || e ? e && (f = !0) : a.height = b.height;
            f && (a.anchor = a.anchor);
            void 0 !== b.enabled && (a.enabled = b.enabled);
            void 0 !== b.useInput && (a.useInput = b.useInput);
            a.batchGroupId = void 0 ===
                b.batchGroupId || null === b.batchGroupId ? -1 : b.batchGroupId;
            b.layers && Array.isArray(b.layers) && (a.layers = b.layers.slice(0));
            a.type = b.type;
            "image" === a.type ? (void 0 !== b.rect && (a.rect = b.rect), void 0 !== b.color && (d = b.color, d instanceof L || (d = new L(b.color[0], b.color[1], b.color[2])), a.color = d), void 0 !== b.opacity && (a.opacity = b.opacity), void 0 !== b.textureAsset && (a.textureAsset = b.textureAsset), b.texture && (a.texture = b.texture), void 0 !== b.spriteAsset && (a.spriteAsset = b.spriteAsset), b.sprite && (a.sprite = b.sprite),
                void 0 !== b.spriteFrame && (a.spriteFrame = b.spriteFrame), void 0 !== b.pixelsPerUnit && null !== b.pixelsPerUnit && (a.pixelsPerUnit = b.pixelsPerUnit), void 0 !== b.materialAsset && (a.materialAsset = b.materialAsset), b.material && (a.material = b.material), void 0 !== b.mask && (a.mask = b.mask)) : "text" === a.type && (void 0 !== b.autoWidth && (a.autoWidth = b.autoWidth), void 0 !== b.autoHeight && (a.autoHeight = b.autoHeight), void 0 !== b.rtlReorder && (a.rtlReorder = b.rtlReorder), void 0 !== b.unicodeConverter && (a.unicodeConverter = b.unicodeConverter),
                null !== b.text && void 0 !== b.text ? a.text = b.text : null !== b.key && void 0 !== b.key && (a.key = b.key), void 0 !== b.color && (d = b.color, d instanceof L || (d = new L(d[0], d[1], d[2])), a.color = d), void 0 !== b.opacity && (a.opacity = b.opacity), void 0 !== b.spacing && (a.spacing = b.spacing), void 0 !== b.fontSize && (a.fontSize = b.fontSize, b.lineHeight || (a.lineHeight = b.fontSize)), void 0 !== b.lineHeight && (a.lineHeight = b.lineHeight), void 0 !== b.maxLines && (a.maxLines = b.maxLines), void 0 !== b.wrapLines && (a.wrapLines = b.wrapLines), void 0 !== b.minFontSize &&
                (a.minFontSize = b.minFontSize), void 0 !== b.maxFontSize && (a.maxFontSize = b.maxFontSize), b.autoFitWidth && (a.autoFitWidth = b.autoFitWidth), b.autoFitHeight && (a.autoFitHeight = b.autoFitHeight), void 0 !== b.fontAsset && (a.fontAsset = b.fontAsset), void 0 !== b.font && (a.font = b.font), void 0 !== b.alignment && (a.alignment = b.alignment), void 0 !== b.outlineColor && (a.outlineColor = b.outlineColor), void 0 !== b.outlineThickness && (a.outlineThickness = b.outlineThickness), void 0 !== b.shadowColor && (a.shadowColor = b.shadowColor), void 0 !==
                b.shadowOffset && (a.shadowOffset = b.shadowOffset), void 0 !== b.enableMarkup && (a.enableMarkup = b.enableMarkup));
            d = a._parseUpToScreen();
            d.screen && a._updateScreen(d.screen);
            H.prototype.initializeComponentData.call(this, a, b, c);
            a._beingInitialized = !1;
            "image" === a.type && a._image._meshDirty && a._image._updateMesh(a._image.mesh)
        },
        onRemoveComponent: function(a, b) {
            b.onRemove()
        },
        cloneComponent: function(a, b) {
            a = a.element;
            var c = {
                enabled: a.enabled,
                width: a.width,
                height: a.height,
                anchor: a.anchor.clone(),
                pivot: a.pivot.clone(),
                margin: a.margin.clone(),
                alignment: a.alignment && a.alignment.clone() || a.alignment,
                autoWidth: a.autoWidth,
                autoHeight: a.autoHeight,
                type: a.type,
                rect: a.rect && a.rect.clone() || a.rect,
                rtlReorder: a.rtlReorder,
                unicodeConverter: a.unicodeConverter,
                materialAsset: a.materialAsset,
                material: a.material,
                color: a.color && a.color.clone() || a.color,
                opacity: a.opacity,
                textureAsset: a.textureAsset,
                texture: a.texture,
                spriteAsset: a.spriteAsset,
                sprite: a.sprite,
                spriteFrame: a.spriteFrame,
                pixelsPerUnit: a.pixelsPerUnit,
                spacing: a.spacing,
                lineHeight: a.lineHeight,
                wrapLines: a.wrapLines,
                layers: a.layers,
                fontSize: a.fontSize,
                minFontSize: a.minFontSize,
                maxFontSize: a.maxFontSize,
                autoFitWidth: a.autoFitWidth,
                autoFitHeight: a.autoFitHeight,
                maxLines: a.maxLines,
                fontAsset: a.fontAsset,
                font: a.font,
                useInput: a.useInput,
                batchGroupId: a.batchGroupId,
                mask: a.mask,
                outlineColor: a.outlineColor && a.outlineColor.clone() || a.outlineColor,
                outlineThickness: a.outlineThickness,
                shadowColor: a.shadowColor && a.shadowColor.clone() || a.shadowColor,
                shadowOffset: a.shadowOffset &&
                    a.shadowOffset.clone() || a.shadowOffset,
                enableMarkup: a.enableMarkup
            };
            void 0 !== a.key && null !== a.key ? c.key = a.key : c.text = a.text;
            return this.addComponent(b, c)
        },
        getTextElementMaterial: function(a, b) {
            if (a) {
                if (b) return this.defaultScreenSpaceTextMaterial || (this.defaultScreenSpaceTextMaterial = new ma, this.defaultScreenSpaceTextMaterial.name = "defaultScreenSpaceTextMaterial", this.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture, this.defaultScreenSpaceTextMaterial.useLighting = !1, this.defaultScreenSpaceTextMaterial.useGammaTonemap = !1, this.defaultScreenSpaceTextMaterial.useFog = !1, this.defaultScreenSpaceTextMaterial.useSkybox = !1, this.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0), this.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1), this.defaultScreenSpaceTextMaterial.opacity = .5, this.defaultScreenSpaceTextMaterial.blendType = 4, this.defaultScreenSpaceTextMaterial.depthWrite = !1, this.defaultScreenSpaceTextMaterial.depthTest = !1, this.defaultScreenSpaceTextMaterial.emissiveVertexColor = !0, this.defaultScreenSpaceTextMaterial.update()),
                    this.defaultScreenSpaceTextMaterial;
                this.defaultScreenSpaceBitmapTextMaterial || (this.defaultScreenSpaceBitmapTextMaterial = new ma, this.defaultScreenSpaceBitmapTextMaterial.name = "defaultScreenSpaceBitmapTextMaterial", this.defaultScreenSpaceBitmapTextMaterial.emissive.set(.5, .5, .5), this.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture, this.defaultScreenSpaceBitmapTextMaterial.emissiveTint = !0, this.defaultScreenSpaceBitmapTextMaterial.opacity = .5, this.defaultScreenSpaceBitmapTextMaterial.opacityMap =
                    this._defaultTexture, this.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = "a", this.defaultScreenSpaceBitmapTextMaterial.useLighting = !1, this.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = !1, this.defaultScreenSpaceBitmapTextMaterial.useFog = !1, this.defaultScreenSpaceBitmapTextMaterial.useSkybox = !1, this.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0), this.defaultScreenSpaceBitmapTextMaterial.blendType = 4, this.defaultScreenSpaceBitmapTextMaterial.depthWrite = !1, this.defaultScreenSpaceBitmapTextMaterial.depthTest = !1, this.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = !0, this.defaultScreenSpaceBitmapTextMaterial.update());
                return this.defaultScreenSpaceBitmapTextMaterial
            }
            if (b) return this.defaultTextMaterial || (this.defaultTextMaterial = new ma, this.defaultTextMaterial.name = "defaultTextMaterial", this.defaultTextMaterial.msdfMap = this._defaultTexture, this.defaultTextMaterial.useLighting = !1, this.defaultTextMaterial.useGammaTonemap = !1, this.defaultTextMaterial.useFog = !1, this.defaultTextMaterial.useSkybox = !1,
                this.defaultTextMaterial.diffuse.set(0, 0, 0), this.defaultTextMaterial.emissive.set(1, 1, 1), this.defaultTextMaterial.opacity = .5, this.defaultTextMaterial.blendType = 4, this.defaultTextMaterial.depthWrite = !1, this.defaultTextMaterial.emissiveVertexColor = !0, this.defaultTextMaterial.update()), this.defaultTextMaterial;
            this.defaultBitmapTextMaterial || (this.defaultBitmapTextMaterial = new ma, this.defaultBitmapTextMaterial.name = "defaultBitmapTextMaterial", this.defaultBitmapTextMaterial.emissive.set(.5, .5, .5), this.defaultBitmapTextMaterial.emissiveTint = !0, this.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture, this.defaultBitmapTextMaterial.opacity = .5, this.defaultBitmapTextMaterial.opacityMap = this._defaultTexture, this.defaultBitmapTextMaterial.opacityMapChannel = "a", this.defaultBitmapTextMaterial.useLighting = !1, this.defaultBitmapTextMaterial.useGammaTonemap = !1, this.defaultBitmapTextMaterial.useFog = !1, this.defaultBitmapTextMaterial.useSkybox = !1, this.defaultBitmapTextMaterial.diffuse.set(0, 0, 0), this.defaultBitmapTextMaterial.blendType = 4, this.defaultBitmapTextMaterial.depthWrite = !1, this.defaultBitmapTextMaterial.emissiveVertexColor = !0, this.defaultBitmapTextMaterial.update());
            return this.defaultBitmapTextMaterial
        },
        _createBaseImageMaterial: function() {
            var a = new ma;
            a.diffuse.set(0, 0, 0);
            a.emissive.set(.5, .5, .5);
            a.emissiveMap = this._defaultTexture;
            a.emissiveTint = !0;
            a.opacityMap = this._defaultTexture;
            a.opacityMapChannel = "a";
            a.opacityTint = !0;
            a.opacity = 0;
            a.useLighting = !1;
            a.useGammaTonemap = !1;
            a.useFog = !1;
            a.useSkybox = !1;
            a.blendType = 4;
            a.depthWrite = !1;
            return a
        },
        getImageElementMaterial: function(a,
            b, c, d) {
            if (a) {
                if (b) {
                    if (c) return this.defaultScreenSpaceImageMask9SlicedMaterial || (this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial", this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = 1, this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1, this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial)), this.defaultScreenSpaceImageMask9SlicedMaterial;
                    if (d) return this.defaultScreenSpaceImageMask9TiledMaterial || (this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone(),
                        this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial", this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = 2, this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = !1, this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1, this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = !1, this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = !1, this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = !1, this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = !1, this.defaultScreenSpaceImageMask9TiledMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial)), this.defaultScreenSpaceImageMask9TiledMaterial;
                    this.defaultScreenSpaceImageMaskMaterial || (this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial", this.defaultScreenSpaceImageMaskMaterial.depthTest = !1, this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1, this.defaultScreenSpaceImageMaskMaterial.redWrite = !1, this.defaultScreenSpaceImageMaskMaterial.greenWrite = !1, this.defaultScreenSpaceImageMaskMaterial.blueWrite = !1, this.defaultScreenSpaceImageMaskMaterial.alphaWrite = !1, this.defaultScreenSpaceImageMaskMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial));
                    return this.defaultScreenSpaceImageMaskMaterial
                }
                if (c) return this.defaultScreenSpaceImage9SlicedMaterial || (this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImage9SlicedMaterial.name =
                    "defaultScreenSpaceImage9SlicedMaterial", this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = 1, this.defaultScreenSpaceImage9SlicedMaterial.depthTest = !1, this.defaultScreenSpaceImage9SlicedMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial)), this.defaultScreenSpaceImage9SlicedMaterial;
                if (d) return this.defaultScreenSpaceImage9TiledMaterial || (this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImage9TiledMaterial.name =
                    "defaultScreenSpaceImage9TiledMaterial", this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = 2, this.defaultScreenSpaceImage9TiledMaterial.depthTest = !1, this.defaultScreenSpaceImage9TiledMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial)), this.defaultScreenSpaceImage9TiledMaterial;
                this.defaultScreenSpaceImageMaterial || (this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial",
                    this.defaultScreenSpaceImageMaterial.depthTest = !1, this.defaultScreenSpaceImageMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial));
                return this.defaultScreenSpaceImageMaterial
            }
            if (b) {
                if (c) return this.defaultImage9SlicedMaskMaterial || (this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial(), this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial", this.defaultImage9SlicedMaskMaterial.nineSlicedMode = 1, this.defaultImage9SlicedMaskMaterial.alphaTest =
                    1, this.defaultImage9SlicedMaskMaterial.redWrite = !1, this.defaultImage9SlicedMaskMaterial.greenWrite = !1, this.defaultImage9SlicedMaskMaterial.blueWrite = !1, this.defaultImage9SlicedMaskMaterial.alphaWrite = !1, this.defaultImage9SlicedMaskMaterial.update(), this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial)), this.defaultImage9SlicedMaskMaterial;
                if (d) return this.defaultImage9TiledMaskMaterial || (this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial(), this.defaultImage9TiledMaskMaterial.name =
                    "defaultImage9TiledMaskMaterial", this.defaultImage9TiledMaskMaterial.nineSlicedMode = 2, this.defaultImage9TiledMaskMaterial.alphaTest = 1, this.defaultImage9TiledMaskMaterial.redWrite = !1, this.defaultImage9TiledMaskMaterial.greenWrite = !1, this.defaultImage9TiledMaskMaterial.blueWrite = !1, this.defaultImage9TiledMaskMaterial.alphaWrite = !1, this.defaultImage9TiledMaskMaterial.update(), this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial)), this.defaultImage9TiledMaskMaterial;
                this.defaultImageMaskMaterial ||
                    (this.defaultImageMaskMaterial = this._createBaseImageMaterial(), this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial", this.defaultImageMaskMaterial.alphaTest = 1, this.defaultImageMaskMaterial.redWrite = !1, this.defaultImageMaskMaterial.greenWrite = !1, this.defaultImageMaskMaterial.blueWrite = !1, this.defaultImageMaskMaterial.alphaWrite = !1, this.defaultImageMaskMaterial.update(), this.defaultImageMaterials.push(this.defaultImageMaskMaterial));
                return this.defaultImageMaskMaterial
            }
            if (c) return this.defaultImage9SlicedMaterial ||
                (this.defaultImage9SlicedMaterial = this._createBaseImageMaterial(), this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial", this.defaultImage9SlicedMaterial.nineSlicedMode = 1, this.defaultImage9SlicedMaterial.update(), this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial)), this.defaultImage9SlicedMaterial;
            if (d) return this.defaultImage9TiledMaterial || (this.defaultImage9TiledMaterial = this._createBaseImageMaterial(), this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial",
                this.defaultImage9TiledMaterial.nineSlicedMode = 2, this.defaultImage9TiledMaterial.update(), this.defaultImageMaterials.push(this.defaultImage9TiledMaterial)), this.defaultImage9TiledMaterial;
            this.defaultImageMaterial || (this.defaultImageMaterial = this._createBaseImageMaterial(), this.defaultImageMaterial.name = "defaultImageMaterial", this.defaultImageMaterial.update(), this.defaultImageMaterials.push(this.defaultImageMaterial));
            return this.defaultImageMaterial
        },
        registerUnicodeConverter: function(a) {
            this._unicodeConverter =
                a
        },
        registerRtlReorder: function(a) {
            this._rtlReorder = a
        },
        getUnicodeConverter: function() {
            return this._unicodeConverter
        },
        getRtlReorder: function() {
            return this._rtlReorder
        }
    });
    Ud.prototype = Object.create(O.prototype);
    Ud.prototype.constructor = Ud;
    Vd("minWidth");
    Vd("minHeight");
    Vd("maxWidth");
    Vd("maxHeight");
    Vd("fitWidthProportion");
    Vd("fitHeightProportion");
    Vd("excludeFromLayout");
    var Zm = ["enabled"],
        Re = function(a) {
            H.call(this, a);
            this.id = "layoutchild";
            this.ComponentType = Ud;
            this.DataType = so;
            this.schema = Zm
        };
    Re.prototype =
        Object.create(H.prototype);
    Re.prototype.constructor = Re;
    O._buildAccessors(Ud.prototype, Zm);
    Object.assign(Re.prototype, {
        initializeComponentData: function(a, b, c) {
            void 0 !== b.enabled && (a.enabled = b.enabled);
            void 0 !== b.minWidth && (a.minWidth = b.minWidth);
            void 0 !== b.minHeight && (a.minHeight = b.minHeight);
            void 0 !== b.maxWidth && (a.maxWidth = b.maxWidth);
            void 0 !== b.maxHeight && (a.maxHeight = b.maxHeight);
            void 0 !== b.fitWidthProportion && (a.fitWidthProportion = b.fitWidthProportion);
            void 0 !== b.fitHeightProportion && (a.fitHeightProportion =
                b.fitHeightProportion);
            void 0 !== b.excludeFromLayout && (a.excludeFromLayout = b.excludeFromLayout);
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            a = a.layoutchild;
            return this.addComponent(b, {
                enabled: a.enabled,
                minWidth: a.minWidth,
                minHeight: a.minHeight,
                maxWidth: a.maxWidth,
                maxHeight: a.maxHeight,
                fitWidthProportion: a.fitWidthProportion,
                fitHeightProportion: a.fitHeightProportion,
                excludeFromLayout: a.excludeFromLayout
            })
        }
    });
    var sj = 0,
        xl = {
            0: {
                axis: "x",
                size: "width",
                calculatedSize: "calculatedWidth",
                minSize: "minWidth",
                maxSize: "maxWidth",
                fitting: "widthFitting",
                fittingProportion: "fitWidthProportion"
            },
            1: {
                axis: "y",
                size: "height",
                calculatedSize: "calculatedHeight",
                minSize: "minHeight",
                maxSize: "maxHeight",
                fitting: "heightFitting",
                fittingProportion: "fitHeightProportion"
            }
        },
        uo = {
            0: 1,
            1: 0
        },
        to = {
            minWidth: 0,
            minHeight: 0,
            maxWidth: Number.POSITIVE_INFINITY,
            maxHeight: Number.POSITIVE_INFINITY,
            width: null,
            height: null,
            fitWidthProportion: 0,
            fitHeightProportion: 0
        },
        zb = {
            NONE: "NONE",
            APPLY_STRETCHING: "APPLY_STRETCHING",
            APPLY_SHRINKING: "APPLY_SHRINKING"
        },
        Gb = new P,
        qk = {};
    qk[0] = wl(0);
    qk[1] = wl(1);
    Object.assign(rj.prototype, {
        calculateLayout: function(a, b) {
            var c = qk[b.orientation];
            if (c) return c(a, b);
            throw Error("Unrecognized orientation value: " + b.orientation);
        }
    });
    kd.prototype = Object.create(O.prototype);
    kd.prototype.constructor = kd;
    Object.assign(kd.prototype, {
        _isSelfOrChild: function(a) {
            return a === this.entity || -1 !== this.entity.children.indexOf(a)
        },
        _listenForReflowEvents: function(a, b) {
            a.element && (a.element[b]("enableelement", this._scheduleReflow, this), a.element[b]("disableelement",
                this._scheduleReflow, this), a.element[b]("resize", this._scheduleReflow, this), a.element[b]("set:pivot", this._scheduleReflow, this));
            a.layoutchild && (a.layoutchild[b]("set_enabled", this._scheduleReflow, this), a.layoutchild[b]("resize", this._scheduleReflow, this))
        },
        _onElementOrLayoutComponentAdd: function(a) {
            this._isSelfOrChild(a) && (this._listenForReflowEvents(a, "on"), this._scheduleReflow())
        },
        _onElementOrLayoutComponentRemove: function(a) {
            this._isSelfOrChild(a) && (this._listenForReflowEvents(a, "off"), this._scheduleReflow())
        },
        _onChildInsert: function(a) {
            this._listenForReflowEvents(a, "on");
            this._scheduleReflow()
        },
        _onChildRemove: function(a) {
            this._listenForReflowEvents(a, "off");
            this._scheduleReflow()
        },
        _scheduleReflow: function() {
            this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow && this.system.scheduleReflow(this)
        },
        reflow: function() {
            var a = this.entity.element,
                b = this.entity.children.filter(wo).map(vo);
            a && 0 !== b.length && (a = {
                orientation: this._orientation,
                reverseX: this._reverseX,
                reverseY: this._reverseY,
                alignment: this._alignment,
                padding: this._padding,
                spacing: this._spacing,
                widthFitting: this._widthFitting,
                heightFitting: this._heightFitting,
                wrap: this._wrap,
                containerSize: new P(Math.max(a.calculatedWidth, 0), Math.max(a.calculatedHeight, 0))
            }, this._isPerformingReflow = !0, b = this._layoutCalculator.calculateLayout(b, a), this._isPerformingReflow = !1, this.fire("reflow", b))
        },
        onEnable: function() {
            this._scheduleReflow()
        },
        onRemove: function() {
            this.entity.off("childinsert", this._onChildInsert, this);
            this.entity.off("childremove", this._onChildRemove,
                this);
            this._listenForReflowEvents(this.entity, "off");
            this.entity.children.forEach(function(a) {
                this._listenForReflowEvents(a, "off")
            }.bind(this));
            this.system.app.systems.element.off("add", this._onElementOrLayoutComponentAdd, this);
            this.system.app.systems.element.off("beforeremove", this._onElementOrLayoutComponentRemove, this);
            this.system.app.systems.layoutchild.off("add", this._onElementOrLayoutComponentAdd, this);
            this.system.app.systems.layoutchild.off("beforeremove", this._onElementOrLayoutComponentRemove,
                this)
        }
    });
    Nc("orientation");
    Nc("reverseX");
    Nc("reverseY");
    Nc("alignment");
    Nc("padding");
    Nc("spacing");
    Nc("widthFitting");
    Nc("heightFitting");
    Nc("wrap");
    var yl = ["enabled"];
    Fe.prototype = Object.create(H.prototype);
    Fe.prototype.constructor = Fe;
    O._buildAccessors(kd.prototype, yl);
    Object.assign(Fe.prototype, {
        initializeComponentData: function(a, b, c) {
            void 0 !== b.enabled && (a.enabled = b.enabled);
            void 0 !== b.orientation && (a.orientation = b.orientation);
            void 0 !== b.reverseX && (a.reverseX = b.reverseX);
            void 0 !== b.reverseY &&
                (a.reverseY = b.reverseY);
            void 0 !== b.alignment && (b.alignment instanceof P ? a.alignment.copy(b.alignment) : a.alignment.set(b.alignment[0], b.alignment[1]), a.alignment = a.alignment);
            void 0 !== b.padding && (b.padding instanceof X ? a.padding.copy(b.padding) : a.padding.set(b.padding[0], b.padding[1], b.padding[2], b.padding[3]), a.padding = a.padding);
            void 0 !== b.spacing && (b.spacing instanceof P ? a.spacing.copy(b.spacing) : a.spacing.set(b.spacing[0], b.spacing[1]), a.spacing = a.spacing);
            void 0 !== b.widthFitting && (a.widthFitting =
                b.widthFitting);
            void 0 !== b.heightFitting && (a.heightFitting = b.heightFitting);
            void 0 !== b.wrap && (a.wrap = b.wrap);
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            a = a.layoutgroup;
            return this.addComponent(b, {
                enabled: a.enabled,
                orientation: a.orientation,
                reverseX: a.reverseX,
                reverseY: a.reverseY,
                alignment: a.alignment,
                padding: a.padding,
                spacing: a.spacing,
                widthFitting: a.widthFitting,
                heightFitting: a.heightFitting,
                wrap: a.wrap
            })
        },
        scheduleReflow: function(a) {
            -1 === this._reflowQueue.indexOf(a) &&
                this._reflowQueue.push(a)
        },
        _onPostUpdate: function() {
            this._processReflowQueue()
        },
        _processReflowQueue: function() {
            if (0 !== this._reflowQueue.length)
                for (var a = 0; 0 < this._reflowQueue.length;) {
                    var b = this._reflowQueue.slice();
                    this._reflowQueue.length = 0;
                    b.sort(function(d, e) {
                        return d.entity.graphDepth - e.entity.graphDepth
                    });
                    for (var c = 0; c < b.length; ++c) b[c].reflow();
                    if (100 <= ++a) {
                        console.warn("Max reflow iterations limit reached, bailing.");
                        break
                    }
                }
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        }
    });
    var Ph = new z,
        Qh =
        new z,
        rk = new z,
        sk = {
            r: 0,
            g: 1,
            b: 2,
            a: 3
        },
        Va = function() {
            this._type = 0;
            this._color = new L(.8, .8, .8);
            this._intensity = 1;
            this.enabled = this._castShadows = !1;
            this.mask = 1;
            this.isStatic = !1;
            this.key = 0;
            this.bakeDir = !0;
            this.attenuationEnd = this.attenuationStart = 10;
            this._shadowType = this._falloffMode = 0;
            this._vsmBlurSize = 11;
            this.vsmBlurMode = 1;
            this.vsmBias = .0025;
            this._cookie = null;
            this.cookieIntensity = 1;
            this._cookieFalloff = !0;
            this._cookieChannel = "rgb";
            this._cookieTransform = null;
            this._cookieTransformUniform = new Float32Array(4);
            this._cookieOffset = null;
            this._cookieOffsetUniform = new Float32Array(2);
            this._cookieOffsetSet = this._cookieTransformSet = !1;
            this._innerConeAngle = 40;
            this._outerConeAngle = 45;
            this._finalColor = new Float32Array([.8, .8, .8]);
            var a = Math.pow(this._finalColor[0], 2.2);
            this._linearFinalColor = new Float32Array([a, a, a]);
            this._position = new z(0, 0, 0);
            this._direction = new z(0, 0, 0);
            this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
            this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
            this._shadowCamera =
                null;
            this._shadowMatrix = new J;
            this.shadowDistance = 40;
            this._shadowResolution = 1024;
            this.shadowBias = -5E-4;
            this._normalOffsetBias = 0;
            this.shadowUpdateMode = 2;
            this._node = this._scene = null;
            this._rendererParams = [];
            this._isVsm = !1;
            this._isPcf = !0;
            this._isCachedShadowMap = this._cacheShadowMap = !1;
            this._visibleLength = [0];
            this._visibleList = [
                []
            ];
            this._visibleCameraSettings = []
        };
    Object.assign(Va.prototype, {
        destroy: function() {
            this._destroyShadowMap()
        },
        clone: function() {
            var a = new Va;
            a.type = this._type;
            a.setColor(this._color);
            a.intensity = this._intensity;
            a.castShadows = this.castShadows;
            a.enabled = this.enabled;
            a.attenuationStart = this.attenuationStart;
            a.attenuationEnd = this.attenuationEnd;
            a.falloffMode = this._falloffMode;
            a.shadowType = this._shadowType;
            a.vsmBlurSize = this._vsmBlurSize;
            a.vsmBlurMode = this.vsmBlurMode;
            a.vsmBias = this.vsmBias;
            a.shadowUpdateMode = this.shadowUpdateMode;
            a.mask = this.mask;
            a.innerConeAngle = this._innerConeAngle;
            a.outerConeAngle = this._outerConeAngle;
            a.shadowBias = this.shadowBias;
            a.normalOffsetBias = this._normalOffsetBias;
            a.shadowResolution = this._shadowResolution;
            a.shadowDistance = this.shadowDistance;
            return a
        },
        getColor: function() {
            return this._color
        },
        getBoundingSphere: function(a) {
            if (2 === this._type) {
                var b = this.attenuationEnd,
                    c = this._outerConeAngle,
                    d = Math.cos(c * N.DEG_TO_RAD),
                    e = this._node;
                Ph.copy(e.up);
                Ph.scale(.5 * -b * d);
                Ph.add(e.getPosition());
                a.center = Ph;
                Qh.copy(e.up);
                Qh.scale(-b);
                rk.copy(e.right);
                rk.scale(Math.sin(c * N.DEG_TO_RAD) * b);
                Qh.add(rk);
                a.radius = .5 * Qh.length()
            } else 1 === this._type && (a.center = this._node.getPosition(),
                a.radius = this.attenuationEnd)
        },
        getBoundingBox: function(a) {
            if (2 === this._type) {
                var b = this.attenuationEnd,
                    c = this._node,
                    d = Math.abs(Math.sin(this._outerConeAngle * N.DEG_TO_RAD) * b);
                a.center.set(0, .5 * -b, 0);
                a.halfExtents.set(d, .5 * b, d);
                a.setFromTransformedAabb(a, c.getWorldTransform())
            } else 1 === this._type && (a.center.copy(this._node.getPosition()), a.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd))
        },
        _updateFinalColor: function() {
            var a = this._color,
                b = a.r,
                c = a.g;
            a = a.b;
            var d = this._intensity,
                e = this._finalColor,
                f = this._linearFinalColor;
            e[0] = b * d;
            e[1] = c * d;
            e[2] = a * d;
            1 <= d ? (f[0] = Math.pow(b, 2.2) * d, f[1] = Math.pow(c, 2.2) * d, f[2] = Math.pow(a, 2.2) * d) : (f[0] = Math.pow(e[0], 2.2), f[1] = Math.pow(e[1], 2.2), f[2] = Math.pow(e[2], 2.2))
        },
        setColor: function() {
            if (1 === arguments.length) {
                var a = arguments[0].r;
                var b = arguments[0].g;
                var c = arguments[0].b
            } else 3 === arguments.length && (a = arguments[0], b = arguments[1], c = arguments[2]);
            this._color.set(a, b, c);
            this._updateFinalColor()
        },
        _destroyShadowMap: function() {
            if (this._shadowCamera) {
                if (!this._isCachedShadowMap) {
                    var a =
                        this._shadowCamera.renderTarget,
                        b;
                    if (a)
                        if (a.length)
                            for (b = 0; b < a.length; b++) a[b].colorBuffer && a[b].colorBuffer.destroy(), a[b].destroy();
                        else a.colorBuffer && a.colorBuffer.destroy(), a.depthBuffer && a.depthBuffer.destroy(), a.destroy()
                }
                this._shadowCubeMap = this._shadowCamera = this._shadowCamera.renderTarget = null;
                0 === this.shadowUpdateMode && (this.shadowUpdateMode = 1)
            }
        },
        updateShadow: function() {
            2 !== this.shadowUpdateMode && (this.shadowUpdateMode = 1)
        },
        updateKey: function() {
            var a = this._type << 29 | (this._castShadows ? 1 :
                0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (0 !== this._normalOffsetBias ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | sk[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12;
            3 === this._cookieChannel.length && (a |= sk[this._cookieChannel.charAt(1)] << 16, a |= sk[this._cookieChannel.charAt(2)] << 14);
            a !== this.key && null !== this._scene && (this._scene.layers._dirtyLights = !0);
            this.key = a
        }
    });
    Object.defineProperty(Va.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            this._type !==
                a && (this._type = a, this._destroyShadowMap(), this.updateKey(), a = this._shadowType, this._shadowType = null, this.shadowType = a)
        }
    });
    Object.defineProperty(Va.prototype, "shadowType", {
        get: function() {
            return this._shadowType
        },
        set: function(a) {
            if (this._shadowType !== a) {
                var b = ea.getApplication().graphicsDevice;
                1 === this._type && (a = 0);
                4 !== a || b.webgl2 || (a = 0);
                3 !== a || b.textureFloatRenderable || (a = 2);
                2 !== a || b.textureHalfFloatRenderable || (a = 1);
                this._isVsm = 1 <= a && 3 >= a;
                this._isPcf = 4 === a || 0 === a;
                this._shadowType = a;
                this._destroyShadowMap();
                this.updateKey()
            }
        }
    });
    Object.defineProperty(Va.prototype, "castShadows", {
        get: function() {
            return this._castShadows && 4 !== this.mask && 0 !== this.mask
        },
        set: function(a) {
            this._castShadows !== a && (this._castShadows = a, this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "shadowResolution", {
        get: function() {
            return this._shadowResolution
        },
        set: function(a) {
            if (this._shadowResolution !== a) {
                var b = ea.getApplication().graphicsDevice;
                this._shadowResolution = a = 1 === this._type ? Math.min(a, b.maxCubeMapSize) : Math.min(a, b.maxTextureSize)
            }
        }
    });
    Object.defineProperty(Va.prototype, "vsmBlurSize", {
        get: function() {
            return this._vsmBlurSize
        },
        set: function(a) {
            this._vsmBlurSize !== a && (0 === a % 2 && a++, this._vsmBlurSize = a)
        }
    });
    Object.defineProperty(Va.prototype, "normalOffsetBias", {
        get: function() {
            return this._normalOffsetBias
        },
        set: function(a) {
            this._normalOffsetBias !== a && ((!this._normalOffsetBias && a || this._normalOffsetBias && !a) && this.updateKey(), this._normalOffsetBias = a)
        }
    });
    Object.defineProperty(Va.prototype, "falloffMode", {
        get: function() {
            return this._falloffMode
        },
        set: function(a) {
            this._falloffMode !== a && (this._falloffMode = a, this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "innerConeAngle", {
        get: function() {
            return this._innerConeAngle
        },
        set: function(a) {
            this._innerConeAngle !== a && (this._innerConeAngle = a, this._innerConeAngleCos = Math.cos(a * Math.PI / 180))
        }
    });
    Object.defineProperty(Va.prototype, "outerConeAngle", {
        get: function() {
            return this._outerConeAngle
        },
        set: function(a) {
            this._outerConeAngle !== a && (this._outerConeAngle = a, this._outerConeAngleCos = Math.cos(a * Math.PI /
                180))
        }
    });
    Object.defineProperty(Va.prototype, "intensity", {
        get: function() {
            return this._intensity
        },
        set: function(a) {
            this._intensity !== a && (this._intensity = a, this._updateFinalColor())
        }
    });
    Object.defineProperty(Va.prototype, "cookie", {
        get: function() {
            return this._cookie
        },
        set: function(a) {
            this._cookie !== a && (this._cookie = a, this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "cookieFalloff", {
        get: function() {
            return this._cookieFalloff
        },
        set: function(a) {
            this._cookieFalloff !== a && (this._cookieFalloff = a, this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "cookieChannel", {
        get: function() {
            return this._cookieChannel
        },
        set: function(a) {
            if (this._cookieChannel !== a) {
                if (3 > a.length)
                    for (var b = a.charAt(a.length - 1), c = 3 - a.length, d = 0; d < c; d++) a += b;
                this._cookieChannel = a;
                this.updateKey()
            }
        }
    });
    Object.defineProperty(Va.prototype, "cookieTransform", {
        get: function() {
            return this._cookieTransform
        },
        set: function(a) {
            this._cookieTransform !== a && (this._cookieTransform = a, this._cookieTransformSet = !!a, a && !this._cookieOffset && (this.cookieOffset = new P,
                this._cookieOffsetSet = !1), this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "cookieOffset", {
        get: function() {
            return this._cookieOffset
        },
        set: function(a) {
            this._cookieOffset !== a && ((this._cookieTransformSet || a) && !a && this._cookieOffset ? this._cookieOffset.set(0, 0) : this._cookieOffset = a, this._cookieOffsetSet = !!a, a && !this._cookieTransform && (this.cookieTransform = new X(1, 1, 0, 0), this._cookieTransformSet = !1), this.updateKey())
        }
    });
    ld.prototype = Object.create(O.prototype);
    ld.prototype.constructor = ld;
    var Rh = [],
        $m = [],
        qa = function(a, b, c, d) {
            var e = ld.prototype;
            Rh.push(a);
            $m.push(b);
            Object.defineProperty(e, a, {
                get: function() {
                    return this.data[a]
                },
                set: function(f) {
                    var g = this.data,
                        k = g[a];
                    if (d || k !== f) g[a] = f, c && c.call(this, f, k)
                },
                configurable: !0
            })
        };
    (function() {
        qa("enabled", !0, function(a, b) {
            this.onSetEnabled(null, b, a)
        });
        qa("light", null);
        qa("type", "directional", function(a, b) {
            this.system.changeType(this, b, a);
            this.refreshProperties()
        });
        qa("color", new L(1, 1, 1), function(a, b) {
            this.light.setColor(a)
        }, !0);
        qa("intensity", 1, function(a,
            b) {
            this.light.intensity = a
        });
        qa("castShadows", !1, function(a, b) {
            this.light.castShadows = a
        });
        qa("shadowDistance", 40, function(a, b) {
            this.light.shadowDistance = a
        });
        qa("shadowResolution", 1024, function(a, b) {
            this.light.shadowResolution = a
        });
        qa("shadowBias", .05, function(a, b) {
            this.light.shadowBias = -.01 * a
        });
        qa("normalOffsetBias", 0, function(a, b) {
            this.light.normalOffsetBias = a
        });
        qa("range", 10, function(a, b) {
            this.light.attenuationEnd = a
        });
        qa("innerConeAngle", 40, function(a, b) {
            this.light.innerConeAngle = a
        });
        qa("outerConeAngle",
            45,
            function(a, b) {
                this.light.outerConeAngle = a
            });
        qa("falloffMode", 0, function(a, b) {
            this.light.falloffMode = a
        });
        qa("shadowType", 0, function(a, b) {
            this.light.shadowType = a
        });
        qa("vsmBlurSize", 11, function(a, b) {
            this.light.vsmBlurSize = a
        });
        qa("vsmBlurMode", 1, function(a, b) {
            this.light.vsmBlurMode = a
        });
        qa("vsmBias", .0025, function(a, b) {
            this.light.vsmBias = a
        });
        qa("cookieAsset", null, function(a, b) {
            if (!this._cookieAssetId || !(a instanceof aa && a.id === this._cookieAssetId || a === this._cookieAssetId))
                if (this.onCookieAssetRemove(),
                    this._cookieAssetId = null, a instanceof aa) this._cookieAssetId = this.data.cookieAsset = a.id, this.onCookieAssetAdd(a);
                else if ("number" === typeof a)
                if (this._cookieAssetId = a, a = this.system.app.assets.get(a)) this.onCookieAssetAdd(a);
                else this._cookieAssetAdd = !0, this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this)
        });
        qa("cookie", null, function(a, b) {
            this.light.cookie = a
        });
        qa("cookieIntensity", 1, function(a, b) {
            this.light.cookieIntensity = a
        });
        qa("cookieFalloff", !0, function(a, b) {
            this.light.cookieFalloff =
                a
        });
        qa("cookieChannel", "rgb", function(a, b) {
            this.light.cookieChannel = a
        });
        qa("cookieAngle", 0, function(a, b) {
            if (0 !== a || null !== this.cookieScale) {
                this._cookieMatrix || (this._cookieMatrix = new X);
                var c = b = 1;
                this.cookieScale && (b = this.cookieScale.x, c = this.cookieScale.y);
                var d = Math.cos(a * N.DEG_TO_RAD);
                a = Math.sin(a * N.DEG_TO_RAD);
                this._cookieMatrix.set(d / b, -a / b, a / c, d / c);
                this.light.cookieTransform = this._cookieMatrix
            } else this.light.cookieTransform = null
        });
        qa("cookieScale", null, function(a, b) {
            if (null !== a || 0 !== this.cookieAngle) {
                this._cookieMatrix ||
                    (this._cookieMatrix = new X);
                b = a.x;
                a = a.y;
                var c = Math.cos(this.cookieAngle * N.DEG_TO_RAD),
                    d = Math.sin(this.cookieAngle * N.DEG_TO_RAD);
                this._cookieMatrix.set(c / b, -d / b, d / a, c / a);
                this.light.cookieTransform = this._cookieMatrix
            } else this.light.cookieTransform = null
        }, !0);
        qa("cookieOffset", null, function(a, b) {
            this.light.cookieOffset = a
        }, !0);
        qa("shadowUpdateMode", 2, function(a, b) {
            this.light.shadowUpdateMode = a
        });
        qa("mask", 1, function(a, b) {
            this.light.mask = a
        });
        qa("affectDynamic", !0, function(a, b) {
            this.light.mask = a ? this.light.mask |
                1 : this.light.mask & -2
        });
        qa("affectLightmapped", !1, function(a, b) {
            a ? (this.light.mask |= 2, this.bake && (this.light.mask &= -5)) : (this.light.mask &= -3, this.bake && (this.light.mask |= 4))
        });
        qa("bake", !1, function(a, b) {
            a ? (this.light.mask |= 4, this.affectLightmapped && (this.light.mask &= -3)) : (this.light.mask &= -5, this.affectLightmapped && (this.light.mask |= 2))
        });
        qa("bakeDir", !0, function(a, b) {
            this.light.bakeDir = a
        });
        qa("isStatic", !1, function(a, b) {
            this.light.isStatic = a
        });
        qa("layers", [0], function(a, b) {
            var c, d;
            for (c = 0; c < b.length; c++)(d =
                this.system.app.scene.layers.getLayerById(b[c])) && d.removeLight(this);
            for (c = 0; c < a.length; c++)(d = this.system.app.scene.layers.getLayerById(a[c])) && this.enabled && this.entity.enabled && d.addLight(this)
        })
    })();
    Object.assign(ld.prototype, {
        addLightToLayers: function() {
            for (var a, b = 0; b < this.layers.length; b++)(a = this.system.app.scene.layers.getLayerById(this.layers[b])) && a.addLight(this)
        },
        removeLightFromLayers: function() {
            for (var a, b = 0; b < this.layers.length; b++)(a = this.system.app.scene.layers.getLayerById(this.layers[b])) &&
                a.removeLight(this)
        },
        onLayersChanged: function(a, b) {
            this.enabled && this.entity.enabled && this.addLightToLayers();
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || this.enabled && this.entity.enabled && a.addLight(this)
        },
        onLayerRemoved: function(a) {
            0 > this.layers.indexOf(a.id) || a.removeLight(this)
        },
        refreshProperties: function() {
            for (var a, b = 0; b < Rh.length; b++) a =
                Rh[b], this[a] = this[a];
            if (this.enabled && this.entity.enabled) this.onEnable()
        },
        updateShadow: function() {
            this.light.updateShadow()
        },
        onCookieAssetSet: function() {
            var a = !1;
            "cubemap" !== this._cookieAsset.type || this._cookieAsset.loadFaces || (a = this._cookieAsset.loadFaces = !0);
            this._cookieAsset.resource && !a || this.system.app.assets.load(this._cookieAsset);
            if (this._cookieAsset.resource) this.onCookieAssetLoad()
        },
        onCookieAssetAdd: function(a) {
            if (this._cookieAssetId === a.id) {
                this._cookieAsset = a;
                if (this.light.enabled) this.onCookieAssetSet();
                this._cookieAsset.on("load", this.onCookieAssetLoad, this);
                this._cookieAsset.on("remove", this.onCookieAssetRemove, this)
            }
        },
        onCookieAssetLoad: function() {
            this._cookieAsset && this._cookieAsset.resource && (this.cookie = this._cookieAsset.resource)
        },
        onCookieAssetRemove: function() {
            this._cookieAssetId && (this._cookieAssetAdd && (this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this), this._cookieAssetAdd = !1), this._cookieAsset && (this._cookieAsset.off("load", this.onCookieAssetLoad, this), this._cookieAsset.off("remove",
                this.onCookieAssetRemove, this), this._cookieAsset = null), this.cookie = null)
        },
        onEnable: function() {
            this.light.enabled = !0;
            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this), this.system.app.scene.layers.on("remove", this.onLayerRemoved, this));
            this.enabled && this.entity.enabled && this.addLightToLayers();
            if (this._cookieAsset && !this.cookie) this.onCookieAssetSet()
        },
        onDisable: function() {
            this.light.enabled = !1;
            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this), this.system.app.scene.layers.off("remove", this.onLayerRemoved, this));
            this.removeLightFromLayers()
        },
        onRemove: function() {
            this.light.destroy();
            this.cookieAsset = null
        }
    });
    var tj = Rh,
        zo = $m,
        an = {
            directional: 0,
            point: 1,
            spot: 2
        };
    Ge.prototype = Object.create(H.prototype);
    Ge.prototype.constructor = Ge;
    Object.assign(Ge.prototype, {
        initializeComponentData: function(a,
            b) {
            for (var c = tj, d = {}, e = 0, f = c.length; e < f; e++) {
                var g = c[e];
                d[g] = b[g]
            }
            d.type || (d.type = a.data.type);
            a.data.type = d.type;
            d.layers && Array.isArray(d.layers) && (d.layers = d.layers.slice(0));
            d.color && Array.isArray(d.color) && (d.color = new L(d.color[0], d.color[1], d.color[2]));
            d.cookieOffset && d.cookieOffset instanceof Array && (d.cookieOffset = new P(d.cookieOffset[0], d.cookieOffset[1]));
            d.cookieScale && d.cookieScale instanceof Array && (d.cookieScale = new P(d.cookieScale[0], d.cookieScale[1]));
            d.enable && (console.warn("WARNING: enable: Property is deprecated. Set enabled property instead."),
                d.enabled = d.enable);
            b = new Va;
            b.type = an[d.type];
            b._node = a.entity;
            b._scene = this.app.scene;
            a.data.light = b;
            H.prototype.initializeComponentData.call(this, a, d, c)
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        },
        cloneComponent: function(a, b) {
            a = a.light;
            for (var c = [], d, e = tj, f = 0; f < e.length; f++) d = e[f], "light" !== d && (c[d] = a[d] && a[d].clone ? a[d].clone() : a[d]);
            this.addComponent(b, c)
        },
        changeType: function(a, b, c) {
            b !== c && (a.light.type = an[c])
        }
    });
    Ga.prototype = Object.create(O.prototype);
    Ga.prototype.constructor = Ga;
    Object.assign(Ga.prototype, {
        addModelToLayers: function() {
            for (var a, b = this.system.app.scene.layers, c = 0; c < this._layers.length; c++)(a = b.getLayerById(this._layers[c])) && a.addMeshInstances(this.meshInstances)
        },
        removeModelFromLayers: function() {
            for (var a, b = this.system.app.scene.layers, c = 0; c < this._layers.length; c++)(a = b.getLayerById(this._layers[c])) && a.removeMeshInstances(this.meshInstances)
        },
        onRemoveChild: function() {
            this._model && this.removeModelFromLayers()
        },
        onInsertChild: function() {
            this._model && this.enabled && this.entity.enabled &&
                this.addModelToLayers()
        },
        onRemove: function() {
            "asset" === this.type ? this.asset = null : this.model = null;
            this.materialAsset = null;
            this._unsetMaterialEvents();
            this.entity.off("remove", this.onRemoveChild, this);
            this.entity.off("insert", this.onInsertChild, this)
        },
        onLayersChanged: function(a, b) {
            this.addModelToLayers();
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) ||
                a.addMeshInstances(this.meshInstances)
        },
        onLayerRemoved: function(a) {
            0 > this.layers.indexOf(a.id) || a.removeMeshInstances(this.meshInstances)
        },
        _setMaterialEvent: function(a, b, c, d) {
            b = b + ":" + c;
            this.system.app.assets.on(b, d, this);
            this._materialEvents || (this._materialEvents = []);
            this._materialEvents[a] || (this._materialEvents[a] = {});
            this._materialEvents[a][b] = {
                id: c,
                handler: d
            }
        },
        _unsetMaterialEvents: function() {
            var a = this.system.app.assets,
                b = this._materialEvents;
            if (b) {
                for (var c = 0, d = b.length; c < d; c++)
                    if (b[c]) {
                        var e =
                            b[c],
                            f;
                        for (f in e) a.off(f, e[f].handler, this)
                    }
                this._materialEvents = null
            }
        },
        _getAssetByIdOrPath: function(a) {
            var b = null;
            isNaN(parseInt(a, 10)) ? this.asset && (a = this._getMaterialAssetUrl(a)) && (b = this.system.app.assets.getByUrl(a)) : b = this.system.app.assets.get(a);
            return b
        },
        _getMaterialAssetUrl: function(a) {
            if (!this.asset) return null;
            var b = this.system.app.assets.get(this.asset);
            return b ? b.getAbsoluteUrl(a) : null
        },
        _loadAndSetMeshInstanceMaterial: function(a, b, c) {
            var d = this.system.app.assets;
            a && (a.resource ? (b.material =
                a.resource, this._setMaterialEvent(c, "remove", a.id, function() {
                    b.material = this.system.defaultMaterial
                })) : (this._setMaterialEvent(c, "load", a.id, function(e) {
                b.material = e.resource;
                this._setMaterialEvent(c, "remove", a.id, function() {
                    b.material = this.system.defaultMaterial
                })
            }), this.enabled && this.entity.enabled && d.load(a)))
        },
        onEnable: function() {
            var a = this.system.app,
                b = a.scene;
            b.on("set:layers", this.onLayersChanged, this);
            b.layers && (b.layers.on("add", this.onLayerAdded, this), b.layers.on("remove", this.onLayerRemoved,
                this));
            b = "asset" === this._type;
            var c;
            this._model ? this.addModelToLayers() : b && this._asset && (c = a.assets.get(this._asset)) && c.resource !== this._model && this._bindModelAsset(c);
            this._materialAsset && (c = a.assets.get(this._materialAsset)) && c.resource !== this._material && this._bindMaterialAsset(c);
            if (b && this._mapping)
                for (var d in this._mapping) this._mapping[d] && (c = this._getAssetByIdOrPath(this._mapping[d])) && !c.resource && a.assets.load(c);
            0 <= this._batchGroupId && a.batcher.insert(bb.MODEL, this.batchGroupId, this.entity)
        },
        onDisable: function() {
            var a = this.system.app,
                b = a.scene;
            b.off("set:layers", this.onLayersChanged, this);
            b.layers && (b.layers.off("add", this.onLayerAdded, this), b.layers.off("remove", this.onLayerRemoved, this));
            0 <= this._batchGroupId && a.batcher.remove(bb.MODEL, this.batchGroupId, this.entity);
            this._model && this.removeModelFromLayers()
        },
        hide: function() {
            if (this._model) {
                var a, b = this._model.meshInstances;
                var c = 0;
                for (a = b.length; c < a; c++) b[c].visible = !1
            }
        },
        show: function() {
            if (this._model) {
                var a, b = this._model.meshInstances;
                var c = 0;
                for (a = b.length; c < a; c++) b[c].visible = !0
            }
        },
        _bindMaterialAsset: function(a) {
            a.on("load", this._onMaterialAssetLoad, this);
            a.on("unload", this._onMaterialAssetUnload, this);
            a.on("remove", this._onMaterialAssetRemove, this);
            a.on("change", this._onMaterialAssetChange, this);
            a.resource ? this._onMaterialAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindMaterialAsset: function(a) {
            a.off("load", this._onMaterialAssetLoad, this);
            a.off("unload", this._onMaterialAssetUnload, this);
            a.off("remove", this._onMaterialAssetRemove, this);
            a.off("change", this._onMaterialAssetChange, this)
        },
        _onMaterialAssetAdd: function(a) {
            this.system.app.assets.off("add:" + a.id, this._onMaterialAssetAdd, this);
            this._materialAsset === a.id && this._bindMaterialAsset(a)
        },
        _onMaterialAssetLoad: function(a) {
            this._setMaterial(a.resource)
        },
        _onMaterialAssetUnload: function(a) {
            this._setMaterial(this.system.defaultMaterial)
        },
        _onMaterialAssetRemove: function(a) {
            this._onMaterialAssetUnload(a)
        },
        _onMaterialAssetChange: function(a) {},
        _bindModelAsset: function(a) {
            this._unbindModelAsset(a);
            a.on("load", this._onModelAssetLoad, this);
            a.on("unload", this._onModelAssetUnload, this);
            a.on("change", this._onModelAssetChange, this);
            a.on("remove", this._onModelAssetRemove, this);
            a.resource ? this._onModelAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindModelAsset: function(a) {
            a.off("load", this._onModelAssetLoad, this);
            a.off("unload", this._onModelAssetUnload, this);
            a.off("change", this._onModelAssetChange, this);
            a.off("remove",
                this._onModelAssetRemove, this)
        },
        _onModelAssetAdded: function(a) {
            this.system.app.assets.off("add:" + a.id, this._onModelAssetAdded, this);
            a.id === this._asset && this._bindModelAsset(a)
        },
        _onModelAssetLoad: function(a) {
            this.model = a.resource.clone();
            this._clonedModel = !0
        },
        _onModelAssetUnload: function(a) {
            this.model = null
        },
        _onModelAssetChange: function(a, b, c, d) {
            "data" === b && (this.mapping = this._mapping)
        },
        _onModelAssetRemove: function(a) {
            this.model = null
        },
        _setMaterial: function(a) {
            if (this._material !== a) {
                this._material = a;
                var b = this._model;
                if (b && "asset" !== this._type) {
                    b = b.meshInstances;
                    for (var c = 0, d = b.length; c < d; c++) b[c].material = a
                }
            }
        }
    });
    Object.defineProperty(Ga.prototype, "meshInstances", {
        get: function() {
            return this._model ? this._model.meshInstances : null
        },
        set: function(a) {
            this._model && (this._model.meshInstances = a)
        }
    });
    Object.defineProperties(Ga.prototype, {
        aabb: {
            get: function() {
                return this._aabb
            },
            set: function(a) {
                this._aabb = a;
                if (a = this._model.meshInstances)
                    for (var b = 0; b < a.length; b++) a[b].setOverrideAabb(this._aabb)
            }
        }
    });
    Object.defineProperty(Ga.prototype,
        "type", {
            get: function() {
                return this._type
            },
            set: function(a) {
                if (this._type !== a)
                    if (this._area = null, this._type = a, "asset" === a) null !== this._asset ? this._bindModelAsset(this._asset) : this.model = null;
                    else {
                        var b = this.system,
                            c = b.app.graphicsDevice;
                        switch (a) {
                            case "box":
                                b.box || (b.box = Hg(c, {
                                    halfExtents: new z(.5, .5, .5)
                                }));
                                a = b.box;
                                this._area = {
                                    x: 2,
                                    y: 2,
                                    z: 2,
                                    uv: 2 / 3
                                };
                                break;
                            case "capsule":
                                b.capsule || (b.capsule = si(c, {
                                    radius: .5,
                                    height: 2
                                }));
                                a = b.capsule;
                                this._area = {
                                    x: 2 * Math.PI,
                                    y: Math.PI,
                                    z: 2 * Math.PI,
                                    uv: 1 / 3 + 1 / 3 / 3 * 2
                                };
                                break;
                            case "cone":
                                b.cone ||
                                    (b.cone = ti(c, {
                                        baseRadius: .5,
                                        peakRadius: 0,
                                        height: 1
                                    }));
                                a = b.cone;
                                this._area = {
                                    x: 2.54,
                                    y: 2.54,
                                    z: 2.54,
                                    uv: 1 / 3 + 1 / 3 / 3
                                };
                                break;
                            case "cylinder":
                                b.cylinder || (b.cylinder = ri(c, {
                                    radius: .5,
                                    height: 1
                                }));
                                a = b.cylinder;
                                this._area = {
                                    x: Math.PI,
                                    y: 1.58,
                                    z: Math.PI,
                                    uv: 1 / 3 + 1 / 3 / 3 * 2
                                };
                                break;
                            case "plane":
                                b.plane || (b.plane = vi(c, {
                                    halfExtents: new P(.5, .5),
                                    widthSegments: 1,
                                    lengthSegments: 1
                                }));
                                a = b.plane;
                                this._area = {
                                    x: 0,
                                    y: 1,
                                    z: 0,
                                    uv: 1
                                };
                                break;
                            case "sphere":
                                b.sphere || (b.sphere = ui(c, {
                                    radius: .5
                                }));
                                a = b.sphere;
                                this._area = {
                                    x: Math.PI,
                                    y: Math.PI,
                                    z: Math.PI,
                                    uv: 1
                                };
                                break;
                            default:
                                throw Error("Invalid model type: " + a);
                        }
                        c = new Z;
                        var d = new tb;
                        d.graph = c;
                        d.meshInstances = [new va(c, a, this._material)];
                        b._inTools && d.generateWireframe();
                        this.model = d;
                        this._asset = null
                    }
            }
        });
    Object.defineProperty(Ga.prototype, "asset", {
        get: function() {
            return this._asset
        },
        set: function(a) {
            var b = this.system.app.assets,
                c = a;
            a instanceof aa && (c = a.id);
            this._asset !== c && (this._asset && (b.off("add:" + this._asset, this._onModelAssetAdded, this), (a = b.get(this._asset)) && this._unbindModelAsset(a)), (this._asset =
                c) ? (c = b.get(this._asset)) ? this._bindModelAsset(c) : (this.model = null, b.on("add:" + this._asset, this._onModelAssetAdded, this)) : this.model = null)
        }
    });
    Object.defineProperty(Ga.prototype, "model", {
        get: function() {
            return this._model
        },
        set: function(a) {
            if (!(this._model === a || a && a._immutable) && (this._model && (this._model._immutable = !1, this.removeModelFromLayers(), this.entity.removeChild(this._model.getGraph()), delete this._model._entity, this._clonedModel && (this._model.destroy(), this._clonedModel = !1)), this._model = a)) {
                this._model._immutable = !0;
                var b = this._model.meshInstances;
                for (a = 0; a < b.length; a++) b[a].castShadow = this._castShadows, b[a].receiveShadow = this._receiveShadows, b[a].isStatic = this._isStatic, b[a].setOverrideAabb(this._aabb);
                this.lightmapped = this._lightmapped;
                this.entity.addChild(this._model.graph);
                this.enabled && this.entity.enabled && this.addModelToLayers();
                this._model._entity = this.entity;
                this.entity.animation && this.entity.animation.setModel(this._model);
                this.entity.anim && this.entity.anim.resetStateGraph();
                "asset" === this.type ? this.mapping =
                    this._mapping : this._unsetMaterialEvents()
            }
        }
    });
    Object.defineProperty(Ga.prototype, "lightmapped", {
        get: function() {
            return this._lightmapped
        },
        set: function(a) {
            if (a !== this._lightmapped && (this._lightmapped = a, this._model)) {
                var b = this._model.meshInstances;
                if (a)
                    for (a = 0; a < b.length; a++) {
                        var c = b[a];
                        var d = c.mask;
                        c.mask = (d | 2) & -6
                    } else
                        for (a = 0; a < b.length; a++) c = b[a], c.deleteParameter("texture_lightMap"), c.deleteParameter("texture_dirLightMap"), c._shaderDefs &= -65, d = c.mask, c.mask = (d | 1) & -7
            }
        }
    });
    Object.defineProperty(Ga.prototype,
        "castShadows", {
            get: function() {
                return this._castShadows
            },
            set: function(a) {
                if (this._castShadows !== a) {
                    var b, c, d = this._model;
                    if (d) {
                        var e = this.layers,
                            f = this.system.app.scene;
                        if (this._castShadows && !a)
                            for (c = 0; c < e.length; c++)(b = this.system.app.scene.layers.getLayerById(this.layers[c])) && b.removeShadowCasters(d.meshInstances);
                        b = d.meshInstances;
                        for (c = 0; c < b.length; c++) b[c].castShadow = a;
                        if (!this._castShadows && a)
                            for (c = 0; c < e.length; c++)(b = f.layers.getLayerById(e[c])) && b.addShadowCasters(d.meshInstances)
                    }
                    this._castShadows =
                        a
                }
            }
        });
    Object.defineProperty(Ga.prototype, "receiveShadows", {
        get: function() {
            return this._receiveShadows
        },
        set: function(a) {
            if (this._receiveShadows !== a && (this._receiveShadows = a, this._model))
                for (var b = this._model.meshInstances, c = 0, d = b.length; c < d; c++) b[c].receiveShadow = a
        }
    });
    Object.defineProperty(Ga.prototype, "castShadowsLightmap", {
        get: function() {
            return this._castShadowsLightmap
        },
        set: function(a) {
            this._castShadowsLightmap = a
        }
    });
    Object.defineProperty(Ga.prototype, "lightmapSizeMultiplier", {
        get: function() {
            return this._lightmapSizeMultiplier
        },
        set: function(a) {
            this._lightmapSizeMultiplier = a
        }
    });
    Object.defineProperty(Ga.prototype, "isStatic", {
        get: function() {
            return this._isStatic
        },
        set: function(a) {
            if (this._isStatic !== a) {
                this._isStatic = a;
                var b;
                if (this._model) {
                    var c = this._model.meshInstances;
                    for (b = 0; b < c.length; b++) {
                        var d = c[b];
                        d.isStatic = a
                    }
                }
            }
        }
    });
    Object.defineProperty(Ga.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            var b, c, d = this.system.app.scene.layers;
            if (this.meshInstances)
                for (b = 0; b < this._layers.length; b++)(c = d.getLayerById(this._layers[b])) &&
                    c.removeMeshInstances(this.meshInstances);
            for (b = this._layers.length = 0; b < a.length; b++) this._layers[b] = a[b];
            if (this.enabled && this.entity.enabled && this.meshInstances)
                for (b = 0; b < this._layers.length; b++)(c = d.getLayerById(this._layers[b])) && c.addMeshInstances(this.meshInstances)
        }
    });
    Object.defineProperty(Ga.prototype, "batchGroupId", {
        get: function() {
            return this._batchGroupId
        },
        set: function(a) {
            if (this._batchGroupId !== a) {
                var b = this.system.app.batcher;
                this.entity.enabled && 0 <= this._batchGroupId && b.remove(bb.MODEL,
                    this.batchGroupId, this.entity);
                this.entity.enabled && 0 <= a && b.insert(bb.MODEL, a, this.entity);
                0 > a && 0 <= this._batchGroupId && this.enabled && this.entity.enabled && this.addModelToLayers();
                this._batchGroupId = a
            }
        }
    });
    Object.defineProperty(Ga.prototype, "materialAsset", {
        get: function() {
            return this._materialAsset
        },
        set: function(a) {
            var b = a;
            a instanceof aa && (b = a.id);
            a = this.system.app.assets;
            if (b !== this._materialAsset) {
                if (this._materialAsset) {
                    a.off("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
                    var c = a.get(this._materialAsset);
                    c && this._unbindMaterialAsset(c)
                }(this._materialAsset = b) ? (b = a.get(this._materialAsset)) ? this._bindMaterialAsset(b): (this._setMaterial(this.system.defaultMaterial), a.on("add:" + this._materialAsset, this._onMaterialAssetAdd, this)): this._setMaterial(this.system.defaultMaterial)
            }
        }
    });
    Object.defineProperty(Ga.prototype, "material", {
        get: function() {
            return this._material
        },
        set: function(a) {
            this._material !== a && (this.materialAsset = null, this._setMaterial(a))
        }
    });
    Object.defineProperty(Ga.prototype, "mapping", {
        get: function() {
            return this._mapping
        },
        set: function(a) {
            if ("asset" === this._type && (this._unsetMaterialEvents(), a || (a = {}), this._mapping = a, this._model)) {
                var b = this._model.meshInstances,
                    c = this.asset ? this.system.app.assets.get(this.asset) : null;
                c = c ? c.data.mapping : null;
                for (var d = null, e = 0, f = b.length; e < f; e++)
                    if (void 0 !== a[e]) a[e] ? (d = this.system.app.assets.get(a[e]), this._loadAndSetMeshInstanceMaterial(d, b[e], e)) : b[e].material = this.system.defaultMaterial;
                    else if (c)
                    if (c[e] && (c[e].material || c[e].path)) {
                        if (void 0 !== c[e].material) d = this.system.app.assets.get(c[e].material);
                        else if (void 0 !== c[e].path) {
                            var g = this._getMaterialAssetUrl(c[e].path);
                            g && (d = this.system.app.assets.getByUrl(g))
                        }
                        this._loadAndSetMeshInstanceMaterial(d, b[e], e)
                    } else b[e].material = this.system.defaultMaterial
            }
        }
    });
    var zl = ["enabled"];
    He.prototype = Object.create(H.prototype);
    He.prototype.constructor = He;
    O._buildAccessors(Ga.prototype, zl);
    Object.assign(He.prototype, {
        initializeComponentData: function(a, b, c) {
            c = "material materialAsset asset castShadows receiveShadows castShadowsLightmap lightmapped lightmapSizeMultiplier type mapping layers isStatic batchGroupId".split(" ");
            if (null === b.batchGroupId || void 0 === b.batchGroupId) b.batchGroupId = -1;
            b.layers && b.layers.length && (b.layers = b.layers.slice(0));
            for (var d = 0; d < c.length; d++) b.hasOwnProperty(c[d]) && (a[c[d]] = b[c[d]]);
            H.prototype.initializeComponentData.call(this, a, b, ["enabled"])
        },
        cloneComponent: function(a, b) {
            var c = {
                    type: a.model.type,
                    asset: a.model.asset,
                    castShadows: a.model.castShadows,
                    receiveShadows: a.model.receiveShadows,
                    castShadowsLightmap: a.model.castShadowsLightmap,
                    lightmapped: a.model.lightmapped,
                    lightmapSizeMultiplier: a.model.lightmapSizeMultiplier,
                    isStatic: a.model.isStatic,
                    enabled: a.model.enabled,
                    layers: a.model.layers,
                    batchGroupId: a.model.batchGroupId,
                    mapping: Hc({}, a.model.mapping)
                },
                d = a.model.materialAsset;
            d instanceof aa || null == d || (d = this.app.assets.get(d));
            var e = a.model.material;
            e && e !== this.defaultMaterial && d && e !== d.resource || (c.materialAsset = d);
            b = this.addComponent(b, c);
            a.model.model && "asset" === a.model.type && !a.model.asset && (b.model = a.model.model.clone(), b._clonedModel = !0);
            c.materialAsset || (b.material = e);
            if (a.model.model)
                for (a = a.model.model.meshInstances,
                    c = b.model.meshInstances, e = 0; e < a.length; e++) c[e].mask = a[e].mask, c[e].material = a[e].material, c[e].layer = a[e].layer, c[e].receiveShadow = a[e].receiveShadow
        },
        onRemove: function(a, b) {
            b.onRemove()
        }
    });
    var Up = "emitterExtents emitterRadius emitterExtentsInner emitterRadiusInner loop initialVelocity animSpeed normalMap particleNormal".split(" "),
        Vp = "numParticles lifetime rate rate2 startAngle startAngle2 lighting halfLambert intensity wrap wrapBounds depthWrite noFog sort stretch alignToMotion preWarm emitterShape animTilesX animTilesY animStartFrame animNumFrames animNumAnimations animIndex randomizeAnimIndex animLoop colorMap localSpace screenSpace orientation".split(" "),
        Wp = "scaleGraph scaleGraph2 colorGraph colorGraph2 alphaGraph alphaGraph2 velocityGraph velocityGraph2 localVelocityGraph localVelocityGraph2 rotationSpeedGraph rotationSpeedGraph2 radialSpeedGraph radialSpeedGraph2".split(" "),
        Sh = ["colorMapAsset", "normalMapAsset", "meshAsset"],
        qf, md = function(a, b) {
            O.call(this, a, b);
            this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
            this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
            this.on("set_meshAsset", this.onSetMeshAsset, this);
            this.on("set_mesh",
                this.onSetMesh, this);
            this.on("set_loop", this.onSetLoop, this);
            this.on("set_blendType", this.onSetBlendType, this);
            this.on("set_depthSoftening", this.onSetDepthSoftening, this);
            this.on("set_layers", this.onSetLayers, this);
            Up.forEach(function(c) {
                this.on("set_" + c, this.onSetSimpleProperty, this)
            }.bind(this));
            Vp.forEach(function(c) {
                this.on("set_" + c, this.onSetComplexProperty, this)
            }.bind(this));
            Wp.forEach(function(c) {
                this.on("set_" + c, this.onSetGraphProperty, this)
            }.bind(this));
            this._requestedDepth = !1;
            this._drawOrder =
                0
        };
    md.prototype = Object.create(O.prototype);
    md.prototype.constructor = md;
    Object.defineProperties(md.prototype, {
        drawOrder: {
            get: function() {
                return this._drawOrder
            },
            set: function(a) {
                this._drawOrder = a;
                this.emitter && (this.emitter.drawOrder = a)
            }
        }
    });
    Object.assign(md.prototype, {
        addModelToLayers: function() {
            if (this.data.model)
                for (var a, b = 0; b < this.layers.length; b++)
                    if (a = this.system.app.scene.layers.getLayerById(this.layers[b])) a.addMeshInstances(this.data.model.meshInstances), this.emitter._layer = a
        },
        removeModelFromLayers: function(a) {
            if (this.data.model)
                for (var b =
                        0; b < this.layers.length; b++)(a = this.system.app.scene.layers.getLayerById(this.layers[b])) && a.removeMeshInstances(this.data.model.meshInstances)
        },
        onSetLayers: function(a, b, c) {
            if (this.data.model) {
                var d;
                for (a = 0; a < b.length; a++)(d = this.system.app.scene.layers.getLayerById(b[a])) && d.removeMeshInstances(this.data.model.meshInstances);
                if (this.enabled && this.entity.enabled)
                    for (a = 0; a < c.length; a++)(d = this.system.app.scene.layers.getLayerById(c[a])) && d.addMeshInstances(this.data.model.meshInstances)
            }
        },
        onLayersChanged: function(a,
            b) {
            this.addModelToLayers();
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            this.data.model && (0 > this.layers.indexOf(a.id) || a.addMeshInstances(this.data.model.meshInstances))
        },
        onLayerRemoved: function(a) {
            this.data.model && (0 > this.layers.indexOf(a.id) || a.removeMeshInstances(this.data.model.meshInstances))
        },
        _bindColorMapAsset: function(a) {
            a.on("load", this._onColorMapAssetLoad,
                this);
            a.on("unload", this._onColorMapAssetUnload, this);
            a.on("remove", this._onColorMapAssetRemove, this);
            a.on("change", this._onColorMapAssetChange, this);
            a.resource ? this._onColorMapAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindColorMapAsset: function(a) {
            a.off("load", this._onColorMapAssetLoad, this);
            a.off("unload", this._onColorMapAssetUnload, this);
            a.off("remove", this._onColorMapAssetRemove, this);
            a.off("change", this._onColorMapAssetChange, this)
        },
        _onColorMapAssetLoad: function(a) {
            this.colorMap =
                a.resource
        },
        _onColorMapAssetUnload: function(a) {
            this.colorMap = null
        },
        _onColorMapAssetRemove: function(a) {
            this._onColorMapAssetUnload(a)
        },
        _onColorMapAssetChange: function(a) {},
        onSetColorMapAsset: function(a, b, c) {
            var d = this;
            a = this.system.app.assets;
            b && (b = a.get(b)) && this._unbindColorMapAsset(b);
            if (c)
                if (c instanceof aa && (c = this.data.colorMapAsset = c.id), b = a.get(c)) d._bindColorMapAsset(b);
                else a.once("add:" + c, function(e) {
                    d._bindColorMapAsset(e)
                });
            else this.colorMap = null
        },
        _bindNormalMapAsset: function(a) {
            a.on("load",
                this._onNormalMapAssetLoad, this);
            a.on("unload", this._onNormalMapAssetUnload, this);
            a.on("remove", this._onNormalMapAssetRemove, this);
            a.on("change", this._onNormalMapAssetChange, this);
            a.resource ? this._onNormalMapAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindNormalMapAsset: function(a) {
            a.off("load", this._onNormalMapAssetLoad, this);
            a.off("unload", this._onNormalMapAssetUnload, this);
            a.off("remove", this._onNormalMapAssetRemove, this);
            a.off("change", this._onNormalMapAssetChange,
                this)
        },
        _onNormalMapAssetLoad: function(a) {
            this.normalMap = a.resource
        },
        _onNormalMapAssetUnload: function(a) {
            this.normalMap = null
        },
        _onNormalMapAssetRemove: function(a) {
            this._onNormalMapAssetUnload(a)
        },
        _onNormalMapAssetChange: function(a) {},
        onSetNormalMapAsset: function(a, b, c) {
            var d = this;
            a = this.system.app.assets;
            b && (b = a.get(b)) && this._unbindNormalMapAsset(b);
            if (c)
                if (c instanceof aa && (c = this.data.normalMapAsset = c.id), b = a.get(c)) d._bindNormalMapAsset(b);
                else a.once("add:" + c, function(e) {
                    d._bindNormalMapAsset(e)
                });
            else this.normalMap = null
        },
        _bindMeshAsset: function(a) {
            a.on("load", this._onMeshAssetLoad, this);
            a.on("unload", this._onMeshAssetUnload, this);
            a.on("remove", this._onMeshAssetRemove, this);
            a.on("change", this._onMeshAssetChange, this);
            a.resource ? this._onMeshAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindMeshAsset: function(a) {
            a.off("load", this._onMeshAssetLoad, this);
            a.off("unload", this._onMeshAssetUnload, this);
            a.off("remove", this._onMeshAssetRemove, this);
            a.off("change",
                this._onMeshAssetChange, this)
        },
        _onMeshAssetLoad: function(a) {
            this._onMeshChanged(a.resource)
        },
        _onMeshAssetUnload: function(a) {
            this.mesh = null
        },
        _onMeshAssetRemove: function(a) {
            this._onMeshAssetUnload(a)
        },
        _onMeshAssetChange: function(a) {},
        onSetMeshAsset: function(a, b, c) {
            a = this.system.app.assets;
            b && (b = a.get(b)) && this._unbindMeshAsset(b);
            if (c) {
                if (c instanceof aa && (c = this.data.meshAsset = c.id), b = a.get(c)) this._bindMeshAsset(b), b.resource ? this._onMeshChanged(b.resource) : a.load(b)
            } else this._onMeshChanged(null)
        },
        onSetMesh: function(a, b, c) {
            !c || c instanceof aa || "number" === typeof c ? this.meshAsset = c : this._onMeshChanged(c)
        },
        _onMeshChanged: function(a) {
            !a || a instanceof sb || (a = a.meshInstances[0] ? a.meshInstances[0].mesh : null);
            this.data.mesh = a;
            this.emitter && (this.emitter.mesh = a, this.emitter.resetMaterial(), this.rebuild())
        },
        onSetLoop: function(a, b, c) {
            this.emitter && (this.emitter[a] = c, this.emitter.resetTime())
        },
        onSetBlendType: function(a, b, c) {
            this.emitter && (this.emitter[a] = c, this.emitter.material.blendType = c, this.emitter.resetMaterial(),
                this.rebuild())
        },
        _requestDepth: function() {
            this._requestedDepth || (qf || (qf = this.system.app.scene.layers.getLayerById(1)), qf && (qf.incrementCounter(), this._requestedDepth = !0))
        },
        _releaseDepth: function() {
            this._requestedDepth && qf && (qf.decrementCounter(), this._requestedDepth = !1)
        },
        onSetDepthSoftening: function(a, b, c) {
            b !== c && (c ? this.enabled && this.entity.enabled && this._requestDepth() : this.enabled && this.entity.enabled && this._releaseDepth(), this.emitter && (this.emitter[a] = c), this.emitter && (this.reset(), this.emitter.resetMaterial(),
                this.rebuild()))
        },
        onSetSimpleProperty: function(a, b, c) {
            this.emitter && (this.emitter[a] = c, this.emitter.resetMaterial())
        },
        onSetComplexProperty: function(a, b, c) {
            this.emitter && (this.emitter[a] = c, this.emitter.resetMaterial(), this.rebuild(), this.reset())
        },
        onSetGraphProperty: function(a, b, c) {
            this.emitter && (this.emitter[a] = c, this.emitter.rebuildGraphs(), this.emitter.resetMaterial())
        },
        onEnable: function() {
            for (var a = this.data, b = 0, c = Sh.length; b < c; b++) {
                var d = a[Sh[b]];
                if (d) {
                    if (!(d instanceof aa))
                        if (0 <= parseInt(d, 10)) d =
                            this.system.app.assets.get(d);
                        else continue;
                    d && !d.resource && this.system.app.assets.load(d)
                }
            }
            this.emitter || (b = a.mesh, b instanceof sb || (b = null), this.emitter = new $b(this.system.app.graphicsDevice, {
                numParticles: a.numParticles,
                emitterExtents: a.emitterExtents,
                emitterExtentsInner: a.emitterExtentsInner,
                emitterRadius: a.emitterRadius,
                emitterRadiusInner: a.emitterRadiusInner,
                emitterShape: a.emitterShape,
                initialVelocity: a.initialVelocity,
                wrap: a.wrap,
                localSpace: a.localSpace,
                screenSpace: a.screenSpace,
                wrapBounds: a.wrapBounds,
                lifetime: a.lifetime,
                rate: a.rate,
                rate2: a.rate2,
                orientation: a.orientation,
                particleNormal: a.particleNormal,
                animTilesX: a.animTilesX,
                animTilesY: a.animTilesY,
                animStartFrame: a.animStartFrame,
                animNumFrames: a.animNumFrames,
                animNumAnimations: a.animNumAnimations,
                animIndex: a.animIndex,
                randomizeAnimIndex: a.randomizeAnimIndex,
                animSpeed: a.animSpeed,
                animLoop: a.animLoop,
                startAngle: a.startAngle,
                startAngle2: a.startAngle2,
                scaleGraph: a.scaleGraph,
                scaleGraph2: a.scaleGraph2,
                colorGraph: a.colorGraph,
                colorGraph2: a.colorGraph2,
                alphaGraph: a.alphaGraph,
                alphaGraph2: a.alphaGraph2,
                localVelocityGraph: a.localVelocityGraph,
                localVelocityGraph2: a.localVelocityGraph2,
                velocityGraph: a.velocityGraph,
                velocityGraph2: a.velocityGraph2,
                rotationSpeedGraph: a.rotationSpeedGraph,
                rotationSpeedGraph2: a.rotationSpeedGraph2,
                radialSpeedGraph: a.radialSpeedGraph,
                radialSpeedGraph2: a.radialSpeedGraph2,
                colorMap: a.colorMap,
                normalMap: a.normalMap,
                loop: a.loop,
                preWarm: a.preWarm,
                sort: a.sort,
                stretch: a.stretch,
                alignToMotion: a.alignToMotion,
                lighting: a.lighting,
                halfLambert: a.halfLambert,
                intensity: a.intensity,
                depthSoftening: a.depthSoftening,
                scene: this.system.app.scene,
                mesh: b,
                depthWrite: a.depthWrite,
                noFog: a.noFog,
                node: this.entity,
                blendType: a.blendType
            }), this.emitter.meshInstance.node = this.entity, this.emitter.drawOrder = this.drawOrder, this.psys = new tb, this.psys.graph = this.entity, this.psys.emitter = this.emitter, this.psys.meshInstances = [this.emitter.meshInstance], a.model = this.psys, this.emitter.psys = this.psys, a.autoPlay || (this.pause(), this.emitter.meshInstance.visible = !1));
            a.model && this.emitter.colorMap && this.addModelToLayers();
            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this), this.system.app.scene.layers.on("remove", this.onLayerRemoved, this));
            this.enabled && this.entity.enabled && a.depthSoftening && this._requestDepth()
        },
        onDisable: function() {
            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.off("add",
                this.onLayerAdded, this), this.system.app.scene.layers.off("remove", this.onLayerRemoved, this));
            this.data.model && (this.removeModelFromLayers(), this.data.depthSoftening && this._releaseDepth());
            this.emitter && (this.emitter.camera = null)
        },
        onBeforeRemove: function() {
            this.enabled && (this.enabled = !1);
            var a = this.data;
            a.model && (this.entity.removeChild(a.model.getGraph()), a.model.destroy(), a.model = null);
            this.emitter && (this.emitter.destroy(), this.emitter = null);
            for (var b = 0; b < Sh.length; b++) {
                var c = Sh[b];
                a[c] && (this[c] =
                    null)
            }
            this.off()
        },
        reset: function() {
            this.emitter && this.emitter.reset()
        },
        stop: function() {
            this.emitter && (this.emitter.loop = !1, this.emitter.resetTime(), this.emitter.addTime(0, !0))
        },
        pause: function() {
            this.data.paused = !0
        },
        unpause: function() {
            this.data.paused = !1
        },
        play: function() {
            this.data.paused = !1;
            this.emitter && (this.emitter.meshInstance.visible = !0, this.emitter.loop = this.data.loop, this.emitter.resetTime())
        },
        isPlaying: function() {
            return this.data.paused ? !1 : this.emitter && this.emitter.loop ? !0 : Date.now() <= this.emitter.endTime
        },
        rebuild: function() {
            var a = this.enabled;
            this.enabled = !1;
            this.emitter && (this.emitter.rebuild(), this.emitter.meshInstance.node = this.entity, this.data.model.meshInstances = [this.emitter.meshInstance]);
            this.enabled = a
        }
    });
    var Al = "enabled autoPlay numParticles lifetime rate rate2 startAngle startAngle2 loop preWarm lighting halfLambert intensity depthWrite noFog depthSoftening sort blendType stretch alignToMotion emitterShape emitterExtents emitterExtentsInner emitterRadius emitterRadiusInner initialVelocity wrap wrapBounds localSpace screenSpace colorMapAsset normalMapAsset mesh meshAsset orientation particleNormal localVelocityGraph localVelocityGraph2 velocityGraph velocityGraph2 rotationSpeedGraph rotationSpeedGraph2 radialSpeedGraph radialSpeedGraph2 scaleGraph scaleGraph2 colorGraph colorGraph2 alphaGraph alphaGraph2 colorMap normalMap animTilesX animTilesY animStartFrame animNumFrames animNumAnimations animIndex randomizeAnimIndex animSpeed animLoop layers".split(" ");
    Ie.prototype = Object.create(H.prototype);
    Ie.prototype.constructor = Ie;
    O._buildAccessors(md.prototype, Al);
    Object.assign(Ie.prototype, {
        initializeComponentData: function(a, b, c) {
            var d = {};
            c = [];
            var e = this.propertyTypes;
            if (b.mesh instanceof aa || "number" === typeof b.mesh) b.meshAsset = b.mesh, delete b.mesh;
            for (var f in b) {
                b.hasOwnProperty(f) && (c.push(f), d[f] = b[f]);
                if ("vec3" === e[f]) Array.isArray(d[f]) && (d[f] = new z(d[f][0], d[f][1], d[f][2]));
                else if ("curve" === e[f]) {
                    if (!(d[f] instanceof hb)) {
                        var g = d[f].type;
                        d[f] = new hb(d[f].keys);
                        d[f].type = g
                    }
                } else "curveset" !== e[f] || d[f] instanceof Cb || (g = d[f].type, d[f] = new Cb(d[f].keys), d[f].type = g);
                d.layers && Array.isArray(d.layers) && (d.layers = d.layers.slice(0))
            }
            H.prototype.initializeComponentData.call(this, a, d, c)
        },
        cloneComponent: function(a, b) {
            a = a.particlesystem.data;
            for (var c = this.schema, d = {}, e = 0, f = c.length; e < f; e++) {
                var g = c[e],
                    k = a[g];
                k instanceof z || k instanceof hb || k instanceof Cb ? (k = k.clone(), d[g] = k) : "layers" === g ? d.layers = a.layers.slice(0) : null !== k && void 0 !== k && (d[g] = k)
            }
            return this.addComponent(b,
                d)
        },
        onUpdate: function(a) {
            var b = this.store,
                c, d = this.app.stats.particles,
                e;
            for (e in b)
                if (b.hasOwnProperty(e)) {
                    var f = b[e];
                    var g = f.entity;
                    var k = f.data;
                    if (k.enabled && g.enabled) {
                        var h = k.model.emitter;
                        if (h.meshInstance.visible) {
                            if (h.lighting) {
                                var l = k.layers;
                                for (g = 0; g < l.length; g++)
                                    if (f = this.app.scene.layers.getLayerById(l[g])) {
                                        f._lightCube || (f._lightCube = new Float32Array(18));
                                        var n = f._lightCube;
                                        for (g = 0; 6 > g; g++) n[3 * g] = this.app.scene.ambientLight.r, n[3 * g + 1] = this.app.scene.ambientLight.g, n[3 * g + 2] = this.app.scene.ambientLight.b;
                                        var p = f._splitLights[0];
                                        for (c = 0; c < p.length; c++)
                                            for (f = 0; 6 > f; f++) {
                                                var q = Math.max(h.lightCubeDir[f].dot(p[c]._direction), 0) * p[c]._intensity;
                                                n[3 * f] += p[c]._color.r * q;
                                                n[3 * f + 1] += p[c]._color.g * q;
                                                n[3 * f + 2] += p[c]._color.b * q
                                            }
                                    }
                                h.constantLightCube.setValue(n)
                            }
                            if (!k.paused) {
                                h.simTime += a;
                                if (h.simTime > h.fixedTimeStep) {
                                    var r = Math.floor(h.simTime / h.fixedTimeStep);
                                    h.simTime -= r * h.fixedTimeStep
                                }
                                if (r) {
                                    r = Math.min(r, h.maxSubSteps);
                                    for (g = 0; g < r; g++) h.addTime(h.fixedTimeStep, !1);
                                    d._updatesPerFrame += r;
                                    d._frameTime += h._addTimeTime;
                                    h._addTimeTime = 0
                                }
                                h.finishFrame()
                            }
                        }
                    }
                }
        },
        onBeforeRemove: function(a, b) {
            b.onBeforeRemove()
        }
    });
    Object.assign(Zg.prototype, {
        _resize: function(a) {
            if (a > this._pool.length)
                for (var b = this._pool.length; b < a; b++) this._pool[b] = new this._constructor
        },
        allocate: function() {
            this._count >= this._pool.length && this._resize(2 * this._pool.length);
            return this._pool[this._count++]
        },
        freeAll: function() {
            this._count = 0
        }
    });
    var Ub, ya, Mf, uj, vj;
    hc.prototype = Object.create(O.prototype);
    hc.prototype.constructor = hc;
    Object.defineProperty(hc.prototype,
        "linearVelocity", {
            get: function() {
                var a = this.body;
                a && "dynamic" === this.type && (a = a.getLinearVelocity(), this._linearVelocity.set(a.x(), a.y(), a.z()));
                return this._linearVelocity
            },
            set: function(a) {
                var b = this.body;
                b && "dynamic" === this.type && (b.activate(), ya.setValue(a.x, a.y, a.z), b.setLinearVelocity(ya), this._linearVelocity.copy(a))
            }
        });
    Object.defineProperty(hc.prototype, "angularVelocity", {
        get: function() {
            var a = this.body;
            a && "dynamic" === this.type && (a = a.getAngularVelocity(), this._angularVelocity.set(a.x(), a.y(),
                a.z()));
            return this._angularVelocity
        },
        set: function(a) {
            var b = this.body;
            b && "dynamic" === this.type && (b.activate(), ya.setValue(a.x, a.y, a.z), b.setAngularVelocity(ya), this._angularVelocity.copy(a))
        }
    });
    Object.assign(hc.prototype, {
        createBody: function() {
            var a = this.entity;
            if (a.collision) {
                var b = a.collision.shape;
                a.trigger && (a.trigger.destroy(), delete a.trigger)
            }
            if (b) {
                if (this.body) this.system.onRemove(this.entity, this);
                var c = "dynamic" === this.type ? this.mass : 0;
                this._getEntityTransform(Ub);
                b = this.system.createBody(c,
                    b, Ub);
                b.setRestitution(this.restitution);
                b.setFriction(this.friction);
                b.setDamping(this.linearDamping, this.angularDamping);
                "dynamic" === this.type ? (c = this.linearFactor, ya.setValue(c.x, c.y, c.z), b.setLinearFactor(ya), c = this.angularFactor, ya.setValue(c.x, c.y, c.z), b.setAngularFactor(ya)) : "kinematic" === this.type && (b.setCollisionFlags(b.getCollisionFlags() | 2), b.setActivationState(4));
                b.entity = a;
                a.rigidbody.body = b;
                this.enabled && this.entity.enabled && this.enableSimulation()
            }
        },
        isActive: function() {
            var a = this.body;
            return a ? a.isActive() : !1
        },
        activate: function() {
            var a = this.body;
            a && a.activate()
        },
        enableSimulation: function() {
            if (this.entity.collision && this.entity.collision.enabled && !this.data.simulationEnabled) {
                var a = this.body;
                if (a) {
                    this.system.addBody(a, this.group, this.mask);
                    switch (this.type) {
                        case "dynamic":
                            this.system._dynamic.push(this);
                            a.forceActivationState(1);
                            this.syncEntityToBody();
                            break;
                        case "kinematic":
                            this.system._kinematic.push(this);
                            a.forceActivationState(4);
                            break;
                        case Je:
                            a.forceActivationState(1), this.syncEntityToBody()
                    }
                    "compound" ===
                    this.entity.collision.type && this.system._compounds.push(this.entity.collision);
                    a.activate();
                    this.data.simulationEnabled = !0
                }
            }
        },
        disableSimulation: function() {
            var a = this.body;
            if (a && this.data.simulationEnabled) {
                var b = this.system._compounds.indexOf(this.entity.collision); - 1 < b && this.system._compounds.splice(b, 1);
                b = this.system._dynamic.indexOf(this); - 1 < b && this.system._dynamic.splice(b, 1);
                b = this.system._kinematic.indexOf(this); - 1 < b && this.system._kinematic.splice(b, 1);
                this.system.removeBody(a);
                a.forceActivationState(5);
                this.data.simulationEnabled = !1
            }
        },
        applyForce: function() {
            switch (arguments.length) {
                case 1:
                    var a = arguments[0].x;
                    var b = arguments[0].y;
                    var c = arguments[0].z;
                    break;
                case 2:
                    a = arguments[0].x;
                    b = arguments[0].y;
                    c = arguments[0].z;
                    var d = arguments[1].x;
                    var e = arguments[1].y;
                    var f = arguments[1].z;
                    break;
                case 3:
                    a = arguments[0];
                    b = arguments[1];
                    c = arguments[2];
                    break;
                case 6:
                    a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3], e = arguments[4], f = arguments[5]
            }
            var g = this.body;
            g && (g.activate(), ya.setValue(a, b, c), void 0 !== d ?
                (Mf.setValue(d, e, f), g.applyForce(ya, Mf)) : g.applyForce(ya, vj))
        },
        applyTorque: function() {
            switch (arguments.length) {
                case 1:
                    var a = arguments[0].x;
                    var b = arguments[0].y;
                    var c = arguments[0].z;
                    break;
                case 3:
                    a = arguments[0];
                    b = arguments[1];
                    c = arguments[2];
                    break;
                default:
                    return
            }
            var d = this.body;
            d && (d.activate(), ya.setValue(a, b, c), d.applyTorque(ya))
        },
        applyImpulse: function() {
            switch (arguments.length) {
                case 1:
                    var a = arguments[0].x;
                    var b = arguments[0].y;
                    var c = arguments[0].z;
                    break;
                case 2:
                    a = arguments[0].x;
                    b = arguments[0].y;
                    c = arguments[0].z;
                    var d = arguments[1].x;
                    var e = arguments[1].y;
                    var f = arguments[1].z;
                    break;
                case 3:
                    a = arguments[0];
                    b = arguments[1];
                    c = arguments[2];
                    break;
                case 6:
                    a = arguments[0];
                    b = arguments[1];
                    c = arguments[2];
                    d = arguments[3];
                    e = arguments[4];
                    f = arguments[5];
                    break;
                default:
                    return
            }
            var g = this.body;
            g && (g.activate(), ya.setValue(a, b, c), void 0 !== d ? (Mf.setValue(d, e, f), g.applyImpulse(ya, Mf)) : g.applyImpulse(ya, vj))
        },
        applyTorqueImpulse: function() {
            switch (arguments.length) {
                case 1:
                    var a = arguments[0].x;
                    var b = arguments[0].y;
                    var c = arguments[0].z;
                    break;
                case 3:
                    a = arguments[0];
                    b = arguments[1];
                    c = arguments[2];
                    break;
                default:
                    return
            }
            var d = this.body;
            d && (d.activate(), ya.setValue(a, b, c), d.applyTorqueImpulse(ya))
        },
        isStatic: function() {
            return this.type === Je
        },
        isStaticOrKinematic: function() {
            return this.type === Je || "kinematic" === this.type
        },
        isKinematic: function() {
            return "kinematic" === this.type
        },
        _getEntityTransform: function(a) {
            var b = this.entity.getPosition(),
                c = this.entity.getRotation();
            ya.setValue(b.x, b.y, b.z);
            uj.setValue(c.x, c.y, c.z, c.w);
            a.setOrigin(ya);
            a.setRotation(uj)
        },
        syncEntityToBody: function() {
            var a = this.data.body;
            if (a) {
                this._getEntityTransform(Ub);
                a.setWorldTransform(Ub);
                if ("kinematic" === this.type) {
                    var b = a.getMotionState();
                    b && b.setWorldTransform(Ub)
                }
                a.activate()
            }
        },
        _updateDynamic: function() {
            var a = this.data.body;
            if (a.isActive() && (a = a.getMotionState())) {
                a.getWorldTransform(Ub);
                a = Ub.getOrigin();
                var b = Ub.getRotation();
                this.entity.setPosition(a.x(), a.y(), a.z());
                this.entity.setRotation(b.x(), b.y(), b.z(), b.w())
            }
        },
        _updateKinematic: function() {
            var a = this.data.body.getMotionState();
            a && (this._getEntityTransform(Ub), a.setWorldTransform(Ub))
        },
        teleport: function() {
            3 > arguments.length ? (arguments[0] && this.entity.setPosition(arguments[0]), arguments[1] && (arguments[1] instanceof Y ? this.entity.setRotation(arguments[1]) : this.entity.setEulerAngles(arguments[1]))) : (6 === arguments.length && this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]), this.entity.setPosition(arguments[0], arguments[1], arguments[2]));
            this.syncEntityToBody()
        },
        onEnable: function() {
            this.body || this.createBody();
            this.enableSimulation()
        },
        onDisable: function() {
            this.disableSimulation()
        },
        onSetMass: function(a, b, c) {
            (a = this.data.body) && "dynamic" === this.type && ((b = this.enabled && this.entity.enabled) && this.disableSimulation(), a.getCollisionShape().calculateLocalInertia(c, ya), a.setMassProps(c, ya), a.updateInertiaTensor(), b && this.enableSimulation())
        },
        onSetLinearDamping: function(a, b, c) {
            (a = this.data.body) && a.setDamping(c, this.data.angularDamping)
        },
        onSetAngularDamping: function(a, b, c) {
            (a = this.data.body) && a.setDamping(this.data.linearDamping,
                c)
        },
        onSetLinearFactor: function(a, b, c) {
            (a = this.data.body) && "dynamic" === this.type && (ya.setValue(c.x, c.y, c.z), a.setLinearFactor(ya))
        },
        onSetAngularFactor: function(a, b, c) {
            (a = this.data.body) && "dynamic" === this.type && (ya.setValue(c.x, c.y, c.z), a.setAngularFactor(ya))
        },
        onSetFriction: function(a, b, c) {
            (a = this.data.body) && a.setFriction(c)
        },
        onSetRestitution: function(a, b, c) {
            (a = this.data.body) && a.setRestitution(c)
        },
        onSetType: function(a, b, c) {
            c !== b && (this.disableSimulation(), "dynamic" === c ? (this.data.group = 1, this.data.mask =
                65535) : "kinematic" === c ? (this.data.group = 4, this.data.mask = 65535) : (this.data.group = wj, this.data.mask = $g), this.createBody())
        },
        onSetGroupOrMask: function(a, b, c) {
            c !== b && this.enabled && this.entity.enabled && (this.disableSimulation(), this.enableSimulation())
        },
        onSetBody: function(a, b, c) {
            this.body && this.data.simulationEnabled && this.body.activate()
        }
    });
    var pe, qe, yd = {},
        pg = {},
        El = "enabled type mass linearDamping angularDamping linearFactor angularFactor friction restitution group mask body".split(" ");
    Wd.prototype =
        Object.create(H.prototype);
    Wd.prototype.constructor = Wd;
    O._buildAccessors(hc.prototype, El);
    Object.assign(Wd.prototype, {
        onLibraryLoaded: function() {
            if ("undefined" !== typeof Ammo) {
                this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration;
                this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
                this.overlappingPairCache = new Ammo.btDbvtBroadphase;
                this.solver = new Ammo.btSequentialImpulseConstraintSolver;
                this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache,
                    this.solver, this.collisionConfiguration);
                if (this.dynamicsWorld.setInternalTickCallback) {
                    var a = Ammo.addFunction(this._checkForCollisions.bind(this), "vif");
                    this.dynamicsWorld.setInternalTickCallback(a)
                }
                pe = new Ammo.btVector3;
                qe = new Ammo.btVector3;
                this.contactPointPool = new Zg(Cl, 1);
                this.contactResultPool = new Zg(Dl, 1);
                this.singleContactResultPool = new Zg(Bl, 1);
                H.bind("update", this.onUpdate, this)
            } else H.unbind("update", this.onUpdate, this)
        },
        initializeComponentData: function(a, b, c) {
            c = "enabled mass linearDamping angularDamping linearFactor angularFactor friction restitution type group mask".split(" ");
            for (var d = {}, e = 0, f = c.length; e < f; e++) {
                var g = c[e];
                d[g] = b[g]
            }
            b.bodyType && (d.type = b.bodyType);
            d.linearFactor && Array.isArray(d.linearFactor) && (d.linearFactor = new z(d.linearFactor[0], d.linearFactor[1], d.linearFactor[2]));
            d.angularFactor && Array.isArray(d.angularFactor) && (d.angularFactor = new z(d.angularFactor[0], d.angularFactor[1], d.angularFactor[2]));
            H.prototype.initializeComponentData.call(this, a, d, c)
        },
        cloneComponent: function(a, b) {
            this.addComponent(b, {
                enabled: a.rigidbody.enabled,
                mass: a.rigidbody.mass,
                linearDamping: a.rigidbody.linearDamping,
                angularDamping: a.rigidbody.angularDamping,
                linearFactor: [a.rigidbody.linearFactor.x, a.rigidbody.linearFactor.y, a.rigidbody.linearFactor.z],
                angularFactor: [a.rigidbody.angularFactor.x, a.rigidbody.angularFactor.y, a.rigidbody.angularFactor.z],
                friction: a.rigidbody.friction,
                restitution: a.rigidbody.restitution,
                type: a.rigidbody.type,
                group: a.rigidbody.group,
                mask: a.rigidbody.mask
            })
        },
        onBeforeRemove: function(a, b) {
            b.enabled && (b.enabled = !1)
        },
        onRemove: function(a, b) {
            if (a = b.body) this.removeBody(a), this.destroyBody(a),
                b.body = null
        },
        addBody: function(a, b, c) {
            void 0 !== b && void 0 !== c ? this.dynamicsWorld.addRigidBody(a, b, c) : this.dynamicsWorld.addRigidBody(a)
        },
        removeBody: function(a) {
            this.dynamicsWorld.removeRigidBody(a)
        },
        createBody: function(a, b, c) {
            var d = new Ammo.btVector3(0, 0, 0);
            0 !== a && b.calculateLocalInertia(a, d);
            c = new Ammo.btDefaultMotionState(c);
            a = new Ammo.btRigidBodyConstructionInfo(a, c, b, d);
            b = new Ammo.btRigidBody(a);
            Ammo.destroy(a);
            Ammo.destroy(d);
            return b
        },
        destroyBody: function(a) {
            var b = a.getMotionState();
            b && Ammo.destroy(b);
            Ammo.destroy(a)
        },
        raycastFirst: function(a, b) {
            var c = null;
            pe.setValue(a.x, a.y, a.z);
            qe.setValue(b.x, b.y, b.z);
            var d = new Ammo.ClosestRayResultCallback(pe, qe);
            this.dynamicsWorld.rayTest(pe, qe, d);
            if (d.hasHit()) {
                var e = d.get_m_collisionObject();
                if (e = Ammo.castObject(e, Ammo.btRigidBody)) {
                    c = d.get_m_hitPointWorld();
                    var f = d.get_m_hitNormalWorld();
                    c = new xj(e.entity, new z(c.x(), c.y(), c.z()), new z(f.x(), f.y(), f.z()));
                    if (2 < arguments.length)(0, arguments[2])(c)
                }
            }
            Ammo.destroy(d);
            return c
        },
        raycastAll: function(a, b) {
            var c = [];
            pe.setValue(a.x, a.y, a.z);
            qe.setValue(b.x, b.y, b.z);
            a = new Ammo.AllHitsRayResultCallback(pe, qe);
            this.dynamicsWorld.rayTest(pe, qe, a);
            if (a.hasHit()) {
                b = a.get_m_collisionObjects();
                for (var d = a.get_m_hitPointWorld(), e = a.get_m_hitNormalWorld(), f = b.size(), g = 0; g < f; g++) {
                    var k = Ammo.castObject(b.at(g), Ammo.btRigidBody);
                    if (k) {
                        var h = d.at(g),
                            l = e.at(g);
                        k = new xj(k.entity, new z(h.x(), h.y(), h.z()), new z(l.x(), l.y(), l.z()));
                        c.push(k)
                    }
                }
            }
            Ammo.destroy(a);
            return c
        },
        _storeCollision: function(a, b) {
            var c = !1,
                d = a.getGuid();
            yd[d] =
                yd[d] || {
                    others: [],
                    entity: a
                };
            0 > yd[d].others.indexOf(b) && (yd[d].others.push(b), c = !0);
            pg[d] = pg[d] || {
                others: [],
                entity: a
            };
            pg[d].others.push(b);
            return c
        },
        _createContactPointFromAmmo: function(a) {
            var b = a.get_m_localPointA(),
                c = a.get_m_localPointB(),
                d = a.getPositionWorldOnA(),
                e = a.getPositionWorldOnB();
            a = a.get_m_normalWorldOnB();
            var f = this.contactPointPool.allocate();
            f.localPoint.set(b.x(), b.y(), b.z());
            f.localPointOther.set(c.x(), c.y(), c.z());
            f.point.set(d.x(), d.y(), d.z());
            f.pointOther.set(e.x(), e.y(), e.z());
            f.normal.set(a.x(), a.y(), a.z());
            return f
        },
        _createReverseContactPointFromAmmo: function(a) {
            var b = a.get_m_localPointA(),
                c = a.get_m_localPointB(),
                d = a.getPositionWorldOnA(),
                e = a.getPositionWorldOnB();
            a = a.get_m_normalWorldOnB();
            var f = this.contactPointPool.allocate();
            f.localPointOther.set(b.x(), b.y(), b.z());
            f.localPoint.set(c.x(), c.y(), c.z());
            f.pointOther.set(d.x(), d.y(), d.z());
            f.point.set(e.x(), e.y(), e.z());
            f.normal.set(a.x(), a.y(), a.z());
            return f
        },
        _createSingleContactResult: function(a, b, c) {
            var d = this.singleContactResultPool.allocate();
            d.a = a;
            d.b = b;
            d.localPointA = c.localPoint;
            d.localPointB = c.localPointOther;
            d.pointA = c.point;
            d.pointB = c.pointOther;
            d.normal = c.normal;
            return d
        },
        _createContactResult: function(a, b) {
            var c = this.contactResultPool.allocate();
            c.other = a;
            c.contacts = b;
            return c
        },
        _cleanOldCollisions: function() {
            for (var a in yd)
                if (yd.hasOwnProperty(a)) {
                    var b = pg[a],
                        c = yd[a],
                        d = c.entity,
                        e = d.collision,
                        f = d.rigidbody;
                    c = c.others;
                    for (var g = c.length; g--;) {
                        var k = c[g];
                        if (!b || 0 > b.others.indexOf(k)) c.splice(g, 1), d.trigger ? (e && e.fire("triggerleave",
                            k), k.rigidbody && k.rigidbody.fire("triggerleave", d)) : k.trigger || (f && f.fire("collisionend", k), e && e.fire("collisionend", k))
                    }
                    0 === c.length && delete yd[a]
                }
        },
        _hasContactEvent: function(a) {
            var b = a.collision;
            return b && (b.hasEvent("collisionstart") || b.hasEvent("collisionend") || b.hasEvent("contact")) ? !0 : (a = a.rigidbody) && (a.hasEvent("collisionstart") || a.hasEvent("collisionend") || a.hasEvent("contact"))
        },
        _checkForCollisions: function(a, b) {
            a = Ammo.wrapPointer(a, Ammo.btDynamicsWorld).getDispatcher();
            b = a.getNumManifolds();
            pg = {};
            for (var c = 0; c < b; c++) {
                var d = a.getManifoldByIndexInternal(c),
                    e = d.getBody0(),
                    f = d.getBody1(),
                    g = Ammo.castObject(e, Ammo.btRigidBody),
                    k = Ammo.castObject(f, Ammo.btRigidBody);
                f = g.entity;
                e = k.entity;
                if (f && e) {
                    var h = g.getCollisionFlags(),
                        l = k.getCollisionFlags(),
                        n = d.getNumContacts(),
                        p = [],
                        q = [];
                    if (0 < n)
                        if (h & 4 || l & 4) {
                            k = f.collision && (f.collision.hasEvent("triggerenter") || f.collision.hasEvent("triggerleave"));
                            g = e.collision && (e.collision.hasEvent("triggerenter") || e.collision.hasEvent("triggerleave"));
                            d = f.rigidbody &&
                                (f.rigidbody.hasEvent("triggerenter") || f.rigidbody.hasEvent("triggerleave"));
                            q = e.rigidbody && (e.rigidbody.hasEvent("triggerenter") || e.rigidbody.hasEvent("triggerleave"));
                            if (k) {
                                var r = this._storeCollision(f, e);
                                !r || l & 4 || f.collision.fire("triggerenter", e)
                            }
                            g && (r = this._storeCollision(e, f), !r || h & 4 || e.collision.fire("triggerenter", f));
                            d && (r || (r = this._storeCollision(e, f)), r && f.rigidbody.fire("triggerenter", e));
                            q && (r || (r = this._storeCollision(f, e)), r && e.rigidbody.fire("triggerenter", f))
                        } else if (k = this._hasContactEvent(f),
                        g = this._hasContactEvent(e), (h = this.hasEvent("contact")) || k || g) {
                        for (l = 0; l < n; l++) {
                            var t = d.getContactPoint(l),
                                u = this._createContactPointFromAmmo(t);
                            if (k || g) t = this._createReverseContactPointFromAmmo(t), p.push(u), q.push(t);
                            h && (u = this._createSingleContactResult(f, e, u), this.fire("contact", u))
                        }
                        k && (d = this._createContactResult(e, p), r = this._storeCollision(f, e), f.collision && (f.collision.fire("contact", d), r && f.collision.fire("collisionstart", d)), f.rigidbody && (f.rigidbody.fire("contact", d), r && f.rigidbody.fire("collisionstart",
                            d)));
                        g && (d = this._createContactResult(f, q), r = this._storeCollision(e, f), e.collision && (e.collision.fire("contact", d), r && e.collision.fire("collisionstart", d)), e.rigidbody && (e.rigidbody.fire("contact", d), r && e.rigidbody.fire("collisionstart", d)))
                    }
                }
            }
            this._cleanOldCollisions();
            this.contactPointPool.freeAll();
            this.contactResultPool.freeAll();
            this.singleContactResultPool.freeAll()
        },
        onUpdate: function(a) {
            var b;
            var c = this.dynamicsWorld.getGravity();
            if (c.x() !== this.gravity.x || c.y() !== this.gravity.y || c.z() !== this.gravity.z) c.setValue(this.gravity.x,
                this.gravity.y, this.gravity.z), this.dynamicsWorld.setGravity(c);
            var d = this._triggers;
            c = 0;
            for (b = d.length; c < b; c++) d[c].updateTransform();
            d = this._compounds;
            c = 0;
            for (b = d.length; c < b; c++) d[c]._updateCompound();
            d = this._kinematic;
            c = 0;
            for (b = d.length; c < b; c++) d[c]._updateKinematic();
            this.dynamicsWorld.stepSimulation(a, this.maxSubSteps, this.fixedTimeStep);
            d = this._dynamic;
            c = 0;
            for (b = d.length; c < b; c++) d[c]._updateDynamic();
            this.dynamicsWorld.setInternalTickCallback || this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld),
                a)
        },
        destroy: function() {
            "undefined" !== typeof Ammo && (Ammo.destroy(this.dynamicsWorld), Ammo.destroy(this.solver), Ammo.destroy(this.overlappingPairCache), Ammo.destroy(this.dispatcher), Ammo.destroy(this.collisionConfiguration), this.collisionConfiguration = this.dispatcher = this.overlappingPairCache = this.solver = this.dynamicsWorld = null)
        }
    });
    var Xd = "none";
    Hb.prototype = Object.create(O.prototype);
    Hb.prototype.constructor = Hb;
    var bn = new J;
    Object.assign(Hb.prototype, {
        syncDrawOrder: function() {
            this.system.queueDrawOrderSync(this.entity.getGuid(),
                this._processDrawOrderSync, this)
        },
        _recurseDrawOrderSync: function(a, b) {
            if (!(a instanceof fa)) return b;
            if (a.element) {
                var c = a.element.drawOrder;
                a.element.drawOrder = b++;
                0 <= a.element._batchGroupId && c != a.element.drawOrder && this.system.app.batcher.markGroupDirty(a.element._batchGroupId)
            }
            a.particlesystem && (a.particlesystem.drawOrder = b++);
            a = a.children;
            for (c = 0; c < a.length; c++) b = this._recurseDrawOrderSync(a[c], b);
            return b
        },
        _processDrawOrderSync: function() {
            this._recurseDrawOrderSync(this.entity, 1);
            this.fire("syncdraworder")
        },
        _calcProjectionMatrix: function() {
            var a = this._resolution.x / this.scale,
                b = this._resolution.y / this.scale;
            this._screenMatrix.setOrtho(0, a, -b, 0, 1, -1);
            this._screenSpace || (bn.setScale(.5 * a, .5 * b, 1), this._screenMatrix.mul2(bn, this._screenMatrix))
        },
        _updateScale: function() {
            this.scale = this._calcScale(this._resolution, this.referenceResolution)
        },
        _calcScale: function(a, b) {
            return Math.pow(2, Math.log2(a.x / b.x) * (1 - this._scaleBlend) + Math.log2(a.y / b.y) * this._scaleBlend)
        },
        _onResize: function(a, b) {
            this._screenSpace && (this._resolution.set(a,
                b), this.resolution = this._resolution)
        },
        onRemove: function() {
            this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
            this.fire("remove");
            this.off()
        }
    });
    Object.defineProperty(Hb.prototype, "resolution", {
        set: function(a) {
            this._screenSpace ? this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height) : this._resolution.set(a.x, a.y);
            this._updateScale();
            this._calcProjectionMatrix();
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:resolution",
                this._resolution)
        },
        get: function() {
            return this._resolution
        }
    });
    Object.defineProperty(Hb.prototype, "referenceResolution", {
        set: function(a) {
            this._referenceResolution.set(a.x, a.y);
            this._updateScale();
            this._calcProjectionMatrix();
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:referenceresolution", this._resolution)
        },
        get: function() {
            return this._scaleMode === Xd ? this._resolution : this._referenceResolution
        }
    });
    Object.defineProperty(Hb.prototype, "screenSpace", {
        set: function(a) {
            (this._screenSpace =
                a) && this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
            this.resolution = this._resolution;
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:screenspace", this._screenSpace)
        },
        get: function() {
            return this._screenSpace
        }
    });
    Object.defineProperty(Hb.prototype, "scaleMode", {
        set: function(a) {
            a !== Xd && "blend" !== a && (a = Xd);
            this._screenSpace || a === Xd || (a = Xd);
            this._scaleMode = a;
            this.resolution = this._resolution;
            this.fire("set:scalemode", this._scaleMode)
        },
        get: function() {
            return this._scaleMode
        }
    });
    Object.defineProperty(Hb.prototype, "scaleBlend", {
        set: function(a) {
            this._scaleBlend = a;
            this._updateScale();
            this._calcProjectionMatrix();
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:scaleblend", this._scaleBlend)
        },
        get: function() {
            return this._scaleBlend
        }
    });
    Object.defineProperty(Hb.prototype, "priority", {
        get: function() {
            return this._priority
        },
        set: function(a) {
            255 < a && (a = 255);
            this._priority = a
        }
    });
    var Fl = ["enabled"];
    Ke.prototype = Object.create(H.prototype);
    Ke.prototype.constructor = Ke;
    O._buildAccessors(Hb.prototype,
        Fl);
    Object.assign(Ke.prototype, {
        initializeComponentData: function(a, b, c) {
            void 0 !== b.priority && (a.priority = b.priority);
            void 0 !== b.screenSpace && (a.screenSpace = b.screenSpace);
            a.cull = a.screenSpace;
            void 0 !== b.scaleMode && (a.scaleMode = b.scaleMode);
            void 0 !== b.scaleBlend && (a.scaleBlend = b.scaleBlend);
            void 0 !== b.resolution && (b.resolution instanceof P ? a._resolution.copy(b.resolution) : a._resolution.set(b.resolution[0], b.resolution[1]), a.resolution = a._resolution);
            void 0 !== b.referenceResolution && (b.referenceResolution instanceof P ? a._referenceResolution.copy(b.referenceResolution) : a._referenceResolution.set(b.referenceResolution[0], b.referenceResolution[1]), a.referenceResolution = a._referenceResolution);
            a.syncDrawOrder();
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        destroy: function() {
            this.off();
            this.app.graphicsDevice.off("resizecanvas", this._onResize, this)
        },
        _onUpdate: function(a) {
            var b = this.store,
                c;
            for (c in b) b[c].entity.screen.update && b[c].entity.screen.update(a)
        },
        _onResize: function(a, b) {
            this.windowResolution.x =
                a;
            this.windowResolution.y = b
        },
        cloneComponent: function(a, b) {
            a = a.screen;
            return this.addComponent(b, {
                enabled: a.enabled,
                screenSpace: a.screenSpace,
                scaleMode: a.scaleMode,
                resolution: a.resolution.clone(),
                referenceResolution: a.referenceResolution.clone()
            })
        },
        onRemoveComponent: function(a, b) {
            b.onRemove()
        },
        processDrawOrderSyncQueue: function() {
            for (var a = this._drawOrderSyncQueue.list(), b = 0; b < a.length; b++) {
                var c = a[b];
                c.callback.call(c.scope)
            }
            this._drawOrderSyncQueue.clear()
        },
        queueDrawOrderSync: function(a, b, c) {
            if (!this._drawOrderSyncQueue.list().length) this.app.once("prerender",
                this.processDrawOrderSyncQueue, this);
            this._drawOrderSyncQueue.has(a) || this._drawOrderSyncQueue.push(a, {
                callback: b,
                scope: c
            })
        }
    });
    var Xp = ["x", "y", "z", "w"],
        Yp = [void 0, void 0, P, z, X],
        Th = function(a, b, c, d) {
            var e, f;
            switch (b.type) {
                case "boolean":
                    return !!c;
                case "number":
                    if ("number" === typeof c) break;
                    else {
                        if ("string" === typeof c) return c = parseInt(c, 10), isNaN(c) ? null : c;
                        if ("boolean" === typeof c) return 0 + c
                    }
                    return null;
                case "json":
                    d = {};
                    if (Array.isArray(b.schema))
                        for (c && "object" === typeof c || (c = {}), e = 0; e < b.schema.length; e++) {
                            var g =
                                b.schema[e];
                            if (g.name)
                                if (g.array) {
                                    d[g.name] = [];
                                    var k = Array.isArray(c[g.name]) ? c[g.name] : [];
                                    for (f = 0; f < k.length; f++) d[g.name].push(Th(a, g, k[f]))
                                } else f = c.hasOwnProperty(g.name) ? c[g.name] : g.default, d[g.name] = Th(a, g, f)
                        }
                    return d;
                case "asset":
                    if (c instanceof aa) break;
                    else {
                        if ("number" === typeof c) return a.assets.get(c) || null;
                        if ("string" === typeof c) return a.assets.get(parseInt(c, 10)) || null
                    }
                    return null;
                case "entity":
                    if (c instanceof Z) break;
                    else if ("string" === typeof c) return a.getEntityFromIndex(c);
                    return null;
                case "rgb":
                case "rgba":
                    if (c instanceof L) return d instanceof L ? (d.copy(c), d) : c.clone();
                    if (c instanceof Array && 3 <= c.length && 4 >= c.length) {
                        for (e = 0; e < c.length; e++)
                            if ("number" !== typeof c[e]) return null;
                        d || (d = new L);
                        d.r = c[0];
                        d.g = c[1];
                        d.b = c[2];
                        d.a = 3 === c.length ? 1 : c[3];
                        return d
                    }
                    return "string" === typeof c && /#([0-9abcdef]{2}){3,4}/i.test(c) ? (d || (d = new L), d.fromString(c), d) : null;
                case "vec2":
                case "vec3":
                case "vec4":
                    a = parseInt(b.type.slice(3), 10);
                    b = Yp[a];
                    if (c instanceof b) return d instanceof b ? (d.copy(c), d) : c.clone();
                    if (c instanceof Array && c.length === a) {
                        for (e = 0; e < c.length; e++)
                            if ("number" !== typeof c[e]) return null;
                        d || (d = new b);
                        for (e = 0; e < a; e++) d[Xp[e]] = c[e];
                        return d
                    }
                    return null;
                case "curve":
                    if (c) return c instanceof hb || c instanceof Cb ? e = c.clone() : (e = new(c.keys[0] instanceof Array ? Cb : hb)(c.keys), e.type = c.type), e
            }
            return c
        };
    Yd.prototype.add = function(a, b) {
        this.index[a] || Ib.reservedAttributes[a] || (this.index[a] = b, Object.defineProperty(this.scriptType.prototype, a, {
            get: function() {
                return this.__attributes[a]
            },
            set: function(c) {
                var d =
                    this.__attributes[a];
                if (b.array) {
                    if (this.__attributes[a] = [], c) {
                        var e;
                        var f = 0;
                        for (e = c.length; f < e; f++) this.__attributes[a].push(Th(this.app, b, c[f], d ? d[f] : null))
                    }
                } else this.__attributes[a] = Th(this.app, b, c, d);
                this.fire("attr", a, this.__attributes[a], d);
                this.fire("attr:" + a, this.__attributes[a], d)
            }
        }))
    };
    Yd.prototype.remove = function(a) {
        if (!this.index[a]) return !1;
        delete this.index[a];
        delete this.scriptType.prototype[a];
        return !0
    };
    Yd.prototype.has = function(a) {
        return !!this.index[a]
    };
    Yd.prototype.get = function(a) {
        return this.index[a] ||
            null
    };
    var Zp = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^\(\s\/]*)\s*/;
    db.prototype = Object.create(M.prototype);
    db.prototype.constructor = db;
    db.__name = null;
    db.__getScriptName = function(a) {
        if ("function" === typeof a) return "name" in Function.prototype ? a.name : a === Function || a === Function.prototype.constructor ? "Function" : (a = ("" + a).match(Zp)) ? a[1] : void 0
    };
    Object.defineProperty(db, "scriptName", {
        get: function() {
            return this.__name
        }
    });
    Object.defineProperty(db, "attributes", {
        get: function() {
            this.hasOwnProperty("__attributes") ||
                (this.__attributes = new Yd(this));
            return this.__attributes
        }
    });
    db.prototype.__initializeAttributes = function(a) {
        if (a || this.__attributesRaw) {
            for (var b in this.__scriptType.attributes.index) this.__attributesRaw && this.__attributesRaw.hasOwnProperty(b) ? this[b] = this.__attributesRaw[b] : this.__attributes.hasOwnProperty(b) || (this.__scriptType.attributes.index[b].hasOwnProperty("default") ? this[b] = this.__scriptType.attributes.index[b].default : this[b] = null);
            this.__attributesRaw = null
        }
    };
    db.extend = function(a) {
        for (var b in a) a.hasOwnProperty(b) &&
            (this.prototype[b] = a[b])
    };
    Object.defineProperty(db.prototype, "enabled", {
        get: function() {
            return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled
        },
        set: function(a) {
            this._enabled = !!a;
            this.enabled !== this._enabledOld && (this._enabledOld = this.enabled, this.fire(this.enabled ? "enable" : "disable"), this.fire("state", this.enabled), !this._initialized && this.enabled && (this._initialized = !0, this.__initializeAttributes(!0), this.initialize && this.entity.script._scriptMethod(this, Xa.scriptMethods.initialize)),
                this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled && (this._postInitialized = !0, this.postInitialize && this.entity.script._scriptMethod(this, Xa.scriptMethods.postInitialize)))
        }
    });
    Ib.reservedScripts = "system entity create destroy swap move scripts _scripts _scriptsIndex _scriptsData enabled _oldState onEnable onDisable onPostStateChange _onSetEnabled _checkState _onBeforeRemove _onInitializeAttributes _onInitialize _onPostInitialize _onUpdate _onPostUpdate _callbacks has get on off fire once hasEvent".split(" ");
    var cn = {},
        zd;
    for (zd = 0; zd < Ib.reservedScripts.length; zd++) cn[Ib.reservedScripts[zd]] = 1;
    Ib.reservedScripts = cn;
    Ib.reservedAttributes = "app entity enabled _enabled _enabledOld _destroyed __attributes __attributesRaw __scriptType __executionOrder _callbacks has get on off fire once hasEvent".split(" ");
    var dn = {};
    for (zd = 0; zd < Ib.reservedAttributes.length; zd++) dn[Ib.reservedAttributes[zd]] = 1;
    Ib.reservedAttributes = dn;
    ic.prototype._binarySearch = function(a) {
        var b = 0,
            c = this.items.length - 1;
        a = a[this._sortBy];
        for (var d,
                e; b <= c;) d = Math.floor((b + c) / 2), e = this.items[d][this._sortBy], e <= a ? b = d + 1 : e > a && (c = d - 1);
        return b
    };
    ic.prototype._doSort = function(a, b) {
        var c = this._sortBy;
        return a[c] - b[c]
    };
    ic.prototype.insert = function(a) {
        var b = this._binarySearch(a);
        this.items.splice(b, 0, a);
        this.length++;
        this.loopIndex >= b && this.loopIndex++
    };
    ic.prototype.append = function(a) {
        this.items.push(a);
        this.length++
    };
    ic.prototype.remove = function(a) {
        a = this.items.indexOf(a);
        0 > a || (this.items.splice(a, 1), this.length--, this.loopIndex >= a && this.loopIndex--)
    };
    ic.prototype.sort = function() {
        var a = 0 <= this.loopIndex ? this.items[this.loopIndex] : null;
        this.items.sort(this._sortHandler);
        null !== a && (this.loopIndex = this.items.indexOf(a))
    };
    Xa.prototype = Object.create(O.prototype);
    Xa.prototype.constructor = Xa;
    Xa.scriptMethods = {
        initialize: "initialize",
        postInitialize: "postInitialize",
        update: "update",
        postUpdate: "postUpdate",
        swap: "swap"
    };
    Object.assign(Xa.prototype, {
        onEnable: function() {
            this._beingEnabled = !0;
            this._checkState();
            if (!this.entity._beingEnabled) this.onPostStateChange();
            this._beingEnabled = !1
        },
        onDisable: function() {
            this._checkState()
        },
        onPostStateChange: function() {
            for (var a, b = this._beginLooping(), c = 0, d = this.scripts.length; c < d; c++) a = this.scripts[c], a._initialized && !a._postInitialized && a.enabled && (a._postInitialized = !0, a.postInitialize && this._scriptMethod(a, Xa.scriptMethods.postInitialize));
            this._endLooping(b)
        },
        _beginLooping: function() {
            var a = this._isLoopingThroughScripts;
            this._isLoopingThroughScripts = !0;
            return a
        },
        _endLooping: function(a) {
            (this._isLoopingThroughScripts =
                a) || this._removeDestroyedScripts()
        },
        _onSetEnabled: function(a, b, c) {
            this._beingEnabled = !0;
            this._checkState();
            this._beingEnabled = !1
        },
        _checkState: function() {
            var a = this.enabled && this.entity.enabled;
            if (a !== this._oldState) {
                this._oldState = a;
                this.fire(a ? "enable" : "disable");
                this.fire("state", a);
                a ? this.system._addComponentToEnabled(this) : this.system._removeComponentFromEnabled(this);
                a = this._beginLooping();
                for (var b, c = 0, d = this.scripts.length; c < d; c++) b = this.scripts[c], b.enabled = b._enabled;
                this._endLooping(a)
            }
        },
        _onBeforeRemove: function() {
            this.fire("remove");
            for (var a = this._beginLooping(), b = 0; b < this.scripts.length; b++) {
                var c = this.scripts[b];
                c && this.destroy(c.__scriptType.__name)
            }
            this._endLooping(a)
        },
        _removeDestroyedScripts: function() {
            var a = this._destroyedScripts.length;
            if (a) {
                var b;
                for (b = 0; b < a; b++) this._removeScriptInstance(this._destroyedScripts[b]);
                this._destroyedScripts.length = 0;
                this._resetExecutionOrder(0, this._scripts.length)
            }
        },
        _onInitializeAttributes: function() {
            for (var a = 0, b = this.scripts.length; a < b; a++) this.scripts[a].__initializeAttributes()
        },
        _scriptMethod: function(a, b, c) {
            a[b](c)
        },
        _onInitialize: function() {
            for (var a, b = this._scripts, c = this._beginLooping(), d = 0, e = b.length; d < e; d++) a = b[d], !a._initialized && a.enabled && (a._initialized = !0, a.initialize && this._scriptMethod(a, Xa.scriptMethods.initialize));
            this._endLooping(c)
        },
        _onPostInitialize: function() {
            this.onPostStateChange()
        },
        _onUpdate: function(a) {
            var b = this._updateList;
            if (b.length) {
                var c = this._beginLooping();
                for (b.loopIndex = 0; b.loopIndex < b.length; b.loopIndex++) {
                    var d = b.items[b.loopIndex];
                    d.enabled &&
                        this._scriptMethod(d, Xa.scriptMethods.update, a)
                }
                this._endLooping(c)
            }
        },
        _onPostUpdate: function(a) {
            var b = this._postUpdateList;
            if (b.length) {
                var c = this._beginLooping();
                for (b.loopIndex = 0; b.loopIndex < b.length; b.loopIndex++) {
                    var d = b.items[b.loopIndex];
                    d.enabled && this._scriptMethod(d, Xa.scriptMethods.postUpdate, a)
                }
                this._endLooping(c)
            }
        },
        _insertScriptInstance: function(a, b, c) {
            -1 === b ? (this._scripts.push(a), a.__executionOrder = c, a.update && this._updateList.append(a), a.postUpdate && this._postUpdateList.append(a)) :
                (this._scripts.splice(b, 0, a), a.__executionOrder = b, this._resetExecutionOrder(b + 1, c + 1), a.update && this._updateList.insert(a), a.postUpdate && this._postUpdateList.insert(a))
        },
        _removeScriptInstance: function(a) {
            var b = this._scripts.indexOf(a);
            if (-1 === b) return b;
            this._scripts.splice(b, 1);
            a.update && this._updateList.remove(a);
            a.postUpdate && this._postUpdateList.remove(a);
            return b
        },
        _resetExecutionOrder: function(a, b) {
            for (; a < b; a++) this._scripts[a].__executionOrder = a
        },
        _resolveEntityScriptAttribute: function(a, b, c,
            d, e, f) {
            if (a.array) {
                if (a = c.length) {
                    c = c.slice();
                    for (var g = 0; g < a; g++) {
                        var k = c[g] instanceof fa ? c[g].getGuid() : c[g];
                        f[k] && (c[g] = d ? f[k].getGuid() : f[k])
                    }
                    e[b] = c
                }
            } else {
                if (c instanceof fa) c = c.getGuid();
                else if ("string" !== typeof c) return;
                f[c] && (e[b] = f[c])
            }
        },
        has: function(a) {
            if ("string" === typeof a) return !!this._scriptsIndex[a];
            if (!a) return !1;
            var b = this._scriptsIndex[a.__name];
            return (b && b.instance) instanceof a
        },
        get: function(a) {
            if ("string" === typeof a) return (a = this._scriptsIndex[a]) ? a.instance : null;
            if (!a) return null;
            var b = this._scriptsIndex[a.__name];
            b = b && b.instance;
            return b instanceof a ? b : null
        },
        create: function(a, b) {
            var c = this;
            b = b || {};
            var d = a,
                e = a;
            "string" === typeof d ? d = this.system.app.scripts.get(d) : d && (e = d.__name);
            if (d) {
                if (!this._scriptsIndex[e] || !this._scriptsIndex[e].instance) {
                    a = new d({
                        app: this.system.app,
                        entity: this.entity,
                        enabled: b.hasOwnProperty("enabled") ? b.enabled : !0,
                        attributes: b.attributes
                    });
                    d = this._scripts.length;
                    var f = -1;
                    "number" === typeof b.ind && -1 !== b.ind && d > b.ind && (f = b.ind);
                    this._insertScriptInstance(a,
                        f, d);
                    this._scriptsIndex[e] = {
                        instance: a,
                        onSwap: function() {
                            c.swap(e)
                        }
                    };
                    this[e] = a;
                    b.preloading || a.__initializeAttributes();
                    this.fire("create", e, a);
                    this.fire("create:" + e, a);
                    this.system.app.scripts.on("swap:" + e, this._scriptsIndex[e].onSwap);
                    b.preloading || (a.enabled && !a._initialized && (a._initialized = !0, a.initialize && this._scriptMethod(a, Xa.scriptMethods.initialize)), a.enabled && !a._postInitialized && (a._postInitialized = !0, a.postInitialize && this._scriptMethod(a, Xa.scriptMethods.postInitialize)));
                    return a
                }
                console.warn("script '" +
                    e + "' is already added to entity '" + this.entity.name + "'")
            } else this._scriptsIndex[e] = {
                awaiting: !0,
                ind: this._scripts.length
            }, console.warn("script '" + e + "' is not found, awaiting it to be added to registry");
            return null
        },
        destroy: function(a) {
            var b = a;
            "string" === typeof a ? this.system.app.scripts.get(a) : a && (b = a.__name);
            a = this._scriptsIndex[b];
            delete this._scriptsIndex[b];
            if (!a) return !1;
            var c = a.instance;
            if (c && !c._destroyed)
                if (c.enabled = !1, c._destroyed = !0, this._isLoopingThroughScripts) this._destroyedScripts.push(c);
                else {
                    var d = this._removeScriptInstance(c);
                    0 <= d && this._resetExecutionOrder(d, this._scripts.length)
                }
            this.system.app.scripts.off("swap:" + b, a.onSwap);
            delete this[b];
            this.fire("destroy", b, c || null);
            this.fire("destroy:" + b, c || null);
            c && c.fire("destroy");
            return !0
        },
        swap: function(a) {
            var b = a;
            "string" === typeof a ? a = this.system.app.scripts.get(a) : a && (b = a.__name);
            var c = this._scriptsIndex[b];
            if (!c || !c.instance) return !1;
            c = c.instance;
            var d = this._scripts.indexOf(c);
            a = new a({
                app: this.system.app,
                entity: this.entity,
                enabled: c.enabled,
                attributes: c.__attributes
            });
            if (!a.swap) return !1;
            a.__initializeAttributes();
            this._scripts[d] = a;
            this._scriptsIndex[b].instance = a;
            this[b] = a;
            a.__executionOrder = d;
            c.update && this._updateList.remove(c);
            c.postUpdate && this._postUpdateList.remove(c);
            a.update && this._updateList.insert(a);
            a.postUpdate && this._postUpdateList.insert(a);
            this._scriptMethod(a, Xa.scriptMethods.swap, c);
            this.fire("swap", b, a);
            this.fire("swap:" + b, a);
            return !0
        },
        resolveDuplicatedEntityReferenceProperties: function(a, b) {
            var c = this.entity.script,
                d, e, f;
            for (f in a._scriptsIndex) {
                var g = this.system.app.scripts.get(f);
                if (g && (d = a._scriptsIndex[f]) && d.instance) {
                    var k = c[f].__attributesRaw,
                        h = c[f].__attributes;
                    if (k || h) {
                        var l = !!k,
                            n = d.instance.__attributes,
                            p;
                        for (p in n)
                            if (n[p]) {
                                var q = g.attributes.get(p);
                                if (q)
                                    if ("entity" === q.type) this._resolveEntityScriptAttribute(q, p, n[p], l, k || h, b);
                                    else if ("json" === q.type && Array.isArray(q.schema)) {
                                    var r = n[p],
                                        t = k ? k[p] : h[p];
                                    for (d = 0; d < q.schema.length; d++) {
                                        var u = q.schema[d];
                                        if ("entity" === u.type)
                                            if (q.array)
                                                for (e = 0; e < r.length; e++) this._resolveEntityScriptAttribute(u,
                                                    u.name, r[e][u.name], l, t[e], b);
                                            else this._resolveEntityScriptAttribute(u, u.name, r[u.name], l, t, b)
                                    }
                                }
                            }
                    }
                }
            }
        },
        move: function(a, b) {
            var c = this._scripts.length;
            if (b >= c || 0 > b) return !1;
            var d = a,
                e = a;
            "string" !== typeof e ? e = a.__name : d = null;
            a = this._scriptsIndex[e];
            if (!a || !a.instance) return !1;
            a = a.instance;
            if (d && !(a instanceof d)) return !1;
            d = this._scripts.indexOf(a);
            if (-1 === d || d === b) return !1;
            this._scripts.splice(b, 0, this._scripts.splice(d, 1)[0]);
            this._resetExecutionOrder(0, c);
            this._updateList.sort();
            this._postUpdateList.sort();
            this.fire("move", e, a, b, d);
            this.fire("move:" + e, a, b, d);
            return !0
        }
    });
    Object.defineProperty(Xa.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            var b = this._enabled;
            this._enabled = a;
            this.fire("set", "enabled", b, a)
        }
    });
    Object.defineProperty(Xa.prototype, "scripts", {
        get: function() {
            return this._scripts
        },
        set: function(a) {
            this._scriptsData = a;
            for (var b in a)
                if (a.hasOwnProperty(b)) {
                    var c = this._scriptsIndex[b];
                    if (c) {
                        if ("boolean" === typeof a[b].enabled && (c.enabled = !!a[b].enabled), "object" === typeof a[b].attributes)
                            for (var d in a[b].attributes)
                                if (!Ib.reservedAttributes[d]) {
                                    if (!c.__attributes.hasOwnProperty(d)) {
                                        var e =
                                            this.system.app.scripts.get(b);
                                        e && e.attributes.add(d, {})
                                    }
                                    c[d] = a[b].attributes[d]
                                }
                    } else console.log(this.order)
                }
        }
    });
    var Uh = 0;
    Le.prototype = Object.create(H.prototype);
    Le.prototype.constructor = Le;
    Object.assign(Le.prototype, {
        initializeComponentData: function(a, b) {
            a._executionOrder = Uh++;
            this._components.append(a);
            Uh > Number.MAX_SAFE_INTEGER && this._resetExecutionOrder();
            a.enabled = b.hasOwnProperty("enabled") ? !!b.enabled : !0;
            a.enabled && a.entity.enabled && this._enabledComponents.append(a);
            if (b.hasOwnProperty("order") &&
                b.hasOwnProperty("scripts")) {
                a._scriptsData = b.scripts;
                for (var c = 0; c < b.order.length; c++) a.create(b.order[c], {
                    enabled: b.scripts[b.order[c]].enabled,
                    attributes: b.scripts[b.order[c]].attributes,
                    preloading: this.preloading
                })
            }
        },
        cloneComponent: function(a, b) {
            var c, d, e = [],
                f = {};
            for (c = 0; c < a.script._scripts.length; c++) {
                var g = a.script._scripts[c],
                    k = g.__scriptType.__name;
                e.push(k);
                var h = {};
                for (d in g.__attributes) h[d] = g.__attributes[d];
                f[k] = {
                    enabled: g._enabled,
                    attributes: h
                }
            }
            for (d in a.script._scriptsIndex) d.awaiting &&
                e.splice(d.ind, 0, d);
            return this.addComponent(b, {
                enabled: a.script.enabled,
                order: e,
                scripts: f
            })
        },
        _resetExecutionOrder: function() {
            for (var a = Uh = 0, b = this._components.length; a < b; a++) this._components.items[a]._executionOrder = Uh++
        },
        _callComponentMethod: function(a, b, c) {
            for (a.loopIndex = 0; a.loopIndex < a.length; a.loopIndex++) a.items[a.loopIndex][b](c)
        },
        _onInitialize: function() {
            this.preloading = !1;
            this._callComponentMethod(this._components, "_onInitializeAttributes");
            this._callComponentMethod(this._enabledComponents,
                "_onInitialize")
        },
        _onPostInitialize: function() {
            this._callComponentMethod(this._enabledComponents, "_onPostInitialize")
        },
        _onUpdate: function(a) {
            this._callComponentMethod(this._enabledComponents, "_onUpdate", a)
        },
        _onPostUpdate: function(a) {
            this._callComponentMethod(this._enabledComponents, "_onPostUpdate", a)
        },
        _addComponentToEnabled: function(a) {
            this._enabledComponents.insert(a)
        },
        _removeComponentFromEnabled: function(a) {
            this._enabledComponents.remove(a)
        },
        _onBeforeRemove: function(a, b) {
            0 <= this._components.items.indexOf(b) &&
                b._onBeforeRemove();
            this._removeComponentFromEnabled(b);
            this._components.remove(b)
        }
    });
    Zd.prototype = Object.create(O.prototype);
    Zd.prototype.constructor = Zd;
    Object.assign(Zd.prototype, {
        send: function(a, b) {
            var c = Array.prototype.slice.call(arguments, 2),
                d = this.entity.script.instances,
                e;
            if (d && d[a] && (e = d[a].instance[b])) return e.apply(d[a].instance, c)
        },
        onEnable: function() {
            this.data.areScriptsLoaded && !this.system.preloading && (this.data.initialized ? this.system._enableScriptComponent(this) : this.system._initializeScriptComponent(this),
                this.data.postInitialized || this.system._postInitializeScriptComponent(this))
        },
        onDisable: function() {
            this.system._disableScriptComponent(this)
        },
        onSetScripts: function(a, b, c) {
            this.system._inTools && !this.runInTools || this._updateScriptAttributes(b, c) || (this.enabled && this.system._disableScriptComponent(this), this.system._destroyScriptComponent(this), this.data.areScriptsLoaded = !1, a = c.map(function(d) {
                return d.url
            }), this._loadFromCache(a) || this._loadScripts(a))
        },
        _updateScriptAttributes: function(a, b) {
            var c = !0;
            if (a.length !== b.length) c = !1;
            else {
                var d, e = b.length;
                for (d = 0; d < e; d++)
                    if (a[d].url !== b[d].url) {
                        c = !1;
                        break
                    }
            }
            if (c)
                for (var f in this.instances) this.instances.hasOwnProperty(f) && this.system._updateAccessors(this.entity, this.instances[f]);
            return c
        },
        _loadFromCache: function(a) {
            var b, c = [],
                d = this.system.app._scriptPrefix || "",
                e = /^http(s)?:\/\//i;
            var f = 0;
            for (b = a.length; f < b; f++) {
                var g = a[f];
                e.test(g) || (g = ca.join(d, g));
                g = this.system.app.loader.getFromCache(g, "script");
                if (!g) return !1;
                c.push(g)
            }
            f = 0;
            for (b = c.length; f <
                b; f++) d = c[f], !0 !== d && d && this.entity.script && !this.entity.script.instances[d._pcScriptName] && (e = new d(this.entity), this.system._preRegisterInstance(this.entity, a[f], d._pcScriptName, e));
            this.data && (this.data.areScriptsLoaded = !0);
            this.system.preloading || (this.system.onInitialize(this.entity), this.system.onPostInitialize(this.entity));
            return !0
        },
        _loadScripts: function(a) {
            var b = a.length,
                c = this.system.app._scriptPrefix || "";
            a.forEach(function(d) {
                var e = null,
                    f = null;
                d.toLowerCase().startsWith("http://") || d.toLowerCase().startsWith("https://") ?
                    e = f = d : (f = d, e = ca.join(c, d));
                this.system.app.loader.load(e, "script", function(g, k) {
                    b--;
                    g ? console.error(g) : k && this.entity.script && !this.entity.script.instances[k._pcScriptName] && (g = new k(this.entity), this.system._preRegisterInstance(this.entity, f, k._pcScriptName, g));
                    0 === b && (this.data.areScriptsLoaded = !0, this.system.preloading || (this.system.onInitialize(this.entity), this.system.onPostInitialize(this.entity)))
                }.bind(this))
            }.bind(this))
        }
    });
    var en = ["enabled", "scripts", "instances", "runInTools"],
        Pe = function(a) {
            H.call(this,
                a);
            this.id = "script";
            this.ComponentType = Zd;
            this.DataType = Fo;
            this.schema = en;
            this.preloading = !1;
            this.instancesWithUpdate = [];
            this.instancesWithFixedUpdate = [];
            this.instancesWithPostUpdate = [];
            this.instancesWithToolsUpdate = [];
            this.on("beforeremove", this.onBeforeRemove, this);
            H.bind("initialize", this.onInitialize, this);
            H.bind("postInitialize", this.onPostInitialize, this);
            H.bind("update", this.onUpdate, this);
            H.bind("fixedUpdate", this.onFixedUpdate, this);
            H.bind("postUpdate", this.onPostUpdate, this);
            H.bind("toolsUpdate",
                this.onToolsUpdate, this)
        };
    Pe.prototype = Object.create(H.prototype);
    Pe.prototype.constructor = Pe;
    O._buildAccessors(Zd.prototype, en);
    Object.assign(Pe.prototype, {
        initializeComponentData: function(a, b, c) {
            c = ["runInTools", "enabled", "scripts"];
            b.scripts && b.scripts.length && b.scripts.forEach(function(d) {
                if (d.attributes && Array.isArray(d.attributes)) {
                    for (var e = {}, f = 0; f < d.attributes.length; f++) e[d.attributes[f].name] = d.attributes[f];
                    d.attributes = e
                }
            });
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a,
            b) {
            var c = this.store[a.getGuid()];
            a = {
                runInTools: c.data.runInTools,
                scripts: [],
                enabled: c.data.enabled
            };
            c = c.data.scripts;
            for (var d = 0, e = c.length; d < e; d++) {
                var f = c[d].attributes;
                f && delete c[d].attributes;
                a.scripts.push(Hc({}, c[d]));
                f && (a.scripts[d].attributes = this._cloneAttributes(f), c[d].attributes = f)
            }
            return this.addComponent(b, a)
        },
        onBeforeRemove: function(a, b) {
            b.enabled && this._disableScriptComponent(b);
            this._destroyScriptComponent(b)
        },
        onInitialize: function(a) {
            this._registerInstances(a);
            if (a.enabled) {
                a.script &&
                    a.script.enabled && this._initializeScriptComponent(a.script);
                a = a._children;
                var b, c = a.length;
                for (b = 0; b < c; b++)
                    if (a[b] instanceof fa) this.onInitialize(a[b])
            }
        },
        onPostInitialize: function(a) {
            if (a.enabled) {
                a.script && a.script.enabled && this._postInitializeScriptComponent(a.script);
                a = a._children;
                var b, c = a.length;
                for (b = 0; b < c; b++)
                    if (a[b] instanceof fa) this.onPostInitialize(a[b])
            }
        },
        _callInstancesMethod: function(a, b) {
            a = a.data.instances;
            for (var c in a)
                if (a.hasOwnProperty(c)) {
                    var d = a[c].instance;
                    if (d[b]) d[b]()
                }
        },
        _initializeScriptComponent: function(a) {
            this._callInstancesMethod(a,
                "initialize");
            a.data.initialized = !0;
            a.enabled && a.entity.enabled && this._enableScriptComponent(a)
        },
        _enableScriptComponent: function(a) {
            this._callInstancesMethod(a, "onEnable")
        },
        _disableScriptComponent: function(a) {
            this._callInstancesMethod(a, "onDisable")
        },
        _destroyScriptComponent: function(a) {
            var b = a.data.instances,
                c;
            for (c in b)
                if (b.hasOwnProperty(c)) {
                    var d = b[c].instance;
                    d.destroy && d.destroy();
                    if (d.update) {
                        var e = this.instancesWithUpdate.indexOf(d);
                        0 <= e && this.instancesWithUpdate.splice(e, 1)
                    }
                    d.fixedUpdate &&
                        (e = this.instancesWithFixedUpdate.indexOf(d), 0 <= e && this.instancesWithFixedUpdate.splice(e, 1));
                    d.postUpdate && (e = this.instancesWithPostUpdate.indexOf(d), 0 <= e && this.instancesWithPostUpdate.splice(e, 1));
                    d.toolsUpdate && (e = this.instancesWithToolsUpdate.indexOf(d), 0 <= e && this.instancesWithToolsUpdate.splice(e, 1));
                    a.instances[c].instance === a[c] && delete a[c];
                    delete a.instances[c]
                }
        },
        _postInitializeScriptComponent: function(a) {
            this._callInstancesMethod(a, "postInitialize");
            a.data.postInitialized = !0
        },
        _updateInstances: function(a,
            b, c) {
            for (var d, e = 0, f = b.length; e < f; e++)
                if ((d = b[e]) && d.entity && d.entity.enabled && d.entity.script.enabled) d[a](c)
        },
        onUpdate: function(a) {
            this._updateInstances("update", this.instancesWithUpdate, a)
        },
        onFixedUpdate: function(a) {
            this._updateInstances("fixedUpdate", this.instancesWithFixedUpdate, a)
        },
        onPostUpdate: function(a) {
            this._updateInstances("postUpdate", this.instancesWithPostUpdate, a)
        },
        onToolsUpdate: function(a) {
            this._updateInstances("toolsUpdate", this.instancesWithToolsUpdate, a)
        },
        broadcast: function(a, b) {
            var c =
                Array.prototype.slice.call(arguments, 2),
                d, e, f = this.store;
            for (d in f)
                if (f.hasOwnProperty(d)) {
                    var g = f[d].data;
                    g.instances[a] && (e = g.instances[a].instance[b]) && e.apply(g.instances[a].instance, c)
                }
        },
        _preRegisterInstance: function(a, b, c, d) {
            if (a.script) {
                a.script.data._instances = a.script.data._instances || {};
                if (a.script.data._instances[c]) throw Error("Script name collision '" + c + "'. Scripts from '" + b + "' and '" + a.script.data._instances[c].url + "' {" + a.getGuid() + "}");
                a.script.data._instances[c] = {
                    url: b,
                    name: c,
                    instance: d
                }
            }
        },
        _registerInstances: function(a) {
            var b;
            if (a.script && a.script.data._instances) {
                a.script.instances = a.script.data._instances;
                for (b in a.script.instances) {
                    var c = a.script.instances[b];
                    var d = c.instance;
                    Rf.attach(d);
                    d.update && this.instancesWithUpdate.push(d);
                    d.fixedUpdate && this.instancesWithFixedUpdate.push(d);
                    d.postUpdate && this.instancesWithPostUpdate.push(d);
                    d.toolsUpdate && this.instancesWithToolsUpdate.push(d);
                    a.script.scripts && this._createAccessors(a, c);
                    if (a.script[b]) throw Error("Script with name '" + b +
                        "' is already attached to Script Component");
                    a.script[b] = d
                }
                delete a.script.data._instances
            }
            a = a._children;
            d = a.length;
            for (c = 0; c < d; c++) a[c] instanceof fa && this._registerInstances(a[c])
        },
        _cloneAttributes: function(a) {
            var b = {},
                c;
            for (c in a)
                if (a.hasOwnProperty(c))
                    if ("entity" !== a[c].type) b[c] = Hc({}, a[c]);
                    else {
                        var d = a[c].value;
                        delete a[c].value;
                        b[c] = Hc({}, a[c]);
                        b[c].value = d;
                        a[c].value = d
                    }
            return b
        },
        _createAccessors: function(a, b) {
            var c, d = a.script.scripts.length,
                e = b.url;
            for (c = 0; c < d; c++) {
                var f = a.script.scripts[c];
                if (f.url === e) {
                    c = f.attributes;
                    if (f.name && c) {
                        for (var g in c) c.hasOwnProperty(g) && this._createAccessor(c[g], b);
                        a.script.data.attributes[f.name] = this._cloneAttributes(c)
                    }
                    break
                }
            }
        },
        _createAccessor: function(a, b) {
            var c = this;
            a = {
                name: a.name,
                value: a.value,
                type: a.type
            };
            c._convertAttributeValue(a);
            Object.defineProperty(b.instance, a.name, {
                get: function() {
                    return a.value
                },
                set: function(d) {
                    var e = a.value;
                    a.value = d;
                    c._convertAttributeValue(a);
                    b.instance.fire("set", a.name, e, a.value)
                },
                configurable: !0
            })
        },
        _updateAccessors: function(a,
            b) {
            var c, d = a.script.scripts.length,
                e, f = b.url;
            for (c = 0; c < d; c++) {
                var g = a.script;
                var k = g.scripts[c];
                if (k.url === f) {
                    a = k.name;
                    k = k.attributes;
                    if (a) {
                        if (k)
                            for (e in k) k.hasOwnProperty(e) && this._createAccessor(k[e], b);
                        if (c = g.data.attributes[a])
                            for (e in c)
                                if (d = c[e], !(e in k)) delete b.instance[d.name];
                                else if (k[e].value !== d.value && b.instance.onAttributeChanged) b.instance.onAttributeChanged(d.name, d.value, k[e].value);
                        k ? g.data.attributes[a] = this._cloneAttributes(k) : delete g.data.attributes[a]
                    }
                    break
                }
            }
        },
        _convertAttributeValue: function(a) {
            if ("rgb" ===
                a.type || "rgba" === a.type) Array.isArray(a.value) && (a.value = 3 === a.value.length ? new L(a.value[0], a.value[1], a.value[2]) : new L(a.value[0], a.value[1], a.value[2], a.value[3]));
            else if ("vec2" === a.type) Array.isArray(a.value) && (a.value = new P(a.value[0], a.value[1]));
            else if ("vec3" === a.type || "vector" === a.type) Array.isArray(a.value) && (a.value = new z(a.value[0], a.value[1], a.value[2]));
            else if ("vec4" === a.type) Array.isArray(a.value) && (a.value = new X(a.value[0], a.value[1], a.value[2], a.value[3]));
            else if ("entity" === a.type) null !==
                a.value && "string" === typeof a.value && (a.value = this.app.root.findByGuid(a.value));
            else if ("curve" === a.type || "colorcurve" === a.type) a.value = new(a.value.keys[0] instanceof Array ? Cb : hb)(a.value.keys), a.value.type = a.value.type
        }
    });
    var Ad = new P,
        fn = new z,
        qg = new z,
        Vh = new z,
        gn = new z,
        tk = new z,
        $p = new Y,
        aq = {
            x: "y",
            y: "x"
        };
    Oc.prototype = Object.create(M.prototype);
    Oc.prototype.constructor = Oc;
    Object.assign(Oc.prototype, {
        _toggleLifecycleListeners: function(a) {
            this._element[a]("mousedown", this._onMouseDownOrTouchStart, this);
            this._element[a]("touchstart", this._onMouseDownOrTouchStart, this)
        },
        _toggleDragListeners: function(a) {
            var b = "on" === a,
                c = b ? "addEventListener" : "removeEventListener";
            this._hasDragListeners && b || (this._handleMouseUpOrTouchEnd || (this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this)), this._app.mouse && (this._app.mouse[a]("mousemove", this._onMove, this), window[c]("mouseup", this._handleMouseUpOrTouchEnd, !1)), Da.touch && (this._app.touch[a]("touchmove", this._onMove, this), window[c]("touchend", this._handleMouseUpOrTouchEnd, !1), window[c]("touchcancel", this._handleMouseUpOrTouchEnd, !1)), this._hasDragListeners = b)
        },
        _onMouseDownOrTouchStart: function(a) {
            this._element && !this._isDragging && this.enabled && (this._dragCamera = a.camera, this._calculateDragScale(), a = this._screenToLocal(a)) && (this._toggleDragListeners("on"), this._isDragging = !0, this._dragStartMousePosition.copy(a), this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition()), this.fire("drag:start"))
        },
        _onMouseUpOrTouchEnd: function() {
            this._isDragging && (this._isDragging = !1, this._toggleDragListeners("off"), this.fire("drag:end"))
        },
        _screenToLocal: function(a) {
            this._determineInputPosition(a);
            this._chooseRayOriginAndDirection();
            gn.copy(this._element.entity.getPosition());
            tk.copy(this._element.entity.forward).scale(-1);
            a = tk.dot(Vh);
            return 0 < Math.abs(a) ? (a = gn.sub(qg).dot(tk) / a, a = qg.add(Vh.scale(a)), $p.copy(this._element.entity.getRotation()).invert().transformVector(a, a), a.mul(this._dragScale), a) : null
        },
        _determineInputPosition: function(a) {
            var b = this._app.graphicsDevice.maxPixelRatio;
            "undefined" !== typeof a.x && "undefined" !== typeof a.y ? (Ad.x = a.x * b, Ad.y = a.y * b) : a.changedTouches ? (Ad.x = a.changedTouches[0].x * b, Ad.y = a.changedTouches[0].y * b) : console.warn("Could not determine position from input event")
        },
        _chooseRayOriginAndDirection: function() {
            this._element.screen && this._element.screen.screen.screenSpace ? (qg.set(Ad.x, -Ad.y, 0), Vh.set(0, 0, -1)) : (fn.copy(this._dragCamera.screenToWorld(Ad.x, Ad.y, 1)), qg.copy(this._dragCamera.entity.getPosition()), Vh.copy(fn).sub(qg).normalize())
        },
        _calculateDragScale: function() {
            var a =
                this._element.entity.parent,
                b = this._element.screen && this._element.screen.screen,
                c = b && b.screenSpace;
            b = c ? b.scale : 1;
            var d = this._dragScale;
            for (d.set(b, b, b); a && (d.mul(a.getLocalScale()), a = a.parent, !c || !a.screen););
            d.x = 1 / d.x;
            d.y = 1 / d.y;
            d.z = 1 / d.z
        },
        _onMove: function(a) {
            if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled && (a = this._screenToLocal(a), this._dragStartMousePosition && a)) {
                this._deltaMousePosition.copy(a).sub(this._dragStartMousePosition);
                this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);
                if (this._axis) {
                    a = this._element.entity.getLocalPosition();
                    var b = aq[this._axis];
                    this._deltaHandlePosition[b] = a[b]
                }
                this._element.entity.setLocalPosition(this._deltaHandlePosition);
                this.fire("drag:move", this._deltaHandlePosition)
            }
        },
        destroy: function() {
            this._toggleLifecycleListeners("off");
            this._toggleDragListeners("off")
        }
    });
    Object.defineProperty(Oc.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            this._enabled = a
        }
    });
    Object.defineProperty(Oc.prototype, "isDragging", {
        get: function() {
            return this._isDragging
        }
    });
    var uk = new P;
    nd.prototype = Object.create(O.prototype);
    nd.prototype.constructor = nd;
    Object.assign(nd.prototype, {
        _toggleLifecycleListeners: function(a, b) {
            this[a]("set_horizontal", this._onSetHorizontalScrollingEnabled, this);
            this[a]("set_vertical", this._onSetVerticalScrollingEnabled, this);
            b.app.systems.element[a]("add", this._onElementComponentAdd, this);
            b.app.systems.element[a]("beforeremove", this._onElementComponentRemove, this)
        },
        _toggleElementListeners: function(a) {
            !this.entity.element || "on" === a && this._hasElementListeners ||
                (this.entity.element[a]("resize", this._onSetContentOrViewportSize, this), this._hasElementListeners = "on" === a)
        },
        _onElementComponentAdd: function(a) {
            this.entity === a && this._toggleElementListeners("on")
        },
        _onElementComponentRemove: function(a) {
            this.entity === a && this._toggleElementListeners("off")
        },
        _onViewportElementGain: function() {
            this._syncAll()
        },
        _onContentElementGain: function() {
            this._destroyDragHelper();
            this._contentDragHelper = new Oc(this._contentReference.entity.element);
            this._contentDragHelper.on("drag:start",
                this._onContentDragStart, this);
            this._contentDragHelper.on("drag:end", this._onContentDragEnd, this);
            this._contentDragHelper.on("drag:move", this._onContentDragMove, this);
            this._prevContentSizes[0] = null;
            this._prevContentSizes[1] = null;
            this._syncAll()
        },
        _onContentElementLose: function() {
            this._destroyDragHelper()
        },
        _onContentDragStart: function() {
            this._contentReference.entity && this.enabled && this.entity.enabled && this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition())
        },
        _onContentDragEnd: function() {
            this._prevContentDragPosition =
                null;
            this._enableContentInput()
        },
        _onContentDragMove: function(a) {
            if (this._contentReference.entity && this.enabled && this.entity.enabled && (this._wasDragged = !0, this._setScrollFromContentPosition(a), this._setVelocityFromContentPositionDelta(a), !this._disabledContentInput)) {
                var b = a.y - this._dragStartPosition.y;
                (Math.abs(a.x - this._dragStartPosition.x) > this.dragThreshold || Math.abs(b) > this.dragThreshold) && this._disableContentInput()
            }
        },
        _onSetContentOrViewportSize: function() {
            this._syncAll()
        },
        _onSetHorizontalScrollbarValue: function(a) {
            !this._scrollbarUpdateFlags[0] &&
                this.enabled && this.entity.enabled && this._onSetScroll(a, null)
        },
        _onSetVerticalScrollbarValue: function(a) {
            !this._scrollbarUpdateFlags[1] && this.enabled && this.entity.enabled && this._onSetScroll(null, a)
        },
        _onSetHorizontalScrollingEnabled: function() {
            this._syncScrollbarEnabledState(0)
        },
        _onSetVerticalScrollingEnabled: function() {
            this._syncScrollbarEnabledState(1)
        },
        _onHorizontalScrollbarGain: function() {
            this._syncScrollbarEnabledState(0);
            this._syncScrollbarPosition(0)
        },
        _onVerticalScrollbarGain: function() {
            this._syncScrollbarEnabledState(1);
            this._syncScrollbarPosition(1)
        },
        _onSetScroll: function(a, b, c) {
            !1 !== c && this._velocity.set(0, 0, 0);
            a = 0 | this._updateAxis(a, "x", 0);
            (a |= this._updateAxis(b, "y", 1)) && this.fire("set:scroll", this._scroll)
        },
        _updateAxis: function(a, b, c) {
            var d = null !== a && 1E-5 < Math.abs(a - this._scroll[b]);
            if (d || this._isDragging() || 0 === a) this._scroll[b] = this._determineNewScrollValue(a, b, c), this._syncContentPosition(c), this._syncScrollbarPosition(c);
            return d
        },
        _determineNewScrollValue: function(a, b, c) {
            if (!this._getScrollingEnabled(c)) return this._scroll[b];
            switch (this.scrollMode) {
                case 0:
                    return N.clamp(a, 0, this._getMaxScrollValue(c));
                case 1:
                    return this._setVelocityFromOvershoot(a, b, c), a;
                case 2:
                    return a;
                default:
                    return console.warn("Unhandled scroll mode:" + this.scrollMode), a
            }
        },
        _syncAll: function() {
            this._syncContentPosition(0);
            this._syncContentPosition(1);
            this._syncScrollbarPosition(0);
            this._syncScrollbarPosition(1);
            this._syncScrollbarEnabledState(0);
            this._syncScrollbarEnabledState(1)
        },
        _syncContentPosition: function(a) {
            var b = this._getAxis(a),
                c = this._getSign(a),
                d = this._contentReference.entity;
            if (d) {
                var e = this._prevContentSizes[a],
                    f = this._getContentSize(a);
                if (null !== e && 1E-4 < Math.abs(e - f)) {
                    e = this._getMaxOffset(a, e);
                    var g = this._getMaxOffset(a, f);
                    this._scroll[b] = 0 === g ? 1 : N.clamp(this._scroll[b] * e / g, 0, 1)
                }
                e = this._scroll[b] * this._getMaxOffset(a);
                g = d.getLocalPosition();
                g[b] = e * c;
                d.setLocalPosition(g);
                this._prevContentSizes[a] = f
            }
        },
        _syncScrollbarPosition: function(a) {
            var b = this._getAxis(a),
                c = this._scrollbarReferences[a].entity;
            c && c.scrollbar && (this._scrollbarUpdateFlags[a] = !0, c.scrollbar.value = this._scroll[b], c.scrollbar.handleSize = this._getScrollbarHandleSize(b, a), this._scrollbarUpdateFlags[a] = !1)
        },
        _syncScrollbarEnabledState: function(a) {
            var b = this._scrollbarReferences[a].entity;
            if (b) {
                var c = this._getScrollingEnabled(a),
                    d = this._getScrollbarVisibility(a);
                switch (d) {
                    case 0:
                        b.enabled = c;
                        break;
                    case 1:
                        b.enabled = c && this._contentIsLargerThanViewport(a);
                        break;
                    default:
                        console.warn("Unhandled scrollbar visibility:" + d), b.enabled = c
                }
            }
        },
        _contentIsLargerThanViewport: function(a) {
            return this._getContentSize(a) >
                this._getViewportSize(a)
        },
        _contentPositionToScrollValue: function(a) {
            var b = this._getMaxOffset(0),
                c = this._getMaxOffset(1);
            uk.x = 0 === b ? 0 : a.x / b;
            uk.y = 0 === c ? 0 : a.y / -c;
            return uk
        },
        _getMaxOffset: function(a, b) {
            b = void 0 === b ? this._getContentSize(a) : b;
            var c = this._getViewportSize(a);
            return b < c ? -this._getViewportSize(a) : c - b
        },
        _getMaxScrollValue: function(a) {
            return this._contentIsLargerThanViewport(a) ? 1 : 0
        },
        _getScrollbarHandleSize: function(a, b) {
            var c = this._getViewportSize(b),
                d = this._getContentSize(b);
            if (.001 > Math.abs(d)) return 1;
            c = Math.min(c / d, 1);
            a = this._toOvershoot(this._scroll[a], b);
            return 0 === a ? c : c / (1 + Math.abs(a))
        },
        _getViewportSize: function(a) {
            return this._getSize(a, this._viewportReference)
        },
        _getContentSize: function(a) {
            return this._getSize(a, this._contentReference)
        },
        _getSize: function(a, b) {
            return b.entity && b.entity.element ? b.entity.element[this._getCalculatedDimension(a)] : 0
        },
        _getScrollingEnabled: function(a) {
            if (0 === a) return this.horizontal;
            if (1 === a) return this.vertical;
            console.warn("Unrecognized orientation: " + a)
        },
        _getScrollbarVisibility: function(a) {
            if (0 ===
                a) return this.horizontalScrollbarVisibility;
            if (1 === a) return this.verticalScrollbarVisibility;
            console.warn("Unrecognized orientation: " + a)
        },
        _getSign: function(a) {
            return 0 === a ? 1 : -1
        },
        _getAxis: function(a) {
            return 0 === a ? "x" : "y"
        },
        _getCalculatedDimension: function(a) {
            return 0 === a ? "calculatedWidth" : "calculatedHeight"
        },
        _destroyDragHelper: function() {
            this._contentDragHelper && this._contentDragHelper.destroy()
        },
        onUpdate: function() {
            this._contentReference.entity && (this._updateVelocity(), this._syncScrollbarEnabledState(0),
                this._syncScrollbarEnabledState(1))
        },
        _updateVelocity: function() {
            if (!this._isDragging() && (1 === this.scrollMode && (this._hasOvershoot("x", 0) && this._setVelocityFromOvershoot(this.scroll.x, "x", 0), this._hasOvershoot("y", 1) && this._setVelocityFromOvershoot(this.scroll.y, "y", 1)), this._velocity.x *= 1 - this.friction, this._velocity.y *= 1 - this.friction, 1E-4 < Math.abs(this._velocity.x) || 1E-4 < Math.abs(this._velocity.y))) {
                var a = this._contentReference.entity.getLocalPosition();
                a.x += this._velocity.x;
                a.y += this._velocity.y;
                this._contentReference.entity.setLocalPosition(a);
                this._setScrollFromContentPosition(a)
            }
        },
        _hasOvershoot: function(a, b) {
            return .001 < Math.abs(this._toOvershoot(this.scroll[a], b))
        },
        _toOvershoot: function(a, b) {
            b = this._getMaxScrollValue(b);
            return 0 > a ? a : a > b ? a - b : 0
        },
        _setVelocityFromOvershoot: function(a, b, c) {
            a = this._toOvershoot(a, c) * this._getMaxOffset(c) * this._getSign(c);
            0 < Math.abs(a) && (this._velocity[b] = -a / (50 * this.bounceAmount + 1))
        },
        _setVelocityFromContentPositionDelta: function(a) {
            this._prevContentDragPosition ?
                (this._velocity.sub2(a, this._prevContentDragPosition), this._prevContentDragPosition.copy(a)) : (this._velocity.set(0, 0, 0), this._prevContentDragPosition = a.clone())
        },
        _setScrollFromContentPosition: function(a) {
            a = this._contentPositionToScrollValue(a);
            this._isDragging() && (a = this._applyScrollValueTension(a));
            this._onSetScroll(a.x, a.y, !1)
        },
        _applyScrollValueTension: function(a) {
            var b = this._getMaxScrollValue(0);
            var c = this._toOvershoot(a.x, 0);
            0 < c ? a.x = b + 1 * Math.log10(1 + c) : 0 > c && (a.x = -1 * Math.log10(1 - c));
            b = this._getMaxScrollValue(1);
            c = this._toOvershoot(a.y, 1);
            0 < c ? a.y = b + 1 * Math.log10(1 + c) : 0 > c && (a.y = -1 * Math.log10(1 - c));
            return a
        },
        _isDragging: function() {
            return this._contentDragHelper && this._contentDragHelper.isDragging
        },
        _setScrollbarComponentsEnabled: function(a) {
            this._scrollbarReferences[0].hasComponent("scrollbar") && (this._scrollbarReferences[0].entity.scrollbar.enabled = a);
            this._scrollbarReferences[1].hasComponent("scrollbar") && (this._scrollbarReferences[1].entity.scrollbar.enabled = a)
        },
        _setContentDraggingEnabled: function(a) {
            this._contentDragHelper &&
                (this._contentDragHelper.enabled = a)
        },
        _enableContentInput: function() {
            for (; this._disabledContentInputEntities.length;) {
                var a = this._disabledContentInputEntities.pop();
                a.element && (a.element.useInput = !0)
            }
            this._disabledContentInput = !1
        },
        _disableContentInput: function() {
            var a = this,
                b = function(f) {
                    f.element && f.element.useInput && (a._disabledContentInputEntities.push(f), f.element.useInput = !1);
                    f = f.children;
                    var g;
                    var k = 0;
                    for (g = f.length; k < g; k++) b(f[k])
                },
                c = this._contentReference.entity;
            if (c) {
                c = c.children;
                var d, e = c.length;
                for (d = 0; d < e; d++) b(c[d])
            }
            this._disabledContentInput = !0
        },
        onEnable: function() {
            this._viewportReference.onParentComponentEnable();
            this._contentReference.onParentComponentEnable();
            this._scrollbarReferences[0].onParentComponentEnable();
            this._scrollbarReferences[1].onParentComponentEnable();
            this._setScrollbarComponentsEnabled(!0);
            this._setContentDraggingEnabled(!0);
            this._syncAll()
        },
        onDisable: function() {
            this._setScrollbarComponentsEnabled(!1);
            this._setContentDraggingEnabled(!1)
        },
        onRemove: function() {
            this._toggleLifecycleListeners("off",
                this.system);
            this._toggleElementListeners("off");
            this._destroyDragHelper()
        }
    });
    Object.defineProperty(nd.prototype, "scroll", {
        get: function() {
            return this._scroll
        },
        set: function(a) {
            this._onSetScroll(a.x, a.y)
        }
    });
    var vk = [{
                name: "enabled",
                type: "boolean"
            }, {
                name: "horizontal",
                type: "boolean"
            }, {
                name: "vertical",
                type: "boolean"
            }, {
                name: "scrollMode",
                type: "number"
            }, {
                name: "bounceAmount",
                type: "number"
            }, {
                name: "friction",
                type: "number"
            }, {
                name: "dragThreshold",
                type: "number"
            }, {
                name: "horizontalScrollbarVisibility",
                type: "number"
            },
            {
                name: "verticalScrollbarVisibility",
                type: "number"
            }, {
                name: "viewportEntity",
                type: "entity"
            }, {
                name: "contentEntity",
                type: "entity"
            }, {
                name: "horizontalScrollbarEntity",
                type: "entity"
            }, {
                name: "verticalScrollbarEntity",
                type: "entity"
            }
        ],
        Qe = function(a) {
            H.call(this, a);
            this.id = "scrollview";
            this.ComponentType = nd;
            this.DataType = Go;
            this.schema = vk;
            this.on("beforeremove", this._onRemoveComponent, this);
            H.bind("update", this.onUpdate, this)
        };
    Qe.prototype = Object.create(H.prototype);
    Qe.prototype.constructor = Qe;
    O._buildAccessors(nd.prototype,
        vk);
    Object.assign(Qe.prototype, {
        initializeComponentData: function(a, b, c) {
            void 0 === b.dragThreshold && (b.dragThreshold = 10);
            H.prototype.initializeComponentData.call(this, a, b, vk)
        },
        onUpdate: function(a) {
            a = this.store;
            for (var b in a) {
                var c = a[b].entity,
                    d = c.scrollview;
                if (d.enabled && c.enabled) d.onUpdate()
            }
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        }
    });
    $d.prototype = Object.create(O.prototype);
    $d.prototype.constructor = $d;
    Object.assign($d.prototype, {
        _toggleLifecycleListeners: function(a) {
            this[a]("set_value", this._onSetValue,
                this);
            this[a]("set_handleSize", this._onSetHandleSize, this);
            this[a]("set_orientation", this._onSetOrientation, this)
        },
        _onHandleElementGain: function() {
            this._destroyDragHelper();
            this._handleDragHelper = new Oc(this._handleReference.entity.element, this._getAxis());
            this._handleDragHelper.on("drag:move", this._onHandleDrag, this);
            this._updateHandlePositionAndSize()
        },
        _onHandleElementLose: function() {
            this._destroyDragHelper()
        },
        _onHandleDrag: function(a) {
            this._handleReference.entity && this.enabled && this.entity.enabled &&
                (this.value = this._handlePositionToScrollValue(a[this._getAxis()]))
        },
        _onSetValue: function(a, b, c) {
            1E-5 < Math.abs(c - b) && (this.data.value = N.clamp(c, 0, 1), this._updateHandlePositionAndSize(), this.fire("set:value", this.data.value))
        },
        _onSetHandleSize: function(a, b, c) {
            1E-5 < Math.abs(c - b) && (this.data.handleSize = N.clamp(c, 0, 1), this._updateHandlePositionAndSize())
        },
        _onSetHandleAlignment: function() {
            this._updateHandlePositionAndSize()
        },
        _onSetOrientation: function(a, b, c) {
            c !== b && this._handleReference.hasComponent("element") &&
                (this._handleReference.entity.element[this._getOppositeDimension()] = 0)
        },
        _updateHandlePositionAndSize: function() {
            var a = this._handleReference.entity,
                b = a && a.element;
            a && (a = a.getLocalPosition(), a[this._getAxis()] = this._getHandlePosition(), this._handleReference.entity.setLocalPosition(a));
            b && (b[this._getDimension()] = this._getHandleLength())
        },
        _handlePositionToScrollValue: function(a) {
            return a * this._getSign() / this._getUsableTrackLength()
        },
        _scrollValueToHandlePosition: function(a) {
            return a * this._getSign() * this._getUsableTrackLength()
        },
        _getUsableTrackLength: function() {
            return Math.max(this._getTrackLength() - this._getHandleLength(), .001)
        },
        _getTrackLength: function() {
            return this.entity.element ? 0 === this.orientation ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight : 0
        },
        _getHandleLength: function() {
            return this._getTrackLength() * this.handleSize
        },
        _getHandlePosition: function() {
            return this._scrollValueToHandlePosition(this.value)
        },
        _getSign: function() {
            return 0 === this.orientation ? 1 : -1
        },
        _getAxis: function() {
            return 0 === this.orientation ?
                "x" : "y"
        },
        _getDimension: function() {
            return 0 === this.orientation ? "width" : "height"
        },
        _getOppositeDimension: function() {
            return 0 === this.orientation ? "height" : "width"
        },
        _destroyDragHelper: function() {
            this._handleDragHelper && this._handleDragHelper.destroy()
        },
        _setHandleDraggingEnabled: function(a) {
            this._handleDragHelper && (this._handleDragHelper.enabled = a)
        },
        onEnable: function() {
            this._handleReference.onParentComponentEnable();
            this._setHandleDraggingEnabled(!0)
        },
        onDisable: function() {
            this._setHandleDraggingEnabled(!1)
        },
        onRemove: function() {
            this._destroyDragHelper();
            this._toggleLifecycleListeners("off")
        }
    });
    var yj = [{
        name: "enabled",
        type: "boolean"
    }, {
        name: "orientation",
        type: "number"
    }, {
        name: "value",
        type: "number"
    }, {
        name: "handleSize",
        type: "number"
    }, {
        name: "handleEntity",
        type: "entity"
    }];
    Me.prototype = Object.create(H.prototype);
    Me.prototype.constructor = Me;
    O._buildAccessors($d.prototype, yj);
    Object.assign(Me.prototype, {
        initializeComponentData: function(a, b, c) {
            H.prototype.initializeComponentData.call(this, a, b, yj)
        },
        _onRemoveComponent: function(a,
            b) {
            b.onRemove()
        }
    });
    fd() ? (m.SoundInstance = function(a, b, c) {
                M.call(this);
                c = c || {};
                this._volume = void 0 !== c.volume ? N.clamp(Number(c.volume) || 0, 0, 1) : 1;
                this._pitch = void 0 !== c.pitch ? Math.max(.01, Number(c.pitch) || 0) : 1;
                this._loop = !(void 0 === c.loop || !c.loop);
                this._sound = b;
                this._state = 2;
                this._suspendInstanceEvents = this._suspendEndEvent = this._suspended = !1;
                this._startTime = Math.max(0, Number(c.startTime) || 0);
                this._duration = Math.max(0, Number(c.duration) || 0);
                this._startedAt = 0;
                this._startOffset = null;
                this._currentOffset =
                    this._currentTime = 0;
                this._playWhenLoaded = !0;
                this._manager = a;
                this._lastNode = this._firstNode = this._connectorNode = this._inputNode = null;
                this._initializeNodes();
                this._onPlayCallback = c.onPlay;
                this._onPauseCallback = c.onPause;
                this._onResumeCallback = c.onResume;
                this._onStopCallback = c.onStop;
                this._onEndCallback = c.onEnd;
                this._endedHandler = this._onEnded.bind(this);
                this.source = null
            }, m.SoundInstance.prototype = Object.create(M.prototype), m.SoundInstance.prototype.constructor = m.SoundInstance, Object.assign(m.SoundInstance.prototype, {
                _initializeNodes: function() {
                    this._connectorNode = this._inputNode = this.gain = this._manager.context.createGain();
                    this._connectorNode.connect(this._manager.context.destination)
                },
                play: function() {
                    2 !== this._state && this.stop();
                    this.source || this._createSource();
                    var a = this._startOffset % this.duration || 0;
                    a = (this._startTime + a) % this._sound.duration || 0;
                    this._startOffset = null;
                    this._duration ? this.source.start(0, a, this._duration) : this.source.start(0, a);
                    this._startedAt = this._manager.context.currentTime;
                    this._currentTime =
                        0;
                    this._currentOffset = a;
                    this._state = 0;
                    this._playWhenLoaded = !1;
                    this.volume = this._volume;
                    this.loop = this._loop;
                    this.pitch = this._pitch;
                    this._manager.on("volumechange", this._onManagerVolumeChange, this);
                    this._manager.on("suspend", this._onManagerSuspend, this);
                    this._manager.on("resume", this._onManagerResume, this);
                    this._manager.on("destroy", this._onManagerDestroy, this);
                    this._manager.suspended && this._onManagerSuspend();
                    this._suspendInstanceEvents || this._onPlay();
                    return !0
                },
                pause: function() {
                    if (0 !== this._state ||
                        !this.source) return !1;
                    this._updateCurrentTime();
                    this._state = 1;
                    this._suspendEndEvent = !0;
                    this.source.stop(0);
                    this.source = null;
                    this._playWhenLoaded = !1;
                    this._startOffset = null;
                    this._suspendInstanceEvents || this._onPause();
                    return !0
                },
                resume: function() {
                    if (1 !== this._state) return !1;
                    this.source || this._createSource();
                    var a = this.currentTime;
                    null !== this._startOffset && (a = this._startOffset % this.duration || 0, a = (this._startTime + a) % this._sound.duration || 0, this._startOffset = null);
                    this._duration ? this.source.start(0, a, this._duration) :
                        this.source.start(0, a);
                    this._state = 0;
                    this._startedAt = this._manager.context.currentTime;
                    this._currentOffset = a;
                    this.volume = this._volume;
                    this.loop = this._loop;
                    this.pitch = this._pitch;
                    this._playWhenLoaded = !1;
                    this._suspendInstanceEvents || this._onResume();
                    return !0
                },
                stop: function() {
                    if (2 === this._state || !this.source) return !1;
                    this._manager.off("volumechange", this._onManagerVolumeChange, this);
                    this._manager.off("suspend", this._onManagerSuspend, this);
                    this._manager.off("resume", this._onManagerResume, this);
                    this._manager.off("destroy",
                        this._onManagerDestroy, this);
                    this._currentOffset = this._currentTime = this._startedAt = 0;
                    this._startOffset = null;
                    this._playWhenLoaded = !1;
                    this._suspendEndEvent = !0;
                    0 === this._state && this.source.stop(0);
                    this.source = null;
                    this._state = 2;
                    this._suspendInstanceEvents || this._onStop();
                    return !0
                },
                setExternalNodes: function(a, b) {
                    if (a) {
                        b || (b = a);
                        var c = this._manager.context.destination;
                        this._firstNode !== a && (this._firstNode ? this._connectorNode.disconnect(this._firstNode) : this._connectorNode.disconnect(c), this._firstNode =
                            a, this._connectorNode.connect(a));
                        this._lastNode !== b && (this._lastNode && this._lastNode.disconnect(c), this._lastNode = b, this._lastNode.connect(c))
                    } else console.error("The firstNode must be a valid Audio Node")
                },
                clearExternalNodes: function() {
                    var a = this._manager.context.destination;
                    this._firstNode && (this._connectorNode.disconnect(this._firstNode), this._firstNode = null);
                    this._lastNode && (this._lastNode.disconnect(a), this._lastNode = null);
                    this._connectorNode.connect(a)
                },
                getExternalNodes: function() {
                    return [this._firstNode,
                        this._lastNode
                    ]
                },
                _createSource: function() {
                    if (!this._sound) return null;
                    var a = this._manager.context;
                    this._sound.buffer && (this.source = a.createBufferSource(), this.source.buffer = this._sound.buffer, this.source.connect(this._inputNode), this.source.onended = this._endedHandler, this.source.loopStart = this._startTime % this.source.buffer.duration || 0, this._duration && (this.source.loopEnd = Math.max(this.source.loopStart, (this._startTime + this._duration) % this.source.buffer.duration || 0)));
                    return this.source
                },
                _updateCurrentTime: function() {
                    this._currentTime =
                        ((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset) % this.duration || 0
                },
                _onManagerDestroy: function() {
                    this.source && 0 === this._state && (this.source.stop(0), this.source = null)
                }
            }), Object.defineProperty(m.SoundInstance.prototype, "volume", {
                get: function() {
                    return this._volume
                },
                set: function(a) {
                    this._volume = a = N.clamp(a, 0, 1);
                    this.gain && (this.gain.gain.value = a * this._manager.volume)
                }
            }), Object.defineProperty(m.SoundInstance.prototype, "pitch", {
                get: function() {
                    return this._pitch
                },
                set: function(a) {
                    this._currentOffset =
                        this.currentTime;
                    this._startedAt = this._manager.context.currentTime;
                    this._pitch = Math.max(Number(a) || 0, .01);
                    this.source && (this.source.playbackRate.value = this._pitch)
                }
            }), Object.defineProperty(m.SoundInstance.prototype, "loop", {
                get: function() {
                    return this._loop
                },
                set: function(a) {
                    this._loop = !!a;
                    this.source && (this.source.loop = this._loop)
                }
            }), Object.defineProperty(m.SoundInstance.prototype, "sound", {
                get: function() {
                    return this._sound
                },
                set: function(a) {
                    this._sound = a;
                    2 !== this._state ? this.stop() : this._createSource()
                }
            }),
            Object.defineProperty(m.SoundInstance.prototype, "currentTime", {
                get: function() {
                    if (null !== this._startOffset) return this._startOffset;
                    if (1 === this._state) return this._currentTime;
                    if (2 === this._state || !this.source) return 0;
                    this._updateCurrentTime();
                    return this._currentTime
                },
                set: function(a) {
                    if (!(0 > a))
                        if (0 === this._state) {
                            this.stop();
                            var b = this._suspendInstanceEvents;
                            this._suspendInstanceEvents = !0;
                            this._startOffset = a;
                            this.play();
                            this._suspendInstanceEvents = b
                        } else this._currentTime = this._startOffset = a
                }
            })) :
        we() ? (m.SoundInstance = function(a, b, c) {
            M.call(this);
            c = c || {};
            this._volume = void 0 !== c.volume ? N.clamp(Number(c.volume) || 0, 0, 1) : 1;
            this._pitch = void 0 !== c.pitch ? Math.max(.01, Number(c.pitch) || 0) : 1;
            this._loop = !(void 0 === c.loop || !c.loop);
            this._sound = b;
            this._state = 2;
            this._suspendInstanceEvents = this._suspendEndEvent = this._suspended = !1;
            this._playWhenLoaded = !0;
            this._startTime = Math.max(0, Number(c.startTime) || 0);
            this._duration = Math.max(0, Number(c.duration) || 0);
            this._startOffset = null;
            this._isReady = !1;
            this._manager =
                a;
            this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
            this._timeUpdateHandler = this._onTimeUpdate.bind(this);
            this._endedHandler = this._onEnded.bind(this);
            this._onPlayCallback = c.onPlay;
            this._onPauseCallback = c.onPause;
            this._onResumeCallback = c.onResume;
            this._onStopCallback = c.onStop;
            this._onEndCallback = c.onEnd;
            this.source = null;
            this._createSource()
        }, m.SoundInstance.prototype = Object.create(M.prototype), m.SoundInstance.prototype.constructor = m.SoundInstance, Object.assign(m.SoundInstance.prototype, {
            play: function() {
                2 !== this._state && this.stop();
                if (!this.source && !this._createSource()) return !1;
                this.volume = this._volume;
                this.pitch = this._pitch;
                this.loop = this._loop;
                this.source.play();
                this._state = 0;
                this._playWhenLoaded = !1;
                this._manager.on("volumechange", this._onManagerVolumeChange, this);
                this._manager.on("suspend", this._onManagerSuspend, this);
                this._manager.on("resume", this._onManagerResume, this);
                this._manager.on("destroy", this._onManagerDestroy, this);
                this._manager.suspended && this._onManagerSuspend();
                this._suspendInstanceEvents || this._onPlay();
                return !0
            },
            pause: function() {
                if (!this.source || 0 !== this._state) return !1;
                this._suspendEndEvent = !0;
                this.source.pause();
                this._playWhenLoaded = !1;
                this._state = 1;
                this._startOffset = null;
                this._suspendInstanceEvents || this._onPause();
                return !0
            },
            resume: function() {
                if (!this.source || 1 !== this._state) return !1;
                this._state = 0;
                this._playWhenLoaded = !1;
                this.source.paused && (this.source.play(), this._suspendInstanceEvents || this._onResume());
                return !0
            },
            stop: function() {
                if (!this.source ||
                    2 === this._state) return !1;
                this._manager.off("volumechange", this._onManagerVolumeChange, this);
                this._manager.off("suspend", this._onManagerSuspend, this);
                this._manager.off("resume", this._onManagerResume, this);
                this._manager.off("destroy", this._onManagerDestroy, this);
                this._suspendEndEvent = !0;
                this.source.pause();
                this._playWhenLoaded = !1;
                this._state = 2;
                this._startOffset = null;
                this._suspendInstanceEvents || this._onStop();
                return !0
            },
            setExternalNodes: function() {},
            clearExternalNodes: function() {},
            getExternalNodes: function() {
                return [null,
                    null
                ]
            },
            _onLoadedMetadata: function() {
                this.source.removeEventListener("loadedmetadata", this._loadedMetadataHandler);
                this._isReady = !0;
                var a = this._startOffset % this.duration || 0;
                a = (this._startTime + a) % this._sound.duration || 0;
                this._startOffset = null;
                this.source.currentTime = a
            },
            _createSource: function() {
                this._sound && this._sound.audio && (this._isReady = !1, this.source = this._sound.audio.cloneNode(!0), this.source.addEventListener("loadedmetadata", this._loadedMetadataHandler), this.source.addEventListener("timeupdate",
                    this._timeUpdateHandler), this.source.onended = this._endedHandler);
                return this.source
            },
            _onTimeUpdate: function() {
                this._duration && this.source.currentTime > ((this._startTime + this._duration) % this.source.duration || 0) && (this.loop ? this.source.currentTime = this._startTime % this.source.duration || 0 : (this.source.removeEventListener("timeupdate", this._timeUpdateHandler), this.source.pause(), this._onEnded()))
            },
            _onManagerDestroy: function() {
                this.source && this.source.pause()
            }
        }), Object.defineProperty(m.SoundInstance.prototype,
            "volume", {
                get: function() {
                    return this._volume
                },
                set: function(a) {
                    this._volume = a = N.clamp(a, 0, 1);
                    this.source && (this.source.volume = a * this._manager.volume)
                }
            }), Object.defineProperty(m.SoundInstance.prototype, "pitch", {
            get: function() {
                return this._pitch
            },
            set: function(a) {
                this._pitch = Math.max(Number(a) || 0, .01);
                this.source && (this.source.playbackRate = this._pitch)
            }
        }), Object.defineProperty(m.SoundInstance.prototype, "loop", {
            get: function() {
                return this._loop
            },
            set: function(a) {
                this._loop = !!a;
                this.source && (this.source.loop =
                    this._loop)
            }
        }), Object.defineProperty(m.SoundInstance.prototype, "sound", {
            get: function() {
                return this._sound
            },
            set: function(a) {
                this.stop();
                this._sound = a
            }
        }), Object.defineProperty(m.SoundInstance.prototype, "currentTime", {
            get: function() {
                return null !== this._startOffset ? this._startOffset : 2 !== this._state && this.source ? this.source.currentTime - this._startTime : 0
            },
            set: function(a) {
                0 > a || (this._startOffset = a, this.source && this._isReady && (this.source.currentTime = (this._startTime + (a % this.duration || 0)) % this._sound.duration ||
                    0, this._startOffset = null))
            }
        })) : m.SoundInstance = function() {};
    Object.assign(m.SoundInstance.prototype, {
        _onPlay: function() {
            this.fire("play");
            this._onPlayCallback && this._onPlayCallback(this)
        },
        _onPause: function() {
            this.fire("pause");
            this._onPauseCallback && this._onPauseCallback(this)
        },
        _onResume: function() {
            this.fire("resume");
            this._onResumeCallback && this._onResumeCallback(this)
        },
        _onStop: function() {
            this.fire("stop");
            this._onStopCallback && this._onStopCallback(this)
        },
        _onEnded: function() {
            this._suspendEndEvent ?
                this._suspendEndEvent = !1 : (this.fire("end"), this._onEndCallback && this._onEndCallback(this), this.stop())
        },
        _onManagerVolumeChange: function() {
            this.volume = this._volume
        },
        _onManagerSuspend: function() {
            0 !== this._state || this._suspended || (this._suspended = !0, this.pause())
        },
        _onManagerResume: function() {
            this._suspended && (this._suspended = !1, this.resume())
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "startTime", {
        get: function() {
            return this._startTime
        },
        set: function(a) {
            this._startTime = Math.max(0, Number(a) || 0);
            a = 0 === this._state;
            this.stop();
            a && this.play()
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "duration", {
        get: function() {
            return this._sound ? this._duration ? this._duration % this._sound.duration || 0 : this._sound.duration : 0
        },
        set: function(a) {
            this._duration = Math.max(0, Number(a) || 0);
            a = 0 === this._state;
            this.stop();
            a && this.play()
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "isPlaying", {
        get: function() {
            return 0 === this._state
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "isPaused", {
        get: function() {
            return 1 ===
                this._state
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "isStopped", {
        get: function() {
            return 2 === this._state
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "isSuspended", {
        get: function() {
            return this._suspended
        }
    });
    if (fd()) m.SoundInstance3d = function(a, b, c) {
        m.SoundInstance.call(this, a, b, c);
        c = c || {};
        this._position = new z;
        c.position && (this.position = c.position);
        this._velocity = new z;
        c.velocity && (this.velocity = c.velocity);
        this.maxDistance = void 0 !== c.maxDistance ? Number(c.maxDistance) : 1E4;
        this.refDistance =
            void 0 !== c.refDistance ? Number(c.refDistance) : 1;
        this.rollOffFactor = void 0 !== c.rollOffFactor ? Number(c.rollOffFactor) : 1;
        this.distanceModel = void 0 !== c.distanceModel ? c.distanceModel : "linear"
    }, m.SoundInstance3d.prototype = Object.create(m.SoundInstance.prototype), m.SoundInstance3d.prototype.constructor = m.SoundInstance3d, Object.assign(m.SoundInstance3d.prototype, {
        _initializeNodes: function() {
            this.gain = this._manager.context.createGain();
            this.panner = this._manager.context.createPanner();
            this.panner.connect(this.gain);
            this._inputNode = this.panner;
            this._connectorNode = this.gain;
            this._connectorNode.connect(this._manager.context.destination)
        }
    }), Object.defineProperty(m.SoundInstance3d.prototype, "position", {
        get: function() {
            return this._position
        },
        set: function(a) {
            this._position.copy(a);
            this.panner.setPosition(a.x, a.y, a.z)
        }
    }), Object.defineProperty(m.SoundInstance3d.prototype, "velocity", {
        get: function() {
            return this._velocity
        },
        set: function(a) {
            this._velocity.copy(a);
            this.panner.setVelocity(a.x, a.y, a.z)
        }
    }), Object.defineProperty(m.SoundInstance3d.prototype,
        "maxDistance", {
            get: function() {
                return this.panner.maxDistance
            },
            set: function(a) {
                this.panner.maxDistance = a
            }
        }), Object.defineProperty(m.SoundInstance3d.prototype, "refDistance", {
        get: function() {
            return this.panner.refDistance
        },
        set: function(a) {
            this.panner.refDistance = a
        }
    }), Object.defineProperty(m.SoundInstance3d.prototype, "rollOffFactor", {
        get: function() {
            return this.panner.rolloffFactor
        },
        set: function(a) {
            this.panner.rolloffFactor = a
        }
    }), Object.defineProperty(m.SoundInstance3d.prototype, "distanceModel", {
        get: function() {
            return this.panner.distanceModel
        },
        set: function(a) {
            this.panner.distanceModel = a
        }
    });
    else if (we()) {
        var wk = new z;
        m.SoundInstance3d = function(a, b, c) {
            m.SoundInstance.call(this, a, b, c);
            c = c || {};
            this._position = new z;
            c.position && (this.position = c.position);
            this._velocity = new z;
            c.velocity && (this.velocity = c.velocity);
            this._maxDistance = void 0 !== c.maxDistance ? Number(c.maxDistance) : 1E4;
            this._refDistance = void 0 !== c.refDistance ? Number(c.refDistance) : 1;
            this._rollOffFactor = void 0 !== c.rollOffFactor ? Number(c.rollOffFactor) : 1;
            this._distanceModel = void 0 !==
                c.distanceModel ? c.distanceModel : "linear"
        };
        m.SoundInstance3d.prototype = Object.create(m.SoundInstance.prototype);
        m.SoundInstance3d.prototype.constructor = m.SoundInstance3d;
        Object.defineProperty(m.SoundInstance3d.prototype, "position", {
            get: function() {
                return this._position
            },
            set: function(a) {
                this._position.copy(a);
                if (this.source) {
                    var b = this._manager.listener.getPosition();
                    a = this.refDistance;
                    var c = this.maxDistance,
                        d = this.rollOffFactor,
                        e = this.distanceModel;
                    wk = wk.sub2(b, this._position);
                    b = wk.length();
                    if (b < a) a =
                        1;
                    else if (b > c) a = 0;
                    else {
                        var f = 0;
                        "linear" === e ? f = 1 - d * (b - a) / (c - a) : e === Kf ? f = a / (a + d * (b - a)) : "exponential" === e && (f = Math.pow(b / a, -d));
                        a = N.clamp(f, 0, 1)
                    }
                    this.source.volume = this.volume * a * this._manager.volume
                }
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype, "velocity", {
            get: function() {
                return this._velocity
            },
            set: function(a) {
                this._velocity.copy(a)
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype, "maxDistance", {
            get: function() {
                return this._maxDistance
            },
            set: function(a) {
                this._maxDistance = a
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype,
            "refDistance", {
                get: function() {
                    return this._refDistance
                },
                set: function(a) {
                    this._refDistance = a
                }
            });
        Object.defineProperty(m.SoundInstance3d.prototype, "rollOffFactor", {
            get: function() {
                return this._rollOffFactor
            },
            set: function(a) {
                this._rollOffFactor = a
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype, "distanceModel", {
            get: function() {
                return this._distanceModel
            },
            set: function(a) {
                this._distanceModel = a
            }
        })
    } else m.SoundInstance3d = function() {};
    var fb = {
        volume: 0,
        pitch: 0,
        loop: !1,
        startTime: 0,
        duration: 0,
        position: new z,
        maxDistance: 0,
        refDistance: 0,
        rollOffFactor: 0,
        distanceModel: 0,
        onPlay: null,
        onPause: null,
        onResume: null,
        onStop: null,
        onEnd: null
    };
    Qa.prototype = Object.create(M.prototype);
    Qa.prototype.constructor = Qa;
    Object.assign(Qa.prototype, {
        play: function() {
            this.overlap || this.stop();
            if (this.isLoaded || this._hasAsset()) {
                var a = this._createInstance();
                this.instances.push(a);
                if (this.isLoaded) a.play();
                else {
                    var b = function(c) {
                        var d = a._playWhenLoaded;
                        a.sound = c;
                        d && a.play()
                    };
                    this.off("load", b);
                    this.once("load", b);
                    this.load()
                }
                return a
            }
        },
        pause: function() {
            for (var a = !1, b = this.instances, c = 0, d = b.length; c < d; c++) b[c].pause() && (a = !0);
            return a
        },
        resume: function() {
            for (var a = !1, b = this.instances, c = 0, d = b.length; c < d; c++) b[c].resume() && (a = !0);
            return a
        },
        stop: function() {
            for (var a = !1, b = this.instances, c = b.length; c--;) b[c].stop(), a = !0;
            b.length = 0;
            return a
        },
        load: function() {
            if (this._hasAsset()) {
                var a = this._assets.get(this._asset);
                a ? (a.off("remove", this._onAssetRemoved, this), a.on("remove", this._onAssetRemoved, this), a.resource ? this.fire("load", a.resource) :
                    (a.off("load", this._onAssetLoad, this), a.once("load", this._onAssetLoad, this), this._assets.load(a))) : (this._assets.off("add:" + this._asset, this._onAssetAdd, this), this._assets.once("add:" + this._asset, this._onAssetAdd, this))
            }
        },
        setExternalNodes: function(a, b) {
            if (a) {
                if (b || (b = a), this._firstNode = a, this._lastNode = b, !this._overlap)
                    for (var c = this.instances, d = 0, e = c.length; d < e; d++) c[d].setExternalNodes(a, b)
            } else console.error("The firstNode must have a valid AudioNode")
        },
        clearExternalNodes: function() {
            this._lastNode =
                this._firstNode = null;
            if (!this._overlap)
                for (var a = this.instances, b = 0, c = a.length; b < c; b++) a[b].clearExternalNodes()
        },
        getExternalNodes: function() {
            return [this._firstNode, this._lastNode]
        },
        _hasAsset: function() {
            return null != this._asset
        },
        _createInstance: function() {
            var a = this._component;
            var b = null;
            if (this._hasAsset()) {
                var c = this._assets.get(this._asset);
                c && (b = c.resource)
            }
            fb.volume = this._volume * a.volume;
            fb.pitch = this._pitch * a.pitch;
            fb.loop = this._loop;
            fb.startTime = this._startTime;
            fb.duration = this._duration;
            fb.onPlay =
                this._onInstancePlayHandler;
            fb.onPause = this._onInstancePauseHandler;
            fb.onResume = this._onInstanceResumeHandler;
            fb.onStop = this._onInstanceStopHandler;
            fb.onEnd = this._onInstanceEndHandler;
            a.positional ? (fb.position.copy(a.entity.getPosition()), fb.maxDistance = a.maxDistance, fb.refDistance = a.refDistance, fb.rollOffFactor = a.rollOffFactor, fb.distanceModel = a.distanceModel, a = new m.SoundInstance3d(this._manager, b, fb)) : a = new m.SoundInstance(this._manager, b, fb);
            this._firstNode && a.setExternalNodes(this._firstNode,
                this._lastNode);
            return a
        },
        _onInstancePlay: function(a) {
            this.fire("play", a);
            this._component.fire("play", this, a)
        },
        _onInstancePause: function(a) {
            this.fire("pause", a);
            this._component.fire("pause", this, a)
        },
        _onInstanceResume: function(a) {
            this.fire("resume", a);
            this._component.fire("resume", this, a)
        },
        _onInstanceStop: function(a) {
            var b = this.instances.indexOf(a); - 1 !== b && this.instances.splice(b, 1);
            this.fire("stop", a);
            this._component.fire("stop", this, a)
        },
        _onInstanceEnd: function(a) {
            var b = this.instances.indexOf(a); -
            1 !== b && this.instances.splice(b, 1);
            this.fire("end", a);
            this._component.fire("end", this, a)
        },
        _onAssetAdd: function(a) {
            this.load()
        },
        _onAssetLoad: function(a) {
            this.load()
        },
        _onAssetRemoved: function(a) {
            a.off("remove", this._onAssetRemoved, this);
            this._assets.off("add:" + a.id, this._onAssetAdd, this);
            this.stop()
        },
        updatePosition: function(a) {
            for (var b = this.instances, c = 0, d = b.length; c < d; c++) b[c].position = a
        }
    });
    Object.defineProperty(Qa.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            this._volume =
                N.clamp(Number(a) || 0, 0, 1);
            if (!this._overlap) {
                a = this.instances;
                for (var b = 0, c = a.length; b < c; b++) a[b].volume = this._volume * this._component.volume
            }
        }
    });
    Object.defineProperty(Qa.prototype, "pitch", {
        get: function() {
            return this._pitch
        },
        set: function(a) {
            this._pitch = Math.max(Number(a) || 0, .01);
            if (!this._overlap) {
                a = this.instances;
                for (var b = 0, c = a.length; b < c; b++) a[b].pitch = this.pitch * this._component.pitch
            }
        }
    });
    Object.defineProperty(Qa.prototype, "loop", {
        get: function() {
            return this._loop
        },
        set: function(a) {
            this._loop = !!a;
            a = this.instances;
            for (var b = 0, c = a.length; b < c; b++) a[b].loop = this._loop
        }
    });
    Object.defineProperty(Qa.prototype, "autoPlay", {
        get: function() {
            return this._autoPlay
        },
        set: function(a) {
            this._autoPlay = !!a
        }
    });
    Object.defineProperty(Qa.prototype, "overlap", {
        get: function() {
            return this._overlap
        },
        set: function(a) {
            this._overlap = !!a
        }
    });
    Object.defineProperty(Qa.prototype, "startTime", {
        get: function() {
            return this._startTime
        },
        set: function(a) {
            this._startTime = Math.max(0, Number(a) || 0);
            if (!this._overlap) {
                a = this.instances;
                for (var b =
                        0, c = a.length; b < c; b++) a[b].startTime = this._startTime
            }
        }
    });
    Object.defineProperty(Qa.prototype, "duration", {
        get: function() {
            var a = 0;
            this._hasAsset() && (a = this._assets.get(this._asset), a = a.resource ? a.resource.duration : 0);
            return null != this._duration ? this._duration % (a || 1) : a
        },
        set: function(a) {
            this._duration = Math.max(0, Number(a) || 0) || null;
            if (!this._overlap) {
                a = this.instances;
                for (var b = 0, c = a.length; b < c; b++) a[b].duration = this._duration
            }
        }
    });
    Object.defineProperty(Qa.prototype, "asset", {
        get: function() {
            return this._asset
        },
        set: function(a) {
            var b = this._asset;
            b && (this._assets.off("add:" + b, this._onAssetAdd, this), (b = this._assets.get(b)) && b.off("remove", this._onAssetRemoved, this));
            this._asset = a;
            this._asset instanceof aa && (this._asset = this._asset.id);
            this._hasAsset() && this._component.enabled && this._component.entity.enabled && this.load()
        }
    });
    Object.defineProperty(Qa.prototype, "isLoaded", {
        get: function() {
            if (this._hasAsset()) {
                var a = this._assets.get(this._asset);
                if (a) return !!a.resource
            }
            return !1
        }
    });
    Object.defineProperty(Qa.prototype,
        "isPlaying", {
            get: function() {
                for (var a = this.instances, b = 0, c = a.length; b < c; b++)
                    if (a[b].isPlaying) return !0;
                return !1
            }
        });
    Object.defineProperty(Qa.prototype, "isPaused", {
        get: function() {
            var a = this.instances,
                b = a.length;
            if (0 === b) return !1;
            for (var c = 0; c < b; c++)
                if (!a[c].isPaused) return !1;
            return !0
        }
    });
    Object.defineProperty(Qa.prototype, "isStopped", {
        get: function() {
            for (var a = this.instances, b = 0, c = a.length; b < c; b++)
                if (!a[b].isStopped) return !1;
            return !0
        }
    });
    jc.prototype = Object.create(O.prototype);
    jc.prototype.constructor =
        jc;
    Hl("pitch", "_pitch");
    Hl("volume", "_volume");
    ah("refDistance", "_refDistance");
    ah("maxDistance", "_maxDistance");
    ah("rollOffFactor", "_rollOffFactor");
    ah("distanceModel", "_distanceModel");
    Object.defineProperty(jc.prototype, "positional", {
        get: function() {
            return this._positional
        },
        set: function(a) {
            this._positional = a;
            a = this._slots;
            for (var b in a) {
                var c = a[b];
                if (!c.overlap)
                    for (var d = c.instances, e = 0, f = d.length; e < f; e++) {
                        var g = d[e].isPlaying || d[e].isSuspended,
                            k = d[e].currentTime;
                        g && d[e].stop();
                        d[e] = c._createInstance();
                        g && (d[e].play(), d[e].currentTime = k)
                    }
            }
        }
    });
    Object.defineProperty(jc.prototype, "slots", {
        get: function() {
            return this._slots
        },
        set: function(a) {
            var b, c = this._slots;
            if (c)
                for (b in c) c[b].stop();
            c = {};
            for (b in a) a[b] instanceof Qa ? c[a[b].name] = a[b] : a[b].name && (c[a[b].name] = new Qa(this, a[b].name, a[b]));
            this._slots = c;
            if (this.enabled && this.entity.enabled) this.onEnable()
        }
    });
    Object.assign(jc.prototype, {
        onEnable: function() {
            if (!this.system._inTools) {
                var a = this._slots,
                    b = this._playingBeforeDisable,
                    c;
                for (c in a) {
                    var d =
                        a[c];
                    d.autoPlay && d.isStopped ? d.play() : b[c] ? d.resume() : d.isLoaded || d.load()
                }
            }
        },
        onDisable: function() {
            var a = this._slots,
                b = {},
                c;
            for (c in a) !a[c].overlap && a[c].isPlaying && (a[c].pause(), b[c] = !0);
            this._playingBeforeDisable = b
        },
        onRemove: function() {
            this.off()
        },
        addSlot: function(a, b) {
            var c = this._slots;
            if (c[a]) return null;
            b = new Qa(this, a, b);
            c[a] = b;
            b.autoPlay && this.enabled && this.entity.enabled && b.play();
            return b
        },
        removeSlot: function(a) {
            var b = this._slots;
            b[a] && (b[a].stop(), delete b[a])
        },
        slot: function(a) {
            return this._slots[a]
        },
        play: function(a) {
            return this.enabled && this.entity.enabled ? (a = this._slots[a]) ? a.play() : null : null
        },
        pause: function(a) {
            var b = this._slots;
            if (a)(a = b[a]) && a.pause();
            else
                for (var c in b) b[c].pause()
        },
        resume: function(a) {
            var b = this._slots;
            if (a)(a = b[a]) && a.isPaused && a.resume();
            else
                for (var c in b) b[c].resume()
        },
        stop: function(a) {
            var b = this._slots;
            if (a)(a = b[a]) && a.stop();
            else
                for (var c in b) b[c].stop()
        }
    });
    var hn = ["enabled"],
        pd = function(a, b) {
            H.call(this, a);
            this.id = "sound";
            this.ComponentType = jc;
            this.DataType = Io;
            this.schema = hn;
            this.manager = b;
            H.bind("update", this.onUpdate, this);
            this.on("beforeremove", this.onBeforeRemove, this)
        };
    pd.prototype = Object.create(H.prototype);
    pd.prototype.constructor = pd;
    O._buildAccessors(jc.prototype, hn);
    Object.assign(pd.prototype, {
        initializeComponentData: function(a, b, c) {
            c = "volume pitch positional refDistance maxDistance rollOffFactor distanceModel slots".split(" ");
            for (var d = 0; d < c.length; d++) b.hasOwnProperty(c[d]) && (a[c[d]] = b[c[d]]);
            H.prototype.initializeComponentData.call(this, a,
                b, ["enabled"])
        },
        cloneComponent: function(a, b) {
            a = a.sound;
            var c = a.slots,
                d = {},
                e;
            for (e in c) {
                var f = c[e];
                d[e] = {
                    name: f.name,
                    volume: f.volume,
                    pitch: f.pitch,
                    loop: f.loop,
                    duration: f.duration,
                    startTime: f.startTime,
                    overlap: f.overlap,
                    autoPlay: f.autoPlay,
                    asset: f.asset
                }
            }
            return this.addComponent(b, {
                distanceModel: a.distanceModel,
                enabled: a.enabled,
                maxDistance: a.maxDistance,
                pitch: a.pitch,
                positional: a.positional,
                refDistance: a.refDistance,
                rollOffFactor: a.rollOffFactor,
                slots: d,
                volume: a.volume
            })
        },
        onUpdate: function(a) {
            a = this.store;
            for (var b in a)
                if (a.hasOwnProperty(b)) {
                    var c = a[b].entity;
                    if (c.enabled) {
                        var d = c.sound;
                        if (d.enabled && d.positional) {
                            c = c.getPosition();
                            d = d.slots;
                            for (var e in d) d[e].updatePosition(c)
                        }
                    }
                }
        },
        onBeforeRemove: function(a, b) {
            a = b.slots;
            for (var c in a) a[c].overlap || a[c].stop();
            b.onRemove()
        }
    });
    Object.defineProperty(pd.prototype, "volume", {
        get: function() {
            return this.manager.volume
        },
        set: function(a) {
            this.manager.volume = a
        }
    });
    Object.defineProperty(pd.prototype, "context", {
        get: function() {
            return fd() ? this.manager.context :
                null
        }
    });
    wb.prototype = Object.create(M.prototype);
    wb.prototype.constructor = wb;
    Object.assign(wb.prototype, {
        _onSpriteAssetAdded: function(a) {
            this._component.system.app.assets.off("add:" + a.id, this._onSpriteAssetAdded, this);
            this._spriteAsset === a.id && this._bindSpriteAsset(a)
        },
        _bindSpriteAsset: function(a) {
            a.on("load", this._onSpriteAssetLoad, this);
            a.on("remove", this._onSpriteAssetRemove, this);
            a.resource ? this._onSpriteAssetLoad(a) : this._component.system.app.assets.load(a)
        },
        _unbindSpriteAsset: function(a) {
            a.off("load",
                this._onSpriteAssetLoad, this);
            a.off("remove", this._onSpriteAssetRemove, this);
            a.resource && a.resource.atlas && this._component.system.app.assets.off("load:" + a.data.textureAtlasAsset, this._onTextureAtlasLoad, this)
        },
        _onSpriteAssetLoad: function(a) {
            if (a.resource)
                if (a.resource.atlas) this.sprite = a.resource;
                else {
                    a = a.data.textureAtlasAsset;
                    var b = this._component.system.app.assets;
                    b.off("load:" + a, this._onTextureAtlasLoad, this);
                    b.once("load:" + a, this._onTextureAtlasLoad, this)
                }
            else this.sprite = null
        },
        _onTextureAtlasLoad: function(a) {
            a =
                this._spriteAsset;
            a instanceof aa ? this._onSpriteAssetLoad(a) : this._onSpriteAssetLoad(this._component.system.app.assets.get(a))
        },
        _onSpriteAssetRemove: function(a) {
            this.sprite = null
        },
        _onSpriteMeshesChange: function() {
            this._component.currentClip === this && this._component._showFrame(this.frame)
        },
        _onSpritePpuChanged: function() {
            this._component.currentClip === this && 0 !== this.sprite.renderMode && this._component._showFrame(this.frame)
        },
        _update: function(a) {
            if (0 !== this.fps && this._playing && !this._paused && this._sprite) {
                var b =
                    this._time + a * this._component.speed * (0 > this.fps ? -1 : 1),
                    c = this.duration;
                a = b > c || 0 > b;
                this._setTime(b);
                b = this._sprite ? Math.floor(this._sprite.frameKeys.length * this._time / c) : 0;
                b !== this._frame && this._setFrame(b);
                a && (this.loop ? (this.fire("loop"), this._component.fire("loop", this)) : (this._paused = this._playing = !1, this.fire("end"), this._component.fire("end", this)))
            }
        },
        _setTime: function(a) {
            this._time = a;
            a = this.duration;
            0 > this._time ? this._time = this.loop ? this._time % a + a : 0 : this._time > a && (this._time = this.loop ? this._time %
                a : a)
        },
        _setFrame: function(a) {
            this._frame = this._sprite ? N.clamp(a, 0, this._sprite.frameKeys.length - 1) : a;
            this._component.currentClip === this && this._component._showFrame(this._frame)
        },
        _destroy: function() {
            this._sprite && (this.sprite = null);
            this._spriteAsset && (this.spriteAsset = null)
        },
        play: function() {
            this._playing || (this._playing = !0, this._paused = !1, this.frame = 0, this.fire("play"), this._component.fire("play", this))
        },
        pause: function() {
            this._playing && !this._paused && (this._paused = !0, this.fire("pause"), this._component.fire("pause",
                this))
        },
        resume: function() {
            this._paused && (this._paused = !1, this.fire("resume"), this._component.fire("resume", this))
        },
        stop: function() {
            this._playing && (this._paused = this._playing = !1, this.frame = this._time = 0, this.fire("stop"), this._component.fire("stop", this))
        }
    });
    Object.defineProperty(wb.prototype, "spriteAsset", {
        get: function() {
            return this._spriteAsset
        },
        set: function(a) {
            var b = this._component.system.app.assets,
                c = a;
            a instanceof aa && (c = a.id);
            this._spriteAsset !== c && (this._spriteAsset && (a = b.get(this._spriteAsset)) &&
                this._unbindSpriteAsset(a), (this._spriteAsset = c) ? (c = b.get(this._spriteAsset)) ? this._bindSpriteAsset(c) : (this.sprite = null, b.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this)) : this.sprite = null)
        }
    });
    Object.defineProperty(wb.prototype, "sprite", {
        get: function() {
            return this._sprite
        },
        set: function(a) {
            this._sprite && (this._sprite.off("set:meshes", this._onSpriteMeshesChange, this), this._sprite.off("set:pixelsPerUnit", this._onSpritePpuChanged, this), this._sprite.off("set:atlas", this._onSpriteMeshesChange,
                this), this._sprite.atlas && this._sprite.atlas.off("set:texture", this._onSpriteMeshesChange, this));
            if (this._sprite = a)
                if (this._sprite.on("set:meshes", this._onSpriteMeshesChange, this), this._sprite.on("set:pixelsPerUnit", this._onSpritePpuChanged, this), this._sprite.on("set:atlas", this._onSpriteMeshesChange, this), this._sprite.atlas) this._sprite.atlas.on("set:texture", this._onSpriteMeshesChange, this);
            if (this._component.currentClip === this) {
                var b;
                if (a && a.atlas) {
                    if (a.atlas.texture) {
                        if (b = this._component._meshInstance) b.setParameter("texture_emissiveMap",
                            a.atlas.texture), b.setParameter("texture_opacityMap", a.atlas.texture);
                        this._component.enabled && this._component.entity.enabled && this._component._showModel()
                    }
                    this.time && this.fps ? this.time = this.time : this.frame = this.frame
                } else {
                    if (b = this._component._meshInstance) b.deleteParameter("texture_emissiveMap"), b.deleteParameter("texture_opacityMap");
                    this._component._hideModel()
                }
            }
        }
    });
    Object.defineProperty(wb.prototype, "frame", {
        get: function() {
            return this._frame
        },
        set: function(a) {
            this._setFrame(a);
            this._setTime(this._frame /
                (this.fps || Number.MIN_VALUE))
        }
    });
    Object.defineProperty(wb.prototype, "isPlaying", {
        get: function() {
            return this._playing
        }
    });
    Object.defineProperty(wb.prototype, "isPaused", {
        get: function() {
            return this._paused
        }
    });
    Object.defineProperty(wb.prototype, "duration", {
        get: function() {
            return this._sprite ? this._sprite.frameKeys.length / Math.abs(this.fps || Number.MIN_VALUE) : 0
        }
    });
    Object.defineProperty(wb.prototype, "time", {
        get: function() {
            return this._time
        },
        set: function(a) {
            this._setTime(a);
            this.frame = this._sprite ? Math.min(this._sprite.frameKeys.length -
                1, Math.floor(this._time * Math.abs(this.fps))) : 0
        }
    });
    var Ba = function(a, b) {
        O.call(this, a, b);
        this._type = "simple";
        this._material = a.defaultMaterial;
        this._color = new L(1, 1, 1, 1);
        this._colorUniform = new Float32Array(3);
        this._speed = 1;
        this._flipY = this._flipX = !1;
        this._height = this._width = 1;
        this._drawOrder = 0;
        this._layers = [0];
        this._outerScale = new P(1, 1);
        this._outerScaleUniform = new Float32Array(2);
        this._innerOffset = new X;
        this._innerOffsetUniform = new Float32Array(4);
        this._atlasRect = new X;
        this._atlasRectUniform = new Float32Array(4);
        this._batchGroupId = -1;
        this._batchGroup = null;
        this._node = new Z;
        this._model = new tb;
        this._model.graph = this._node;
        this._meshInstance = null;
        b.addChild(this._model.graph);
        this._model._entity = b;
        this._updateAabbFunc = this._updateAabb.bind(this);
        this._addedModel = !1;
        this._autoPlayClip = null;
        this._clips = {};
        this._currentClip = this._defaultClip = new wb(this, {
            name: this.entity.name,
            fps: 0,
            loop: !1,
            spriteAsset: null
        })
    };
    Ba.prototype = Object.create(O.prototype);
    Ba.prototype.constructor = Ba;
    Object.assign(Ba.prototype, {
        onEnable: function() {
            var a =
                this.system.app,
                b = a.scene;
            b.on("set:layers", this._onLayersChanged, this);
            b.layers && (b.layers.on("add", this._onLayerAdded, this), b.layers.on("remove", this._onLayerRemoved, this));
            this._showModel();
            this._autoPlayClip && this._tryAutoPlay();
            0 <= this._batchGroupId && a.batcher.insert(bb.SPRITE, this._batchGroupId, this.entity)
        },
        onDisable: function() {
            var a = this.system.app,
                b = a.scene;
            b.off("set:layers", this._onLayersChanged, this);
            b.layers && (b.layers.off("add", this._onLayerAdded, this), b.layers.off("remove", this._onLayerRemoved,
                this));
            this.stop();
            this._hideModel();
            0 <= this._batchGroupId && a.batcher.remove(bb.SPRITE, this._batchGroupId, this.entity)
        },
        onDestroy: function() {
            this._currentClip = null;
            this._defaultClip && (this._defaultClip._destroy(), this._defaultClip = null);
            for (var a in this._clips) this._clips[a]._destroy();
            this._clips = null;
            this._hideModel();
            this._model = null;
            this._node && (this._node.parent && this._node.parent.removeChild(this._node), this._node = null);
            this._meshInstance && (this._meshInstance.material = null, this._meshInstance =
                this._meshInstance.mesh = null)
        },
        _showModel: function() {
            if (!this._addedModel && this._meshInstance) {
                var a, b = [this._meshInstance];
                var c = 0;
                for (a = this._layers.length; c < a; c++) {
                    var d = this.system.app.scene.layers.getLayerById(this._layers[c]);
                    d && d.addMeshInstances(b)
                }
                this._addedModel = !0
            }
        },
        _hideModel: function() {
            if (this._addedModel && this._meshInstance) {
                var a, b = [this._meshInstance];
                var c = 0;
                for (a = this._layers.length; c < a; c++) {
                    var d = this.system.app.scene.layers.getLayerById(this._layers[c]);
                    d && d.removeMeshInstances(b)
                }
                this._addedModel = !1
            }
        },
        _showFrame: function(a) {
            if (this.sprite) {
                var b = this.sprite.meshes[a];
                if (b) {
                    var c = 1 === this.sprite.renderMode ? this.system.default9SlicedMaterialSlicedMode : 2 === this.sprite.renderMode ? this.system.default9SlicedMaterialTiledMode : this.system.defaultMaterial;
                    this._meshInstance || (this._meshInstance = new va(this._node, b, this._material), this._meshInstance.castShadow = !1, this._meshInstance.receiveShadow = !1, this._meshInstance.drawOrder = this._drawOrder, this._model.meshInstances.push(this._meshInstance), this._colorUniform[0] =
                        this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b, this._meshInstance.setParameter("material_emissive", this._colorUniform), this._meshInstance.setParameter("material_opacity", this._color.a), this.enabled && this.entity.enabled && this._showModel());
                    this._meshInstance.material !== c && (this._meshInstance.material = c);
                    this._meshInstance.mesh !== b && (this._meshInstance.mesh = b, this._meshInstance.visible = !0, this._meshInstance._aabbVer = -1);
                    this.sprite.atlas && this.sprite.atlas.texture ?
                        (this._meshInstance.setParameter("texture_emissiveMap", this.sprite.atlas.texture), this._meshInstance.setParameter("texture_opacityMap", this.sprite.atlas.texture)) : (this._meshInstance.deleteParameter("texture_emissiveMap"), this._meshInstance.deleteParameter("texture_opacityMap"));
                    !this.sprite.atlas || 1 !== this.sprite.renderMode && 2 !== this.sprite.renderMode ? this._meshInstance._updateAabbFunc = null : (this._meshInstance._updateAabbFunc = this._updateAabbFunc, (a = this.sprite.atlas.frames[this.sprite.frameKeys[a]]) ?
                        (b = 2 / a.rect.z, c = 2 / a.rect.w, this._innerOffset.set(a.border.x * b, a.border.y * c, a.border.z * b, a.border.w * c), b = this.sprite.atlas.texture, this._atlasRect.set(a.rect.x / b.width, a.rect.y / b.height, a.rect.z / b.width, a.rect.w / b.height)) : this._innerOffset.set(0, 0, 0, 0), this._innerOffsetUniform[0] = this._innerOffset.x, this._innerOffsetUniform[1] = this._innerOffset.y, this._innerOffsetUniform[2] = this._innerOffset.z, this._innerOffsetUniform[3] = this._innerOffset.w, this._meshInstance.setParameter("innerOffset", this._innerOffsetUniform),
                        this._atlasRectUniform[0] = this._atlasRect.x, this._atlasRectUniform[1] = this._atlasRect.y, this._atlasRectUniform[2] = this._atlasRect.z, this._atlasRectUniform[3] = this._atlasRect.w, this._meshInstance.setParameter("atlasRect", this._atlasRectUniform));
                    this._updateTransform()
                } else this._meshInstance && (this._meshInstance.mesh = null, this._meshInstance.visible = !1)
            }
        },
        _updateTransform: function() {
            var a = this.flipX ? -1 : 1,
                b = this.flipY ? -1 : 1,
                c = 0,
                d = 0;
            if (this.sprite && (1 === this.sprite.renderMode || 2 === this.sprite.renderMode)) {
                var e =
                    1,
                    f = 1;
                if (this.sprite.atlas) {
                    var g = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
                    g && (e = g.rect.z, f = g.rect.w, c = (.5 - g.pivot.x) * this._width, d = (.5 - g.pivot.y) * this._height)
                }
                e /= this.sprite.pixelsPerUnit;
                f /= this.sprite.pixelsPerUnit;
                this._outerScale.set(Math.max(this._width, this._innerOffset.x * e), Math.max(this._height, this._innerOffset.y * f));
                b *= f;
                this._outerScale.x /= e;
                this._outerScale.y /= f;
                a = a * e * N.clamp(this._width / (this._innerOffset.x * e), 1E-4, 1);
                b *= N.clamp(this._height / (this._innerOffset.y *
                    f), 1E-4, 1);
                this._meshInstance && (this._outerScaleUniform[0] = this._outerScale.x, this._outerScaleUniform[1] = this._outerScale.y, this._meshInstance.setParameter("outerScale", this._outerScaleUniform))
            }
            this._node.setLocalScale(a, b, 1);
            this._node.setLocalPosition(c, d, 0)
        },
        _updateAabb: function(a) {
            a.center.set(0, 0, 0);
            a.halfExtents.set(.5 * this._outerScale.x, .5 * this._outerScale.y, .001);
            a.setFromTransformedAabb(a, this._node.getWorldTransform());
            return a
        },
        _tryAutoPlay: function() {
            if (this._autoPlayClip && "animated" ===
                this.type) {
                var a = this._clips[this._autoPlayClip];
                !a || a.isPlaying || this._currentClip && this._currentClip.isPlaying || this.enabled && this.entity.enabled && this.play(a.name)
            }
        },
        _onLayersChanged: function(a, b) {
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this);
            this.enabled && this.entity.enabled && this._showModel()
        },
        _onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || this._addedModel && this.enabled && this.entity.enabled &&
                this._meshInstance && a.addMeshInstances([this._meshInstance])
        },
        _onLayerRemoved: function(a) {
            this._meshInstance && (0 > this.layers.indexOf(a.id) || a.removeMeshInstances([this._meshInstance]))
        },
        removeModelFromLayers: function() {
            for (var a, b = 0; b < this.layers.length; b++)(a = this.system.app.scene.layers.getLayerById(this.layers[b])) && a.removeMeshInstances([this._meshInstance])
        },
        addClip: function(a) {
            var b = new wb(this, {
                name: a.name,
                fps: a.fps,
                loop: a.loop,
                spriteAsset: a.spriteAsset
            });
            this._clips[a.name] = b;
            b.name && b.name ===
                this._autoPlayClip && this._tryAutoPlay();
            return b
        },
        removeClip: function(a) {
            delete this._clips[a]
        },
        clip: function(a) {
            return this._clips[a]
        },
        play: function(a) {
            a = this._clips[a];
            var b = this._currentClip;
            b && b !== a && (b._playing = !1);
            if (this._currentClip = a) this._currentClip = a, this._currentClip.play();
            return a
        },
        pause: function() {
            this._currentClip !== this._defaultClip && this._currentClip.isPlaying && this._currentClip.pause()
        },
        resume: function() {
            this._currentClip !== this._defaultClip && this._currentClip.isPaused && this._currentClip.resume()
        },
        stop: function() {
            this._currentClip !== this._defaultClip && this._currentClip.stop()
        }
    });
    Object.defineProperty(Ba.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            this._type !== a && (this._type = a, "simple" === this._type ? (this.stop(), this._currentClip = this._defaultClip, this.enabled && this.entity.enabled && (this._currentClip.frame = this.frame, this._currentClip.sprite ? this._showModel() : this._hideModel())) : "animated" === this._type && (this.stop(), this._autoPlayClip && this._tryAutoPlay(), this._currentClip &&
                this._currentClip.isPlaying && this.enabled && this.entity.enabled ? this._showModel() : this._hideModel()))
        }
    });
    Object.defineProperty(Ba.prototype, "frame", {
        get: function() {
            return this._currentClip.frame
        },
        set: function(a) {
            this._currentClip.frame = a
        }
    });
    Object.defineProperty(Ba.prototype, "spriteAsset", {
        get: function() {
            return this._defaultClip._spriteAsset
        },
        set: function(a) {
            this._defaultClip.spriteAsset = a
        }
    });
    Object.defineProperty(Ba.prototype, "sprite", {
        get: function() {
            return this._currentClip.sprite
        },
        set: function(a) {
            this._currentClip.sprite =
                a
        }
    });
    Object.defineProperty(Ba.prototype, "material", {
        get: function() {
            return this._material
        },
        set: function(a) {
            this._material = a;
            this._meshInstance && (this._meshInstance.material = a)
        }
    });
    Object.defineProperty(Ba.prototype, "color", {
        get: function() {
            return this._color
        },
        set: function(a) {
            this._color.r = a.r;
            this._color.g = a.g;
            this._color.b = a.b;
            this._meshInstance && (this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b, this._meshInstance.setParameter("material_emissive",
                this._colorUniform))
        }
    });
    Object.defineProperty(Ba.prototype, "opacity", {
        get: function() {
            return this._color.a
        },
        set: function(a) {
            this._color.a = a;
            this._meshInstance && this._meshInstance.setParameter("material_opacity", a)
        }
    });
    Object.defineProperty(Ba.prototype, "clips", {
        get: function() {
            return this._clips
        },
        set: function(a) {
            var b, c;
            if (a) {
                for (b in this._clips) {
                    var d = !1;
                    for (c in a)
                        if (a[c].name === b) {
                            d = !0;
                            this._clips[b].fps = a[c].fps;
                            this._clips[b].loop = a[c].loop;
                            a[c].hasOwnProperty("sprite") ? this._clips[b].sprite = a[c].sprite :
                                a[c].hasOwnProperty("spriteAsset") && (this._clips[b].spriteAsset = a[c].spriteAsset);
                            break
                        }
                    d || this.removeClip(b)
                }
                for (c in a) this._clips[a[c].name] || this.addClip(a[c]);
                this._autoPlayClip && this._tryAutoPlay();
                this._currentClip && this._currentClip.sprite || this._hideModel()
            } else
                for (b in this._clips) this.removeClip(b)
        }
    });
    Object.defineProperty(Ba.prototype, "currentClip", {
        get: function() {
            return this._currentClip
        }
    });
    Object.defineProperty(Ba.prototype, "speed", {
        get: function() {
            return this._speed
        },
        set: function(a) {
            this._speed =
                a
        }
    });
    Object.defineProperty(Ba.prototype, "flipX", {
        get: function() {
            return this._flipX
        },
        set: function(a) {
            this._flipX !== a && (this._flipX = a, this._updateTransform())
        }
    });
    Object.defineProperty(Ba.prototype, "flipY", {
        get: function() {
            return this._flipY
        },
        set: function(a) {
            this._flipY !== a && (this._flipY = a, this._updateTransform())
        }
    });
    Object.defineProperty(Ba.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(a) {
            a !== this._width && (this._width = a, this._outerScale.x = this._width, !this.sprite || 2 !== this.sprite.renderMode &&
                1 !== this.sprite.renderMode || this._updateTransform())
        }
    });
    Object.defineProperty(Ba.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(a) {
            a !== this._height && (this._height = a, this._outerScale.y = this.height, !this.sprite || 2 !== this.sprite.renderMode && 1 !== this.sprite.renderMode || this._updateTransform())
        }
    });
    Object.defineProperty(Ba.prototype, "batchGroupId", {
        get: function() {
            return this._batchGroupId
        },
        set: function(a) {
            if (this._batchGroupId !== a) {
                var b = this._batchGroupId;
                this._batchGroupId = a;
                this.entity.enabled &&
                    0 <= b && this.system.app.batcher.remove(bb.SPRITE, b, this.entity);
                this.entity.enabled && 0 <= a ? this.system.app.batcher.insert(bb.SPRITE, a, this.entity) : 0 <= b && this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled && this._showModel()
            }
        }
    });
    Object.defineProperty(Ba.prototype, "autoPlayClip", {
        get: function() {
            return this._autoPlayClip
        },
        set: function(a) {
            this._autoPlayClip = a instanceof wb ? a.name : a;
            this._tryAutoPlay()
        }
    });
    Object.defineProperty(Ba.prototype, "drawOrder", {
        get: function() {
            return this._drawOrder
        },
        set: function(a) {
            this._drawOrder = a;
            this._meshInstance && (this._meshInstance.drawOrder = a)
        }
    });
    Object.defineProperty(Ba.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            this._addedModel && this._hideModel();
            this._layers = a;
            this._meshInstance && this.enabled && this.entity.enabled && this._showModel()
        }
    });
    Object.defineProperty(Ba.prototype, "aabb", {
        get: function() {
            return this._meshInstance ? this._meshInstance.aabb : null
        }
    });
    var Il = ["enabled"];
    ae.prototype = Object.create(H.prototype);
    ae.prototype.constructor =
        ae;
    O._buildAccessors(Ba.prototype, Il);
    Object.defineProperties(ae.prototype, {
        defaultMaterial: {
            get: function() {
                if (!this._defaultMaterial) {
                    var a = new V(this.app.graphicsDevice, {
                            width: 1,
                            height: 1,
                            format: 7
                        }),
                        b = new Uint8Array(a.lock());
                    b[0] = b[1] = b[2] = b[3] = 255;
                    a.name = "sprite";
                    a.unlock();
                    b = new ma;
                    b.diffuse.set(0, 0, 0);
                    b.emissive.set(.5, .5, .5);
                    b.emissiveMap = a;
                    b.emissiveMapTint = !0;
                    b.opacityMap = a;
                    b.opacityMapChannel = "a";
                    b.opacityTint = !0;
                    b.opacity = 0;
                    b.useLighting = !1;
                    b.useGammaTonemap = !1;
                    b.useFog = !1;
                    b.useSkybox = !1;
                    b.blendType = 4;
                    b.depthWrite = !1;
                    b.pixelSnap = !1;
                    b.cull = 0;
                    b.update();
                    this._defaultTexture = a;
                    this._defaultMaterial = b
                }
                return this._defaultMaterial
            },
            set: function(a) {
                this._defaultMaterial = a
            }
        },
        default9SlicedMaterialSlicedMode: {
            get: function() {
                if (!this._default9SlicedMaterialSlicedMode) {
                    var a = this.defaultMaterial.clone();
                    a.nineSlicedMode = 1;
                    a.update();
                    this._default9SlicedMaterialSlicedMode = a
                }
                return this._default9SlicedMaterialSlicedMode
            },
            set: function(a) {
                this._default9SlicedMaterialSlicedMode = a
            }
        },
        default9SlicedMaterialTiledMode: {
            get: function() {
                if (!this._default9SlicedMaterialTiledMode) {
                    var a =
                        this.defaultMaterial.clone();
                    a.nineSlicedMode = 2;
                    a.update();
                    this._default9SlicedMaterialTiledMode = a
                }
                return this._default9SlicedMaterialTiledMode
            },
            set: function(a) {
                this._default9SlicedMaterialTiledMode = a
            }
        }
    });
    Object.assign(ae.prototype, {
        destroy: function() {
            this._defaultTexture && (this._defaultTexture.destroy(), this._defaultTexture = null)
        },
        initializeComponentData: function(a, b, c) {
            void 0 !== b.enabled && (a.enabled = b.enabled);
            a.type = b.type;
            b.layers && Array.isArray(b.layers) && (a.layers = b.layers.slice(0));
            void 0 !==
                b.drawOrder && (a.drawOrder = b.drawOrder);
            void 0 !== b.color && (b.color instanceof L ? a.color.set(b.color.r, b.color.g, b.color.b, void 0 !== b.opacity ? b.opacity : 1) : a.color.set(b.color[0], b.color[1], b.color[2], void 0 !== b.opacity ? b.opacity : 1), a.color = a.color);
            void 0 !== b.opacity && (a.opacity = b.opacity);
            void 0 !== b.flipX && (a.flipX = b.flipX);
            void 0 !== b.flipY && (a.flipY = b.flipY);
            void 0 !== b.width && (a.width = b.width);
            void 0 !== b.height && (a.height = b.height);
            void 0 !== b.spriteAsset && (a.spriteAsset = b.spriteAsset);
            b.sprite && (a.sprite =
                b.sprite);
            void 0 !== b.frame && (a.frame = b.frame);
            if (b.clips)
                for (var d in b.clips) a.addClip(b.clips[d]);
            void 0 !== b.speed && (a.speed = b.speed);
            b.autoPlayClip && (a.autoPlayClip = b.autoPlayClip);
            a.batchGroupId = void 0 === b.batchGroupId || null === b.batchGroupId ? -1 : b.batchGroupId;
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            a = a.sprite;
            return this.addComponent(b, {
                enabled: a.enabled,
                type: a.type,
                spriteAsset: a.spriteAsset,
                sprite: a.sprite,
                frame: a.frame,
                color: a.color.clone(),
                opacity: a.opacity,
                flipX: a.flipX,
                flipY: a.flipY,
                speed: a.speed,
                clips: a.clips,
                autoPlayClip: a.autoPlayClip,
                batchGroupId: a.batchGroupId,
                drawOrder: a.drawOrder,
                layers: a.layers.slice(0)
            })
        },
        onUpdate: function(a) {
            var b = this.store,
                c;
            for (c in b)
                if (b.hasOwnProperty(c)) {
                    var d = b[c];
                    d.data.enabled && d.entity.enabled && (d = d.entity.sprite, d._currentClip && d._currentClip._update(a))
                }
        },
        onBeforeRemove: function(a, b) {
            b.onDestroy()
        }
    });
    od.prototype = Object.create(O.prototype);
    od.prototype.constructor = od;
    Object.assign(od.prototype, {
        onEnable: function() {
            this._checkState()
        },
        onDisable: function() {
            this._checkState()
        },
        _onSetEnabled: function(a, b, c) {
            this._checkState()
        },
        _checkState: function() {
            var a = this.enabled && this.entity.enabled;
            a !== this._oldState && (this._oldState = a, this.fire("enable"), this.fire("state", this.enabled))
        },
        _onBeforeRemove: function() {
            this.fire("remove")
        }
    });
    Object.defineProperty(od.prototype, "size", {
        set: function(a) {
            a instanceof z ? this._size.copy(a) : a instanceof Array && 3 <= a.length && this.size.set(a[0], a[1], a[2])
        },
        get: function() {
            return this._size
        }
    });
    var jn = ["enabled"],
        Se = function(a) {
            H.call(this, a);
            this.id = "zone";
            this.ComponentType = od;
            this.DataType = Ko;
            this.schema = jn;
            this.on("beforeremove", this._onBeforeRemove, this)
        };
    Se.prototype = Object.create(H.prototype);
    Se.prototype.constructor = Se;
    O._buildAccessors(od.prototype, jn);
    Object.assign(Se.prototype, {
        initializeComponentData: function(a, b, c) {
            a.enabled = b.hasOwnProperty("enabled") ? !!b.enabled : !0;
            b.size && (b.size instanceof z ? a.size.copy(b.size) : b.size instanceof Array && 3 <= b.size.length && a.size.set(b.size[0], b.size[1], b.size[2]))
        },
        cloneComponent: function(a, b) {
            return this.addComponent(b, {
                size: a.zone.size
            })
        },
        _onBeforeRemove: function(a, b) {
            b._onBeforeRemove()
        }
    });
    kc.prototype.destroy = function() {
        this._app = null
    };
    kc.prototype.list = function() {
        return this._list
    };
    kc.prototype.add = function(a, b) {
        if (this._index.hasOwnProperty(a)) return !1;
        a = new Jl(a, b);
        b = this._list.push(a);
        this._index[a.name] = b - 1;
        this._urlIndex[a.url] = b - 1;
        return !0
    };
    kc.prototype.find = function(a) {
        return this._index.hasOwnProperty(a) ? this._list[this._index[a]] : null
    };
    kc.prototype.findByUrl =
        function(a) {
            return this._urlIndex.hasOwnProperty(a) ? this._list[this._urlIndex[a]] : null
        };
    kc.prototype.remove = function(a) {
        if (this._index.hasOwnProperty(a)) {
            var b = this._index[a],
                c = this._list[b];
            delete this._urlIndex[c.url];
            delete this._index[a];
            this._list.splice(b, 1);
            for (b = 0; b < this._list.length; b++) c = this._list[b], this._index[c.name] = b, this._urlIndex[c.url] = b
        }
    };
    kc.prototype.loadSceneHierarchy = function(a, b) {
        var c = this,
            d = this._app.loader.getHandler("hierarchy");
        this._app.assets && this._app.assets.prefix &&
            !hf.test(a) && (a = ca.join(this._app.assets.prefix, a));
        d.load(a, function(e, f) {
            e ? b && b(e) : c._app._preloadScripts(f, function() {
                c._app.systems.script.preloading = !0;
                var g = d.open(a, f);
                c._app.systems.script.preloading = !1;
                c._app.loader.clearCache(a, "hierarchy");
                c._app.root.addChild(g);
                H.initialize(g);
                H.postInitialize(g);
                b && b(e, g)
            })
        })
    };
    kc.prototype.loadSceneSettings = function(a, b) {
        var c = this;
        this._app.assets && this._app.assets.prefix && !hf.test(a) && (a = ca.join(this._app.assets.prefix, a));
        this._app.loader.load(a,
            "scenesettings",
            function(d, e) {
                d ? b && b(d) : (c._app.applySceneSettings(e), b && b(null))
            })
    };
    kc.prototype.loadScene = function(a, b) {
        var c = this,
            d = this._app.loader.getHandler("scene");
        this._app.assets && this._app.assets.prefix && !hf.test(a) && (a = ca.join(this._app.assets.prefix, a));
        d.load(a, function(e, f) {
            e ? b && b(e) : c._app._preloadScripts(f, function() {
                c._app.systems.script.preloading = !0;
                var g = d.open(a, f);
                c._app.systems.script.preloading = !1;
                c._app.loader.clearCache(a, "scene");
                c._app.loader.patch({
                        resource: g,
                        type: "scene"
                    },
                    c._app.assets);
                c._app.root.addChild(g.root);
                c._app.systems.rigidbody && "undefined" !== typeof Ammo && c._app.systems.rigidbody.gravity.set(g._gravity.x, g._gravity.y, g._gravity.z);
                b && b(null, g)
            })
        })
    };
    var rf = !1,
        Bd = new Z;
    m.app = null;
    ea.prototype = Object.create(M.prototype);
    ea.prototype.constructor = ea;
    ea._currentApplication = null;
    ea._applications = {};
    ea.getApplication = function(a) {
        return a ? ea._applications[a] : ea._currentApplication
    };
    var kn = function(a) {
        this.length = a;
        this.count = 0;
        this.inc = function() {
            this.count++
        };
        this.done = function() {
            return this.count === this.length
        }
    };
    Object.defineProperty(ea.prototype, "fillMode", {
        get: function() {
            return this._fillMode
        }
    });
    Object.defineProperty(ea.prototype, "resolutionMode", {
        get: function() {
            return this._resolutionMode
        }
    });
    Object.assign(ea.prototype, {
        configure: function(a, b) {
            var c = this;
            wa.get(a, function(d, e) {
                if (d) b(d);
                else {
                    var f = e.scenes,
                        g = e.assets;
                    c._parseApplicationProperties(e.application_properties, function(k) {
                        c._parseScenes(f);
                        c._parseAssets(g);
                        k ? b(k) : b(null)
                    })
                }
            })
        },
        preload: function(a) {
            var b =
                this,
                c;
            b.fire("preload:start");
            var d = this.assets.list({
                    preload: !0
                }),
                e = new kn(d.length),
                f = !1,
                g = function() {
                    b.graphicsDevice && !f && e.done() && (f = !0, b.fire("preload:end"), a())
                };
            var k = d.length;
            if (e.length) {
                var h = function(n) {
                        e.inc();
                        b.fire("preload:progress", e.count / k);
                        e.done() && g()
                    },
                    l = function(n, p) {
                        e.inc();
                        b.fire("preload:progress", e.count / k);
                        e.done() && g()
                    };
                for (c = 0; c < d.length; c++) d[c].loaded ? (e.inc(), b.fire("preload:progress", e.count / k), e.done() && g()) : (d[c].once("load", h), d[c].once("error", l), this.assets.load(d[c]))
            } else g()
        },
        getSceneUrl: function(a) {
            return (a = this.scenes.find(a)) ? a.url : null
        },
        loadSceneHierarchy: function(a, b) {
            this.scenes.loadSceneHierarchy(a, b)
        },
        loadSceneSettings: function(a, b) {
            this.scenes.loadSceneSettings(a, b)
        },
        loadScene: function(a, b) {
            this.scenes.loadScene(a, b)
        },
        _preloadScripts: function(a, b) {
            if (vb.legacy) {
                var c = this;
                c.systems.script.preloading = !0;
                a = this._getScriptReferences(a);
                var d = 0,
                    e = a.length,
                    f = new kn(e),
                    g = /^http(s)?:\/\//;
                if (e) {
                    var k = function(l, n) {
                        l && console.error(l);
                        f.inc();
                        f.done() && (c.systems.script.preloading = !1, b())
                    };
                    for (d = 0; d < e; d++) {
                        var h = a[d];
                        !g.test(h.toLowerCase()) && c._scriptPrefix && (h = ca.join(c._scriptPrefix, a[d]));
                        this.loader.load(h, "script", k)
                    }
                } else c.systems.script.preloading = !1, b()
            } else b()
        },
        _parseApplicationProperties: function(a, b) {
            "number" === typeof a.maxAssetRetries && 0 < a.maxAssetRetries && this.loader.enableRetry(a.maxAssetRetries);
            a.useDevicePixelRatio || (a.useDevicePixelRatio = a.use_device_pixel_ratio);
            a.resolutionMode || (a.resolutionMode = a.resolution_mode);
            a.fillMode || (a.fillMode = a.fill_mode);
            this._width = a.width;
            this._height = a.height;
            a.useDevicePixelRatio && (this.graphicsDevice.maxPixelRatio = window.devicePixelRatio);
            this.setCanvasResolution(a.resolutionMode, this._width, this._height);
            this.setCanvasFillMode(a.fillMode, this._width, this._height);
            if (a.layers && a.layerOrder) {
                var c = new xa,
                    d = {};
                for (f in a.layers) {
                    var e = a.layers[f];
                    e.id = parseInt(f, 10);
                    e.enabled = 1 !== e.id;
                    d[f] = new ka(e)
                }
                var f = 0;
                for (e = a.layerOrder.length; f < e; f++) {
                    var g = a.layerOrder[f],
                        k = d[g.layer];
                    k && (g.transparent ? c.pushTransparent(k) :
                        c.pushOpaque(k), c.subLayerEnabled[f] = g.enabled)
                }
                this.scene.layers = c
            }
            if (a.batchGroups)
                for (f = 0, e = a.batchGroups.length; f < e; f++) c = a.batchGroups[f], this.batcher.addGroup(c.name, c.dynamic, c.maxAabbSize, c.id, c.layers);
            a.i18nAssets && (this.i18n.assets = a.i18nAssets);
            this._loadLibraries(a.libraries, b)
        },
        _loadLibraries: function(a, b) {
            var c = a.length,
                d = c,
                e = this,
                f = /^http(s)?:\/\//;
            if (c)
                for (var g = function(l, n) {
                        d--;
                        l ? b(l) : 0 === d && (e.onLibrariesLoaded(), b(null))
                    }, k = 0; k < c; ++k) {
                    var h = a[k];
                    !f.test(h.toLowerCase()) && e._scriptPrefix &&
                        (h = ca.join(e._scriptPrefix, h));
                    this.loader.load(h, "script", g)
                } else e.onLibrariesLoaded(), b(null)
        },
        _parseScenes: function(a) {
            if (a)
                for (var b = 0; b < a.length; b++) this.scenes.add(a[b].name, a[b].url)
        },
        _parseAssets: function(a) {
            var b, c = [],
                d = {},
                e = {};
            if (vb.legacy) {
                if (this.enableBundles)
                    for (f in a) "bundle" === a[f].type && (e[f] = !0, c.push(a[f]));
                for (f in a) e[f] || c.push(a[f])
            } else {
                for (b = 0; b < this.scriptsOrder.length; b++) {
                    var f = this.scriptsOrder[b];
                    a[f] && (d[f] = !0, c.push(a[f]))
                }
                if (this.enableBundles)
                    for (f in a) "bundle" ===
                        a[f].type && (e[f] = !0, c.push(a[f]));
                for (f in a) d[f] || e[f] || c.push(a[f])
            }
            for (b = 0; b < c.length; b++) {
                a = c[b];
                f = new aa(a.name, a.type, a.file, a.data);
                f.id = parseInt(a.id, 10);
                f.preload = a.preload ? a.preload : !1;
                f.loaded = "script" === a.type && a.data && 0 < a.data.loadingType;
                f.tags.add(a.tags);
                if (a.i18n)
                    for (var g in a.i18n) f.addLocalizedAssetId(g, a.i18n[g]);
                this.assets.add(f)
            }
        },
        _getScriptReferences: function(a) {
            var b, c, d = [];
            a.settings.priority_scripts && (d = a.settings.priority_scripts);
            var e = [],
                f = {};
            for (b = 0; b < d.length; b++) e.push(d[b]),
                f[d[b]] = !0;
            a = a.entities;
            for (c in a)
                if (a[c].components.script)
                    for (d = a[c].components.script.scripts, b = 0; b < d.length; b++) f[d[b].url] || (e.push(d[b].url), f[d[b].url] = !0);
            return e
        },
        start: function() {
            this.frame = 0;
            this.fire("start", {
                timestamp: Lb(),
                target: this
            });
            if (!this._librariesLoaded) this.onLibrariesLoaded();
            H.initialize(this.root);
            this.fire("initialize");
            H.postInitialize(this.root);
            this.fire("postinitialize");
            this.tick()
        },
        update: function(a) {
            this.frame++;
            this.graphicsDevice.updateClientRect();
            this.vr && this.vr.poll();
            vb.legacy && H.fixedUpdate(1 / 60, this._inTools);
            H.update(a, this._inTools);
            H.animationUpdate(a, this._inTools);
            H.postUpdate(a, this._inTools);
            this.fire("update", a);
            this.controller && this.controller.update(a);
            this.mouse && this.mouse.update(a);
            this.keyboard && this.keyboard.update(a);
            this.gamepads && this.gamepads.update(a)
        },
        render: function() {
            this.fire("prerender");
            this.root.syncHierarchy();
            this.batcher.updateAll();
            this.renderer.renderComposition(this.scene.layers);
            this.fire("postrender")
        },
        _fillFrameStatsBasic: function(a,
            b, c) {
            var d = this.stats.frame;
            d.dt = b;
            d.ms = c;
            a > d._timeToCountFrames ? (d.fps = d._fpsAccum, d._fpsAccum = 0, d._timeToCountFrames = a + 1E3) : d._fpsAccum++;
            this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
            this.graphicsDevice._drawCallsPerFrame = 0
        },
        _fillFrameStats: function() {
            var a = this.stats.frame;
            a.cameras = this.renderer._camerasRendered;
            a.materials = this.renderer._materialSwitches;
            a.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
            a.shadowMapUpdates = this.renderer._shadowMapUpdates;
            a.shadowMapTime =
                this.renderer._shadowMapTime;
            a.depthMapTime = this.renderer._depthMapTime;
            a.forwardTime = this.renderer._forwardTime;
            var b = this.graphicsDevice._primsPerFrame;
            a.triangles = b[4] / 3 + Math.max(b[5] - 2, 0) + Math.max(b[6] - 2, 0);
            a.cullTime = this.renderer._cullTime;
            a.sortTime = this.renderer._sortTime;
            a.skinTime = this.renderer._skinTime;
            a.morphTime = this.renderer._morphTime;
            a.instancingTime = this.renderer._instancingTime;
            for (var c = a.otherPrimitives = 0; c < b.length; c++) 4 > c && (a.otherPrimitives += b[c]), b[c] = 0;
            this.renderer._camerasRendered =
                0;
            this.renderer._materialSwitches = 0;
            this.renderer._shadowMapUpdates = 0;
            this.graphicsDevice._shaderSwitchesPerFrame = 0;
            this.renderer._cullTime = 0;
            this.renderer._layerCompositionUpdateTime = 0;
            this.renderer._sortTime = 0;
            this.renderer._skinTime = 0;
            this.renderer._morphTime = 0;
            this.renderer._instancingTime = 0;
            this.renderer._shadowMapTime = 0;
            this.renderer._depthMapTime = 0;
            this.renderer._forwardTime = 0;
            a = this.stats.drawCalls;
            a.forward = this.renderer._forwardDrawCalls;
            a.culled = this.renderer._numDrawCallsCulled;
            a.depth =
                0;
            a.shadow = this.renderer._shadowDrawCalls;
            a.skinned = this.renderer._skinDrawCalls;
            a.immediate = 0;
            a.instanced = 0;
            a.removedByInstancing = 0;
            a.misc = a.total - (a.forward + a.shadow);
            this.renderer._depthDrawCalls = 0;
            this.renderer._shadowDrawCalls = 0;
            this.renderer._forwardDrawCalls = 0;
            this.renderer._numDrawCallsCulled = 0;
            this.renderer._skinDrawCalls = 0;
            this.renderer._immediateRendered = 0;
            this.renderer._instancedDrawCalls = 0;
            this.renderer._removedByInstancing = 0;
            this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
            a = this.stats.particles;
            a.updatesPerFrame = a._updatesPerFrame;
            a.frameTime = a._frameTime;
            a._updatesPerFrame = 0;
            a._frameTime = 0
        },
        setCanvasFillMode: function(a, b, c) {
            this._fillMode = a;
            this.resizeCanvas(b, c)
        },
        setCanvasResolution: function(a, b, c) {
            this._resolutionMode = a;
            "AUTO" === a && void 0 === b && (b = this.graphicsDevice.canvas.clientWidth, c = this.graphicsDevice.canvas.clientHeight);
            this.graphicsDevice.resizeCanvas(b, c)
        },
        isHidden: function() {
            return document[this._hiddenAttr]
        },
        onVisibilityChange: function() {
            this.isHidden() ?
                this._soundManager.suspend() : this._soundManager.resume()
        },
        resizeCanvas: function(a, b) {
            if (this._allowResize && (!this.xr || !this.xr.session)) {
                var c = window.innerWidth,
                    d = window.innerHeight;
                if (this._fillMode === bh) {
                    var e = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
                    e > c / d ? (a = c, b = a / e) : (b = d, a = b * e)
                } else "FILL_WINDOW" === this._fillMode && (a = c, b = d);
                this.graphicsDevice.canvas.style.width = a + "px";
                this.graphicsDevice.canvas.style.height = b + "px";
                "AUTO" === this._resolutionMode && this.setCanvasResolution("AUTO");
                return {
                    width: a,
                    height: b
                }
            }
        },
        onLibrariesLoaded: function() {
            this._librariesLoaded = !0;
            this.systems.rigidbody.onLibraryLoaded()
        },
        applySceneSettings: function(a) {
            if (this.systems.rigidbody && "undefined" !== typeof Ammo) {
                var b = a.physics.gravity;
                this.systems.rigidbody.gravity.set(b[0], b[1], b[2])
            }
            this.scene.applySettings(a);
            if (a.render.hasOwnProperty("skybox"))
                if (a.render.skybox)
                    if (b = this.assets.get(a.render.skybox)) this.setSkybox(b);
                    else this.assets.once("add:" + a.render.skybox, this.setSkybox, this);
            else this.setSkybox(null)
        },
        setSkybox: function(a) {
            a ? this._skyboxLast === a.id ? 0 !== this.scene.skyboxMip || a.loadFaces ? this._onSkyboxChange(a) : this._skyboxLoad(a) : (this._skyboxLast && (this.assets.off("add:" + this._skyboxLast, this.setSkybox, this), this.assets.off("load:" + this._skyboxLast, this._onSkyboxChange, this), this.assets.off("remove:" + this._skyboxLast, this._skyboxRemove, this)), this._skyboxLast = a.id, this.assets.on("load:" + a.id, this._onSkyboxChange, this), this.assets.once("remove:" + a.id, this._skyboxRemove, this), a.resource && this.scene.setSkybox(a.resources),
                this._skyboxLoad(a)) : this._skyboxLast && this._skyboxRemove({
                id: this._skyboxLast
            })
        },
        enableVr: function() {
            this.vr || (this.vr = new hd(this))
        },
        disableVr: function() {
            this.vr && (this.vr.destroy(), this.vr = null)
        },
        _onSkyboxChange: function(a) {
            this.scene.setSkybox(a.resources)
        },
        _skyboxLoad: function(a) {
            0 === this.scene.skyboxMip && (a.loadFaces = !0);
            this.assets.load(a);
            this._onSkyboxChange(a)
        },
        _skyboxRemove: function(a) {
            this._skyboxLast && (this.assets.off("add:" + a.id, this.setSkybox, this), this.assets.off("load:" + a.id, this._onSkyboxChange,
                this), this.assets.off("remove:" + a.id, this._skyboxRemove, this), this.scene.setSkybox(null), this._skyboxLast = null)
        },
        _firstBake: function() {
            this.lightmapper.bake(null, this.scene.lightmapMode)
        },
        _firstBatch: function() {
            this.scene._needsStaticPrepare && (this.renderer.prepareStaticMeshes(this.graphicsDevice, this.scene), this.scene._needsStaticPrepare = !1);
            this.batcher.generate()
        },
        _processTimestamp: function(a) {
            return a
        },
        _preRenderImmediate: function() {
            for (var a = 0; a < this._immediateData.lineBatches.length; a++) this._immediateData.lineBatches[a] &&
                this._immediateData.lineBatches[a].finalize(this.meshInstanceArray)
        },
        _postRenderImmediate: function() {
            for (var a = 0; a < this._immediateData.layers.length; a++) this._immediateData.layers[a].clearMeshInstances(!0);
            this._immediateData.layers.length = 0
        },
        _initImmediate: function() {
            this._immediateData || (this._immediateData = new Cg(this.graphicsDevice), this.on("prerender", this._preRenderImmediate, this), this.on("postrender", this._postRenderImmediate, this))
        },
        _addLines: function(a, b, c) {
            var d = c && c.layer ? c.layer : this.scene.layers.getLayerById(3),
                e = c && void 0 !== c.depthTest ? c.depthTest : !0;
            c = c && c.mask ? c.mask : void 0;
            this._initImmediate();
            this._immediateData.addLayer(d);
            var f = this._immediateData.getLayerIdx(d);
            void 0 === f ? (f = new Pk, f.init(this.graphicsDevice, this._immediateData.lineVertexFormat, d, a.length / 2), f.material.depthTest = e, c && (f.meshInstance.mask = c), f = this._immediateData.lineBatches.push(f) - 1, this._immediateData.addLayerIdx(f, d)) : (this._immediateData.lineBatches[f].init(this.graphicsDevice, this._immediateData.lineVertexFormat, d, a.length /
                2), this._immediateData.lineBatches[f].material.depthTest = e, c && (this._immediateData.lineBatches[f].meshInstance.mask = c));
            this._immediateData.lineBatches[f].addLines(a, b)
        },
        renderLine: function(a, b, c, d, e) {
            var f = c;
            if (d instanceof L)
                if (f = d, "number" === typeof e) {
                    rf || (console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead"), rf = !0);
                    var g = 1 === e ? {
                        layer: this.scene.layers.getLayerById(3),
                        depthTest: !1
                    } : {
                        layer: this.scene.layers.getLayerById(3),
                        depthTest: !0
                    }
                } else g = e;
            else "number" ===
                typeof d ? (rf || (console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead"), rf = !0), f = c, g = 1 === d ? {
                    layer: this.scene.layers.getLayerById(3),
                    depthTest: !1
                } : {
                    layer: this.scene.layers.getLayerById(3),
                    depthTest: !0
                }) : d && (g = d);
            this._addLines([a, b], [c, f], g)
        },
        renderLines: function(a, b, c) {
            c ? "number" === typeof c && (rf || (console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead"), rf = !0), c = 1 === c ? {
                layer: this.scene.layers.getLayerById(3),
                depthTest: !1
            } : {
                layer: this.scene.layers.getLayerById(3),
                depthTest: !0
            }) : c = {
                layer: this.scene.layers.getLayerById(3),
                depthTest: !0
            };
            b.length && a.length !== b.length ? console.error("renderLines: position/color arrays have different lengths") : 0 !== a.length % 2 ? console.error("renderLines: array length is not divisible by 2") : this._addLines(a, b, c)
        },
        renderWireCube: function(a, b, c) {
            var d;
            this._initImmediate();
            this._immediateData.cubeLocalPos || (this._immediateData.cubeLocalPos = [new z(-.5, -.5, -.5), new z(-.5, .5, -.5), new z(.5, .5, -.5), new z(.5, -.5, -.5), new z(-.5, -.5, .5), new z(-.5,
                .5, .5), new z(.5, .5, .5), new z(.5, -.5, .5)], this._immediateData.cubeWorldPos = [new z, new z, new z, new z, new z, new z, new z, new z]);
            var e = this._immediateData.cubeLocalPos,
                f = this._immediateData.cubeWorldPos;
            for (d = 0; 8 > d; d++) a.transformPoint(e[d], f[d]);
            this.renderLines([f[0], f[1], f[1], f[2], f[2], f[3], f[3], f[0], f[4], f[5], f[5], f[6], f[6], f[7], f[7], f[4], f[0], f[4], f[1], f[5], f[2], f[6], f[3], f[7]], b, c)
        },
        renderMeshInstance: function(a, b) {
            b || (b = {
                layer: this.scene.layers.getLayerById(3)
            });
            this._initImmediate();
            this._immediateData.addLayer(b.layer);
            this.meshInstanceArray[0] = a;
            b.layer.addMeshInstances(this.meshInstanceArray, !0)
        },
        renderMesh: function(a, b, c, d) {
            d || (d = {
                layer: this.scene.layers.getLayerById(3)
            });
            this._initImmediate();
            Bd.worldTransform = c;
            Bd._dirtyWorld = Bd._dirtyNormal = !1;
            a = new va(Bd, a, b);
            a.cull = !1;
            d.mask && (a.mask = d.mask);
            this._immediateData.addLayer(d.layer);
            this.meshInstanceArray[0] = a;
            d.layer.addMeshInstances(this.meshInstanceArray, !0)
        },
        renderQuad: function(a, b, c) {
            c || (c = {
                layer: this.scene.layers.getLayerById(3)
            });
            this._initImmediate();
            if (!this._immediateData.quadMesh) {
                var d = new Na(this.graphicsDevice, [{
                    semantic: "POSITION",
                    components: 3,
                    type: 6
                }]);
                d = new ab(this.graphicsDevice, d, 4);
                var e = new Pb(d);
                e.element.POSITION.set(-.5, -.5, 0);
                e.next();
                e.element.POSITION.set(.5, -.5, 0);
                e.next();
                e.element.POSITION.set(-.5, .5, 0);
                e.next();
                e.element.POSITION.set(.5, .5, 0);
                e.end();
                this._immediateData.quadMesh = new sb(this.graphicsDevice);
                this._immediateData.quadMesh.vertexBuffer = d;
                this._immediateData.quadMesh.primitive[0].type = 5;
                this._immediateData.quadMesh.primitive[0].base =
                    0;
                this._immediateData.quadMesh.primitive[0].count = 4;
                this._immediateData.quadMesh.primitive[0].indexed = !1
            }
            Bd.worldTransform = a;
            Bd._dirtyWorld = Bd._dirtyNormal = !1;
            a = new va(Bd, this._immediateData.quadMesh, b);
            a.cull = !1;
            this.meshInstanceArray[0] = a;
            this._immediateData.addLayer(c.layer);
            c.layer.addMeshInstances(this.meshInstanceArray, !0)
        },
        destroy: function() {
            var a, b = this.graphicsDevice.canvas.id;
            this.off("librariesloaded");
            document.removeEventListener("visibilitychange", this._visibilityChangeHandler, !1);
            document.removeEventListener("mozvisibilitychange",
                this._visibilityChangeHandler, !1);
            document.removeEventListener("msvisibilitychange", this._visibilityChangeHandler, !1);
            document.removeEventListener("webkitvisibilitychange", this._visibilityChangeHandler, !1);
            this.onVisibilityChange = this._visibilityChangeHandler = null;
            this.root.destroy();
            this.root = null;
            this.mouse && (this.mouse.off(), this.mouse.detach(), this.mouse = null);
            this.keyboard && (this.keyboard.off(), this.keyboard.detach(), this.keyboard = null);
            this.touch && (this.touch.off(), this.touch.detach(), this.touch =
                null);
            this.elementInput && (this.elementInput.detach(), this.elementInput = null);
            this.controller && (this.controller = null);
            var c = this.systems.list;
            var d = 0;
            for (a = c.length; d < a; d++) c[d].destroy();
            H.destroy();
            a = this.assets.list();
            for (d = 0; d < a.length; d++) a[d].unload(), a[d].off();
            this.assets.off();
            this.bundles.destroy();
            this.bundles = null;
            this.i18n.destroy();
            this.i18n = null;
            for (var e in this.loader.getHandler("script")._cache) d = this.loader.getHandler("script")._cache[e], (a = d.parentNode) && a.removeChild(d);
            this.loader.getHandler("script")._cache = {};
            this.loader.destroy();
            this.loader = null;
            this.scene.destroy();
            this.scene = null;
            this.systems = [];
            this.context = null;
            this.scripts.destroy();
            this.scripts = null;
            this.scenes.destroy();
            this.scenes = null;
            this.lightmapper.destroy();
            this.lightmapper = null;
            this.batcher.destroyManager();
            this.batcher = null;
            this._entityIndex = {};
            this.defaultLayerDepth.onPreRenderOpaque = null;
            this.defaultLayerDepth.onPostRenderOpaque = null;
            this.defaultLayerDepth.onDisable = null;
            this.defaultLayerWorld = this.defaultLayerDepth = this.defaultLayerDepth.onEnable =
                null;
            Gd && (Gd.destroy(), Gd = null);
            this.vr && (this.vr.destroy(), this.vr = null);
            this.xr.end();
            this.graphicsDevice.destroy();
            this.tick = this.renderer = this.graphicsDevice = null;
            this.off();
            this._soundManager && (this._soundManager.destroy(), this._soundManager = null);
            vb.app = null;
            $b.DEFAULT_PARAM_TEXTURE = null;
            ea._applications[b] = null;
            ea._currentApplication === this && (ea._currentApplication = null)
        },
        getEntityFromIndex: function(a) {
            return this._entityIndex[a]
        }
    });
    var Wh = {},
        Mo = function(a) {
            var b;
            return function(c, d) {
                if (a.graphicsDevice) {
                    ea._currentApplication =
                        a;
                    b && (window.cancelAnimationFrame(b), b = null);
                    m.app = a;
                    c = a._processTimestamp(c) || Lb();
                    var e = c - (a._time || c);
                    var f = N.clamp(e / 1E3, 0, a.maxDeltaTime);
                    f *= a.timeScale;
                    a._time = c;
                    b = a.vr && a.vr.display ? a.vr.display.requestAnimationFrame(a.tick) : a.xr.session ? a.xr.session.requestAnimationFrame(a.tick) : window.requestAnimationFrame(a.tick);
                    if (!a.graphicsDevice.contextLost) {
                        a._fillFrameStatsBasic(c, f, e);
                        a.fire("frameupdate", e);
                        d ? (a.xr.update(d), a.graphicsDevice.defaultFramebuffer = d.session.renderState.baseLayer.framebuffer) :
                            a.graphicsDevice.defaultFramebuffer = null;
                        a.update(f);
                        a.fire("framerender");
                        if (a.autoRender || a.renderNextFrame) a.render(), a.renderNextFrame = !1;
                        Wh.timestamp = Lb();
                        Wh.target = a;
                        a.fire("frameend", Wh);
                        a.fire("frameEnd", Wh);
                        a.vr && a.vr.display && a.vr.display.presenting && a.vr.display.submitFrame()
                    }
                }
            }
        },
        No = 0;
    Object.defineProperty(la.prototype, "shader", {
        get: function() {
            return this._shader
        },
        set: function(a) {
            this._shader = a
        }
    });
    Object.defineProperty(la.prototype, "blendType", {
        get: function() {
            if (!this.blend && 1 === this.blendSrc &&
                0 === this.blendDst && 0 === this.blendEquation) return 3;
            if (!this.blend || 6 !== this.blendSrc || 8 !== this.blendDst || 0 !== this.blendEquation) {
                if (this.blend && 1 === this.blendSrc && 1 === this.blendDst && 0 === this.blendEquation) return 1;
                if (this.blend && 6 === this.blendSrc && 1 === this.blendDst && 0 === this.blendEquation) return 6;
                if (this.blend && 4 === this.blendSrc && 2 === this.blendDst && 0 === this.blendEquation) return 7;
                if (this.blend && 5 === this.blendSrc && 1 === this.blendDst && 0 === this.blendEquation) return 8;
                if (this.blend && 1 === this.blendSrc &&
                    1 === this.blendDst && 3 === this.blendEquation) return 9;
                if (this.blend && 1 === this.blendSrc && 1 === this.blendDst && 4 === this.blendEquation) return 10;
                if (this.blend && 4 === this.blendSrc && 0 === this.blendDst && 0 === this.blendEquation) return 5;
                if (this.blend && 1 === this.blendSrc && 8 === this.blendDst && 0 === this.blendEquation) return 4
            }
            return 2
        },
        set: function(a) {
            var b = this.blend;
            switch (a) {
                case 3:
                    this.blend = !1;
                    this.blendSrc = 1;
                    this.blendEquation = this.blendDst = 0;
                    break;
                case 2:
                    this.blend = !0;
                    this.blendSrc = 6;
                    this.blendDst = 8;
                    this.blendEquation =
                        0;
                    break;
                case 4:
                    this.blend = !0;
                    this.blendSrc = 1;
                    this.blendDst = 8;
                    this.blendEquation = 0;
                    break;
                case 1:
                    this.blend = !0;
                    this.blendDst = this.blendSrc = 1;
                    this.blendEquation = 0;
                    break;
                case 6:
                    this.blend = !0;
                    this.blendSrc = 6;
                    this.blendDst = 1;
                    this.blendEquation = 0;
                    break;
                case 7:
                    this.blend = !0;
                    this.blendSrc = 4;
                    this.blendDst = 2;
                    this.blendEquation = 0;
                    break;
                case 8:
                    this.blend = !0;
                    this.blendSrc = 5;
                    this.blendDst = 1;
                    this.blendEquation = 0;
                    break;
                case 5:
                    this.blend = !0;
                    this.blendSrc = 4;
                    this.blendEquation = this.blendDst = 0;
                    break;
                case 9:
                    this.blend = !0;
                    this.blendDst = this.blendSrc = 1;
                    this.blendEquation = 3;
                    break;
                case 10:
                    this.blend = !0, this.blendDst = this.blendSrc = 1, this.blendEquation = 4
            }
            b !== this.blend && (this._scene ? this._scene.layers._dirtyBlend = !0 : this._dirtyBlend = !0);
            this._updateMeshInstanceKeys()
        }
    });
    la.prototype._cloneInternal = function(a) {
        a.name = this.name;
        a.shader = this.shader;
        a.alphaTest = this.alphaTest;
        a.alphaToCoverage = this.alphaToCoverage;
        a.blend = this.blend;
        a.blendSrc = this.blendSrc;
        a.blendDst = this.blendDst;
        a.blendEquation = this.blendEquation;
        a.separateAlphaBlend =
            this.separateAlphaBlend;
        a.blendSrcAlpha = this.blendSrcAlpha;
        a.blendDstAlpha = this.blendDstAlpha;
        a.blendAlphaEquation = this.blendAlphaEquation;
        a.cull = this.cull;
        a.depthTest = this.depthTest;
        a.depthWrite = this.depthWrite;
        a.depthBias = this.depthBias;
        a.slopeDepthBias = this.slopeDepthBias;
        this.stencilFront && (a.stencilFront = this.stencilFront.clone());
        this.stencilBack && (a.stencilBack = this.stencilFront === this.stencilBack ? a.stencilFront : this.stencilBack.clone());
        a.redWrite = this.redWrite;
        a.greenWrite = this.greenWrite;
        a.blueWrite = this.blueWrite;
        a.alphaWrite = this.alphaWrite
    };
    la.prototype.clone = function() {
        var a = new la;
        this._cloneInternal(a);
        return a
    };
    la.prototype._updateMeshInstanceKeys = function() {
        var a, b = this.meshInstances;
        for (a = 0; a < b.length; a++) b[a].updateKey()
    };
    la.prototype.updateUniforms = function() {};
    la.prototype.updateShader = function(a, b, c) {};
    la.prototype.update = function() {
        this.dirty = !0;
        this._shader && (this._shader.failed = !1)
    };
    la.prototype.clearParameters = function() {
        this.parameters = {}
    };
    la.prototype.getParameters =
        function() {
            return this.parameters
        };
    la.prototype.clearVariants = function() {
        this.variants = {};
        for (var a, b = 0; b < this.meshInstances.length; b++) {
            var c = this.meshInstances[b];
            for (a = 0; a < c._shader.length; a++) c._shader[a] = null
        }
    };
    la.prototype.getParameter = function(a) {
        return this.parameters[a]
    };
    la.prototype.setParameter = function(a, b) {
        if (void 0 === b && "object" === typeof a) {
            b = a;
            if (b.length) {
                for (a = 0; a < b.length; a++) this.setParameter(b[a]);
                return
            }
            a = b.name;
            b = b.value
        }
        var c = this.parameters[a];
        c ? c.data = b : this.parameters[a] = {
            scopeId: null,
            data: b
        }
    };
    la.prototype.deleteParameter = function(a) {
        this.parameters[a] && delete this.parameters[a]
    };
    la.prototype.setParameters = function(a, b) {
        var c = this.parameters;
        void 0 === b && (b = c);
        for (var d in b)
            if (b = c[d]) b.scopeId || (b.scopeId = a.scope.resolve(d)), b.scopeId.setValue(b.data)
    };
    la.prototype.destroy = function() {
        this.variants = {};
        this.shader = null;
        for (var a, b, c = 0; c < this.meshInstances.length; c++) {
            a = this.meshInstances[c];
            for (b = 0; b < a._shader.length; b++) a._shader[b] = null;
            a._material = null;
            b = ea.getApplication().scene.defaultMaterial;
            this !== b && (a.material = b)
        }
    };
    Vb.prototype.updateMinRef = function(a, b, c, d, e, f, g, k, h) {
        this._updateSharedOptions(a, d, e, g);
        this._updateMinOptions(a, d);
        this._updateUVOptions(a, d, e, !0)
    };
    Vb.prototype.updateRef = function(a, b, c, d, e, f, g, k, h) {
        this._updateSharedOptions(a, d, e, g);
        a.useTexCubeLod = b.useTexCubeLod;
        this._updateEnvOptions(a, d, c, h);
        this._updateMaterialOptions(a, d);
        1 === g && (a.gamma && (a.gamma = 3), a.toneMap = 0);
        a.hasTangents = e && d.normalMap && 0 !== (e & 512);
        this._updateLightOptions(a, d, e, k, f);
        this._updateUVOptions(a,
            d, e, !1);
        a.clearCoat = d.clearCoat;
        a.clearCoatGlossiness = d.clearCoatGlossiness
    };
    Vb.prototype._updateSharedOptions = function(a, b, c, d) {
        a.pass = d;
        a.alphaTest = 0 < b.alphaTest;
        a.forceFragmentPrecision = b.forceFragmentPrecision || "";
        a.chunks = b.chunks || "";
        a.blendType = b.blendType;
        a.forceUv1 = b.forceUv1;
        a.screenSpace = c && 0 !== (c & 256);
        a.skin = c && 0 !== (c & 2);
        a.useInstancing = c && 0 !== (c & 32);
        a.useMorphPosition = c && 0 !== (c & 1024);
        a.useMorphNormal = c && 0 !== (c & 2048);
        a.useMorphTextureBased = c && 0 !== (c & 4096);
        a.nineSlicedMode = b.nineSlicedMode ||
            0
    };
    Vb.prototype._updateUVOptions = function(a, b, c, d) {
        var e = !1,
            f = !1,
            g = !1;
        c && (e = 0 !== (c & 4), f = 0 !== (c & 8), g = 0 !== (c & 16));
        a.vertexColors = !1;
        this._mapXForms = [];
        for (var k in Ac) this._updateTexOptions(a, b, k, e, f, g, d);
        this._mapXForms = null
    };
    Vb.prototype._updateMinOptions = function(a, b) {
        a.opacityTint = 1 !== b.opacity && 3 !== b.blendType;
        a.lights = []
    };
    Vb.prototype._updateMaterialOptions = function(a, b) {
        var c = 1 === b.diffuse.r && 1 === b.diffuse.g && 1 === b.diffuse.b || !b.diffuseTint && (b.diffuseMap || b.diffuseVertexColor) ? 0 : 3,
            d = !1,
            e = (b.useMetalness ?
                !0 : !!b.specularMap) || !!b.sphereMap || !!b.cubeMap || !!b.dpAtlas;
        (e = (e = (e = e || (b.useMetalness ? !0 : !(0 === b.specular.r && 0 === b.specular.g && 0 === b.specular.b))) || b.enableGGXSpecular) || 0 < b.clearCoat) && (!b.specularTint && (b.specularMap || b.specularVertexColor) || b.useMetalness || (d = 1 !== b.specular.r || 1 !== b.specular.g || 1 !== b.specular.b));
        var f = b.emissiveMap ? 0 : 3;
        f || (f = (f = (1 !== b.emissive.r || 1 !== b.emissive.g || 1 !== b.emissive.b || 1 !== b.emissiveIntensity) && b.emissiveTint) ? 3 : 1 !== b.emissiveIntensity ? 1 : 0);
        var g = b.normalMap ? 10 ===
            b.normalMap.format || "swizzleGGGR" === b.normalMap.type : !1;
        a.opacityTint = 1 !== b.opacity && 3 !== b.blendType ? 1 : 0;
        a.blendMapsWithColors = !0;
        a.ambientTint = b.ambientTint;
        a.diffuseTint = c;
        a.specularTint = d ? 3 : 0;
        a.metalnessTint = b.useMetalness && 1 > b.metalness ? 1 : 0;
        a.glossTint = 1;
        a.emissiveTint = f;
        a.alphaToCoverage = b.alphaToCoverage;
        a.normalizeNormalMap = b.normalizeNormalMap;
        a.sphereMap = !!b.sphereMap;
        a.cubeMap = !!b.cubeMap;
        a.dpAtlas = !!b.dpAtlas;
        a.ambientSH = !!b.ambientSH;
        a.useSpecular = e;
        a.emissiveFormat = b.emissiveMap ? "rgbm" ===
            b.emissiveMap.type ? 1 : 14 === b.emissiveMap.format ? 2 : 0 : null;
        a.lightMapFormat = b.lightMap ? "rgbm" === b.lightMap.type ? 1 : 14 === b.lightMap.format ? 2 : 0 : null;
        a.specularAntialias = b.specularAntialias && !!b.normalMap && !!b.normalMap.mipmaps && !g;
        a.conserveEnergy = b.conserveEnergy;
        a.opacityFadesSpecular = b.opacityFadesSpecular;
        a.alphaFade = b.alphaFade;
        a.occludeSpecular = b.occludeSpecular;
        a.occludeSpecularFloat = 1 !== b.occludeSpecularIntensity;
        a.occludeDirect = b.occludeDirect;
        a.shadingModel = b.shadingModel;
        a.fresnelModel = b.fresnelModel;
        a.packedNormal = g;
        a.fastTbn = b.fastTbn;
        a.cubeMapProjection = b.cubeMapProjection;
        a.customFragmentShader = b.customFragmentShader;
        a.refraction = !!b.refraction;
        a.useMetalness = b.useMetalness;
        a.enableGGXSpecular = b.enableGGXSpecular;
        a.msdf = !!b.msdfMap;
        a.twoSidedLighting = b.twoSidedLighting;
        a.pixelSnap = b.pixelSnap;
        a.aoMapUv = b.aoUvSet;
        a.diffuseDetail = !!b.diffuseMap;
        a.normalDetail = !!b.normalMap;
        a.diffuseDetailMode = b.diffuseDetailMode;
        a.detailModes = !!a.diffuseDetail;
        a.clearCoatTint = 1 !== b.clearCoat ? 1 : 0;
        a.clearCoatGlossTint =
            1 !== b.clearCoatGlossiness ? 1 : 0
    };
    Vb.prototype._updateEnvOptions = function(a, b, c, d) {
        var e = d && "rgbm" === d.type || b.cubeMap && "rgbm" === b.cubeMap.type || b.dpAtlas && "rgbm" === b.dpAtlas.type,
            f = d && ("rgbm" === d.type || 14 === d.format) || b.cubeMap && ("rgbm" === b.cubeMap.type || 14 === b.cubeMap.format) || b.dpAtlas && ("rgbm" === b.dpAtlas.type || 14 === b.dpAtlas.format),
            g = d && !b.cubeMap && !b.sphereMap && !b.dpAtlas && "rgbm" === d.type || b.cubeMap && "rgbm" === b.cubeMap.type || b.sphereMap && "rgbm" === b.sphereMap.type || b.dpAtlas && "rgbm" === b.dpAtlas.type,
            k = (!d || b.cubeMap || b.sphereMap || b.dpAtlas ? !1 : "rgbm" === d.type || 14 === d.format) || b.cubeMap && ("rgbm" === b.cubeMap.type || 14 === b.cubeMap.format) || b.sphereMap && ("rgbm" === b.sphereMap.type || 14 === b.sphereMap.format) || b.dpAtlas && ("rgbm" === b.dpAtlas.type || 14 === b.dpAtlas.format),
            h;
        b.useSkybox && c._skyboxPrefiltered && (h = c._skyboxPrefiltered[0]);
        a.fog = b.useFog ? c.fog : "none";
        a.gamma = b.useGammaTonemap ? c.gammaCorrection : 0;
        a.toneMap = b.useGammaTonemap ? c.toneMapping : -1;
        a.rgbmAmbient = e;
        a.hdrAmbient = f;
        a.rgbmReflection = g;
        a.hdrReflection =
            k;
        a.useRgbm = g || e || b.emissiveMap && "rgbm" === b.emissiveMap.type || b.lightMap && "rgbm" === b.lightMap.type;
        a.fixSeams = d ? d.fixCubemapSeams : b.cubeMap ? b.cubeMap.fixCubemapSeams : !1;
        a.prefilteredCubemap = !!d;
        a.skyboxIntensity = d && h && d === h && 1 !== c.skyboxIntensity;
        a.useCubeMapRotation = b.useSkybox && c && c.skyboxRotation && !c.skyboxRotation.equals(Y.IDENTITY);
        a.useRightHandedCubeMap = b.cubeMap ? b.cubeMap._isRenderTarget : b.useSkybox && c && c._skyboxIsRenderTarget
    };
    Vb.prototype._updateLightOptions = function(a, b, c, d, e) {
        a.lightMap = !1;
        a.lightMapChannel = "";
        a.lightMapUv = 0;
        a.lightMapTransform = 0;
        a.lightMapWithoutAmbient = !1;
        a.dirLightMap = !1;
        c && (a.noShadow = 0 !== (c & 1), 0 !== (c & 64) && (a.lightMapFormat = 1, a.lightMap = !0, a.lightMapChannel = "rgb", a.lightMapUv = 1, a.lightMapTransform = 0, a.lightMapWithoutAmbient = !b.lightMap, a.useRgbm = !0, 0 !== (c & 128) && (a.dirLightMap = !0)));
        b.useLighting ? (b = [], c = c ? c >> 16 : 1, d && (this._collectLights(0, d[0], b, c), this._collectLights(1, d[1], b, c, e), this._collectLights(2, d[2], b, c, e)), a.lights = b) : a.lights = [];
        0 === a.lights.length &&
            (a.noShadow = !0)
    };
    Vb.prototype._updateTexOptions = function(a, b, c, d, e, f, g) {
        var k = c + "Map",
            h = c + "VertexColor",
            l = c + "VertexColorChannel",
            n = k + "Channel",
            p = k + "Transform",
            q = k + "Uv";
        "light" !== c && (a[k] = !1, a[n] = "", a[p] = 0, a[q] = 0);
        a[h] = !1;
        a[l] = "";
        var r = "opacity" === c;
        if (r && 3 === b.blendType && 0 === b.alphaTest && !b.alphaToCoverage) return a;
        if (!g || r) "height" !== c && b[h] && f && (a[h] = b[h], a[l] = b[l], a.vertexColors = !0), b[k] && (c = !0, 0 !== b[q] || d || (c = !1), 1 !== b[q] || e || (c = !1), c && (a[k] = !!b[k], a[p] = this._getMapTransformID(b[p], b[q]), a[n] =
            b[n], a[q] = b[q]))
    };
    Vb.prototype._collectLights = function(a, b, c, d, e) {
        var f;
        for (f = 0; f < b.length; f++) {
            var g = b[f];
            g.enabled && g.mask & d && (0 === a || !g.isStatic) && c.push(g)
        }
        if (e)
            for (f = 0; f < e.length; f++) g = e[f], g._type === a && c.push(g)
    };
    Vb.prototype._getMapTransformID = function(a, b) {
        if (!a) return 0;
        this._mapXForms[b] || (this._mapXForms[b] = []);
        var c;
        for (c = 0; c < this._mapXForms[b].length && this._mapXForms[b][c][0] == a.x && this._mapXForms[b][c][1] == a.y && this._mapXForms[b][c][2] == a.z && this._mapXForms[b][c][3] == a.w;) return c + 1;
        c = this._mapXForms[b].length;
        this._mapXForms[b][c] = [];
        this._mapXForms[b][c][0] = a.x;
        this._mapXForms[b][c][1] = a.y;
        this._mapXForms[b][c][2] = a.z;
        this._mapXForms[b][c][3] = a.w;
        return c + 1
    };
    ma.prototype = Object.create(la.prototype);
    ma.prototype.constructor = ma;
    ma.TEXTURE_PARAMETERS = mf;
    ma.CUBEMAP_PARAMETERS = Jh;
    var Ra = [],
        ln = [],
        xk = [],
        yk = [],
        re = {},
        qb = function(a, b, c, d, e, f, g) {
            var k = "_" + b + "Map",
                h = k + "Tiling",
                l = k + "Offset",
                n = k.substring(1) + "Transform",
                p = n + "Uniform",
                q = k + "Uv",
                r = k + "Channel",
                t = "_" + b + "VertexColor",
                u = "_" + b +
                "VertexColorChannel",
                x = "_" + b + "Mode";
            a[k] = null;
            a[h] = new P(1, 1);
            a[l] = new P(0, 0);
            a[n] = null;
            a[p] = null;
            a[q] = c;
            0 < d && (c = e ? e : 1 < d ? "rgb" : "g", a[r] = c, f && (a[u] = c));
            f && (a[t] = !1);
            g && (a[x] = "mul");
            Ac[b] = d;
            Object.defineProperty(ma.prototype, k.substring(1), {
                get: function() {
                    return this[k]
                },
                set: function(v) {
                    var w = this[k];
                    !!w ^ !!v && (this.dirtyShader = !0);
                    w && v && (w.type !== v.type || w.fixCubemapSeams !== v.fixCubemapSeams || w.format !== v.format) && (this.dirtyShader = !0);
                    this[k] = v
                }
            });
            a = h.substring(1);
            b = l.substring(1);
            Object.defineProperty(ma.prototype,
                a, {
                    get: function() {
                        return this[h]
                    },
                    set: function(v) {
                        this.dirtyShader = !0;
                        this[h] = v
                    }
                });
            re[a] = function(v, w, y) {
                v = v._updateMapTransform(y ? v[n] : null, w, v[l]);
                return {
                    name: "texture_" + n,
                    value: v.data
                }
            };
            Object.defineProperty(ma.prototype, b, {
                get: function() {
                    return this[l]
                },
                set: function(v) {
                    this.dirtyShader = !0;
                    this[l] = v
                }
            });
            re[b] = function(v, w, y) {
                v = v._updateMapTransform(y ? v[n] : null, v[h], w);
                return {
                    name: "texture_" + n,
                    value: v.data
                }
            };
            Object.defineProperty(ma.prototype, q.substring(1), {
                get: function() {
                    return this[q]
                },
                set: function(v) {
                    this[q] !==
                        v && (this.dirtyShader = !0);
                    this[q] = v
                }
            });
            Object.defineProperty(ma.prototype, r.substring(1), {
                get: function() {
                    return this[r]
                },
                set: function(v) {
                    this[r] !== v && (this.dirtyShader = !0);
                    this[r] = v
                }
            });
            f && (Object.defineProperty(ma.prototype, t.substring(1), {
                get: function() {
                    return this[t]
                },
                set: function(v) {
                    this.dirtyShader = !0;
                    this[t] = v
                }
            }), Object.defineProperty(ma.prototype, u.substring(1), {
                get: function() {
                    return this[u]
                },
                set: function(v) {
                    this[u] !== v && (this.dirtyShader = !0);
                    this[u] = v
                }
            }));
            g && Object.defineProperty(ma.prototype,
                x.substring(1), {
                    get: function() {
                        return this[x]
                    },
                    set: function(v) {
                        this.dirtyShader = !0;
                        this[x] = v
                    }
                });
            Ra.push(k.substring(1));
            Ra.push(h.substring(1));
            Ra.push(l.substring(1));
            Ra.push(q.substring(1));
            Ra.push(r.substring(1));
            f && (Ra.push(t.substring(1)), Ra.push(u.substring(1)));
            g && Ra.push(x.substring(1));
            xk.push(n)
        },
        Xh = [],
        Yh = function(a, b, c, d) {
            var e = "_" + b,
                f = b + "Uniform",
                g = b + "Intensity",
                k = "_" + g;
            a[e] = c;
            a[f] = new Float32Array(3);
            Object.defineProperty(ma.prototype, b, {
                get: function() {
                    this.dirtyShader = this.dirtyColor = !0;
                    return this[e]
                },
                set: function(h) {
                    var l = this[e];
                    (0 === l.r && 0 === l.g && 0 === l.b || 1 === l.r && 1 === l.g && 1 === l.b) ^ (0 === h.r && 0 === h.g && 0 === h.b || 1 === h.r && 1 === h.g && 1 === h.b) && (this.dirtyShader = !0);
                    this.dirtyColor = !0;
                    this[e] = h
                }
            });
            Ra.push(b);
            yk.push(f);
            Xh.push(b);
            re[b] = function(h, l, n) {
                n = n ? h[f] : new Float32Array(3);
                var p = !1;
                h.useGammaTonemap && (p = (h._scene || ea.getApplication().scene).gammaCorrection);
                for (var q = 0; 3 > q; q++) n[q] = p ? Math.pow(l.data[q], 2.2) : l.data[q], d && (n[q] *= h[k]);
                return {
                    name: "material_" + b,
                    value: n
                }
            };
            d && (a[k] =
                1, Object.defineProperty(ma.prototype, g, {
                    get: function() {
                        return this[k]
                    },
                    set: function(h) {
                        var l = this[k];
                        (0 === l || 1 === l) ^ (0 === h || 1 === h) && (this.dirtyShader = !0);
                        this.dirtyColor = !0;
                        this[k] = h
                    }
                }), Ra.push(g), re[g] = function(h, l, n) {
                    l = n ? h[f] : new Float32Array(3);
                    n = !1;
                    h.useGammaTonemap && (n = (h._scene || ea.getApplication().scene).gammaCorrection);
                    for (var p = 0; 3 > p; p++) l[p] = n ? Math.pow(h[e].data[p], 2.2) : h[e].data[p], l[p] *= h[k];
                    return {
                        name: "material_" + b,
                        value: l
                    }
                })
        },
        gb = function(a, b, c, d) {
            var e = "_" + b;
            a[e] = c;
            Object.defineProperty(ma.prototype,
                b, {
                    get: function() {
                        return this[e]
                    },
                    set: function(f) {
                        var g = this[e];
                        g !== f && (this[e] = f, 0 === g || 1 === g || 0 === f || 1 === f) && (this.dirtyShader = !0)
                    }
                });
            Ra.push(b);
            re[b] = void 0 !== d ? d : function(f, g, k) {
                return {
                    name: "material_" + b,
                    value: g
                }
            }
        },
        sc = function(a, b, c) {
            var d = "_" + b;
            a[d] = null;
            Object.defineProperty(ma.prototype, b, {
                get: function() {
                    return this[d]
                },
                set: function(e) {
                    !!this[d] ^ !!e && (this.dirtyShader = !0);
                    this[d] = e
                }
            });
            Ra.push(b);
            re[b] = c
        },
        tc = function(a, b, c) {
            Object.defineProperty(ma.prototype, c, {
                get: function() {
                    return this[b]
                },
                set: function(d) {
                    this[b] = d
                }
            })
        },
        bq = function(a) {
            Object.defineProperty(ma.prototype, "chunks", {
                get: function() {
                    this.dirtyShader = !0;
                    return this._chunks
                },
                set: function(b) {
                    this.dirtyShader = !0;
                    this._chunks = b
                }
            });
            Ra.push("chunks")
        },
        Ca = function(a, b, c) {
            var d = "_" + b;
            a[d] = c;
            Object.defineProperty(ma.prototype, b, {
                get: function() {
                    return this[d]
                },
                set: function(e) {
                    this[d] !== e && (this.dirtyShader = !0);
                    this[d] = e
                }
            });
            Ra.push(b)
        },
        mn = function() {};
    mn.prototype.copy = function(a) {
        for (var b in a) a.hasOwnProperty(b) && "copy" !== b && (this[b] =
            a[b])
    };
    Object.assign(ma.prototype, {
        reset: function() {
            var a;
            for (a = 0; a < Ra.length; a++) {
                var b = ln[a];
                this[Ra[a]] = b ? b.clone ? b.clone() : b : b
            }
            for (a = 0; a < xk.length; a++) this[xk[a]] = null;
            for (a = 0; a < yk.length; a++) this[yk[a]] = new Float32Array(3);
            this._chunks = new mn;
            this.cubeMapMinUniform = new Float32Array(3);
            this.cubeMapMaxUniform = new Float32Array(3)
        },
        clone: function() {
            var a = new ma;
            la.prototype._cloneInternal.call(this, a);
            for (var b, c = 0; c < Ra.length; c++) b = Ra[c], void 0 !== this[b] && (this[b] && this[b].copy ? a[b] ? a[b].copy(this[b]) :
                a[b] = this[b].clone() : a[b] = this[b]);
            return a
        },
        _updateMapTransform: function(a, b, c) {
            if (1 === b.x && 1 === b.y && 0 === c.x && 0 === c.y) return null;
            a = a || new X;
            a.set(b.x, b.y, c.x, c.y);
            return a
        },
        _setParameter: function(a, b) {
            this.parameters[a] || this._propsSet.push(a);
            this.setParameter(a, b)
        },
        _clearParameters: function() {
            for (var a = this._propsSet, b = 0; b < a.length; b++) delete this.parameters[a[b]];
            this._propsSet = []
        },
        _updateMap: function(a) {
            var b = a + "Map";
            if (a = this[b]) {
                this._setParameter("texture_" + b, a);
                a = b + "Transform";
                this[a] = this._updateMapTransform(this[a],
                    this[b + "Tiling"], this[b + "Offset"]);
                var c = this[a];
                if (c) {
                    b += "TransformUniform";
                    var d = this[b];
                    d || (d = new Float32Array(4), this[b] = d);
                    d[0] = c.x;
                    d[1] = c.y;
                    d[2] = c.z;
                    d[3] = c.w;
                    this._setParameter("texture_" + a, d)
                }
            }
        },
        getUniform: function(a, b, c) {
            return (a = re[a]) ? a(this, b, c) : null
        },
        updateUniforms: function() {
            this._clearParameters();
            this._setParameter("material_ambient", this.ambientUniform);
            this.diffuseMap && !this.diffuseTint || this._setParameter("material_diffuse", this.diffuseUniform);
            this.useMetalness ? ((!this.metalnessMap ||
                1 > this.metalness) && this._setParameter("material_metalness", this.metalness), this.enableGGXSpecular && this._setParameter("material_anisotropy", this.anisotropy)) : this.specularMap && !this.specularTint || this._setParameter("material_specular", this.specularUniform);
            0 < this.clearCoat && (this._setParameter("material_clearCoat", this.clearCoat), this._setParameter("material_clearCoatGlossiness", this.clearCoatGlossiness), this._setParameter("material_clearCoatReflectivity", this.clearCoat), this._setParameter("material_clearCoatBumpiness",
                this.clearCoatBumpiness));
            var a = this.getUniform("shininess", this.shininess, !0);
            this._setParameter(a.name, a.value);
            this.emissiveMap && !this.emissiveTint || this._setParameter("material_emissive", this.emissiveUniform);
            this.emissiveMap && this._setParameter("material_emissiveIntensity", this.emissiveIntensity);
            0 < this.refraction && (this._setParameter("material_refraction", this.refraction), this._setParameter("material_refractionIndex", this.refractionIndex));
            this._setParameter("material_opacity", this.opacity);
            !1 === this.opacityFadesSpecular && this._setParameter("material_alphaFade", this.alphaFade);
            this.occludeSpecular && this._setParameter("material_occludeSpecularIntensity", this.occludeSpecularIntensity);
            1 === this.cubeMapProjection && this._setParameter(this.getUniform("cubeMapProjectionBox", this.cubeMapProjectionBox, !0));
            for (var b in Ac) this._updateMap(b);
            this.ambientSH && this._setParameter("ambientSH[0]", this.ambientSH);
            this.normalMap && this._setParameter("material_bumpiness", this.bumpiness);
            this.normalMap &&
                this.normalDetailMap && this._setParameter("material_normalDetailMapBumpiness", this.normalDetailMapBumpiness);
            this.heightMap && (a = this.getUniform("heightMapFactor", this.heightMapFactor, !0), this._setParameter(a.name, a.value));
            this.cubeMap && this._setParameter("texture_cubeMap", this.cubeMap);
            this.prefilteredCubeMap128 ? this._setParameter("texture_prefilteredCubeMap128", this.prefilteredCubeMap128) : this._scene && this._scene._skyboxPrefiltered[0] && this._setParameter("texture_prefilteredCubeMap128", this._scene._skyboxPrefiltered[0]);
            this.prefilteredCubeMap64 ? this._setParameter("texture_prefilteredCubeMap64", this.prefilteredCubeMap64) : this._scene && this._scene._skyboxPrefiltered[1] && this._setParameter("texture_prefilteredCubeMap64", this._scene._skyboxPrefiltered[1]);
            this.prefilteredCubeMap32 ? this._setParameter("texture_prefilteredCubeMap32", this.prefilteredCubeMap32) : this._scene && this._scene._skyboxPrefiltered[2] && this._setParameter("texture_prefilteredCubeMap32", this._scene._skyboxPrefiltered[2]);
            this.prefilteredCubeMap16 ? this._setParameter("texture_prefilteredCubeMap16",
                this.prefilteredCubeMap16) : this._scene && this._scene._skyboxPrefiltered[3] && this._setParameter("texture_prefilteredCubeMap16", this._scene._skyboxPrefiltered[3]);
            this.prefilteredCubeMap8 ? this._setParameter("texture_prefilteredCubeMap8", this.prefilteredCubeMap8) : this._scene && this._scene._skyboxPrefiltered[4] && this._setParameter("texture_prefilteredCubeMap8", this._scene._skyboxPrefiltered[4]);
            this.prefilteredCubeMap4 ? this._setParameter("texture_prefilteredCubeMap4", this.prefilteredCubeMap4) : this._scene &&
                this._scene._skyboxPrefiltered[5] && this._setParameter("texture_prefilteredCubeMap4", this._scene._skyboxPrefiltered[5]);
            this.sphereMap && this._setParameter("texture_sphereMap", this.sphereMap);
            this.dpAtlas && this._setParameter("texture_sphereMap", this.dpAtlas);
            this._setParameter("material_reflectivity", this.reflectivity);
            if (this.dirtyShader || !this._scene) this.shader = null, this.clearVariants();
            this._processColor()
        },
        _processColor: function() {
            var a;
            if (this.dirtyColor && (this._scene || !this.useGammaTonemap)) {
                var b = !1;
                this.useGammaTonemap && (b = this._scene.gammaCorrection);
                for (a = 0; a < Xh.length; a++) {
                    var c = this["_" + Xh[a]],
                        d = this[Xh[a] + "Uniform"];
                    b ? (d[0] = Math.pow(c.r, 2.2), d[1] = Math.pow(c.g, 2.2), d[2] = Math.pow(c.b, 2.2)) : (d[0] = c.r, d[1] = c.g, d[2] = c.b)
                }
                for (a = 0; 3 > a; a++) this.emissiveUniform[a] *= this.emissiveIntensity;
                this.dirtyColor = !1
            }
        },
        updateShader: function(a, b, c, d, e, f) {
            !this._colorProcessed && this._scene && (this._colorProcessed = !0, this._processColor());
            var g = a.useTexCubeLod,
                k = !a.extTextureLod;
            if (this.useSkybox) {
                var h = b._skyboxPrefiltered[0];
                var l = b._skyboxPrefiltered[1];
                var n = b._skyboxPrefiltered[2];
                var p = b._skyboxPrefiltered[3];
                var q = b._skyboxPrefiltered[4];
                var r = b._skyboxPrefiltered[5]
            }
            h = this.prefilteredCubeMap128 || h;
            l = this.prefilteredCubeMap64 || l;
            n = this.prefilteredCubeMap32 || n;
            p = this.prefilteredCubeMap16 || p;
            q = this.prefilteredCubeMap8 || q;
            r = this.prefilteredCubeMap4 || r;
            if (h) {
                var t = h && l && n && p && q && r;
                if (k && t) {
                    if (!h.dpAtlas) {
                        g = [h, l, n, p, q, r];
                        k = new X;
                        r = new X;
                        l = 4 * g[0].width;
                        q = Wa(a, F.fullscreenQuadVS, F.dpAtlasQuadPS, "dpAtlasQuad");
                        n = a.scope.resolve("source");
                        t = a.scope.resolve("params");
                        var u = new V(a, {
                            type: g[0].type,
                            format: g[0].format,
                            width: l,
                            height: l,
                            mipmaps: !1
                        });
                        u.name = "paraboloid";
                        for (var x = new sa(a, u, {
                                depth: !1
                            }), v = (l + 2) / l - 1, w = 0; 6 > w; w++) {
                            var y = a;
                            var A = g[w],
                                B = w,
                                E = Wa(y, F.fullscreenQuadVS, (A.fixCubemapSeams ? F.fixCubemapSeamsStretchPS : F.fixCubemapSeamsNonePS) + F.genParaboloidPS, "genParaboloid"),
                                D = y.scope.resolve("source"),
                                C = y.scope.resolve("params"),
                                G = new X,
                                K = A.width,
                                R = A.format;
                            K = 2 * Math.max(K, 8);
                            K = new V(y, {
                                type: A.type,
                                format: R,
                                width: 2 * K,
                                height: K,
                                mipmaps: !1
                            });
                            K.name = "paraboloid";
                            R = new sa(y, K, {
                                depth: !1
                            });
                            G.x = B;
                            G.y = 1;
                            D.setValue(A);
                            C.setValue(G.data);
                            La(y, R, E);
                            y = K;
                            n.setValue(y);
                            y = k;
                            A = w;
                            y.x = .5 * N.clamp(A - 2, 0, 1);
                            A -= 6 * y.x;
                            B = 1 - y.x;
                            y.y = Math.min(.5 * A, .75) * B + y.x;
                            y.z = (1 - .5 * N.clamp(A, 0, 1)) * B;
                            y.w = .5 * y.z;
                            y = 1 / y.z;
                            r.x = y * v;
                            r.y = 2 * r.x;
                            r.x += 1;
                            r.y += 1;
                            t.setValue(r.data);
                            k.x *= l;
                            k.y *= l;
                            k.z *= l;
                            k.w *= l;
                            La(a, x, q, k)
                        }
                        h.dpAtlas = u;
                        h.sh = Nl(p)
                    }
                    this.dpAtlas = h.dpAtlas;
                    this.ambientSH = h.sh;
                    this._setParameter("ambientSH[0]", this.ambientSH);
                    this._setParameter("texture_sphereMap", this.dpAtlas)
                } else g ?
                    6 > h._levels.length ? t ? this._setParameter("texture_prefilteredCubeMap128", h) : console.log("Can't use prefiltered cubemap: " + t + ", " + g + ", " + h._levels) : this._setParameter("texture_prefilteredCubeMap128", h) : t ? (this._setParameter("texture_prefilteredCubeMap128", h), this._setParameter("texture_prefilteredCubeMap64", l), this._setParameter("texture_prefilteredCubeMap32", n), this._setParameter("texture_prefilteredCubeMap16", p), this._setParameter("texture_prefilteredCubeMap8", q), this._setParameter("texture_prefilteredCubeMap4",
                        r)) : console.log("Can't use prefiltered cubemap: " + t + ", " + g + ", " + h._levels);
                this.useSkybox && !b.skyboxRotation.equals(Y.IDENTITY) && b._skyboxRotationMat3 && this._setParameter("cubeMapRotationMatrix", b._skyboxRotationMat3.data)
            }
            g = (p = 1 < e && 18 >= e) ? Uj.optionsContextMin : Uj.optionsContext;
            p ? this.shaderOptBuilder.updateMinRef(g, a, b, this, c, d, e, f, h) : this.shaderOptBuilder.updateRef(g, a, b, this, c, d, e, f, h);
            this.onUpdateShader && (g = this.onUpdateShader(g));
            this.shader = a.getProgramLibrary().getProgram("standard", g);
            c ||
                (this.clearVariants(), this.variants[0] = this.shader);
            this.dirtyShader = !1
        }
    });
    (function(a) {
        a.dirtyShader = !0;
        a.dirtyColor = !0;
        a._scene = null;
        a._colorProcessed = !1;
        Yh(a, "ambient", new L(.7, .7, .7));
        Yh(a, "diffuse", new L(1, 1, 1));
        Yh(a, "specular", new L(0, 0, 0));
        Yh(a, "emissive", new L(0, 0, 0), !0);
        gb(a, "shininess", 25, function(c, d) {
            return {
                name: "material_shininess",
                value: 0 === c.shadingModel ? Math.pow(2, .11 * d) : .01 * d
            }
        });
        gb(a, "heightMapFactor", 1, function(c, d) {
            return {
                name: "material_heightMapFactor",
                value: .025 * d
            }
        });
        gb(a, "opacity",
            1);
        gb(a, "alphaFade", 1);
        gb(a, "alphaTest", 0);
        gb(a, "bumpiness", 1);
        gb(a, "normalDetailMapBumpiness", 1);
        gb(a, "reflectivity", 1);
        gb(a, "occludeSpecularIntensity", 1);
        gb(a, "refraction", 0);
        gb(a, "refractionIndex", 1 / 1.5);
        gb(a, "metalness", 1);
        gb(a, "anisotropy", 0);
        gb(a, "clearCoat", 0);
        gb(a, "clearCoatGlossiness", 1);
        gb(a, "clearCoatBumpiness", 1);
        gb(a, "aoUvSet", 0, null);
        sc(a, "ambientSH", function(c, d, e) {
            return {
                name: "ambientSH[0]",
                value: d
            }
        });
        sc(a, "cubeMapProjectionBox", function(c, d, e) {
            var f = e ? c.cubeMapMinUniform : new Float32Array(3);
            c = e ? c.cubeMapMaxUniform : new Float32Array(3);
            f[0] = d.center.x - d.halfExtents.x;
            f[1] = d.center.y - d.halfExtents.y;
            f[2] = d.center.z - d.halfExtents.z;
            c[0] = d.center.x + d.halfExtents.x;
            c[1] = d.center.y + d.halfExtents.y;
            c[2] = d.center.z + d.halfExtents.z;
            return [{
                name: "envBoxMin",
                value: f
            }, {
                name: "envBoxMax",
                value: c
            }]
        });
        bq();
        Ca(a, "ambientTint", !1);
        Ca(a, "diffuseTint", !1);
        Ca(a, "specularTint", !1);
        Ca(a, "emissiveTint", !1);
        Ca(a, "fastTbn", !1);
        Ca(a, "specularAntialias", !1);
        Ca(a, "useMetalness", !1);
        Ca(a, "enableGGXSpecular", !1);
        Ca(a,
            "occludeDirect", !1);
        Ca(a, "normalizeNormalMap", !0);
        Ca(a, "conserveEnergy", !0);
        Ca(a, "opacityFadesSpecular", !0);
        Ca(a, "occludeSpecular", 1);
        Ca(a, "shadingModel", 1);
        Ca(a, "fresnelModel", 0);
        Ca(a, "cubeMapProjection", 0);
        Ca(a, "customFragmentShader", null);
        Ca(a, "forceFragmentPrecision", null);
        Ca(a, "useFog", !0);
        Ca(a, "useLighting", !0);
        Ca(a, "useGammaTonemap", !0);
        Ca(a, "useSkybox", !0);
        Ca(a, "forceUv1", !1);
        Ca(a, "pixelSnap", !1);
        Ca(a, "twoSidedLighting", !1);
        Ca(a, "nineSlicedMode", void 0);
        qb(a, "diffuse", 0, 3, "", !0);
        qb(a, "specular",
            0, 3, "", !0);
        qb(a, "emissive", 0, 3, "", !0);
        qb(a, "normal", 0, -1, "", !1);
        qb(a, "metalness", 0, 1, "", !0);
        qb(a, "gloss", 0, 1, "", !0);
        qb(a, "opacity", 0, 1, "a", !0);
        qb(a, "height", 0, 1, "", !1);
        qb(a, "ao", 0, 1, "", !0);
        qb(a, "light", 1, 3, "", !0);
        qb(a, "msdf", 0, 3, "", !1);
        qb(a, "diffuseDetail", 0, 3, "", !1, !0);
        qb(a, "normalDetail", 0, -1, "", !1);
        qb(a, "clearCoat", 0, 1, "", !0);
        qb(a, "clearCoatGloss", 0, 1, "", !0);
        qb(a, "clearCoatNormal", 0, -1, "", !1);
        sc(a, "cubeMap");
        sc(a, "sphereMap");
        sc(a, "dpAtlas");
        sc(a, "prefilteredCubeMap128");
        sc(a, "prefilteredCubeMap64");
        sc(a, "prefilteredCubeMap32");
        sc(a, "prefilteredCubeMap16");
        sc(a, "prefilteredCubeMap8");
        sc(a, "prefilteredCubeMap4");
        tc(a, "diffuseTint", "diffuseMapTint");
        tc(a, "specularTint", "specularMapTint");
        tc(a, "emissiveTint", "emissiveMapTint");
        tc(a, "aoVertexColor", "aoMapVertexColor");
        tc(a, "diffuseVertexColor", "diffuseMapVertexColor");
        tc(a, "specularVertexColor", "specularMapVertexColor");
        tc(a, "emissiveVertexColor", "emissiveMapVertexColor");
        tc(a, "metalnessVertexColor", "metalnessMapVertexColor");
        tc(a, "glossVertexColor",
            "glossMapVertexColor");
        tc(a, "opacityVertexColor", "opacityMapVertexColor");
        tc(a, "lightVertexColor", "lightMapVertexColor");
        for (var b = 0; b < Ra.length; b++) ln[b] = a[Ra[b]];
        a._propsSet = []
    })(ma.prototype);
    Jb.prototype.register = function(a, b) {
        this.isRegistered(a) || (this._generators[a] = b)
    };
    Jb.prototype.unregister = function(a) {
        this.isRegistered(a) && delete this._generators[a]
    };
    Jb.prototype.isRegistered = function(a) {
        return void 0 !== this._generators[a]
    };
    Jb.prototype.getProgram = function(a, b) {
        var c = this._generators[a];
        if (void 0 === c) return null;
        var d = this._device,
            e = c.generateKey(b),
            f = this._cache[e];
        if (!f) {
            if (b.lights) {
                var g = b.lights;
                b.lights = g.map(function(k) {
                    var h = k.clone ? k.clone() : k;
                    h.key = k.key;
                    return h
                })
            }
            this.storeNewProgram(a, b);
            b.lights && (b.lights = g);
            this._precached && console.warn("ProgramLibrary#getProgram: Cache miss for shader", a, "key", e, "after shaders precaching");
            a = c.createShaderDefinition(d, b);
            f = this._cache[e] = new te(d, a)
        }
        return f
    };
    Jb.prototype.storeNewProgram = function(a, b) {
        var c = {};
        if ("standard" === a) {
            var d =
                this._getDefaultStdMatOptions(b.pass),
                e;
            for (e in b)
                if (b.hasOwnProperty(e) && d[e] !== b[e] || "pass" === e) c[e] = b[e]
        } else c = b;
        this._programsCollection.push(JSON.stringify({
            name: a,
            options: c
        }))
    };
    Jb.prototype.dumpPrograms = function() {
        var a = "var device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\nvar shaders = [";
        this._programsCollection[0] && (a += "\n\t" + this._programsCollection[0]);
        for (var b = 1; b < this._programsCollection.length; ++b) a += ",\n\t" + this._programsCollection[b];
        a +=
            '\n];\ndevice.programLib.precompile(shaders);\nif (pc.version != "1.37.0" || pc.revision != "ef8e593")\n\tconsole.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';
        b = document.createElement("a");
        b.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(a));
        b.setAttribute("download", "precompile-shaders.js");
        b.style.display = "none";
        document.body.appendChild(b);
        b.click();
        document.body.removeChild(b)
    };
    Jb.prototype.clearCache = function() {
        var a =
            this._cache;
        this._isClearingCache = !0;
        for (var b in a) a.hasOwnProperty(b) && a[b].destroy();
        this._cache = {};
        this._isClearingCache = !1
    };
    Jb.prototype.removeFromCache = function(a) {
        if (!this._isClearingCache) {
            var b = this._cache,
                c;
            for (c in b)
                if (b.hasOwnProperty(c) && b[c] === a) {
                    delete b[c];
                    break
                }
        }
    };
    Jb.prototype._getDefaultStdMatOptions = function(a) {
        return 1 < a && 18 >= a ? this._defaultStdMatOptionMin : this._defaultStdMatOption
    };
    Jb.prototype.precompile = function(a) {
        if (a)
            for (var b = Array(a.length), c = 0; c < a.length; c++) {
                if ("standard" ===
                    a[c].name) {
                    var d = a[c].options,
                        e = this._getDefaultStdMatOptions(d.pass),
                        f;
                    for (f in e) e.hasOwnProperty(f) && void 0 === d[f] && (d[f] = e[f]);
                    d.useTexCubeLod = this._device.useTexCubeLod
                }
                b[c] = this.getProgram(a[c].name, a[c].options)
            }
        this._precached = !0
    };
    Object.assign(Aj.prototype, {
        equals: function(a) {
            return this.globalId === a.globalId && this.revision === a.revision
        },
        notequals: function(a) {
            return this.globalId !== a.globalId || this.revision !== a.revision
        },
        copy: function(a) {
            this.globalId = a.globalId;
            this.revision = a.revision
        },
        reset: function() {
            this.revision = this.globalId = 0
        }
    });
    var Ll = 0;
    Object.assign(Kl.prototype, {
        increment: function() {
            this.version.revision++
        }
    });
    Object.assign(ch.prototype, {
        setValue: function(a) {
            this.value = a;
            this.versionObject.increment()
        },
        getValue: function() {
            return this.value
        }
    });
    Object.assign(dh.prototype, {
        resolve: function(a) {
            this.variables.hasOwnProperty(a) || (this.variables[a] = new ch(a));
            return this.variables[a]
        },
        getSubSpace: function(a) {
            this.namespaces.hasOwnProperty(a) || (this.namespaces[a] = new dh(a));
            return this.namespaces[a]
        }
    });
    var nn = function(a, b) {
            var c = a.width,
                d = a.height;
            if (c > b || d > b) {
                var e = b / Math.max(c, d),
                    f = Math.floor(c * e);
                e = Math.floor(d * e);
                console.warn("Image dimensions larger than max supported texture size of " + b + ". Resizing from " + c + ", " + d + " to " + f + ", " + e + ".");
                b = document.createElement("canvas");
                b.width = f;
                b.height = e;
                b.getContext("2d").drawImage(a, 0, 0, c, d, 0, 0, f, e);
                return b
            }
            return a
        },
        jb = function(a, b) {
            M.call(this);
            var c;
            this.canvas = a;
            this.indexBuffer = this.shader = null;
            this.vertexBuffers = [];
            this._enableAutoInstancing = !1;
            this.autoInstancingMaxObjects = 16384;
            this.activeFramebuffer = this.transformFeedbackBuffer = this.boundVao = this.defaultFramebuffer = null;
            this.textureUnit = 0;
            this.textureUnits = [];
            this._maxPixelRatio = 1;
            this.feedback = this.renderTarget = null;
            this._tempEnableSafariTextureUnitWorkaround = !!window.safari;
            this._height = this._width = 0;
            this.updateClientRect();
            this.vertexShaderCache = {};
            this.fragmentShaderCache = {};
            this.shaders = [];
            this.buffers = [];
            this.textures = [];
            this.targets = [];
            this._vaoMap = new Map;
            this.contextLost = !1;
            this._contextLostHandler = function(q) {
                q.preventDefault();
                this.contextLost = !0;
                this.fire("devicelost")
            }.bind(this);
            this._contextRestoredHandler = function() {
                this.initializeContext();
                this.contextLost = !1;
                this.fire("devicerestored")
            }.bind(this);
            var d = b && void 0 !== b.preferWebGl2 ? b.preferWebGl2 : !0,
                e = d ? ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"],
                f = null;
            b = b || {};
            b.stencil = !0;
            for (c = 0; c < e.length; c++) {
                try {
                    f = a.getContext(e[c], b)
                } catch (q) {}
                if (f) {
                    this.webgl2 = d && 2 > c;
                    break
                }
            }
            if (!f) throw Error("WebGL not supported");
            this.gl = f;
            window.setupVertexArrayObject(f);
            a.addEventListener("webglcontextlost", this._contextLostHandler, !1);
            a.addEventListener("webglcontextrestored", this._contextRestoredHandler, !1);
            this.initializeExtensions();
            this.initializeCapabilities();
            this.initializeRenderState();
            for (c = 0; c < this.maxCombinedTextures; c++) this.textureUnits.push([null, null, null]);
            this.defaultClearOptions = {
                color: [0, 0, 0, 1],
                depth: 1,
                stencil: 0,
                flags: 3
            };
            this.glAddress = [f.REPEAT, f.CLAMP_TO_EDGE, f.MIRRORED_REPEAT];
            this.glBlendEquation = [f.FUNC_ADD, f.FUNC_SUBTRACT, f.FUNC_REVERSE_SUBTRACT, this.webgl2 ? f.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : f.FUNC_ADD, this.webgl2 ? f.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : f.FUNC_ADD];
            this.glBlendFunction = [f.ZERO, f.ONE, f.SRC_COLOR, f.ONE_MINUS_SRC_COLOR, f.DST_COLOR, f.ONE_MINUS_DST_COLOR, f.SRC_ALPHA, f.SRC_ALPHA_SATURATE, f.ONE_MINUS_SRC_ALPHA, f.DST_ALPHA, f.ONE_MINUS_DST_ALPHA];
            this.glComparison = [f.NEVER, f.LESS, f.EQUAL, f.LEQUAL, f.GREATER, f.NOTEQUAL, f.GEQUAL, f.ALWAYS];
            this.glStencilOp = [f.KEEP, f.ZERO, f.REPLACE, f.INCR, f.INCR_WRAP, f.DECR, f.DECR_WRAP, f.INVERT];
            this.glClearFlag = [0, f.COLOR_BUFFER_BIT, f.DEPTH_BUFFER_BIT, f.COLOR_BUFFER_BIT | f.DEPTH_BUFFER_BIT, f.STENCIL_BUFFER_BIT, f.STENCIL_BUFFER_BIT | f.COLOR_BUFFER_BIT, f.STENCIL_BUFFER_BIT | f.DEPTH_BUFFER_BIT, f.STENCIL_BUFFER_BIT | f.COLOR_BUFFER_BIT | f.DEPTH_BUFFER_BIT];
            this.glCull = [0, f.BACK, f.FRONT, f.FRONT_AND_BACK];
            this.glFilter = [f.NEAREST, f.LINEAR, f.NEAREST_MIPMAP_NEAREST, f.NEAREST_MIPMAP_LINEAR, f.LINEAR_MIPMAP_NEAREST, f.LINEAR_MIPMAP_LINEAR];
            this.glPrimitive = [f.POINTS, f.LINES, f.LINE_LOOP, f.LINE_STRIP, f.TRIANGLES, f.TRIANGLE_STRIP, f.TRIANGLE_FAN];
            this.glType = [f.BYTE, f.UNSIGNED_BYTE, f.SHORT, f.UNSIGNED_SHORT, f.INT, f.UNSIGNED_INT, f.FLOAT];
            this.pcUniformType = {};
            this.pcUniformType[f.BOOL] = 0;
            this.pcUniformType[f.INT] = 1;
            this.pcUniformType[f.FLOAT] = 2;
            this.pcUniformType[f.FLOAT_VEC2] = 3;
            this.pcUniformType[f.FLOAT_VEC3] = 4;
            this.pcUniformType[f.FLOAT_VEC4] = 5;
            this.pcUniformType[f.INT_VEC2] = 6;
            this.pcUniformType[f.INT_VEC3] = 7;
            this.pcUniformType[f.INT_VEC4] =
                8;
            this.pcUniformType[f.BOOL_VEC2] = 9;
            this.pcUniformType[f.BOOL_VEC3] = 10;
            this.pcUniformType[f.BOOL_VEC4] = 11;
            this.pcUniformType[f.FLOAT_MAT2] = 12;
            this.pcUniformType[f.FLOAT_MAT3] = 13;
            this.pcUniformType[f.FLOAT_MAT4] = 14;
            this.pcUniformType[f.SAMPLER_2D] = 15;
            this.pcUniformType[f.SAMPLER_CUBE] = 16;
            this.webgl2 && (this.pcUniformType[f.SAMPLER_2D_SHADOW] = 18, this.pcUniformType[f.SAMPLER_CUBE_SHADOW] = 19, this.pcUniformType[f.SAMPLER_3D] = 20);
            this.targetToSlot = {};
            this.targetToSlot[f.TEXTURE_2D] = 0;
            this.targetToSlot[f.TEXTURE_CUBE_MAP] =
                1;
            this.targetToSlot[f.TEXTURE_3D] = 2;
            var g, k, h, l, n;
            this.commitFunction = [];
            this.commitFunction[0] = function(q, r) {
                q.value !== r && (f.uniform1i(q.locationId, r), q.value = r)
            };
            this.commitFunction[1] = this.commitFunction[0];
            this.commitFunction[2] = function(q, r) {
                q.value !== r && (f.uniform1f(q.locationId, r), q.value = r)
            };
            this.commitFunction[3] = function(q, r) {
                n = q.value;
                g = r[0];
                k = r[1];
                if (n[0] !== g || n[1] !== k) f.uniform2fv(q.locationId, r), n[0] = g, n[1] = k
            };
            this.commitFunction[4] = function(q, r) {
                n = q.value;
                g = r[0];
                k = r[1];
                h = r[2];
                if (n[0] !==
                    g || n[1] !== k || n[2] !== h) f.uniform3fv(q.locationId, r), n[0] = g, n[1] = k, n[2] = h
            };
            this.commitFunction[5] = function(q, r) {
                n = q.value;
                g = r[0];
                k = r[1];
                h = r[2];
                l = r[3];
                if (n[0] !== g || n[1] !== k || n[2] !== h || n[3] !== l) f.uniform4fv(q.locationId, r), n[0] = g, n[1] = k, n[2] = h, n[3] = l
            };
            this.commitFunction[6] = function(q, r) {
                n = q.value;
                g = r[0];
                k = r[1];
                if (n[0] !== g || n[1] !== k) f.uniform2iv(q.locationId, r), n[0] = g, n[1] = k
            };
            this.commitFunction[9] = this.commitFunction[6];
            this.commitFunction[7] = function(q, r) {
                n = q.value;
                g = r[0];
                k = r[1];
                h = r[2];
                if (n[0] !== g ||
                    n[1] !== k || n[2] !== h) f.uniform3iv(q.locationId, r), n[0] = g, n[1] = k, n[2] = h
            };
            this.commitFunction[10] = this.commitFunction[7];
            this.commitFunction[8] = function(q, r) {
                n = q.value;
                g = r[0];
                k = r[1];
                h = r[2];
                l = r[3];
                if (n[0] !== g || n[1] !== k || n[2] !== h || n[3] !== l) f.uniform4iv(q.locationId, r), n[0] = g, n[1] = k, n[2] = h, n[3] = l
            };
            this.commitFunction[11] = this.commitFunction[8];
            this.commitFunction[12] = function(q, r) {
                f.uniformMatrix2fv(q.locationId, !1, r)
            };
            this.commitFunction[13] = function(q, r) {
                f.uniformMatrix3fv(q.locationId, !1, r)
            };
            this.commitFunction[14] =
                function(q, r) {
                    f.uniformMatrix4fv(q.locationId, !1, r)
                };
            this.commitFunction[17] = function(q, r) {
                f.uniform1fv(q.locationId, r)
            };
            this.commitFunction[21] = function(q, r) {
                f.uniform2fv(q.locationId, r)
            };
            this.commitFunction[22] = function(q, r) {
                f.uniform3fv(q.locationId, r)
            };
            this.commitFunction[23] = function(q, r) {
                f.uniform4fv(q.locationId, r)
            };
            this.scope = new dh("Device");
            this.programLib = new Jb(this);
            for (var p in qh) this.programLib.register(p, qh[p]);
            this.supportsBoneTextures = this.extTextureFloat && 0 < this.maxVertexTextures;
            this.useTexCubeLod = this.extTextureLod && 16 > this.maxTextures;
            this.boneLimit = Math.floor((this.vertexUniformsCount - 16 - 8 - 1 - 16) / 3);
            this.boneLimit = Math.min(this.boneLimit, 128);
            "Mali-450 MP" === this.unmaskedRenderer && (this.boneLimit = 34);
            this._shaderSwitchesPerFrame = this._drawCallsPerFrame = 0;
            this._primsPerFrame = [];
            for (c = 0; 6 >= c; c++) this._primsPerFrame[c] = 0;
            this._renderTargetCreationTime = 0;
            this._vram = {
                tex: 0,
                vb: 0,
                ib: 0
            };
            this._shaderStats = {
                vsCompiled: 0,
                fsCompiled: 0,
                linked: 0,
                materialShaders: 0,
                compileTime: 0
            };
            this.constantTexSource =
                this.scope.resolve("source");
            this.textureFloatRenderable = this.extTextureFloat ? this.webgl2 ? !!this.extColorBufferFloat : Ml(f, f.FLOAT) : !1;
            this.textureHalfFloatRenderable = this.extTextureHalfFloat ? this.webgl2 ? !!this.extColorBufferFloat : Ml(f, this.extTextureHalfFloat.HALF_FLOAT_OES) : !1;
            this.supportsMorphTargetTexturesCore = "highp" === this.maxPrecision && 2 <= this.maxVertexTextures;
            this._textureHalfFloatUpdatable = this._textureFloatHighPrecision = void 0;
            this.createGrabPass();
            Na.init(this)
        };
    jb.prototype = Object.create(M.prototype);
    jb.prototype.constructor = jb;
    Object.assign(jb.prototype, {
        getPrecision: function() {
            var a = this.gl,
                b = "highp";
            if (a.getShaderPrecisionFormat) {
                var c = a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT),
                    d = a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT),
                    e = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
                a = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT);
                d = 0 < d.precision && 0 < a.precision;
                0 < c.precision && 0 < e.precision || (b = d ? "mediump" : "lowp")
            }
            return b
        },
        initializeExtensions: function() {
            var a =
                this.gl,
                b = a.getSupportedExtensions(),
                c = function() {
                    for (var e = 0; e < arguments.length; e++)
                        if (-1 !== b.indexOf(arguments[e])) return a.getExtension(arguments[e]);
                    return null
                };
            if (this.webgl2) this.extVertexArrayObject = this.extUintElement = this.extTextureLod = this.extTextureHalfFloatLinear = this.extTextureHalfFloat = this.extTextureFloat = this.extStandardDerivatives = this.extInstancing = this.extDrawBuffers = this.extBlendMinmax = !0, this.extColorBufferFloat = c("EXT_color_buffer_float"), this.extDisjointTimerQuery = c("EXT_disjoint_timer_query_webgl2",
                "EXT_disjoint_timer_query");
            else {
                this.extBlendMinmax = c("EXT_blend_minmax");
                this.extDrawBuffers = c("EXT_draw_buffers");
                if (this.extInstancing = c("ANGLE_instanced_arrays")) {
                    var d = this.extInstancing;
                    a.drawArraysInstanced = d.drawArraysInstancedANGLE.bind(d);
                    a.drawElementsInstanced = d.drawElementsInstancedANGLE.bind(d);
                    a.vertexAttribDivisor = d.vertexAttribDivisorANGLE.bind(d)
                }
                this.extStandardDerivatives = c("OES_standard_derivatives");
                this.extTextureFloat = c("OES_texture_float");
                this.extTextureHalfFloat = c("OES_texture_half_float");
                this.extTextureHalfFloatLinear = c("OES_texture_half_float_linear");
                this.extTextureLod = c("EXT_shader_texture_lod");
                this.extUintElement = c("OES_element_index_uint");
                if (this.extVertexArrayObject = c("OES_vertex_array_object")) d = this.extVertexArrayObject, a.createVertexArray = d.createVertexArrayOES.bind(d), a.deleteVertexArray = d.deleteVertexArrayOES.bind(d), a.isVertexArray = d.isVertexArrayOES.bind(d), a.bindVertexArray = d.bindVertexArrayOES.bind(d);
                this.extDisjointTimerQuery = this.extColorBufferFloat = null
            }
            this.extDebugRendererInfo =
                c("WEBGL_debug_renderer_info");
            this.extTextureFloatLinear = c("OES_texture_float_linear");
            this.extFloatBlend = c("EXT_float_blend");
            this.extTextureFilterAnisotropic = c("EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic");
            this.extCompressedTextureETC1 = c("WEBGL_compressed_texture_etc1");
            this.extCompressedTextureETC = c("WEBGL_compressed_texture_etc");
            this.extCompressedTexturePVRTC = c("WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc");
            this.extCompressedTextureS3TC =
                c("WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc");
            this.extCompressedTextureATC = c("WEBGL_compressed_texture_atc");
            this.extCompressedTextureASTC = c("WEBGL_compressed_texture_astc");
            this.extParallelShaderCompile = c("KHR_parallel_shader_compile");
            this.supportsInstancing = !!this.extInstancing
        },
        initializeCapabilities: function() {
            var a = this.gl;
            this.maxPrecision = this.precision = this.getPrecision();
            var b = a.getContextAttributes();
            this.supportsMsaa = b.antialias;
            this.supportsStencil = b.stencil;
            this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            this.maxCubeMapSize = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxRenderBufferSize = a.getParameter(a.MAX_RENDERBUFFER_SIZE);
            this.maxTextures = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
            this.maxCombinedTextures = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.vertexUniformsCount = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS);
            this.fragmentUniformsCount = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS);
            this.webgl2 ? (this.maxDrawBuffers = a.getParameter(a.MAX_DRAW_BUFFERS), this.maxColorAttachments = a.getParameter(a.MAX_COLOR_ATTACHMENTS), this.maxVolumeSize = a.getParameter(a.MAX_3D_TEXTURE_SIZE)) : (this.maxDrawBuffers = (b = this.extDrawBuffers) ? a.getParameter(b.MAX_DRAW_BUFFERS_EXT) : 1, this.maxColorAttachments = b ? a.getParameter(b.MAX_COLOR_ATTACHMENTS_EXT) : 1, this.maxVolumeSize = 1);
            this.unmaskedRenderer = (b = this.extDebugRendererInfo) ? a.getParameter(b.UNMASKED_RENDERER_WEBGL) : "";
            this.unmaskedVendor = b ? a.getParameter(b.UNMASKED_VENDOR_WEBGL) :
                "";
            this.maxAnisotropy = (b = this.extTextureFilterAnisotropic) ? a.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
            this.samples = a.getParameter(a.SAMPLES)
        },
        initializeRenderState: function() {
            var a = this.gl;
            this.blending = !1;
            a.disable(a.BLEND);
            this.blendSrc = 1;
            this.blendDst = 0;
            this.blendSrcAlpha = 1;
            this.blendDstAlpha = 0;
            this.separateAlphaBlend = !1;
            this.blendAlphaEquation = this.blendEquation = 0;
            this.separateAlphaEquation = !1;
            a.blendFunc(a.ONE, a.ZERO);
            a.blendEquation(a.FUNC_ADD);
            this.writeAlpha = this.writeBlue = this.writeGreen =
                this.writeRed = !0;
            a.colorMask(!0, !0, !0, !0);
            this.cullMode = 1;
            a.enable(a.CULL_FACE);
            a.cullFace(a.BACK);
            this.depthTest = !0;
            a.enable(a.DEPTH_TEST);
            this.depthFunc = 3;
            a.depthFunc(a.LEQUAL);
            this.depthWrite = !0;
            a.depthMask(!0);
            this.stencil = !1;
            a.disable(a.STENCIL_TEST);
            this.stencilFuncFront = this.stencilFuncBack = 7;
            this.stencilRefFront = this.stencilRefBack = 0;
            this.stencilMaskFront = this.stencilMaskBack = 255;
            a.stencilFunc(a.ALWAYS, 0, 255);
            this.stencilZpassFront = this.stencilZpassBack = this.stencilZfailFront = this.stencilZfailBack =
                this.stencilFailFront = this.stencilFailBack = 0;
            this.stencilWriteMaskBack = this.stencilWriteMaskFront = 255;
            a.stencilOp(a.KEEP, a.KEEP, a.KEEP);
            a.stencilMask(255);
            this.alphaToCoverage = !1;
            this.raster = !0;
            this.webgl2 && (a.disable(a.SAMPLE_ALPHA_TO_COVERAGE), a.disable(a.RASTERIZER_DISCARD));
            this.depthBiasEnabled = !1;
            a.disable(a.POLYGON_OFFSET_FILL);
            this.clearDepth = 1;
            a.clearDepth(1);
            this.clearAlpha = this.clearGreen = this.clearBlue = this.clearRed = 0;
            a.clearColor(0, 0, 0, 0);
            this.clearStencil = 0;
            a.clearStencil(0);
            this.sx =
                this.sy = this.sw = this.sh = this.vx = this.vy = this.vw = this.vh = 0;
            this.webgl2 ? a.hint(a.FRAGMENT_SHADER_DERIVATIVE_HINT, a.NICEST) : this.extStandardDerivatives && a.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, a.NICEST);
            a.enable(a.SCISSOR_TEST);
            a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL, a.NONE);
            this.unpackFlipY = !1;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1);
            this.unpackPremultiplyAlpha = !1;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1)
        },
        initializeContext: function() {
            this.initializeExtensions();
            this.initializeCapabilities();
            this.initializeRenderState();
            var a;
            var b = 0;
            for (a = this.shaders.length; b < a; b++) this.compileAndLinkShader(this.shaders[b]);
            this.shader = null;
            b = 0;
            for (a = this.buffers.length; b < a; b++) this.buffers[b].bufferId = void 0, this.buffers[b].unlock();
            this.indexBuffer = this.boundVao = null;
            this.vertexBuffers = [];
            b = 0;
            for (a = this.textures.length; b < a; b++) {
                var c = this.textures[b];
                this.destroyTexture(c);
                c.dirtyAll()
            }
            this.textureUnit = 0;
            for (b = this.textureUnits.length = 0; b < this.maxCombinedTextures; b++) this.textureUnits.push([null,
                null, null
            ]);
            b = 0;
            for (a = this.targets.length; b < a; b++) this.targets[b]._glFrameBuffer = void 0, this.targets[b]._glDepthBuffer = void 0, this.targets[b]._glResolveFrameBuffer = void 0, this.targets[b]._glMsaaColorBuffer = void 0, this.targets[b]._glMsaaDepthBuffer = void 0;
            this.transformFeedbackBuffer = this.feedback = this.activeFramebuffer = this.renderTarget = null
        },
        createGrabPass: function() {
            if (!this.grabPassTexture) {
                var a = new V(this, {
                    format: 7,
                    minFilter: 1,
                    magFilter: 1,
                    addressU: 1,
                    addressV: 1,
                    mipmaps: !1
                });
                a.name = "texture_grabPass";
                var b = this.scope.resolve(a.name);
                b.setValue(a);
                this.grabPassRenderTarget = new sa({
                    colorBuffer: a,
                    depth: !1
                });
                this.grabPassTextureId = b;
                this.grabPassTexture = a
            }
        },
        updateGrabPass: function() {
            var a = this.gl,
                b = this.renderTarget,
                c = b && b._glResolveFrameBuffer,
                d = this.grabPassTexture,
                e = this.width,
                f = this.height;
            this.webgl2 && e === d._width && f === d._height ? (c && b.resolve(!0), c = b ? b._glFrameBuffer : null, b = b ? b._glResolveFrameBuffer || b._glFrameBuffer : null, this.initRenderTarget(this.grabPassRenderTarget), d = this.grabPassRenderTarget._glFrameBuffer,
                a.bindFramebuffer(a.READ_FRAMEBUFFER, b), a.bindFramebuffer(a.DRAW_FRAMEBUFFER, d), a.blitFramebuffer(0, 0, e, f, 0, 0, e, f, a.COLOR_BUFFER_BIT, a.NEAREST), a.bindFramebuffer(a.DRAW_FRAMEBUFFER, c)) : (c && (b.resolve(!0), a.bindFramebuffer(a.FRAMEBUFFER, b._glResolveFrameBuffer)), a.copyTexImage2D(a.TEXTURE_2D, 0, d._glFormat, 0, 0, e, f, 0), d._width = e, d._height = f, c && a.bindFramebuffer(a.FRAMEBUFFER, b._glFrameBuffer))
        },
        destroyGrabPass: function() {
            this.grabPassRenderTarget.destroy();
            this.grabPassTextureId = this.grabPassRenderTarget =
                null;
            this.grabPassTexture.destroy();
            this.grabPassTexture = null
        },
        updateClientRect: function() {
            this.clientRect = this.canvas.getBoundingClientRect()
        },
        setViewport: function(a, b, c, d) {
            if (this.vx !== a || this.vy !== b || this.vw !== c || this.vh !== d) this.gl.viewport(a, b, c, d), this.vx = a, this.vy = b, this.vw = c, this.vh = d
        },
        setScissor: function(a, b, c, d) {
            if (this.sx !== a || this.sy !== b || this.sw !== c || this.sh !== d) this.gl.scissor(a, b, c, d), this.sx = a, this.sy = b, this.sw = c, this.sh = d
        },
        getProgramLibrary: function() {
            return this.programLib
        },
        setProgramLibrary: function(a) {
            this.programLib =
                a
        },
        setFramebuffer: function(a) {
            this.activeFramebuffer !== a && (this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, a), this.activeFramebuffer = a)
        },
        _checkFbo: function() {
            var a = this.gl;
            switch (a.checkFramebufferStatus(a.FRAMEBUFFER)) {
                case a.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                    break;
                case a.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                    break;
                case a.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                    break;
                case a.FRAMEBUFFER_UNSUPPORTED:
                    console.error("ERROR: FRAMEBUFFER_UNSUPPORTED")
            }
        },
        copyRenderTarget: function(a, b, c, d) {
            var e = this.gl;
            if (!this.webgl2 && d) return !1;
            if (c)
                if (!b) {
                    if (!a._colorBuffer) return !1
                } else if (!a._colorBuffer || !b._colorBuffer || a._colorBuffer._format !== b._colorBuffer._format) return !1;
            if (d && (!a._depthBuffer || !b._depthBuffer || a._depthBuffer._format !== b._depthBuffer._format)) return !1;
            if (this.webgl2 && b) {
                var f = this.renderTarget;
                this.renderTarget = b;
                this.updateBegin();
                e.bindFramebuffer(e.READ_FRAMEBUFFER,
                    a ? a._glFrameBuffer : null);
                e.bindFramebuffer(e.DRAW_FRAMEBUFFER, b._glFrameBuffer);
                var g = a ? a.width : b.width;
                a = a ? a.height : b.height;
                e.blitFramebuffer(0, 0, g, a, 0, 0, g, a, (c ? e.COLOR_BUFFER_BIT : 0) | (d ? e.DEPTH_BUFFER_BIT : 0), e.NEAREST);
                this.renderTarget = f;
                e.bindFramebuffer(e.FRAMEBUFFER, f ? f._glFrameBuffer : null)
            } else c = this.getCopyShader(), this.constantTexSource.setValue(a._colorBuffer), La(this, b, c);
            return !0
        },
        initRenderTarget: function(a) {
            if (!a._glFrameBuffer) {
                a._device = this;
                var b = this.gl;
                a._glFrameBuffer = b.createFramebuffer();
                this.setFramebuffer(a._glFrameBuffer);
                var c = a._colorBuffer;
                c && (c._glTexture || (c._width = Math.min(c.width, this.maxRenderBufferSize), c._height = Math.min(c.height, this.maxRenderBufferSize), this.setTexture(c, 0)), b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, c._cubemap ? b.TEXTURE_CUBE_MAP_POSITIVE_X + a._face : b.TEXTURE_2D, c._glTexture, 0));
                var d = a._depthBuffer;
                d && this.webgl2 ? (d._glTexture || (d._width = Math.min(d.width, this.maxRenderBufferSize), d._height = Math.min(d.height, this.maxRenderBufferSize), this.setTexture(d,
                    0)), a._stencil ? b.framebufferTexture2D(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, d._cubemap ? b.TEXTURE_CUBE_MAP_POSITIVE_X + a._face : b.TEXTURE_2D, a._depthBuffer._glTexture, 0) : b.framebufferTexture2D(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, d._cubemap ? b.TEXTURE_CUBE_MAP_POSITIVE_X + a._face : b.TEXTURE_2D, a._depthBuffer._glTexture, 0)) : !a._depth || 1 < a._samples && this.webgl2 || (a._glDepthBuffer || (a._glDepthBuffer = b.createRenderbuffer()), b.bindRenderbuffer(b.RENDERBUFFER, a._glDepthBuffer), a._stencil ? (b.renderbufferStorage(b.RENDERBUFFER,
                    b.DEPTH_STENCIL, a.width, a.height), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.RENDERBUFFER, a._glDepthBuffer)) : (b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_COMPONENT16, a.width, a.height), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, b.RENDERBUFFER, a._glDepthBuffer)), b.bindRenderbuffer(b.RENDERBUFFER, null));
                this.webgl2 && 1 < a._samples && (a._glResolveFrameBuffer = a._glFrameBuffer, a._glFrameBuffer = b.createFramebuffer(), this.setFramebuffer(a._glFrameBuffer), c && (a._glMsaaColorBuffer ||
                    (a._glMsaaColorBuffer = b.createRenderbuffer()), b.bindRenderbuffer(b.RENDERBUFFER, a._glMsaaColorBuffer), b.renderbufferStorageMultisample(b.RENDERBUFFER, a._samples, c._glInternalFormat, a.width, a.height), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.RENDERBUFFER, a._glMsaaColorBuffer)), a._depth && (a._glMsaaDepthBuffer || (a._glMsaaDepthBuffer = b.createRenderbuffer()), b.bindRenderbuffer(b.RENDERBUFFER, a._glMsaaDepthBuffer), a._stencil ? (b.renderbufferStorageMultisample(b.RENDERBUFFER, a._samples,
                    b.DEPTH24_STENCIL8, a.width, a.height), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.RENDERBUFFER, a._glMsaaDepthBuffer)) : (b.renderbufferStorageMultisample(b.RENDERBUFFER, a._samples, b.DEPTH_COMPONENT32F, a.width, a.height), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, b.RENDERBUFFER, a._glMsaaDepthBuffer))));
                this.targets.push(a)
            }
        },
        getCopyShader: function() {
            this._copyShader || (this._copyShader = Wa(this, F.fullscreenQuadVS, F.outputTex2DPS, "outputTex2D"));
            return this._copyShader
        },
        updateBegin: function() {
            this.boundVao = null;
            if (this._tempEnableSafariTextureUnitWorkaround)
                for (var a = 0; a < this.textureUnits.length; ++a)
                    for (var b = 0; 3 > b; ++b) this.textureUnits[a][b] = null;
            (a = this.renderTarget) ? a._glFrameBuffer ? this.setFramebuffer(a._glFrameBuffer) : this.initRenderTarget(a): this.setFramebuffer(this.defaultFramebuffer)
        },
        updateEnd: function() {
            var a = this.gl;
            this.boundVao = null;
            this.gl.bindVertexArray(null);
            var b = this.renderTarget;
            if (b) {
                var c = b._colorBuffer;
                c && c._glTexture && c.mipmaps && c.pot && (this.activeTexture(this.maxCombinedTextures -
                    1), this.bindTexture(c), a.generateMipmap(c._glTarget));
                this.webgl2 && 1 < b._samples && b.autoResolve && b.resolve()
            }
        },
        initializeTexture: function(a) {
            var b = this.gl;
            a._glTexture = b.createTexture();
            a._glTarget = a._cubemap ? b.TEXTURE_CUBE_MAP : a._volume ? b.TEXTURE_3D : b.TEXTURE_2D;
            switch (a._format) {
                case 0:
                    a._glFormat = b.ALPHA;
                    a._glInternalFormat = b.ALPHA;
                    a._glPixelType = b.UNSIGNED_BYTE;
                    break;
                case 1:
                    a._glFormat = b.LUMINANCE;
                    a._glInternalFormat = b.LUMINANCE;
                    a._glPixelType = b.UNSIGNED_BYTE;
                    break;
                case 2:
                    a._glFormat = b.LUMINANCE_ALPHA;
                    a._glInternalFormat = b.LUMINANCE_ALPHA;
                    a._glPixelType = b.UNSIGNED_BYTE;
                    break;
                case 3:
                    a._glFormat = b.RGB;
                    a._glInternalFormat = b.RGB;
                    a._glPixelType = b.UNSIGNED_SHORT_5_6_5;
                    break;
                case 4:
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = b.RGBA;
                    a._glPixelType = b.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case 5:
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = b.RGBA;
                    a._glPixelType = b.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case 6:
                    a._glFormat = b.RGB;
                    a._glInternalFormat = this.webgl2 ? b.RGB8 : b.RGB;
                    a._glPixelType = b.UNSIGNED_BYTE;
                    break;
                case 7:
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = this.webgl2 ? b.RGBA8 : b.RGBA;
                    a._glPixelType = b.UNSIGNED_BYTE;
                    break;
                case 8:
                    var c = this.extCompressedTextureS3TC;
                    a._glFormat = b.RGB;
                    a._glInternalFormat = c.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    break;
                case 9:
                    c = this.extCompressedTextureS3TC;
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = c.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    break;
                case 10:
                    c = this.extCompressedTextureS3TC;
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = c.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    break;
                case 21:
                    c = this.extCompressedTextureETC1;
                    a._glFormat = b.RGB;
                    a._glInternalFormat =
                        c.COMPRESSED_RGB_ETC1_WEBGL;
                    break;
                case 24:
                    c = this.extCompressedTexturePVRTC;
                    a._glFormat = b.RGB;
                    a._glInternalFormat = c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    break;
                case 25:
                    c = this.extCompressedTexturePVRTC;
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    break;
                case 26:
                    c = this.extCompressedTexturePVRTC;
                    a._glFormat = b.RGB;
                    a._glInternalFormat = c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    break;
                case 27:
                    c = this.extCompressedTexturePVRTC;
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    break;
                case 22:
                    c = this.extCompressedTextureETC;
                    a._glFormat = b.RGB;
                    a._glInternalFormat = c.COMPRESSED_RGB8_ETC2;
                    break;
                case 23:
                    c = this.extCompressedTextureETC;
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = c.COMPRESSED_RGBA8_ETC2_EAC;
                    break;
                case 28:
                    c = this.extCompressedTextureASTC;
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = c.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    break;
                case 29:
                    c = this.extCompressedTextureATC;
                    a._glFormat = b.RGB;
                    a._glInternalFormat = c.COMPRESSED_RGB_ATC_WEBGL;
                    break;
                case 30:
                    c = this.extCompressedTextureATC;
                    a._glFormat =
                        b.RGBA;
                    a._glInternalFormat = c.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
                    break;
                case 11:
                    c = this.extTextureHalfFloat;
                    a._glFormat = b.RGB;
                    this.webgl2 ? (a._glInternalFormat = b.RGB16F, a._glPixelType = b.HALF_FLOAT) : (a._glInternalFormat = b.RGB, a._glPixelType = c.HALF_FLOAT_OES);
                    break;
                case 12:
                    c = this.extTextureHalfFloat;
                    a._glFormat = b.RGBA;
                    this.webgl2 ? (a._glInternalFormat = b.RGBA16F, a._glPixelType = b.HALF_FLOAT) : (a._glInternalFormat = b.RGBA, a._glPixelType = c.HALF_FLOAT_OES);
                    break;
                case 13:
                    a._glFormat = b.RGB;
                    a._glInternalFormat =
                        this.webgl2 ? b.RGB32F : b.RGB;
                    a._glPixelType = b.FLOAT;
                    break;
                case 14:
                    a._glFormat = b.RGBA;
                    a._glInternalFormat = this.webgl2 ? b.RGBA32F : b.RGBA;
                    a._glPixelType = b.FLOAT;
                    break;
                case 15:
                    a._glFormat = b.RED;
                    a._glInternalFormat = b.R32F;
                    a._glPixelType = b.FLOAT;
                    break;
                case 16:
                    this.webgl2 ? (a._glFormat = b.DEPTH_COMPONENT, a._glInternalFormat = b.DEPTH_COMPONENT32F, a._glPixelType = b.FLOAT) : (a._glFormat = b.DEPTH_COMPONENT, a._glInternalFormat = b.DEPTH_COMPONENT, a._glPixelType = b.UNSIGNED_SHORT);
                    break;
                case 17:
                    a._glFormat = b.DEPTH_STENCIL;
                    a._glInternalFormat = b.DEPTH24_STENCIL8;
                    a._glPixelType = b.UNSIGNED_INT_24_8;
                    break;
                case 18:
                    a._glFormat = b.RGB;
                    a._glInternalFormat = b.R11F_G11F_B10F;
                    a._glPixelType = b.FLOAT;
                    break;
                case 19:
                    a._glFormat = b.RGB;
                    a._glInternalFormat = b.SRGB8;
                    a._glPixelType = b.UNSIGNED_BYTE;
                    break;
                case 20:
                    a._glFormat = b.RGBA, a._glInternalFormat = b.SRGB8_ALPHA8, a._glPixelType = b.UNSIGNED_BYTE
            }
            this.textures.push(a)
        },
        destroyTexture: function(a) {
            if (a._glTexture) {
                var b = this.textures.indexOf(a); - 1 !== b && this.textures.splice(b, 1);
                for (var c in this.scope.variables) b =
                    this.scope.variables[c], b.value === a && (b.value = null);
                for (c = 0; c < this.textureUnits.length; c++) {
                    b = this.textureUnits[c];
                    for (var d = 0; d < b.length; d++) b[d] === a._glTexture && (b[d] = null)
                }
                this.gl.deleteTexture(a._glTexture);
                delete a._glTexture;
                delete a._glTarget;
                delete a._glFormat;
                delete a._glInternalFormat;
                delete a._glPixelType;
                this._vram.tex -= a._gpuSize
            }
        },
        setUnpackFlipY: function(a) {
            if (this.unpackFlipY !== a) {
                this.unpackFlipY = a;
                var b = this.gl;
                b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, a)
            }
        },
        setUnpackPremultiplyAlpha: function(a) {
            if (this.unpackPremultiplyAlpha !==
                a) {
                this.unpackPremultiplyAlpha = a;
                var b = this.gl;
                b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a)
            }
        },
        _isBrowserInterface: function(a) {
            return "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLVideoElement && a instanceof HTMLVideoElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap
        },
        uploadTexture: function(a) {
            var b = this.gl;
            if (a._needsUpload || !(a._needsMipmapsUpload && a._mipmapsUploaded ||
                    !a.pot)) {
                for (var c = 0, d, e, f = Math.log2(Math.max(a._width, a._height)) + 1; a._levels[c] || 0 === c;) {
                    if (a._needsUpload || 0 !== c) {
                        if (c && (!a._needsMipmapsUpload || !a._mipmaps)) break;
                        d = a._levels[c];
                        1 == c && !a._compressed && a._levels.length < f && (b.generateMipmap(a._glTarget), a._mipmapsUploaded = !0);
                        if (a._cubemap) {
                            var g;
                            if (this._isBrowserInterface(d[0]))
                                for (g = 0; 6 > g; g++) a._levelsUpdated[0][g] && (e = d[g], e instanceof HTMLImageElement && (e.width > this.maxCubeMapSize || e.height > this.maxCubeMapSize) && (e = nn(e, this.maxCubeMapSize),
                                    0 === c && (a._width = e.width, a._height = e.height)), this.setUnpackFlipY(!1), this.setUnpackPremultiplyAlpha(a._premultiplyAlpha), b.texImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + g, c, a._glInternalFormat, a._glFormat, a._glPixelType, e));
                            else
                                for (e = 1 / Math.pow(2, c), g = 0; 6 > g; g++)
                                    if (a._levelsUpdated[0][g]) {
                                        var k = d[g];
                                        a._compressed ? b.compressedTexImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + g, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), 0, k) : (this.setUnpackFlipY(!1), this.setUnpackPremultiplyAlpha(a._premultiplyAlpha),
                                            b.texImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + g, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), 0, a._glFormat, a._glPixelType, k))
                                    }
                        } else a._volume ? (e = 1 / Math.pow(2, c), a._compressed ? b.compressedTexImage3D(b.TEXTURE_3D, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), Math.max(a._depth * e, 1), 0, d) : (this.setUnpackFlipY(!1), this.setUnpackPremultiplyAlpha(a._premultiplyAlpha), b.texImage3D(b.TEXTURE_3D, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1),
                            Math.max(a._depth * e, 1), 0, a._glFormat, a._glPixelType, d))) : (this._isBrowserInterface(d) ? (d instanceof HTMLImageElement && (d.width > this.maxTextureSize || d.height > this.maxTextureSize) && (d = nn(d, this.maxTextureSize), 0 === c && (a._width = d.width, a._height = d.height)), this.setUnpackFlipY(a._flipY), this.setUnpackPremultiplyAlpha(a._premultiplyAlpha), b.texImage2D(b.TEXTURE_2D, c, a._glInternalFormat, a._glFormat, a._glPixelType, d)) : (e = 1 / Math.pow(2, c), a._compressed ? b.compressedTexImage2D(b.TEXTURE_2D, c, a._glInternalFormat,
                            Math.max(a._width * e, 1), Math.max(a._height * e, 1), 0, d) : (this.setUnpackFlipY(!1), this.setUnpackPremultiplyAlpha(a._premultiplyAlpha), b.texImage2D(b.TEXTURE_2D, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), 0, a._glFormat, a._glPixelType, d))), a._mipmapsUploaded = 0 === c ? !1 : !0)
                    }
                    c++
                }
                if (a._needsUpload)
                    if (a._cubemap)
                        for (c = 0; 6 > c; c++) a._levelsUpdated[0][c] = !1;
                    else a._levelsUpdated[0] = !1;
                !a._compressed && a._mipmaps && a._needsMipmapsUpload && a.pot && 1 === a._levels.length && (b.generateMipmap(a._glTarget),
                    a._mipmapsUploaded = !0);
                a._gpuSize && (this._vram.tex -= a._gpuSize);
                a._gpuSize = a.gpuSize;
                this._vram.tex += a._gpuSize
            }
        },
        activeTexture: function(a) {
            this.textureUnit !== a && (this.gl.activeTexture(this.gl.TEXTURE0 + a), this.textureUnit = a)
        },
        bindTexture: function(a) {
            var b = a._glTarget;
            a = a._glTexture;
            var c = this.textureUnit,
                d = this.targetToSlot[b];
            this.textureUnits[c][d] !== a && (this.gl.bindTexture(b, a), this.textureUnits[c][d] = a)
        },
        bindTextureOnUnit: function(a, b) {
            var c = a._glTarget;
            a = a._glTexture;
            var d = this.targetToSlot[c];
            this.textureUnits[b][d] !== a && (this.activeTexture(b), this.gl.bindTexture(c, a), this.textureUnits[b][d] = a)
        },
        setTextureParameters: function(a) {
            var b = this.gl,
                c = a._parameterFlags,
                d = a._glTarget;
            if (c & 1) {
                var e = a._minFilter;
                if (!a.pot || !a._mipmaps || a._compressed && 1 === a._levels.length)
                    if (2 === e || 3 === e) e = 0;
                    else if (4 === e || 5 === e) e = 1;
                b.texParameteri(d, b.TEXTURE_MIN_FILTER, this.glFilter[e])
            }
            c & 2 && b.texParameteri(d, b.TEXTURE_MAG_FILTER, this.glFilter[a._magFilter]);
            c & 4 && (this.webgl2 ? b.texParameteri(d, b.TEXTURE_WRAP_S,
                this.glAddress[a._addressU]) : b.texParameteri(d, b.TEXTURE_WRAP_S, this.glAddress[a.pot ? a._addressU : 1]));
            c & 8 && (this.webgl2 ? b.texParameteri(d, b.TEXTURE_WRAP_T, this.glAddress[a._addressV]) : b.texParameteri(d, b.TEXTURE_WRAP_T, this.glAddress[a.pot ? a._addressV : 1]));
            c & 16 && this.webgl2 && b.texParameteri(d, b.TEXTURE_WRAP_R, this.glAddress[a._addressW]);
            c & 32 && this.webgl2 && b.texParameteri(d, b.TEXTURE_COMPARE_MODE, a._compareOnRead ? b.COMPARE_REF_TO_TEXTURE : b.NONE);
            c & 64 && this.webgl2 && b.texParameteri(d, b.TEXTURE_COMPARE_FUNC,
                this.glComparison[a._compareFunc]);
            c & 128 && (c = this.extTextureFilterAnisotropic) && b.texParameterf(d, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(a._anisotropy), this.maxAnisotropy)))
        },
        setTexture: function(a, b) {
            a._glTexture || this.initializeTexture(a);
            if (0 < a._parameterFlags || a._needsUpload || a._needsMipmapsUpload || a === this.grabPassTexture)
                if (this.activeTexture(b), this.bindTexture(a), a._parameterFlags && (this.setTextureParameters(a), a._parameterFlags = 0), a === this.grabPassTexture) this.updateGrabPass();
                else {
                    if (a._needsUpload || a._needsMipmapsUpload) this.uploadTexture(a), a._needsUpload = !1, a._needsMipmapsUpload = !1
                }
            else this.bindTextureOnUnit(a, b)
        },
        createVertexArray: function(a) {
            var b, c = 1 < a.length;
            if (c) {
                var d = "";
                for (b = 0; b < a.length; b++) {
                    var e = a[b];
                    d += e.id + e.format.renderingingHash
                }
                var f = this._vaoMap.get(d)
            }
            if (!f) {
                var g = this.gl;
                f = g.createVertexArray();
                g.bindVertexArray(f);
                g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, null);
                for (b = 0; b < a.length; b++) {
                    e = a[b];
                    g.bindBuffer(g.ARRAY_BUFFER, e.bufferId);
                    var k = e.format.elements;
                    for (var h = 0; h < k.length; h++) {
                        var l = k[h];
                        var n = Pj[l.name];
                        g.vertexAttribPointer(n, l.numComponents, this.glType[l.dataType], l.normalize, l.stride, l.offset);
                        g.enableVertexAttribArray(n);
                        e.instancing && g.vertexAttribDivisor(n, 1)
                    }
                }
                g.bindVertexArray(null);
                g.bindBuffer(g.ARRAY_BUFFER, null);
                c && this._vaoMap.set(d, f)
            }
            return f
        },
        setBuffers: function() {
            var a = this.gl;
            if (1 === this.vertexBuffers.length) {
                var b = this.vertexBuffers[0];
                b._vao || (b._vao = this.createVertexArray(this.vertexBuffers));
                b = b._vao
            } else b = this.createVertexArray(this.vertexBuffers);
            this.boundVao !== b && (this.boundVao = b, a.bindVertexArray(b));
            this.vertexBuffers.length = 0;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer ? this.indexBuffer.bufferId : null)
        },
        draw: function(a, b, c) {
            var d = this.gl,
                e, f, g, k = this.shader;
            var h = k.samplers;
            k = k.uniforms;
            c || this.setBuffers();
            var l = 0;
            c = 0;
            for (f = h.length; c < f; c++) {
                var n = h[c];
                if (g = n.scopeId.value)
                    if (g instanceof V) {
                        var p = g;
                        this.setTexture(p, l);
                        n.slot !== l && (d.uniform1i(n.locationId, l), n.slot = l);
                        l++
                    } else {
                        n.array.length = 0;
                        var q = g.length;
                        for (e = 0; e < q; e++) p =
                            g[e], this.setTexture(p, l), n.array[e] = l, l++;
                        d.uniform1iv(n.locationId, n.array)
                    }
            }
            c = 0;
            for (f = k.length; c < f; c++)
                if (h = k[c], e = h.scopeId, n = h.version, g = e.versionObject.version, n.globalId !== g.globalId || n.revision !== g.revision)
                    if (n.globalId = g.globalId, n.revision = g.revision, null !== e.value) this.commitFunction[h.dataType](h, e.value);
            this.webgl2 && this.transformFeedbackBuffer && (d.bindBufferBase(d.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId), d.beginTransformFeedback(d.POINTS));
            k = this.glPrimitive[a.type];
            c = a.count;
            a.indexed ? (h = this.indexBuffer, f = h.glFormat, a = a.base * h.bytesPerIndex, 0 < b ? d.drawElementsInstanced(k, c, f, a, b) : d.drawElements(k, c, f, a)) : (a = a.base, 0 < b ? d.drawArraysInstanced(k, a, c, b) : d.drawArrays(k, a, c));
            this.webgl2 && this.transformFeedbackBuffer && (d.endTransformFeedback(), d.bindBufferBase(d.TRANSFORM_FEEDBACK_BUFFER, 0, null));
            this._drawCallsPerFrame++
        },
        clear: function(a) {
            var b = this.defaultClearOptions;
            a = a || b;
            var c = void 0 == a.flags ? b.flags : a.flags;
            if (0 !== c) {
                var d = this.gl;
                if (c & 1) {
                    var e = void 0 == a.color ?
                        b.color : a.color;
                    this.setClearColor(e[0], e[1], e[2], e[3])
                }
                c & 2 && (this.setClearDepth(void 0 == a.depth ? b.depth : a.depth), this.depthWrite || d.depthMask(!0));
                c & 4 && this.setClearStencil(void 0 == a.stencil ? b.stencil : a.stencil);
                d.clear(this.glClearFlag[c]);
                c & 2 && (this.depthWrite || d.depthMask(!1))
            }
        },
        readPixels: function(a, b, c, d, e) {
            var f = this.gl;
            f.readPixels(a, b, c, d, f.RGBA, f.UNSIGNED_BYTE, e)
        },
        setClearDepth: function(a) {
            a !== this.clearDepth && (this.gl.clearDepth(a), this.clearDepth = a)
        },
        setClearColor: function(a, b, c, d) {
            if (a !==
                this.clearRed || b !== this.clearGreen || c !== this.clearBlue || d !== this.clearAlpha) this.gl.clearColor(a, b, c, d), this.clearRed = a, this.clearGreen = b, this.clearBlue = c, this.clearAlpha = d
        },
        setClearStencil: function(a) {
            a !== this.clearStencil && (this.gl.clearStencil(a), this.clearStencil = a)
        },
        setRenderTarget: function(a) {
            this.renderTarget = a
        },
        getRenderTarget: function() {
            return this.renderTarget
        },
        getDepthTest: function() {
            return this.depthTest
        },
        setDepthTest: function(a) {
            if (this.depthTest !== a) {
                var b = this.gl;
                a ? b.enable(b.DEPTH_TEST) :
                    b.disable(b.DEPTH_TEST);
                this.depthTest = a
            }
        },
        setDepthFunc: function(a) {
            this.depthFunc !== a && (this.gl.depthFunc(this.glComparison[a]), this.depthFunc = a)
        },
        getDepthWrite: function() {
            return this.depthWrite
        },
        setDepthWrite: function(a) {
            this.depthWrite !== a && (this.gl.depthMask(a), this.depthWrite = a)
        },
        setColorWrite: function(a, b, c, d) {
            if (this.writeRed !== a || this.writeGreen !== b || this.writeBlue !== c || this.writeAlpha !== d) this.gl.colorMask(a, b, c, d), this.writeRed = a, this.writeGreen = b, this.writeBlue = c, this.writeAlpha = d
        },
        setAlphaToCoverage: function(a) {
            this.webgl2 &&
                this.alphaToCoverage !== a && ((this.alphaToCoverage = a) ? this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE) : this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE))
        },
        setTransformFeedbackBuffer: function(a) {
            if (this.transformFeedbackBuffer !== a && (this.transformFeedbackBuffer = a, this.webgl2)) {
                var b = this.gl;
                a ? (this.feedback || (this.feedback = b.createTransformFeedback()), b.bindTransformFeedback(b.TRANSFORM_FEEDBACK, this.feedback)) : b.bindTransformFeedback(b.TRANSFORM_FEEDBACK, null)
            }
        },
        setRaster: function(a) {
            this.raster !==
                a && (this.raster = a, this.webgl2 && (a ? this.gl.disable(this.gl.RASTERIZER_DISCARD) : this.gl.enable(this.gl.RASTERIZER_DISCARD)))
        },
        setDepthBias: function(a) {
            this.depthBiasEnabled !== a && ((this.depthBiasEnabled = a) ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL))
        },
        setDepthBiasValues: function(a, b) {
            this.gl.polygonOffset(b, a)
        },
        getBlending: function() {
            return this.blending
        },
        setBlending: function(a) {
            if (this.blending !== a) {
                var b = this.gl;
                a ? b.enable(b.BLEND) : b.disable(b.BLEND);
                this.blending =
                    a
            }
        },
        setStencilTest: function(a) {
            if (this.stencil !== a) {
                var b = this.gl;
                a ? b.enable(b.STENCIL_TEST) : b.disable(b.STENCIL_TEST);
                this.stencil = a
            }
        },
        setStencilFunc: function(a, b, c) {
            if (this.stencilFuncFront !== a || this.stencilRefFront !== b || this.stencilMaskFront !== c || this.stencilFuncBack !== a || this.stencilRefBack !== b || this.stencilMaskBack !== c) this.gl.stencilFunc(this.glComparison[a], b, c), this.stencilFuncFront = this.stencilFuncBack = a, this.stencilRefFront = this.stencilRefBack = b, this.stencilMaskFront = this.stencilMaskBack =
                c
        },
        setStencilFuncFront: function(a, b, c) {
            if (this.stencilFuncFront !== a || this.stencilRefFront !== b || this.stencilMaskFront !== c) {
                var d = this.gl;
                d.stencilFuncSeparate(d.FRONT, this.glComparison[a], b, c);
                this.stencilFuncFront = a;
                this.stencilRefFront = b;
                this.stencilMaskFront = c
            }
        },
        setStencilFuncBack: function(a, b, c) {
            if (this.stencilFuncBack !== a || this.stencilRefBack !== b || this.stencilMaskBack !== c) {
                var d = this.gl;
                d.stencilFuncSeparate(d.BACK, this.glComparison[a], b, c);
                this.stencilFuncBack = a;
                this.stencilRefBack = b;
                this.stencilMaskBack =
                    c
            }
        },
        setStencilOperation: function(a, b, c, d) {
            if (this.stencilFailFront !== a || this.stencilZfailFront !== b || this.stencilZpassFront !== c || this.stencilFailBack !== a || this.stencilZfailBack !== b || this.stencilZpassBack !== c) this.gl.stencilOp(this.glStencilOp[a], this.glStencilOp[b], this.glStencilOp[c]), this.stencilFailFront = this.stencilFailBack = a, this.stencilZfailFront = this.stencilZfailBack = b, this.stencilZpassFront = this.stencilZpassBack = c;
            if (this.stencilWriteMaskFront !== d || this.stencilWriteMaskBack !== d) this.gl.stencilMask(d),
                this.stencilWriteMaskBack = this.stencilWriteMaskFront = d
        },
        setStencilOperationFront: function(a, b, c, d) {
            if (this.stencilFailFront !== a || this.stencilZfailFront !== b || this.stencilZpassFront !== c) this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[a], this.glStencilOp[b], this.glStencilOp[c]), this.stencilFailFront = a, this.stencilZfailFront = b, this.stencilZpassFront = c;
            this.stencilWriteMaskFront !== d && (this.gl.stencilMaskSeparate(this.gl.FRONT, d), this.stencilWriteMaskFront = d)
        },
        setStencilOperationBack: function(a,
            b, c, d) {
            if (this.stencilFailBack !== a || this.stencilZfailBack !== b || this.stencilZpassBack !== c) this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[a], this.glStencilOp[b], this.glStencilOp[c]), this.stencilFailBack = a, this.stencilZfailBack = b, this.stencilZpassBack = c;
            this.stencilWriteMaskBack !== d && (this.gl.stencilMaskSeparate(this.gl.BACK, d), this.stencilWriteMaskBack = d)
        },
        setBlendFunction: function(a, b) {
            if (this.blendSrc !== a || this.blendDst !== b || this.separateAlphaBlend) this.gl.blendFunc(this.glBlendFunction[a],
                this.glBlendFunction[b]), this.blendSrc = a, this.blendDst = b, this.separateAlphaBlend = !1
        },
        setBlendFunctionSeparate: function(a, b, c, d) {
            this.blendSrc === a && this.blendDst === b && this.blendSrcAlpha === c && this.blendDstAlpha === d && this.separateAlphaBlend || (this.gl.blendFuncSeparate(this.glBlendFunction[a], this.glBlendFunction[b], this.glBlendFunction[c], this.glBlendFunction[d]), this.blendSrc = a, this.blendDst = b, this.blendSrcAlpha = c, this.blendDstAlpha = d, this.separateAlphaBlend = !0)
        },
        setBlendEquation: function(a) {
            if (this.blendEquation !==
                a || this.separateAlphaEquation) this.gl.blendEquation(this.glBlendEquation[a]), this.blendEquation = a, this.separateAlphaEquation = !1
        },
        setBlendEquationSeparate: function(a, b) {
            this.blendEquation === a && this.blendAlphaEquation === b && this.separateAlphaEquation || (this.gl.blendEquationSeparate(this.glBlendEquation[a], this.glBlendEquation[b]), this.blendEquation = a, this.blendAlphaEquation = b, this.separateAlphaEquation = !0)
        },
        setCullMode: function(a) {
            if (this.cullMode !== a) {
                if (0 === a) this.gl.disable(this.gl.CULL_FACE);
                else {
                    0 ===
                        this.cullMode && this.gl.enable(this.gl.CULL_FACE);
                    var b = this.glCull[a];
                    this.cullFace !== b && (this.gl.cullFace(b), this.cullFace = b)
                }
                this.cullMode = a
            }
        },
        getCullMode: function() {
            return this.cullMode
        },
        setIndexBuffer: function(a) {
            this.indexBuffer = a
        },
        setVertexBuffer: function(a) {
            a && this.vertexBuffers.push(a)
        },
        compileShaderSource: function(a, b) {
            var c = this.gl,
                d = b ? this.vertexShaderCache[a] : this.fragmentShaderCache[a];
            d || (d = c.createShader(b ? c.VERTEX_SHADER : c.FRAGMENT_SHADER), c.shaderSource(d, a), c.compileShader(d), b ?
                this.vertexShaderCache[a] = d : this.fragmentShaderCache[a] = d);
            return d
        },
        compileAndLinkShader: function(a) {
            var b = this.gl,
                c = a.definition,
                d, e = c.attributes,
                f = this.compileShaderSource(c.vshader, !0),
                g = this.compileShaderSource(c.fshader, !1),
                k = b.createProgram();
            b.attachShader(k, f);
            b.attachShader(k, g);
            if (this.webgl2 && c.useTransformFeedback) {
                c = [];
                for (d in e) e.hasOwnProperty(d) && c.push("out_" + d);
                b.transformFeedbackVaryings(k, c, b.INTERLEAVED_ATTRIBS)
            }
            c = {};
            for (d in e)
                if (e.hasOwnProperty(d)) {
                    var h = Pj[e[d]];
                    c.hasOwnProperty(h);
                    c[h] = d;
                    b.bindAttribLocation(k, h, d)
                }
            b.linkProgram(k);
            a._glVertexShader = f;
            a._glFragmentShader = g;
            a._glProgram = k
        },
        createShader: function(a) {
            this.compileAndLinkShader(a);
            this.shaders.push(a)
        },
        destroyShader: function(a) {
            var b = this.shaders.indexOf(a); - 1 !== b && this.shaders.splice(b, 1);
            a._glProgram && (this.gl.deleteProgram(a._glProgram), a._glProgram = null, this.removeShaderFromCache(a))
        },
        _addLineNumbers: function(a) {
            a = a.split("\n");
            for (var b = 0, c = a.length; b < c; b++) a[b] = b + 1 + ":\t" + a[b];
            return a.join("\n")
        },
        postLink: function(a) {
            var b =
                this.gl,
                c = a._glVertexShader,
                d = a._glFragmentShader,
                e = a._glProgram,
                f = a.definition;
            if (!b.getShaderParameter(c, b.COMPILE_STATUS)) return console.error("Failed to compile vertex shader:\n\n" + this._addLineNumbers(f.vshader) + "\n\n" + b.getShaderInfoLog(c)), !1;
            if (!b.getShaderParameter(d, b.COMPILE_STATUS)) return console.error("Failed to compile fragment shader:\n\n" + this._addLineNumbers(f.fshader) + "\n\n" + b.getShaderInfoLog(d)), !1;
            if (!b.getProgramParameter(e, b.LINK_STATUS)) return console.error("Failed to link shader program. Error: " +
                b.getProgramInfoLog(e)), !1;
            c = 0;
            for (var g = b.getProgramParameter(e, b.ACTIVE_ATTRIBUTES); c < g;) {
                d = b.getActiveAttrib(e, c++);
                var k = b.getAttribLocation(e, d.name);
                void 0 === f.attributes[d.name] && console.error('Vertex shader attribute "' + d.name + '" is not mapped to a semantic in shader definition.');
                k = new Bj(this, f.attributes[d.name], this.pcUniformType[d.type], k);
                a.attributes.push(k)
            }
            c = 0;
            for (f = b.getProgramParameter(e, b.ACTIVE_UNIFORMS); c < f;) d = b.getActiveUniform(e, c++), k = b.getUniformLocation(e, d.name), k = new Bj(this,
                d.name, this.pcUniformType[d.type], k), d.type === b.SAMPLER_2D || d.type === b.SAMPLER_CUBE || this.webgl2 && (d.type === b.SAMPLER_2D_SHADOW || d.type === b.SAMPLER_CUBE_SHADOW || d.type === b.SAMPLER_3D) ? a.samplers.push(k) : a.uniforms.push(k);
            return a.ready = !0
        },
        setShader: function(a) {
            if (a !== this.shader) {
                if (!a.ready && !this.postLink(a)) return !1;
                this.shader = a;
                this.gl.useProgram(a._glProgram);
                this.attributesInvalidated = !0
            }
            return !0
        },
        getHdrFormat: function() {
            return this.textureHalfFloatRenderable ? 12 : this.textureFloatRenderable ?
                14 : 7
        },
        getBoneLimit: function() {
            return this.boneLimit
        },
        setBoneLimit: function(a) {
            this.boneLimit = a
        },
        resizeCanvas: function(a, b) {
            this._width = a;
            this._height = b;
            var c = Math.min(this._maxPixelRatio, window.devicePixelRatio);
            a *= c;
            b *= c;
            if (this.canvas.width !== a || this.canvas.height !== b) this.canvas.width = a, this.canvas.height = b, this.fire("resizecanvas", a, b)
        },
        setResolution: function(a, b) {
            this._width = a;
            this._height = b;
            this.canvas.width = a;
            this.canvas.height = b;
            this.fire("resizecanvas", a, b)
        },
        clearShaderCache: function() {
            var a =
                this.gl,
                b;
            for (b in this.fragmentShaderCache) a.deleteShader(this.fragmentShaderCache[b]), delete this.fragmentShaderCache[b];
            for (b in this.vertexShaderCache) a.deleteShader(this.vertexShaderCache[b]), delete this.vertexShaderCache[b];
            this.programLib.clearCache()
        },
        clearVertexArrayObjectCache: function() {
            var a = this.gl;
            this._vaoMap.forEach(function(b, c, d) {
                a.deleteVertexArray(b)
            });
            this._vaoMap.clear()
        },
        removeShaderFromCache: function(a) {
            this.programLib.removeFromCache(a)
        },
        destroy: function() {
            var a = this.gl;
            this.destroyGrabPass();
            this.webgl2 && this.feedback && a.deleteTransformFeedback(this.feedback);
            this.clearShaderCache();
            this.clearVertexArrayObjectCache();
            this.canvas.removeEventListener("webglcontextlost", this._contextLostHandler, !1);
            this.canvas.removeEventListener("webglcontextrestored", this._contextRestoredHandler, !1);
            this.gl = this.canvas = this._contextRestoredHandler = this._contextLostHandler = null
        }
    });
    Object.defineProperty(jb.prototype, "width", {
        get: function() {
            return this.gl.drawingBufferWidth || this.canvas.width
        }
    });
    Object.defineProperty(jb.prototype,
        "height", {
            get: function() {
                return this.gl.drawingBufferHeight || this.canvas.height
            }
        });
    Object.defineProperty(jb.prototype, "fullscreen", {
        get: function() {
            return !!document.fullscreenElement
        },
        set: function(a) {
            a ? this.gl.canvas.requestFullscreen() : document.exitFullscreen()
        }
    });
    Object.defineProperty(jb.prototype, "enableAutoInstancing", {
        get: function() {
            return this._enableAutoInstancing
        },
        set: function(a) {
            this._enableAutoInstancing = a && this.extInstancing
        }
    });
    Object.defineProperty(jb.prototype, "maxPixelRatio", {
        get: function() {
            return this._maxPixelRatio
        },
        set: function(a) {
            this._maxPixelRatio = a;
            this.resizeCanvas(this._width, this._height)
        }
    });
    Object.defineProperty(jb.prototype, "textureFloatHighPrecision", {
        get: function() {
            if (void 0 === this._textureFloatHighPrecision) {
                if (this.textureFloatRenderable) {
                    var a = Wa(this, F.fullscreenQuadVS, F.precisionTestPS, "ptest1"),
                        b = Wa(this, F.fullscreenQuadVS, F.precisionTest2PS, "ptest2"),
                        c = {
                            format: 14,
                            width: 1,
                            height: 1,
                            mipmaps: !1,
                            minFilter: 0,
                            magFilter: 0
                        };
                    var d = new V(this, c);
                    d.name = "testFHP";
                    var e = new sa(this, d, {
                        depth: !1
                    });
                    La(this,
                        e, a);
                    c.format = 7;
                    a = new V(this, c);
                    a.name = "testFHP";
                    c = new sa(this, a, {
                        depth: !1
                    });
                    this.constantTexSource.setValue(d);
                    La(this, c, b);
                    b = this.activeFramebuffer;
                    this.setFramebuffer(c._glFrameBuffer);
                    var f = new Uint8Array(4);
                    this.readPixels(0, 0, 1, 1, f);
                    this.setFramebuffer(b);
                    b = f[0] / 255 / 16777216 + f[1] / 255 / 65536 + f[2] / 255 / 256 + f[3] / 255;
                    d.destroy();
                    e.destroy();
                    a.destroy();
                    c.destroy();
                    d = 0 === b
                } else d = !1;
                this._textureFloatHighPrecision = d
            }
            return this._textureFloatHighPrecision
        }
    });
    Object.defineProperties(jb.prototype, {
        textureHalfFloatUpdatable: {
            get: function() {
                if (void 0 ===
                    this._textureHalfFloatUpdatable)
                    if (this.webgl2) this._textureHalfFloatUpdatable = !0;
                    else {
                        var a = this.gl,
                            b = this.extTextureHalfFloat.HALF_FLOAT_OES,
                            c = !0,
                            d = a.createTexture();
                        a.bindTexture(a.TEXTURE_2D, d);
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST);
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
                        var e = new Uint16Array(16);
                        a.texImage2D(a.TEXTURE_2D, 0, a.RGBA,
                            2, 2, 0, a.RGBA, b, e);
                        a.getError() !== a.NO_ERROR && (c = !1, console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support"));
                        a.bindTexture(a.TEXTURE_2D, null);
                        a.deleteTexture(d);
                        this._textureHalfFloatUpdatable = c
                    }
                return this._textureHalfFloatUpdatable
            }
        }
    });
    var cq = {
            depth: !0,
            face: 0
        },
        sa = function(a, b, c) {
            a instanceof jb ? (this._colorBuffer = b, a = c) : this._colorBuffer = a.colorBuffer;
            this._glDepthBuffer = this._glFrameBuffer = null;
            a = void 0 !== a ? a : cq;
            this._depthBuffer =
                a.depthBuffer;
            this._face = void 0 !== a.face ? a.face : 0;
            this._depthBuffer ? (b = this._depthBuffer._format, 16 === b ? (this._depth = !0, this._stencil = !1) : this._stencil = 17 === b ? this._depth = !0 : this._depth = !1) : (this._depth = void 0 !== a.depth ? a.depth : !0, this._stencil = void 0 !== a.stencil ? a.stencil : !1);
            this._samples = void 0 !== a.samples ? a.samples : 1;
            this.autoResolve = void 0 !== a.autoResolve ? a.autoResolve : !0;
            this._glMsaaDepthBuffer = this._glMsaaColorBuffer = this._glResolveFrameBuffer = null
        };
    Object.assign(sa.prototype, {
        destroy: function() {
            if (this._device) {
                var a =
                    this._device,
                    b = a.targets.indexOf(this); - 1 !== b && a.targets.splice(b, 1);
                a = a.gl;
                this._glFrameBuffer && (a.deleteFramebuffer(this._glFrameBuffer), this._glFrameBuffer = null);
                this._glDepthBuffer && (a.deleteRenderbuffer(this._glDepthBuffer), this._glDepthBuffer = null);
                this._glResolveFrameBuffer && (a.deleteFramebuffer(this._glResolveFrameBuffer), this._glResolveFrameBuffer = null);
                this._glMsaaColorBuffer && (a.deleteRenderbuffer(this._glMsaaColorBuffer), this._glMsaaColorBuffer = null);
                this._glMsaaDepthBuffer && (a.deleteRenderbuffer(this._glMsaaDepthBuffer),
                    this._glMsaaDepthBuffer = null)
            }
        },
        resolve: function(a, b) {
            if (this._device && this._device.webgl2) {
                var c = this._device.gl;
                void 0 === a && (a = !0);
                void 0 === b && this._depthBuffer && (b = !0);
                c.bindFramebuffer(c.READ_FRAMEBUFFER, this._glFrameBuffer);
                c.bindFramebuffer(c.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
                c.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (a ? c.COLOR_BUFFER_BIT : 0) | (b ? c.DEPTH_BUFFER_BIT : 0), c.NEAREST);
                c.bindFramebuffer(c.FRAMEBUFFER, this._glFrameBuffer)
            }
        },
        copy: function(a, b, c) {
            if (!this._device)
                if (a._device) this._device =
                    a._device;
                else return !1;
            return this._device.copyRenderTarget(a, this, b, c)
        }
    });
    Object.defineProperty(sa.prototype, "colorBuffer", {
        get: function() {
            return this._colorBuffer
        }
    });
    Object.defineProperty(sa.prototype, "depthBuffer", {
        get: function() {
            return this._depthBuffer
        }
    });
    Object.defineProperty(sa.prototype, "face", {
        get: function() {
            return this._face
        }
    });
    Object.defineProperty(sa.prototype, "width", {
        get: function() {
            return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width
        }
    });
    Object.defineProperty(sa.prototype,
        "height", {
            get: function() {
                return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height
            }
        });
    var on = function(a) {
            switch (a.type) {
                case "rgbm":
                    return "RGBM";
                case "rgbe":
                    return "RGBE";
                default:
                    switch (a.format) {
                        case 11:
                        case 13:
                        case 12:
                        case 14:
                            return "Linear";
                        default:
                            return "Gamma"
                    }
            }
        },
        Oo = {
            type: 5,
            base: 0,
            count: 4,
            indexed: !1
        };
    Object.assign(Cj.prototype, {
        render: function(a, b, c) {}
    });
    Nf.createShader = function(a, b, c) {
        return Wa(a, b, null, c, !0)
    };
    Object.assign(Nf.prototype, {
        destroy: function() {
            this._outputBuffer.destroy()
        },
        process: function(a, b) {
            void 0 === b && (b = !0);
            var c = this.device;
            c.setRenderTarget(null);
            c.updateBegin();
            c.setVertexBuffer(this._inputBuffer, 0);
            c.setRaster(!1);
            c.setTransformFeedbackBuffer(this._outputBuffer);
            c.setShader(a);
            c.draw({
                type: 0,
                base: 0,
                count: this._inputBuffer.numVertices,
                indexed: !1
            });
            c.setTransformFeedbackBuffer(null);
            c.setRaster(!0);
            c.updateEnd();
            b && (a = this._inputBuffer.bufferId, this._inputBuffer.bufferId = this._outputBuffer.bufferId, this._outputBuffer.bufferId = a, a = this._inputBuffer._vao, this._inputBuffer._vao =
                this._outputBuffer._vao, this._outputBuffer._vao = a)
        }
    });
    Object.defineProperty(Nf.prototype, "inputBuffer", {
        get: function() {
            return this._inputBuffer
        }
    });
    Object.defineProperty(Nf.prototype, "outputBuffer", {
        get: function() {
            return this._outputBuffer
        }
    });
    be.prototype = Object.create(la.prototype);
    be.prototype.constructor = be;
    Object.assign(be.prototype, {
        clone: function() {
            var a = new be;
            la.prototype._cloneInternal.call(this, a);
            return a
        },
        updateShader: function(a) {
            var b = {
                skin: !!this.meshInstances[0].skinInstance
            };
            this.shader =
                a.getProgramLibrary().getProgram("depth", b)
        }
    });
    qd.prototype.getSelection = function(a, b, c, d) {
        var e = this.device;
        "object" === typeof a ? (d = a, a = d.x, b = d.y, c = d.width, d = d.height) : b = this.layer.renderTarget.height - (b + (d || 1));
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(Math.max(c || 1, 1));
        d = Math.floor(Math.max(d || 1, 1));
        var f = e.renderTarget;
        e.setRenderTarget(this.layer.renderTarget);
        e.updateBegin();
        var g = new Uint8Array(4 * c * d);
        e.readPixels(a, b, c, d, g);
        e.updateEnd();
        e.setRenderTarget(f);
        a = [];
        b = this.mapping;
        for (e = 0; e <
            c * d; e++) {
            f = g[4 * e];
            var k = g[4 * e + 1];
            var h = g[4 * e + 2];
            f = f << 16 | k << 8 | h;
            16777215 !== f && (f = b[f], -1 === a.indexOf(f) && a.push(f))
        }
        return a
    };
    qd.prototype.prepare = function(a, b, c) {
        var d = this.device,
            e = this;
        a instanceof pa && (a = a.node.camera);
        this.scene = b;
        var f = null,
            g = null;
        c instanceof ka ? f = c : g = c;
        if (!this.layer) {
            var k = d.scope.resolve("uColor");
            this.layer = new ka({
                name: "Picker",
                shaderPass: 18,
                opaqueSortMode: 0,
                onEnable: function() {
                    if (!this.renderTarget) {
                        var t = new V(d, {
                            format: 7,
                            width: e.width,
                            height: e.height,
                            mipmaps: !1
                        });
                        t.name =
                            "pick";
                        t.minFilter = 0;
                        t.magFilter = 0;
                        t.addressU = 1;
                        t.addressV = 1;
                        this.renderTarget = new sa(d, t, {
                            depth: !0
                        })
                    }
                },
                onDisable: function() {
                    this.renderTarget && (this.renderTarget._colorBuffer.destroy(), this.renderTarget.destroy(), this.renderTarget = null)
                },
                onDrawCall: function(t, u) {
                    e.pickColor[0] = (u >> 16 & 255) / 255;
                    e.pickColor[1] = (u >> 8 & 255) / 255;
                    e.pickColor[2] = (u & 255) / 255;
                    k.setValue(e.pickColor);
                    d.setBlending(!1);
                    e.mapping[u] = t
                }
            });
            this.layerComp = new xa;
            this.layerComp.pushOpaque(this.layer);
            this.meshInstances = this.layer.opaqueMeshInstances;
            this._instancesVersion = -1
        }
        if (!f) {
            this.layer.clearMeshInstances();
            c = b.layers.layerList;
            var h = b.layers.subLayerEnabled,
                l = b.layers.subLayerList;
            for (b = 0; b < c.length; b++) c[b].overrideClear && c[b]._clearDepthBuffer && (c[b]._pickerCleared = !1);
            for (b = 0; b < c.length; b++) {
                var n = c[b];
                if (n.renderTarget === g && n.enabled && h[b]) {
                    var p = n.cameras.indexOf(a);
                    if (!(0 > p)) {
                        n.overrideClear && n._clearDepthBuffer && !n._pickerCleared && (this.meshInstances.push(this.clearDepthCommand), n._pickerCleared = !0);
                        p = (p = l[b]) ? n.instances.transparentMeshInstances :
                            n.instances.opaqueMeshInstances;
                        var q = p.length;
                        for (n = 0; n < q; n++) {
                            var r = p[n];
                            r.pick && this.meshInstances.push(r)
                        }
                    }
                }
            }
        } else if (this._instancesVersion !== f._version) {
            this.layer.clearMeshInstances();
            p = f.instances.opaqueMeshInstances;
            q = p.length;
            for (n = 0; n < q; n++) r = p[n], r.pick && this.meshInstances.push(r);
            p = f.instances.transparentMeshInstances;
            q = p.length;
            for (n = 0; n < q; n++) r = p[n], r.pick && this.meshInstances.push(r);
            this._instancesVersion = f._version
        }
        this.layer.cameras[0] !== a && (this.layer.clearCameras(), this.layer.addCamera(a));
        this.onLayerPreRender(this.layer, f, g);
        e.mapping.length = 0;
        this.app.renderer.renderComposition(this.layerComp);
        this.onLayerPostRender(this.layer)
    };
    qd.prototype.onLayerPreRender = function(a, b, c) {
        if (this.width !== a.renderTarget.width || this.height !== a.renderTarget.height) a.onDisable(), a.onEnable();
        a.oldClear = a.cameras[0].camera._clearOptions;
        a.oldAspectMode = a.cameras[0].aspectRatioMode;
        a.oldAspect = a.cameras[0].aspectRatio;
        a.cameras[0].camera._clearOptions = this.clearOptions;
        a.cameras[0].aspectRatioMode = 1;
        a.cameras[0].aspectRatio = a.cameras[0].calculateAspectRatio(c ? c : b ? b.renderTarget : null);
        this.app.renderer.updateCameraFrustum(a.cameras[0].camera)
    };
    qd.prototype.onLayerPostRender = function(a) {
        a.cameras[0].camera._clearOptions = a.oldClear;
        a.cameras[0].aspectRatioMode = a.oldAspectMode;
        a.cameras[0].aspectRatio = a.oldAspect
    };
    qd.prototype.resize = function(a, b) {
        this.width = a;
        this.height = b
    };
    Object.defineProperty(qd.prototype, "renderTarget", {
        get: function() {
            return this.layer.renderTarget
        }
    });
    Object.assign(Ql.prototype, {
        load: function(a, b, c) {
            throw Error("not implemented");
        },
        open: function(a, b, c) {
            throw Error("not implemented");
        },
        patch: function(a, b) {}
    });
    var gh = new Dj,
        dq = {
            9: "Tab",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            27: "Escape",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            46: "Delete",
            91: "Win"
        };
    kb.prototype = Object.create(M.prototype);
    kb.prototype.constructor = kb;
    kb.prototype.attach = function(a) {
        this._element && this.detach();
        this._element = a;
        this._element.addEventListener("keydown", this._keyDownHandler, !1);
        this._element.addEventListener("keypress",
            this._keyPressHandler, !1);
        this._element.addEventListener("keyup", this._keyUpHandler, !1)
    };
    kb.prototype.detach = function() {
        this._element.removeEventListener("keydown", this._keyDownHandler);
        this._element.removeEventListener("keypress", this._keyPressHandler);
        this._element.removeEventListener("keyup", this._keyUpHandler);
        this._element = null
    };
    kb.prototype.toKeyIdentifier = function(a) {
        a = hh(a);
        var b;
        if (b = dq[a.toString()]) return b;
        b = a.toString(16).toUpperCase();
        var c = b.length;
        for (a = 0; a < 4 - c; a++) b = "0" + b;
        return "U+" +
            b
    };
    kb.prototype._handleKeyDown = function(a) {
        var b = a.keyCode || a.charCode;
        void 0 !== b && (b = this.toKeyIdentifier(b), this._keymap[b] = !0, this.fire("keydown", Ej(a)), this.preventDefault && a.preventDefault(), this.stopPropagation && a.stopPropagation())
    };
    kb.prototype._handleKeyUp = function(a) {
        var b = a.keyCode || a.charCode;
        void 0 !== b && (b = this.toKeyIdentifier(b), delete this._keymap[b], this.fire("keyup", Ej(a)), this.preventDefault && a.preventDefault(), this.stopPropagation && a.stopPropagation())
    };
    kb.prototype._handleKeyPress =
        function(a) {
            this.fire("keypress", Ej(a));
            this.preventDefault && a.preventDefault();
            this.stopPropagation && a.stopPropagation()
        };
    kb.prototype.update = function() {
        for (var a in this._lastmap) delete this._lastmap[a];
        for (a in this._keymap) this._keymap.hasOwnProperty(a) && (this._lastmap[a] = this._keymap[a])
    };
    kb.prototype.isPressed = function(a) {
        a = hh(a);
        a = this.toKeyIdentifier(a);
        return !!this._keymap[a]
    };
    kb.prototype.wasPressed = function(a) {
        a = hh(a);
        a = this.toKeyIdentifier(a);
        return !!this._keymap[a] && !this._lastmap[a]
    };
    kb.prototype.wasReleased = function(a) {
        a = hh(a);
        a = this.toKeyIdentifier(a);
        return !this._keymap[a] && !!this._lastmap[a]
    };
    Kb.prototype = Object.create(M.prototype);
    Kb.prototype.constructor = Kb;
    Kb.isPointerLocked = function() {
        return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement)
    };
    Object.assign(Kb.prototype, {
        attach: function(a) {
            this._target = a;
            this._attached || (this._attached = !0, a = Da.passiveEvents ? {
                passive: !1
            } : !1, window.addEventListener("mouseup", this._upHandler,
                a), window.addEventListener("mousedown", this._downHandler, a), window.addEventListener("mousemove", this._moveHandler, a), window.addEventListener("wheel", this._wheelHandler, a))
        },
        detach: function() {
            if (this._attached) {
                this._attached = !1;
                this._target = null;
                var a = Da.passiveEvents ? {
                    passive: !1
                } : !1;
                window.removeEventListener("mouseup", this._upHandler, a);
                window.removeEventListener("mousedown", this._downHandler, a);
                window.removeEventListener("mousemove", this._moveHandler, a);
                window.removeEventListener("wheel", this._wheelHandler,
                    a)
            }
        },
        disableContextMenu: function() {
            this._target && this._target.addEventListener("contextmenu", this._contextMenuHandler)
        },
        enableContextMenu: function() {
            this._target && this._target.removeEventListener("contextmenu", this._contextMenuHandler)
        },
        enablePointerLock: function(a, b) {
            if (document.body.requestPointerLock) {
                var c = function() {
                        a();
                        document.removeEventListener("pointerlockchange", c)
                    },
                    d = function() {
                        b();
                        document.removeEventListener("pointerlockerror", d)
                    };
                a && document.addEventListener("pointerlockchange", c, !1);
                b && document.addEventListener("pointerlockerror", d, !1);
                document.body.requestPointerLock()
            } else b && b()
        },
        disablePointerLock: function(a) {
            if (document.exitPointerLock) {
                var b = function() {
                    a();
                    document.removeEventListener("pointerlockchange", b)
                };
                a && document.addEventListener("pointerlockchange", b, !1);
                document.exitPointerLock()
            }
        },
        update: function() {
            this._lastbuttons[0] = this._buttons[0];
            this._lastbuttons[1] = this._buttons[1];
            this._lastbuttons[2] = this._buttons[2]
        },
        isPressed: function(a) {
            return this._buttons[a]
        },
        wasPressed: function(a) {
            return this._buttons[a] &&
                !this._lastbuttons[a]
        },
        wasReleased: function(a) {
            return !this._buttons[a] && this._lastbuttons[a]
        },
        _handleUp: function(a) {
            this._buttons[a.button] = !1;
            a = new rd(this, a);
            a.event && this.fire("mouseup", a)
        },
        _handleDown: function(a) {
            this._buttons[a.button] = !0;
            a = new rd(this, a);
            a.event && this.fire("mousedown", a)
        },
        _handleMove: function(a) {
            a = new rd(this, a);
            a.event && (this.fire("mousemove", a), this._lastX = a.x, this._lastY = a.y)
        },
        _handleWheel: function(a) {
            a = new rd(this, a);
            a.event && this.fire("mousewheel", a)
        },
        _getTargetCoords: function(a) {
            var b =
                this._target.getBoundingClientRect(),
                c = Math.floor(b.left);
            b = Math.floor(b.top);
            return a.clientX < c || a.clientX >= c + this._target.clientWidth || a.clientY < b || a.clientY >= b + this._target.clientHeight ? null : {
                x: a.clientX - c,
                y: a.clientY - b
            }
        }
    });
    lb.prototype.attach = function(a) {
        this._element = a;
        this._keyboard && this._keyboard.attach(a);
        this._mouse && this._mouse.attach(a)
    };
    lb.prototype.detach = function() {
        this._keyboard && this._keyboard.detach();
        this._mouse && this._mouse.detach();
        this._element = null
    };
    lb.prototype.disableContextMenu =
        function() {
            this._mouse || this._enableMouse();
            this._mouse.disableContextMenu()
        };
    lb.prototype.enableContextMenu = function() {
        this._mouse || this._enableMouse();
        this._mouse.enableContextMenu()
    };
    lb.prototype.update = function(a) {
        this._keyboard && this._keyboard.update(a);
        this._mouse && this._mouse.update(a);
        this._gamepads && this._gamepads.update(a);
        this._axesValues = {};
        for (var b in this._axes) this._axesValues[b] = []
    };
    lb.prototype.registerKeys = function(a, b) {
        this._keyboard || this._enableKeyboard();
        if (this._actions[a]) throw Error("Action: " +
            a + " already registered");
        if (void 0 === b) throw Error("Invalid button");
        b.length || (b = [b]);
        this._actions[a] ? this._actions[a].push({
            type: "keyboard",
            keys: b
        }) : this._actions[a] = [{
            type: "keyboard",
            keys: b
        }]
    };
    lb.prototype.registerMouse = function(a, b) {
        this._mouse || this._enableMouse();
        if (void 0 === b) throw Error("Invalid button");
        this._actions[a] ? this._actions[a].push({
            type: "mouse",
            button: b
        }) : this._actions[a] = [{
            type: "mouse",
            button: -b
        }]
    };
    lb.prototype.registerPadButton = function(a, b, c) {
        if (void 0 === c) throw Error("Invalid button");
        this._actions[a] ? this._actions[a].push({
            type: "gamepad",
            button: c,
            pad: b
        }) : this._actions[a] = [{
            type: "gamepad",
            button: c,
            pad: b
        }]
    };
    lb.prototype.registerAxis = function(a) {
        var b = a.name;
        this._axes[b] || (this._axes[b] = []);
        var c = this._axes[b].push(b);
        a = a || {};
        a.pad = a.pad || 0;
        var d = function(e, f, g, k) {
            switch (f) {
                case "mousex":
                    e._mouse.on("mousemove", function(h) {
                        e._axesValues[b][c] = h.dx / 10
                    });
                    break;
                case "mousey":
                    e._mouse.on("mousemove", function(h) {
                        e._axesValues[b][c] = h.dy / 10
                    });
                    break;
                case "key":
                    e._axes[b].push(function() {
                        return e._keyboard.isPressed(k) ?
                            g : 0
                    });
                    break;
                case "padrx":
                    e._axes[b].push(function() {
                        return e._gamepads.getAxis(a.pad, 2)
                    });
                    break;
                case "padry":
                    e._axes[b].push(function() {
                        return e._gamepads.getAxis(a.pad, 3)
                    });
                    break;
                case "padlx":
                    e._axes[b].push(function() {
                        return e._gamepads.getAxis(a.pad, 0)
                    });
                    break;
                case "padly":
                    e._axes[b].push(function() {
                        return e._gamepads.getAxis(a.pad, 1)
                    });
                    break;
                default:
                    throw Error("Unknown axis");
            }
        };
        d(this, a.positive, 1, a.positiveKey);
        (a.negativeKey || a.negative !== a.positive) && d(this, a.negative, -1, a.negativeKey)
    };
    lb.prototype.isPressed = function(a) {
        if (!this._actions[a]) return !1;
        var b, c = this._actions[a].length;
        for (b = 0; b < c; ++b) {
            var d = this._actions[a][b];
            switch (d.type) {
                case "keyboard":
                    if (this._keyboard) {
                        var e, f = d.keys.length;
                        for (e = 0; e < f; e++)
                            if (this._keyboard.isPressed(d.keys[e])) return !0
                    }
                    break;
                case "mouse":
                    if (this._mouse && this._mouse.isPressed(d.button)) return !0;
                    break;
                case "gamepad":
                    if (this._gamepads && this._gamepads.isPressed(d.pad, d.button)) return !0
            }
        }
        return !1
    };
    lb.prototype.wasPressed = function(a) {
        if (!this._actions[a]) return !1;
        var b, c = this._actions[a].length;
        for (b = 0; b < c; ++b) {
            var d = this._actions[a][b];
            switch (d.type) {
                case "keyboard":
                    if (this._keyboard) {
                        var e, f = d.keys.length;
                        for (e = 0; e < f; e++)
                            if (this._keyboard.wasPressed(d.keys[e])) return !0
                    }
                    break;
                case "mouse":
                    if (this._mouse && this._mouse.wasPressed(d.button)) return !0;
                    break;
                case "gamepad":
                    if (this._gamepads && this._gamepads.wasPressed(d.pad, d.button)) return !0
            }
        }
        return !1
    };
    lb.prototype.getAxis = function(a) {
        var b = 0;
        if (this._axes[a]) {
            var c, d = this._axes[a].length;
            for (c = 0; c < d; c++)
                if ("function" ===
                    $c(this._axes[a][c])) {
                    var e = this._axes[a][c]();
                    Math.abs(e) > Math.abs(b) && (b = e)
                } else this._axesValues[a] && Math.abs(this._axesValues[a][c]) > Math.abs(b) && (b = this._axesValues[a][c])
        }
        return b
    };
    lb.prototype._enableMouse = function() {
        this._mouse = new Kb;
        if (!this._element) throw Error("Controller must be attached to an Element");
        this._mouse.attach(this._element)
    };
    lb.prototype._enableKeyboard = function() {
        this._keyboard = new kb;
        if (!this._element) throw Error("Controller must be attached to an Element");
        this._keyboard.attach(this._element)
    };
    var cc, Cd, pn = new z,
        qn = new z,
        Dd = new cd,
        rn = new cd,
        zk = new cd;
    Dd.end = new z;
    rn.end = new z;
    zk.end = new z;
    var Te = new z,
        ih = new z,
        Fj = new z,
        Rl = new z,
        Gj = new z,
        jh = new z,
        Sl = new z,
        Ak = new P,
        rg = new z,
        Zh = new z,
        $h = new z,
        sg = new z,
        sn = new z,
        tn = new z,
        un = new z,
        vn = new z,
        eq = new X;
    Object.assign(sd.prototype, {
        stopPropagation: function() {
            this._stopPropagation = !0;
            this.event && (this.event.stopImmediatePropagation(), this.event.stopPropagation())
        }
    });
    td.prototype = Object.create(sd.prototype);
    td.prototype.constructor = td;
    Pc.prototype = Object.create(sd.prototype);
    Pc.prototype.constructor = Pc;
    lc.prototype = Object.create(sd.prototype);
    lc.prototype.constructor = lc;
    Object.assign(Of.prototype, {
        attach: function(a) {
            this._attached && (this._attached = !1, this.detach());
            this._target = a;
            this._attached = !0;
            a = Da.passiveEvents ? {
                passive: !0
            } : !1;
            this._useMouse && (window.addEventListener("mouseup", this._upHandler, a), window.addEventListener("mousedown", this._downHandler, a), window.addEventListener("mousemove", this._moveHandler, a), window.addEventListener("wheel", this._wheelHandler, a));
            this._useTouch && Da.touch && (this._target.addEventListener("touchstart", this._touchstartHandler, a), this._target.addEventListener("touchend", this._touchendHandler, !1), this._target.addEventListener("touchmove", this._touchmoveHandler, !1), this._target.addEventListener("touchcancel", this._touchcancelHandler, !1));
            this.attachSelectEvents()
        },
        attachSelectEvents: function() {
            !this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported && (this._clickedEntities || (this._clickedEntities = {}),
                this._selectEventsAttached = !0, this.app.xr.on("start", this._onXrStart, this))
        },
        detach: function() {
            if (this._attached) {
                this._attached = !1;
                var a = Da.passiveEvents ? {
                    passive: !0
                } : !1;
                this._useMouse && (window.removeEventListener("mouseup", this._upHandler, a), window.removeEventListener("mousedown", this._downHandler, a), window.removeEventListener("mousemove", this._moveHandler, a), window.removeEventListener("wheel", this._wheelHandler, a));
                this._useTouch && (this._target.removeEventListener("touchstart", this._touchstartHandler,
                    a), this._target.removeEventListener("touchend", this._touchendHandler, !1), this._target.removeEventListener("touchmove", this._touchmoveHandler, !1), this._target.removeEventListener("touchcancel", this._touchcancelHandler, !1));
                this._selectEventsAttached && (this._selectEventsAttached = !1, this.app.xr.off("start", this._onXrStart, this), this.app.xr.off("end", this._onXrEnd, this), this.app.xr.off("update", this._onXrUpdate, this), this.app.xr.input.off("selectstart", this._onSelectStart, this), this.app.xr.input.off("selectend",
                    this._onSelectEnd, this), this.app.xr.input.off("remove", this._onXrInputRemove, this));
                this._target = null
            }
        },
        addElement: function(a) {
            -1 === this._elements.indexOf(a) && this._elements.push(a)
        },
        removeElement: function(a) {
            a = this._elements.indexOf(a); - 1 !== a && this._elements.splice(a, 1)
        },
        _handleUp: function(a) {
            this._enabled && !Kb.isPointerLocked() && (this._calcMouseCoords(a), null !== cc && this._onElementMouseEvent("mouseup", a))
        },
        _handleDown: function(a) {
            this._enabled && !Kb.isPointerLocked() && (this._calcMouseCoords(a), null !==
                cc && this._onElementMouseEvent("mousedown", a))
        },
        _handleMove: function(a) {
            this._enabled && (this._calcMouseCoords(a), null !== cc && (this._onElementMouseEvent("mousemove", a), this._lastX = cc, this._lastY = Cd))
        },
        _handleWheel: function(a) {
            this._enabled && (this._calcMouseCoords(a), null !== cc && this._onElementMouseEvent("mousewheel", a))
        },
        _determineTouchedElements: function(a) {
            var b = {},
                c = this.app.systems.camera.cameras,
                d, e;
            for (d = c.length - 1; 0 <= d; d--) {
                var f = c[d],
                    g = 0;
                var k = 0;
                for (e = a.changedTouches.length; k < e; k++)
                    if (b[a.changedTouches[k].identifier]) g++;
                    else {
                        var h = this._calcTouchCoords(a.changedTouches[k]),
                            l = this._getTargetElement(f, h.x, h.y);
                        l && (g++, b[a.changedTouches[k].identifier] = {
                            element: l,
                            camera: f,
                            x: h.x,
                            y: h.y
                        })
                    }
                if (g === e) break
            }
            return b
        },
        _handleTouchStart: function(a) {
            if (this._enabled) {
                for (var b = this._determineTouchedElements(a), c = 0, d = a.changedTouches.length; c < d; c++) {
                    var e = a.changedTouches[c],
                        f = b[e.identifier],
                        g = this._touchedElements[e.identifier];
                    !f || g && f.element === g.element || (this._fireEvent(a.type, new Pc(a, f.element, f.camera, f.x, f.y, e)), this._touchesForWhichTouchLeaveHasFired[e.identifier] = !1)
                }
                for (var k in b) this._touchedElements[k] = b[k]
            }
        },
        _handleTouchEnd: function(a) {
            if (this._enabled) {
                var b = this.app.systems.camera.cameras;
                for (c in this._clickedEntities) delete this._clickedEntities[c];
                var c = 0;
                for (var d = a.changedTouches.length; c < d; c++) {
                    var e = a.changedTouches[c],
                        f = this._touchedElements[e.identifier];
                    if (f) {
                        var g = f.element,
                            k = f.camera,
                            h = f.x;
                        f = f.y;
                        delete this._touchedElements[e.identifier];
                        delete this._touchesForWhichTouchLeaveHasFired[e.identifier];
                        this._fireEvent(a.type, new Pc(a, g, k, h, f,
                            e));
                        if (0 === a.touches.length)
                            for (var l = this._calcTouchCoords(e), n = b.length - 1; 0 <= n; n--) this._getTargetElement(b[n], l.x, l.y) !== g || this._clickedEntities[g.entity.getGuid()] || (this._fireEvent("click", new Pc(a, g, k, h, f, e)), this._clickedEntities[g.entity.getGuid()] = !0)
                    }
                }
            }
        },
        _handleTouchMove: function(a) {
            a.preventDefault();
            if (this._enabled)
                for (var b = this._determineTouchedElements(a), c = 0, d = a.changedTouches.length; c < d; c++) {
                    var e = a.changedTouches[c],
                        f = b[e.identifier],
                        g = this._touchedElements[e.identifier];
                    if (g) {
                        var k =
                            this._calcTouchCoords(e);
                        f && f.element === g.element || this._touchesForWhichTouchLeaveHasFired[e.identifier] || (this._fireEvent("touchleave", new Pc(a, g.element, g.camera, k.x, k.y, e)), this._touchesForWhichTouchLeaveHasFired[e.identifier] = !0);
                        this._fireEvent("touchmove", new Pc(a, g.element, g.camera, k.x, k.y, e))
                    }
                }
        },
        _onElementMouseEvent: function(a, b) {
            var c, d = this._hoveredElement;
            this._hoveredElement = null;
            for (var e = this.app.systems.camera.cameras, f, g = e.length - 1; 0 <= g && !(f = e[g], c = this._getTargetElement(f, cc, Cd)); g--);
            c && (this._fireEvent(a, new td(b, c, f, cc, Cd, this._lastX, this._lastY)), this._hoveredElement = c, "mousedown" === a && (this._pressedElement = c));
            d !== this._hoveredElement && (d && this._fireEvent("mouseleave", new td(b, d, f, cc, Cd, this._lastX, this._lastY)), this._hoveredElement && this._fireEvent("mouseenter", new td(b, this._hoveredElement, f, cc, Cd, this._lastX, this._lastY)));
            "mouseup" === a && this._pressedElement && (this._pressedElement === this._hoveredElement ? (this._pressedElement = null, this._clickedEntities && this._clickedEntities[this._hoveredElement.entity.getGuid()] ||
                this._fireEvent("click", new td(b, this._hoveredElement, f, cc, Cd, this._lastX, this._lastY))) : this._pressedElement = null)
        },
        _onXrStart: function() {
            this.app.xr.on("end", this._onXrEnd, this);
            this.app.xr.on("update", this._onXrUpdate, this);
            this.app.xr.input.on("selectstart", this._onSelectStart, this);
            this.app.xr.input.on("selectend", this._onSelectEnd, this);
            this.app.xr.input.on("remove", this._onXrInputRemove, this)
        },
        _onXrEnd: function() {
            this.app.xr.off("update", this._onXrUpdate, this);
            this.app.xr.input.off("selectstart",
                this._onSelectStart, this);
            this.app.xr.input.off("selectend", this._onSelectEnd, this);
            this.app.xr.input.off("remove", this._onXrInputRemove, this)
        },
        _onXrUpdate: function() {
            if (this._enabled)
                for (var a = this.app.xr.input.inputSources, b = 0; b < a.length; b++) this._onElementSelectEvent("selectmove", a[b], null)
        },
        _onXrInputRemove: function(a) {
            var b = this._selectedElements[a.id];
            b && (a._elementEntity = null, this._fireEvent("selectleave", new lc(null, b, null, a)));
            delete this._selectedElements[a.id];
            delete this._selectedPressedElements[a.id]
        },
        _onSelectStart: function(a, b) {
            this._enabled && this._onElementSelectEvent("selectstart", a, b)
        },
        _onSelectEnd: function(a, b) {
            this._enabled && this._onElementSelectEvent("selectend", a, b)
        },
        _onElementSelectEvent: function(a, b, c) {
            var d, e = this._selectedElements[b.id],
                f = this.app.systems.camera.cameras;
            if (b.elementInput) {
                zk.set(b.getOrigin(), b.getDirection());
                for (var g = f.length - 1; 0 <= g; g--) {
                    var k = f[g];
                    if (d = this._getTargetElementByRay(zk, k)) break
                }
            }
            b._elementEntity = d || null;
            if (d) var h = this._selectedElements[b.id] = d;
            else delete this._selectedElements[b.id];
            e !== h && (e && this._fireEvent("selectleave", new lc(c, e, k, b)), h && this._fireEvent("selectenter", new lc(c, h, k, b)));
            "selectstart" === a && (this._selectedPressedElements[b.id] = h) && this._fireEvent("selectstart", new lc(c, h, k, b));
            d = this._selectedPressedElements[b.id];
            !b.elementInput && d && (delete this._selectedPressedElements[b.id], e && this._fireEvent("selectend", new lc(c, e, k, b)));
            "selectend" === a && b.elementInput && (delete this._selectedPressedElements[b.id], e && this._fireEvent("selectend", new lc(c, e, k, b)), d && d === e &&
                this._fireEvent("click", new lc(c, d, k, b)))
        },
        _fireEvent: function(a, b) {
            for (var c = b.element;;) {
                c.fire(a, b);
                if (b._stopPropagation) break;
                if (!c.entity.parent) break;
                c = c.entity.parent.element;
                if (!c) break
            }
        },
        _calcMouseCoords: function(a) {
            var b = this._target.getBoundingClientRect(),
                c = Math.floor(b.left);
            b = Math.floor(b.top);
            a.clientX < c || a.clientX >= c + this._target.clientWidth || a.clientY < b || a.clientY >= b + this._target.clientHeight ? Cd = cc = null : (cc = a.clientX - c, Cd = a.clientY - b)
        },
        _calcTouchCoords: function(a) {
            for (var b = 0, c =
                    0, d = a.target; !(d instanceof HTMLElement);) d = d.parentNode;
            do b += d.offsetLeft - d.scrollLeft, c += d.offsetTop - d.scrollTop, d = d.offsetParent; while (d);
            return {
                x: a.pageX - b,
                y: a.pageY - c
            }
        },
        _sortElements: function(a, b) {
            var c = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
            return 0 !== c ? c : a.screen && !b.screen ? -1 : !a.screen && b.screen ? 1 : a.screen || b.screen ? a.screen.screen.screenSpace && !b.screen.screen.screenSpace ? -1 : b.screen.screen.screenSpace && !a.screen.screen.screenSpace ? 1 : b.drawOrder - a.drawOrder : 0
        },
        _getTargetElement: function(a,
            b, c) {
            var d = null;
            this._elements.sort(this._sortHandler);
            for (var e, f, g = 0, k = this._elements.length; g < k; g++) {
                var h = this._elements[g],
                    l = !1;
                if (h.screen && h.screen.screen.screenSpace) {
                    void 0 === e && (e = Dd, !1 === this._calculateRayScreen(b, c, a, e) && (e = null));
                    var n = e;
                    l = !0
                } else void 0 === f && (f = rn, !1 === this._calculateRay3d(b, c, a, f) && (f = null)), n = f;
                if (n && this._checkElement(n, h, l)) {
                    d = h;
                    break
                }
            }
            return d
        },
        _getTargetElementByRay: function(a, b) {
            var c = null;
            Dd.origin.copy(a.origin);
            Dd.direction.copy(a.direction);
            Dd.end.copy(Dd.direction).scale(2 *
                b.farClip).add(Dd.origin);
            this._elements.sort(this._sortHandler);
            a = 0;
            for (b = this._elements.length; a < b; a++) {
                var d = this._elements[a];
                if ((!d.screen || !d.screen.screen.screenSpace) && this._checkElement(Dd, d, !1)) {
                    c = d;
                    break
                }
            }
            return c
        },
        _buildHitCorners: function(a, b, c, d) {
            if (a.entity && a.entity.button) {
                var e = a.entity.button.hitPadding || eq;
                rg.copy(a.entity.up);
                Zh.copy(rg).scale(-1);
                sg.copy(a.entity.right);
                $h.copy(sg).scale(-1);
                rg.scale(e.w * d);
                Zh.scale(e.y * d);
                sg.scale(e.z * c);
                $h.scale(e.x * c);
                sn.copy(b[0]).add(Zh).add($h);
                tn.copy(b[1]).add(Zh).add(sg);
                un.copy(b[2]).add(rg).add(sg);
                vn.copy(b[3]).add(rg).add($h);
                b = [sn, tn, un, vn]
            }
            return b
        },
        _calculateScaleToScreen: function(a) {
            var b = a.entity;
            a = a.screen.screen.scale;
            for (Ak.set(a, a); b && !b.screen;) Ak.mul(b.getLocalScale()), b = b.parent;
            return Ak
        },
        _calculateRayScreen: function(a, b, c, d) {
            var e = this.app.graphicsDevice.width,
                f = this.app.graphicsDevice.height,
                g = c.rect.z * e,
                k = c.rect.w * f,
                h = c.rect.x * e;
            c = (1 - c.rect.y) * f;
            var l = c - k;
            a = a * e / this._target.clientWidth;
            b = b * f / this._target.clientHeight;
            return a >= h && a <= h + g && b <= c && b >= l ? (d.origin.set(e * (a - h) / g, f - f * (b - l) / k, 1), d.direction.set(0, 0, -1), d.end.copy(d.direction).scale(2).add(d.origin), !0) : !1
        },
        _calculateRay3d: function(a, b, c, d) {
            var e = this._target.clientWidth,
                f = this._target.clientHeight,
                g = c.rect.z * e,
                k = c.rect.w * f,
                h = c.rect.x * e,
                l = (1 - c.rect.y) * f,
                n = l - k,
                p = b;
            return a >= h && a <= h + g && b <= l && p >= n ? (a = e * (a - h) / g, p = f * (p - n) / k, c.screenToWorld(a, p, c.nearClip, pn), c.screenToWorld(a, p, c.farClip, qn), d.origin.copy(pn), d.direction.set(0, 0, -1), d.end.copy(qn), !0) : !1
        },
        _checkElement: function(a,
            b, c) {
            if (b.maskedBy && !this._checkElement(a, b.maskedBy.element, c)) return !1;
            var d = c ? this._calculateScaleToScreen(b) : b.entity.getWorldTransform().getScale();
            b = this._buildHitCorners(b, c ? b.screenCorners : b.worldCorners, d.x, d.y);
            return Po(a.origin, a.end, b) ? !0 : !1
        }
    });
    Object.defineProperty(Of.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            this._enabled = a
        }
    });
    Object.defineProperty(Of.prototype, "app", {
        get: function() {
            return this._app || ea.getApplication()
        },
        set: function(a) {
            this._app = a
        }
    });
    var wn = {
            DEFAULT: {
                buttons: "PAD_FACE_1 PAD_FACE_2 PAD_FACE_3 PAD_FACE_4 PAD_L_SHOULDER_1 PAD_R_SHOULDER_1 PAD_L_SHOULDER_2 PAD_R_SHOULDER_2 PAD_SELECT PAD_START PAD_L_STICK_BUTTON PAD_R_STICK_BUTTON PAD_UP PAD_DOWN PAD_LEFT PAD_RIGHT PAD_VENDOR".split(" "),
                axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]
            },
            PS3: {
                buttons: "PAD_FACE_1 PAD_FACE_2 PAD_FACE_4 PAD_FACE_3 PAD_L_SHOULDER_1 PAD_R_SHOULDER_1 PAD_L_SHOULDER_2 PAD_R_SHOULDER_2 PAD_SELECT PAD_START PAD_L_STICK_BUTTON PAD_R_STICK_BUTTON PAD_UP PAD_DOWN PAD_LEFT PAD_RIGHT PAD_VENDOR".split(" "),
                axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]
            }
        },
        xn = {
            "Product: 0268": "PS3"
        };
    Object.assign(Hj.prototype, {
        update: function() {
            var a, b;
            var c = 0;
            for (b = this.current.length; c < b; c++) {
                var d = this.current[c].pad.buttons;
                var e = d.length;
                for (a = 0; a < e; a++) void 0 === this.previous[c] && (this.previous[c] = []), this.previous[c][a] = d[a].pressed
            }
            a = this.poll();
            c = 0;
            for (b = a.length; c < b; c++) this.current[c] = a[c]
        },
        poll: function() {
            var a = [];
            if (this.gamepadsSupported) {
                var b = navigator.getGamepads ? navigator.getGamepads() :
                    navigator.webkitGetGamepads(),
                    c, d = b.length;
                for (c = 0; c < d; c++) b[c] && a.push({
                    map: this.getMap(b[c]),
                    pad: b[c]
                })
            }
            return a
        },
        getMap: function(a) {
            for (var b in xn)
                if (0 <= a.id.indexOf(b)) return wn[xn[b]];
            return wn.DEFAULT
        },
        isPressed: function(a, b) {
            return this.current[a] ? this.current[a].pad.buttons[pc[this.current[a].map.buttons[b]]].pressed : !1
        },
        wasPressed: function(a, b) {
            if (!this.current[a]) return !1;
            b = pc[this.current[a].map.buttons[b]];
            return this.current[a].pad.buttons[b].pressed && !this.previous[a][b]
        },
        getAxis: function(a,
            b) {
            if (!this.current[a]) return !1;
            a = this.current[a].pad.axes[pc[this.current[a].map.axes[b]]];
            Math.abs(a) < this.deadZone && (a = 0);
            return a
        }
    });
    Object.assign(ce.prototype, {
        getTouchById: function(a, b) {
            var c, d = b.length;
            for (c = 0; c < d; c++)
                if (b[c].id === a) return b[c];
            return null
        }
    });
    Ue.prototype = Object.create(M.prototype);
    Ue.prototype.constructor = Ue;
    Object.assign(Ue.prototype, {
        attach: function(a) {
            this._element && this.detach();
            this._element = a;
            this._element.addEventListener("touchstart", this._startHandler, !1);
            this._element.addEventListener("touchend",
                this._endHandler, !1);
            this._element.addEventListener("touchmove", this._moveHandler, !1);
            this._element.addEventListener("touchcancel", this._cancelHandler, !1)
        },
        detach: function() {
            this._element && (this._element.removeEventListener("touchstart", this._startHandler, !1), this._element.removeEventListener("touchend", this._endHandler, !1), this._element.removeEventListener("touchmove", this._moveHandler, !1), this._element.removeEventListener("touchcancel", this._cancelHandler, !1));
            this._element = null
        },
        _handleTouchStart: function(a) {
            this.fire("touchstart",
                new ce(this, a))
        },
        _handleTouchEnd: function(a) {
            this.fire("touchend", new ce(this, a))
        },
        _handleTouchMove: function(a) {
            a.preventDefault();
            this.fire("touchmove", new ce(this, a))
        },
        _handleTouchCancel: function(a) {
            this.fire("touchcancel", new ce(this, a))
        }
    });
    xb.prototype = Object.create(M.prototype);
    xb.prototype.constructor = xb;
    xb.prototype.createTextures = function(a) {
        a = this._normalizeCharsSet(a);
        if (a.length !== this.chars.length) this._renderAtlas(a);
        else
            for (var b = 0; b < a.length; b++)
                if (a[b] !== this.chars[b]) {
                    this._renderAtlas(a);
                    break
                }
    };
    xb.prototype.updateTextures = function(a) {
        a = this._normalizeCharsSet(a);
        for (var b = [], c = 0; c < a.length; c++) {
            var d = a[c];
            this.data.chars[d] || b.push(d)
        }
        0 < b.length && this._renderAtlas(this.chars.concat(b))
    };
    xb.prototype.destroy = function() {
        for (var a = 0; a < this.textures.length; a++) this.textures[a].destroy();
        this.fontWeight = this.type = this.textures = this.intensity = this.glyphSize = this.fontSize = this.fontName = this.data = this.color = this.chars = null
    };
    xb.prototype._getAndClearContext = function(a, b) {
        var c = a.width,
            d =
            a.height;
        a = a.getContext("2d", {
            alpha: !0
        });
        a.clearRect(0, 0, c, d);
        a.fillStyle = b;
        a.fillRect(0, 0, c, d);
        return a
    };
    xb.prototype._colorToRgbString = function(a, b) {
        var c = Math.round(255 * a.r),
            d = Math.round(255 * a.g),
            e = Math.round(255 * a.b);
        return b ? "rgba(" + c + ", " + d + ", " + e + ", " + a.a + ")" : "rgb(" + c + ", " + d + ", " + e + ")"
    };
    xb.prototype.renderCharacter = function(a, b, c, d, e) {
        a.fillStyle = e;
        a.fillText(b, c, d)
    };
    xb.prototype._renderAtlas = function(a) {
        this.chars = a;
        a = 1;
        var b = this.textures[a - 1].getSource(),
            c = b.width,
            d = b.height,
            e = this._colorToRgbString(this.color, !1),
            f = this.color.a;
        this.color.a = 1 / 255;
        var g = this._colorToRgbString(this.color, !0);
        this.color.a = f;
        f = this._getAndClearContext(b, g);
        f.font = this.fontWeight + " " + this.fontSize.toString() + "px " + this.fontName;
        f.textAlign = "center";
        f.textBaseline = "alphabetic";
        this.data = this._createJson(this.chars, this.fontName, c, d);
        var k = vc.getSymbols(this.chars.join("")),
            h = this.textures.length,
            l = 0,
            n = 0,
            p = {},
            q;
        for (q = 0; q < k.length; q++) b = k[q], p[b] = this._getTextMetrics(b), l = Math.max(l, p[b].height), n = Math.max(n, p[b].descent);
        this.glyphSize =
            Math.max(this.glyphSize, l);
        l = this.glyphSize + 2 * this.padding;
        var r = this.glyphSize + 2 * this.padding,
            t = this.glyphSize / 2 + this.padding,
            u = r - n - this.padding,
            x = 0,
            v = 0;
        for (q = 0; q < k.length; q++) {
            b = k[q];
            var w = vc.getCodePoint(k[q]),
                y = this.fontSize;
            f.font = this.fontWeight + " " + y.toString() + "px " + this.fontName;
            f.textAlign = "center";
            f.textBaseline = "alphabetic";
            var A = f.measureText(b).width;
            A > y && (y = this.fontSize * this.fontSize / A, f.font = this.fontWeight + " " + y.toString() + "px " + this.fontName, A = this.fontSize);
            this.renderCharacter(f,
                b, x + t, v + u, e);
            this._addChar(this.data, b, w, x, v, l, r, this.padding + (this.glyphSize - A) / 2, -this.padding + p[b].descent - n, A, a - 1, c, d);
            x += l;
            x + l > c && (x = 0, v += r, v + r > d && (this.textures[a - 1].upload(), a++, v = 0, a > h ? (b = document.createElement("canvas"), b.height = d, b.width = c, f = this._getAndClearContext(b, g), w = new V(this.app.graphicsDevice, {
                format: 7,
                autoMipmap: !0
            }), w.name = "font-atlas", w.setSource(b), w.minFilter = 5, w.magFilter = 1, w.addressU = 1, w.addressV = 1, this.textures.push(w)) : (b = this.textures[a - 1].getSource(), f = this._getAndClearContext(b,
                g))))
        }
        this.textures[a - 1].upload();
        if (a < h) {
            for (q = a; q < h; q++) this.textures[q].destroy();
            this.textures.splice(a)
        }
        this.fire("render")
    };
    xb.prototype._createJson = function(a, b, c, d) {
        return {
            version: 3,
            intensity: this.intensity,
            info: {
                face: b,
                width: c,
                height: d,
                maps: [{
                    width: c,
                    height: d
                }]
            },
            chars: {}
        }
    };
    xb.prototype._addChar = function(a, b, c, d, e, f, g, k, h, l, n, p, q) {
        a.info.maps.length < n + 1 && a.info.maps.push({
            width: p,
            height: q
        });
        p = this.fontSize / 32;
        a.chars[b] = {
            id: c,
            letter: b,
            x: d,
            y: e,
            width: f,
            height: g,
            xadvance: l / p,
            xoffset: k / p,
            yoffset: (h +
                this.padding) / p,
            scale: p,
            range: 1,
            map: n,
            bounds: [0, 0, f / p, g / p]
        }
    };
    xb.prototype._normalizeCharsSet = function(a) {
        var b = this.app.systems.element.getUnicodeConverter();
        b && (a = b(a));
        b = {};
        a = vc.getSymbols(a);
        var c;
        for (c = 0; c < a.length; c++) {
            var d = a[c];
            b[d] || (b[d] = d)
        }
        return Object.keys(b).sort()
    };
    xb.prototype._getTextMetrics = function(a) {
        var b = document.createElement("span");
        b.id = "content-span";
        b.innerHTML = a;
        a = document.createElement("div");
        a.id = "content-block";
        a.style.display = "inline-block";
        a.style.width = "1px";
        a.style.height =
            "0px";
        var c = document.createElement("div");
        c.appendChild(b);
        c.appendChild(a);
        c.style.font = this.fontName;
        c.style.fontSize = this.fontSize + "px";
        document.body.appendChild(c);
        var d = -1,
            e = -1,
            f = -1;
        try {
            a.style["vertical-align"] = "baseline", d = a.offsetTop - b.offsetTop, a.style["vertical-align"] = "bottom", f = a.offsetTop - b.offsetTop, e = f - d
        } finally {
            document.body.removeChild(c)
        }
        return {
            ascent: d,
            descent: e,
            height: f
        }
    };
    var Ka = [null, null],
        Jj = null,
        Wl, Ab = new X,
        Pf = new Float32Array(4),
        mc = [],
        Qf = !1,
        Lj = !1,
        Kj = !1,
        Qo = /uniform[ \t\n\r]+\S+[ \t\n\r]+\S+[ \t\n\r]*;/g,
        Ro = /\S+[ \t\n\r]*;/,
        So = /[ \t\n\r]*;/,
        ap = /(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^;]+[ \t\n\r]*,*)+;/g,
        bp = /(float|int|bool|vec2|vec3|vec4|struct|,|;|\{|\})/g,
        cp = /(uniform|varying|in|out)[ \t\n\r]+(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^;]+[ \t\n\r]*,*)+;/g,
        dp = /(float|int|bool|vec2|vec3|vec4|struct|uniform|varying|in|out|,|;|\{|\})/g,
        To = /#version/g,
        Uo = /out highp vec4 pc_fragColor;/g,
        Vo = /#define gl_FragColor/g,
        Wo = /gl_FragColor/g,
        Xo = /uniform[ \t\n\r]+sampler2D[ \t\n\r]+uColorBuffer;/g,
        Yo = /(varying|in)[ \t\n\r]+vec2[ \t\n\r]+vUv0;/g,
        Zo = /(texture2D|texture)[ \t\n\r]*\([ \t\n\r]*uColorBuffer/g,
        $o = /void[ \t\n\r]+main/g;
    Vl.prototype.addToComposition = function(a) {
        this.app.scene.layers.insertTransparent(this.layer, a)
    };
    var ai = {
        write: function(a) {
            console.log(a)
        },
        open: function() {
            ai.write("Powered by PlayCanvas 1.37.0 ef8e593")
        },
        info: function(a) {
            console.info("INFO:\t" + a)
        },
        debug: function(a) {
            console.debug("DEBUG:   " + a)
        },
        error: function(a) {
            console.error("ERROR:   " + a)
        },
        warning: function(a) {
            console.warn("WARNING: " +
                a)
        },
        alert: function(a) {
            ai.write("ALERT:   " + a);
            alert(a)
        },
        assert: function(a, b) {
            !1 === a && ai.write("ASSERT:  " + b)
        }
    };
    vc.endsWith = function(a, b) {
        return a.endsWith(b)
    };
    vc.startsWith = function(a, b) {
        return a.startsWith(b)
    };
    var fq = {
        now: Lb,
        Timer: ei
    };
    Object.defineProperty(L.prototype, "data", {
        get: function() {
            this._data || (this._data = new Float32Array(4));
            this._data[0] = this.r;
            this._data[1] = this.g;
            this._data[2] = this.b;
            this._data[3] = this.a;
            return this._data
        }
    });
    Object.defineProperty(L.prototype, "data3", {
        get: function() {
            this._data3 ||
                (this._data3 = new Float32Array(3));
            this._data3[0] = this.r;
            this._data3[1] = this.g;
            this._data3[2] = this.b;
            return this._data3
        }
    });
    N.INV_LOG2 = Math.LOG2E;
    N.intToBytes = N.intToBytes32;
    N.bytesToInt = N.bytesToInt32;
    Object.defineProperty(P.prototype, "data", {
        get: function() {
            this._data || (this._data = new Float32Array(2));
            this._data[0] = this.x;
            this._data[1] = this.y;
            return this._data
        }
    });
    Object.defineProperty(z.prototype, "data", {
        get: function() {
            this._data || (this._data = new Float32Array(3));
            this._data[0] = this.x;
            this._data[1] =
                this.y;
            this._data[2] = this.z;
            return this._data
        }
    });
    Object.defineProperty(X.prototype, "data", {
        get: function() {
            this._data || (this._data = new Float32Array(4));
            this._data[0] = this.x;
            this._data[1] = this.y;
            this._data[2] = this.z;
            this._data[3] = this.w;
            return this._data
        }
    });
    var gq = {
        Aabb: oa,
        Sphere: Ed,
        Plane: hi
    };
    Ed.prototype.intersectRay = Ed.prototype.intersectsRay;
    ug.prototype.update = function(a, b) {
        var c = new J;
        c.mul2(a, b);
        this.setFromMat4(c)
    };
    Mj.prototype = Error.prototype;
    Nj.prototype = Error.prototype;
    var hq = {
            ADDRESS_CLAMP_TO_EDGE: 1,
            ADDRESS_MIRRORED_REPEAT: 2,
            ADDRESS_REPEAT: 0,
            BLENDMODE_ZERO: 0,
            BLENDMODE_ONE: 1,
            BLENDMODE_SRC_COLOR: 2,
            BLENDMODE_ONE_MINUS_SRC_COLOR: 3,
            BLENDMODE_DST_COLOR: 4,
            BLENDMODE_ONE_MINUS_DST_COLOR: 5,
            BLENDMODE_SRC_ALPHA: 6,
            BLENDMODE_SRC_ALPHA_SATURATE: 7,
            BLENDMODE_ONE_MINUS_SRC_ALPHA: 8,
            BLENDMODE_DST_ALPHA: 9,
            BLENDMODE_ONE_MINUS_DST_ALPHA: 10,
            BUFFER_STATIC: 0,
            BUFFER_DYNAMIC: 1,
            BUFFER_STREAM: 2,
            CULLFACE_NONE: 0,
            CULLFACE_BACK: 1,
            CULLFACE_FRONT: 2,
            CULLFACE_FRONTANDBACK: 3,
            ELEMENTTYPE_INT8: 0,
            ELEMENTTYPE_UINT8: 1,
            ELEMENTTYPE_INT16: 2,
            ELEMENTTYPE_UINT16: 3,
            ELEMENTTYPE_INT32: 4,
            ELEMENTTYPE_UINT32: 5,
            ELEMENTTYPE_FLOAT32: 6,
            FILTER_NEAREST: 0,
            FILTER_LINEAR: 1,
            FILTER_NEAREST_MIPMAP_NEAREST: 2,
            FILTER_NEAREST_MIPMAP_LINEAR: 3,
            FILTER_LINEAR_MIPMAP_NEAREST: 4,
            FILTER_LINEAR_MIPMAP_LINEAR: 5,
            INDEXFORMAT_UINT8: 0,
            INDEXFORMAT_UINT16: 1,
            INDEXFORMAT_UINT32: 2,
            PIXELFORMAT_R5_G6_B5: 3,
            PIXELFORMAT_R8_G8_B8: 6,
            PIXELFORMAT_R8_G8_B8_A8: 7,
            PRIMITIVE_POINTS: 0,
            PRIMITIVE_LINES: 1,
            PRIMITIVE_LINELOOP: 2,
            PRIMITIVE_LINESTRIP: 3,
            PRIMITIVE_TRIANGLES: 4,
            PRIMITIVE_TRISTRIP: 5,
            PRIMITIVE_TRIFAN: 6,
            SEMANTIC_POSITION: "POSITION",
            SEMANTIC_NORMAL: "NORMAL",
            SEMANTIC_COLOR: "COLOR",
            SEMANTIC_TEXCOORD: "TEXCOORD",
            SEMANTIC_TEXCOORD0: "TEXCOORD0",
            SEMANTIC_TEXCOORD1: "TEXCOORD1",
            SEMANTIC_ATTR0: "ATTR0",
            SEMANTIC_ATTR1: "ATTR1",
            SEMANTIC_ATTR2: "ATTR2",
            SEMANTIC_ATTR3: "ATTR3",
            TEXTURELOCK_READ: 1,
            TEXTURELOCK_WRITE: 2,
            drawQuadWithShader: La,
            programlib: qh,
            shaderChunks: F,
            ContextCreationError: Nj,
            Device: jb,
            IndexBuffer: dc,
            ProgramLibrary: Jb,
            RenderTarget: sa,
            ScopeId: ch,
            Shader: te,
            ShaderInput: Bj,
            Texture: V,
            UnsupportedBrowserError: Mj,
            VertexBuffer: ab,
            VertexFormat: Na,
            VertexIterator: Pb
        },
        iq = {
            createFullscreenQuad: Ol,
            drawFullscreenQuad: Pl,
            PostEffect: Cj,
            PostEffectQueue: Yg
        };
    Object.defineProperty(F, "transformSkinnedVS", {
        get: function() {
            return "#define SKIN\n" + F.transformVS
        }
    });
    Object.defineProperties(V.prototype, {
        rgbm: {
            get: function() {
                return "rgbm" === this.type
            },
            set: function(a) {
                this.type = a ? "rgbm" : "default"
            }
        },
        swizzleGGGR: {
            get: function() {
                return "swizzleGGGR" === this.type
            },
            set: function(a) {
                this.type = a ? "swizzleGGGR" : "default"
            }
        }
    });
    var jq = ma,
        kq = {
            partitionSkin: cl,
            procedural: {
                calculateTangents: Uk,
                createMesh: Qb,
                createTorus: Vk,
                createCylinder: ri,
                createCapsule: si,
                createCone: ti,
                createSphere: ui,
                createPlane: vi,
                createBox: Hg
            },
            BasicMaterial: ed,
            Command: yg,
            DepthMaterial: be,
            ForwardRenderer: Ag,
            GraphNode: Z,
            Material: la,
            Mesh: sb,
            MeshInstance: va,
            Model: tb,
            ParticleEmitter: $b,
            PhongMaterial: ma,
            Picker: qd,
            Projection: {
                ORTHOGRAPHIC: 1,
                PERSPECTIVE: 0
            },
            Scene: ra,
            Skin: Kg,
            SkinInstance: Ic
        };
    Z.prototype._dirtify = function(a) {
        a ? this._dirtifyLocal() : this._dirtifyWorld()
    };
    Z.prototype.addLabel = function(a) {
        this._labels[a] = !0
    };
    Z.prototype.getLabels = function() {
        return Object.keys(this._labels)
    };
    Z.prototype.hasLabel = function(a) {
        return !!this._labels[a]
    };
    Z.prototype.removeLabel = function(a) {
        delete this._labels[a]
    };
    Z.prototype.findByLabel = function(a, b) {
        var c, d = this._children.length;
        b = b || [];
        this.hasLabel(a) && b.push(this);
        for (c = 0; c < d; ++c) b = this._children[c].findByLabel(a, b);
        return b
    };
    Z.prototype.getChildren = function() {
        return this.children
    };
    Z.prototype.getName = function() {
        return this.name
    };
    Z.prototype.getPath = function() {
        return this.path
    };
    Z.prototype.getRoot = function() {
        return this.root
    };
    Z.prototype.getParent = function() {
        return this.parent
    };
    Z.prototype.setName = function(a) {
        this.name = a
    };
    la.prototype.getName = function() {
        return this.name
    };
    la.prototype.setName = function(a) {
        this.name = a
    };
    la.prototype.getShader = function() {
        return this.shader
    };
    la.prototype.setShader = function(a) {
        this.shader = a
    };
    var lq = {
            Animation: Rb,
            Key: Ig,
            Node: Jg,
            Skeleton: Ta
        },
        mq = {
            AudioManager: ec,
            Channel: ac,
            Channel3d: $a,
            Listener: wi,
            Sound: Ng
        };
    ec.prototype.getListener = function() {
        return this.listener
    };
    ec.prototype.getVolume = function() {
        return this.volume
    };
    ec.prototype.setVolume = function(a) {
        this.volume = a
    };
    Nd.prototype.getAssetById = function(a) {
        return this.get(a)
    };
    Object.defineProperty(ta.prototype, "ray", {
        get: function() {
            return this._rayLocal
        }
    });
    Object.defineProperty(ta.prototype, "position", {
        get: function() {
            return this._localPosition
        }
    });
    Object.defineProperty(ta.prototype, "rotation", {
        get: function() {
            return this._localRotation
        }
    });
    var nq = {
        getTouchTargetCoords: Ij,
        Controller: lb,
        GamePads: Hj,
        Keyboard: kb,
        KeyboardEvent: Dj,
        Mouse: Kb,
        MouseEvent: rd,
        Touch: kh,
        TouchDevice: Ue,
        TouchEvent: ce
    };
    Object.defineProperty(Of.prototype, "wheel", {
        get: function() {
            return -2 * this.wheelDelta
        }
    });
    Object.defineProperty(rd.prototype, "wheel", {
        get: function() {
            return -2 * this.wheelDelta
        }
    });
    var oq = Je,
        pq = {
            Application: ea,
            Component: O,
            ComponentData: Tl,
            ComponentSystem: H,
            Entity: fa,
            FillMode: {
                NONE: "NONE",
                FILL_WINDOW: "FILL_WINDOW",
                KEEP_ASPECT: bh
            },
            ResolutionMode: {
                AUTO: "AUTO",
                FIXED: zj
            }
        };
    ea.prototype.isFullscreen = function() {
        return !!document.fullscreenElement
    };
    ea.prototype.enableFullscreen =
        function(a, b, c) {
            a = a || this.graphicsDevice.canvas;
            var d = function() {
                    b();
                    document.removeEventListener("fullscreenchange", d)
                },
                e = function() {
                    c();
                    document.removeEventListener("fullscreenerror", e)
                };
            b && document.addEventListener("fullscreenchange", d, !1);
            c && document.addEventListener("fullscreenerror", e, !1);
            a.requestFullscreen ? a.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : c()
        };
    ea.prototype.disableFullscreen = function(a) {
        var b = function() {
            a();
            document.removeEventListener("fullscreenchange", b)
        };
        a && document.addEventListener("fullscreenchange",
            b, !1);
        document.exitFullscreen()
    };
    Object.defineProperty(Ob.prototype, "node", {
        get: function() {
            return this.entity
        }
    });
    Object.defineProperty(ld.prototype, "enable", {
        get: function() {
            return this.enabled
        },
        set: function(a) {
            this.enabled = a
        }
    });
    Ga.prototype.setVisible = function(a) {
        this.enabled = a
    };
    Object.defineProperty(hc.prototype, "bodyType", {
        get: function() {
            return this.type
        },
        set: function(a) {
            this.type = a
        }
    });
    hc.prototype.syncBodyToEntity = function() {
        this._updateDynamic()
    };
    Wd.prototype.setGravity = function() {
        1 === arguments.length ?
            this.gravity.copy(arguments[0]) : this.gravity.set(arguments[0], arguments[1], arguments[2])
    };
    m.ABSOLUTE_URL = hf;
    m.ACTION_GAMEPAD = "gamepad";
    m.ACTION_KEYBOARD = "keyboard";
    m.ACTION_MOUSE = "mouse";
    m.ADDRESS_CLAMP_TO_EDGE = 1;
    m.ADDRESS_MIRRORED_REPEAT = 2;
    m.ADDRESS_REPEAT = 0;
    m.ANIM_BLEND_1D = "1D";
    m.ANIM_BLEND_2D_CARTESIAN = "2D_CARTESIAN";
    m.ANIM_BLEND_2D_DIRECTIONAL = "2D_DIRECTIONAL";
    m.ANIM_BLEND_DIRECT = "DIRECT";
    m.ANIM_EQUAL_TO = "EQUAL_TO";
    m.ANIM_GREATER_THAN = "GREATER_THAN";
    m.ANIM_GREATER_THAN_EQUAL_TO = "GREATER_THAN_EQUAL_TO";
    m.ANIM_INTERRUPTION_NEXT = "NEXT_STATE";
    m.ANIM_INTERRUPTION_NEXT_PREV = "NEXT_STATE_PREV_STATE";
    m.ANIM_INTERRUPTION_NONE = "NONE";
    m.ANIM_INTERRUPTION_PREV = "PREV_STATE";
    m.ANIM_INTERRUPTION_PREV_NEXT = "PREV_STATE_NEXT_STATE";
    m.ANIM_LESS_THAN = "LESS_THAN";
    m.ANIM_LESS_THAN_EQUAL_TO = "LESS_THAN_EQUAL_TO";
    m.ANIM_NOT_EQUAL_TO = "NOT_EQUAL_TO";
    m.ANIM_PARAMETER_BOOLEAN = "BOOLEAN";
    m.ANIM_PARAMETER_FLOAT = "FLOAT";
    m.ANIM_PARAMETER_INTEGER = "INTEGER";
    m.ANIM_PARAMETER_TRIGGER = "TRIGGER";
    m.ANIM_STATE_ANY = "ANY";
    m.ANIM_STATE_END =
        "END";
    m.ANIM_STATE_START = "START";
    m.ASPECT_AUTO = 0;
    m.ASPECT_MANUAL = 1;
    m.ASSET_ANIMATION = "animation";
    m.ASSET_AUDIO = "audio";
    m.ASSET_CONTAINER = "container";
    m.ASSET_CSS = "css";
    m.ASSET_CUBEMAP = "cubemap";
    m.ASSET_HTML = "html";
    m.ASSET_IMAGE = "image";
    m.ASSET_JSON = "json";
    m.ASSET_MATERIAL = "material";
    m.ASSET_MODEL = "model";
    m.ASSET_SCRIPT = "script";
    m.ASSET_SHADER = "shader";
    m.ASSET_TEXT = "text";
    m.ASSET_TEXTURE = "texture";
    m.AXIS_KEY = "key";
    m.AXIS_MOUSE_X = "mousex";
    m.AXIS_MOUSE_Y = "mousey";
    m.AXIS_PAD_L_X = "padlx";
    m.AXIS_PAD_L_Y =
        "padly";
    m.AXIS_PAD_R_X = "padrx";
    m.AXIS_PAD_R_Y = "padry";
    m.AnimBinder = uc;
    m.AnimClip = yf;
    m.AnimClipHandler = Ai;
    m.AnimComponent = jd;
    m.AnimComponentLayer = Ug;
    m.AnimComponentSystem = ze;
    m.AnimController = Wg;
    m.AnimCurve = Lg;
    m.AnimData = xf;
    m.AnimEvaluator = Ja;
    m.AnimPropertyLocator = wf;
    m.AnimSnapshot = Yk;
    m.AnimStateGraph = Af;
    m.AnimStateGraphHandler = Bi;
    m.AnimTarget = Jc;
    m.AnimTrack = Md;
    m.Animation = Rb;
    m.AnimationComponent = id;
    m.AnimationComponentSystem = ye;
    m.AnimationHandler = zi;
    m.Application = ea;
    m.Asset = aa;
    m.AssetListLoader = Eb;
    m.AssetReference = wc;
    m.AssetRegistry = Nd;
    m.AudioHandler = Bf;
    m.AudioListenerComponent = Qd;
    m.AudioListenerComponentSystem = Ae;
    m.AudioSourceComponent = Rd;
    m.AudioSourceComponentSystem = Be;
    m.BAKE_COLOR = 0;
    m.BAKE_COLORDIR = 1;
    m.BLENDEQUATION_ADD = 0;
    m.BLENDEQUATION_MAX = 4;
    m.BLENDEQUATION_MIN = 3;
    m.BLENDEQUATION_REVERSE_SUBTRACT = 2;
    m.BLENDEQUATION_SUBTRACT = 1;
    m.BLENDMODE_DST_ALPHA = 9;
    m.BLENDMODE_DST_COLOR = 4;
    m.BLENDMODE_ONE = 1;
    m.BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
    m.BLENDMODE_ONE_MINUS_DST_COLOR = 5;
    m.BLENDMODE_ONE_MINUS_SRC_ALPHA =
        8;
    m.BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
    m.BLENDMODE_SRC_ALPHA = 6;
    m.BLENDMODE_SRC_ALPHA_SATURATE = 7;
    m.BLENDMODE_SRC_COLOR = 2;
    m.BLENDMODE_ZERO = 0;
    m.BLEND_ADDITIVE = 1;
    m.BLEND_ADDITIVEALPHA = 6;
    m.BLEND_MAX = 10;
    m.BLEND_MIN = 9;
    m.BLEND_MULTIPLICATIVE = 5;
    m.BLEND_MULTIPLICATIVE2X = 7;
    m.BLEND_NONE = 3;
    m.BLEND_NORMAL = 2;
    m.BLEND_PREMULTIPLIED = 4;
    m.BLEND_SCREEN = 8;
    m.BLEND_SUBTRACTIVE = 0;
    m.BLUR_BOX = 0;
    m.BLUR_GAUSSIAN = 1;
    m.BODYFLAG_KINEMATIC_OBJECT = 2;
    m.BODYFLAG_NORESPONSE_OBJECT = 4;
    m.BODYFLAG_STATIC_OBJECT = 1;
    m.BODYGROUP_DEFAULT = 1;
    m.BODYGROUP_DYNAMIC =
        1;
    m.BODYGROUP_ENGINE_1 = 8;
    m.BODYGROUP_ENGINE_2 = 32;
    m.BODYGROUP_ENGINE_3 = 64;
    m.BODYGROUP_KINEMATIC = 4;
    m.BODYGROUP_NONE = 0;
    m.BODYGROUP_STATIC = wj;
    m.BODYGROUP_TRIGGER = 16;
    m.BODYGROUP_USER_1 = 128;
    m.BODYGROUP_USER_2 = 256;
    m.BODYGROUP_USER_3 = 512;
    m.BODYGROUP_USER_4 = 1024;
    m.BODYGROUP_USER_5 = 2048;
    m.BODYGROUP_USER_6 = 4096;
    m.BODYGROUP_USER_7 = 8192;
    m.BODYGROUP_USER_8 = 16384;
    m.BODYMASK_ALL = 65535;
    m.BODYMASK_NONE = 0;
    m.BODYMASK_NOT_STATIC = $g;
    m.BODYMASK_NOT_STATIC_KINEMATIC = 65529;
    m.BODYMASK_STATIC = 2;
    m.BODYSTATE_ACTIVE_TAG = 1;
    m.BODYSTATE_DISABLE_DEACTIVATION =
        4;
    m.BODYSTATE_DISABLE_SIMULATION = 5;
    m.BODYSTATE_ISLAND_SLEEPING = 2;
    m.BODYSTATE_WANTS_DEACTIVATION = 3;
    m.BODYTYPE_DYNAMIC = "dynamic";
    m.BODYTYPE_KINEMATIC = "kinematic";
    m.BODYTYPE_STATIC = Je;
    m.BUFFER_DYNAMIC = 1;
    m.BUFFER_GPUDYNAMIC = 3;
    m.BUFFER_STATIC = 0;
    m.BUFFER_STREAM = 2;
    m.BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;
    m.BUTTON_TRANSITION_MODE_TINT = Xg;
    m.BasicMaterial = ed;
    m.BasisParser = gj;
    m.Batch = ki;
    m.BatchGroup = bb;
    m.BatchManager = Ia;
    m.BinaryHandler = Ci;
    m.BoundingBox = oa;
    m.BoundingSphere = Ed;
    m.Bundle = Cf;
    m.BundleHandler = Ei;
    m.BundleRegistry =
        kj;
    m.ButtonComponent = Sd;
    m.ButtonComponentSystem = Ce;
    m.CLEARFLAG_COLOR = 1;
    m.CLEARFLAG_DEPTH = 2;
    m.CLEARFLAG_STENCIL = 4;
    m.COMPUPDATED_BLEND = 8;
    m.COMPUPDATED_CAMERAS = 4;
    m.COMPUPDATED_INSTANCES = 1;
    m.COMPUPDATED_LIGHTS = 2;
    m.CUBEFACE_NEGX = 1;
    m.CUBEFACE_NEGY = 3;
    m.CUBEFACE_NEGZ = 5;
    m.CUBEFACE_POSX = 0;
    m.CUBEFACE_POSY = 2;
    m.CUBEFACE_POSZ = 4;
    m.CUBEPROJ_BOX = 1;
    m.CUBEPROJ_NONE = 0;
    m.CULLFACE_BACK = 1;
    m.CULLFACE_FRONT = 2;
    m.CULLFACE_FRONTANDBACK = 3;
    m.CULLFACE_NONE = 0;
    m.CURVE_CARDINAL = 3;
    m.CURVE_CATMULL = 2;
    m.CURVE_LINEAR = 0;
    m.CURVE_SMOOTHSTEP =
        1;
    m.CURVE_SPLINE = 4;
    m.CURVE_STEP = 5;
    m.Camera = pa;
    m.CameraComponent = Ob;
    m.CameraComponentSystem = Oe;
    m.CanvasFont = xb;
    m.CollisionComponent = ne;
    m.CollisionComponentSystem = Ne;
    m.Color = L;
    m.Command = yg;
    m.Component = O;
    m.ComponentData = Tl;
    m.ComponentSystem = H;
    m.ComponentSystemRegistry = qj;
    m.ContactPoint = Cl;
    m.ContactResult = Dl;
    m.ContainerHandler = Gi;
    m.ContainerResource = Fi;
    m.ContextCreationError = Nj;
    m.Controller = lb;
    m.CssHandler = Hi;
    m.CubemapHandler = Ii;
    m.Curve = hb;
    m.CurveSet = Cb;
    m.DETAILMODE_ADD = "add";
    m.DETAILMODE_MAX = "max";
    m.DETAILMODE_MIN =
        "min";
    m.DETAILMODE_MUL = "mul";
    m.DETAILMODE_OVERLAY = "overlay";
    m.DETAILMODE_SCREEN = "screen";
    m.DISTANCE_EXPONENTIAL = "exponential";
    m.DISTANCE_INVERSE = Kf;
    m.DISTANCE_LINEAR = "linear";
    m.DefaultAnimBinder = zf;
    m.DepthMaterial = be;
    m.ELEMENTTYPE_FLOAT32 = 6;
    m.ELEMENTTYPE_GROUP = ul;
    m.ELEMENTTYPE_IMAGE = "image";
    m.ELEMENTTYPE_INT16 = 2;
    m.ELEMENTTYPE_INT32 = 4;
    m.ELEMENTTYPE_INT8 = 0;
    m.ELEMENTTYPE_TEXT = "text";
    m.ELEMENTTYPE_UINT16 = 3;
    m.ELEMENTTYPE_UINT32 = 5;
    m.ELEMENTTYPE_UINT8 = 1;
    m.EMITTERSHAPE_BOX = 0;
    m.EMITTERSHAPE_SPHERE = 1;
    m.EVENT_KEYDOWN =
        "keydown";
    m.EVENT_KEYUP = "keyup";
    m.EVENT_MOUSEDOWN = "mousedown";
    m.EVENT_MOUSEMOVE = "mousemove";
    m.EVENT_MOUSEUP = "mouseup";
    m.EVENT_MOUSEWHEEL = "mousewheel";
    m.EVENT_SELECT = "select";
    m.EVENT_SELECTEND = "selectend";
    m.EVENT_SELECTSTART = "selectstart";
    m.EVENT_TOUCHCANCEL = "touchcancel";
    m.EVENT_TOUCHEND = "touchend";
    m.EVENT_TOUCHMOVE = "touchmove";
    m.EVENT_TOUCHSTART = "touchstart";
    m.ElementComponent = ia;
    m.ElementComponentSystem = Ee;
    m.ElementDragHelper = Oc;
    m.ElementInput = Of;
    m.ElementInputEvent = sd;
    m.ElementMouseEvent = td;
    m.ElementSelectEvent =
        lc;
    m.ElementTouchEvent = Pc;
    m.Entity = fa;
    m.EntityReference = Lc;
    m.EventHandler = M;
    m.FILLMODE_FILL_WINDOW = "FILL_WINDOW";
    m.FILLMODE_KEEP_ASPECT = bh;
    m.FILLMODE_NONE = "NONE";
    m.FILTER_LINEAR = 1;
    m.FILTER_LINEAR_MIPMAP_LINEAR = 5;
    m.FILTER_LINEAR_MIPMAP_NEAREST = 4;
    m.FILTER_NEAREST = 0;
    m.FILTER_NEAREST_MIPMAP_LINEAR = 3;
    m.FILTER_NEAREST_MIPMAP_NEAREST = 2;
    m.FITTING_BOTH = 3;
    m.FITTING_NONE = sj;
    m.FITTING_SHRINK = 2;
    m.FITTING_STRETCH = 1;
    m.FOG_EXP = "exp";
    m.FOG_EXP2 = "exp2";
    m.FOG_LINEAR = "linear";
    m.FOG_NONE = "none";
    m.FONT_BITMAP = "bitmap";
    m.FONT_MSDF = "msdf";
    m.FRESNEL_NONE = 0;
    m.FRESNEL_SCHLICK = 2;
    m.FUNC_ALWAYS = 7;
    m.FUNC_EQUAL = 2;
    m.FUNC_GREATER = 4;
    m.FUNC_GREATEREQUAL = 6;
    m.FUNC_LESS = 1;
    m.FUNC_LESSEQUAL = 3;
    m.FUNC_NEVER = 0;
    m.FUNC_NOTEQUAL = 5;
    m.FolderHandler = Ji;
    m.Font = Og;
    m.FontHandler = Li;
    m.ForwardRenderer = Ag;
    m.Frustum = ug;
    m.GAMMA_NONE = 0;
    m.GAMMA_SRGB = 1;
    m.GAMMA_SRGBFAST = 2;
    m.GAMMA_SRGBHDR = 3;
    m.GamePads = Hj;
    m.GraphNode = Z;
    m.GraphicsDevice = jb;
    m.HierarchyHandler = Mi;
    m.HtmlHandler = Ni;
    m.Http = da;
    m.I18n = Oa;
    m.INDEXFORMAT_UINT16 = 1;
    m.INDEXFORMAT_UINT32 = 2;
    m.INDEXFORMAT_UINT8 =
        0;
    m.INTERPOLATION_CUBIC = 2;
    m.INTERPOLATION_LINEAR = 1;
    m.INTERPOLATION_STEP = 0;
    m.ImageElement = cb;
    m.ImgParser = hj;
    m.IndexBuffer = dc;
    m.IndexedList = di;
    m.JsonHandler = Oi;
    m.JsonStandardMaterialParser = xe;
    m.KEY_0 = 48;
    m.KEY_1 = 49;
    m.KEY_2 = 50;
    m.KEY_3 = 51;
    m.KEY_4 = 52;
    m.KEY_5 = 53;
    m.KEY_6 = 54;
    m.KEY_7 = 55;
    m.KEY_8 = 56;
    m.KEY_9 = 57;
    m.KEY_A = 65;
    m.KEY_ADD = 107;
    m.KEY_ALT = 18;
    m.KEY_B = 66;
    m.KEY_BACKSPACE = 8;
    m.KEY_BACK_SLASH = 220;
    m.KEY_C = 67;
    m.KEY_CAPS_LOCK = 20;
    m.KEY_CLOSE_BRACKET = 221;
    m.KEY_COMMA = 188;
    m.KEY_CONTEXT_MENU = 93;
    m.KEY_CONTROL = 17;
    m.KEY_D =
        68;
    m.KEY_DECIMAL = 110;
    m.KEY_DELETE = 46;
    m.KEY_DIVIDE = 111;
    m.KEY_DOWN = 40;
    m.KEY_E = 69;
    m.KEY_END = 35;
    m.KEY_ENTER = 13;
    m.KEY_EQUAL = 61;
    m.KEY_ESCAPE = 27;
    m.KEY_F = 70;
    m.KEY_F1 = 112;
    m.KEY_F10 = 121;
    m.KEY_F11 = 122;
    m.KEY_F12 = 123;
    m.KEY_F2 = 113;
    m.KEY_F3 = 114;
    m.KEY_F4 = 115;
    m.KEY_F5 = 116;
    m.KEY_F6 = 117;
    m.KEY_F7 = 118;
    m.KEY_F8 = 119;
    m.KEY_F9 = 120;
    m.KEY_G = 71;
    m.KEY_H = 72;
    m.KEY_HOME = 36;
    m.KEY_I = 73;
    m.KEY_INSERT = 45;
    m.KEY_J = 74;
    m.KEY_K = 75;
    m.KEY_L = 76;
    m.KEY_LEFT = 37;
    m.KEY_M = 77;
    m.KEY_META = 224;
    m.KEY_MULTIPLY = 106;
    m.KEY_N = 78;
    m.KEY_NUMPAD_0 = 96;
    m.KEY_NUMPAD_1 =
        97;
    m.KEY_NUMPAD_2 = 98;
    m.KEY_NUMPAD_3 = 99;
    m.KEY_NUMPAD_4 = 100;
    m.KEY_NUMPAD_5 = 101;
    m.KEY_NUMPAD_6 = 102;
    m.KEY_NUMPAD_7 = 103;
    m.KEY_NUMPAD_8 = 104;
    m.KEY_NUMPAD_9 = 105;
    m.KEY_O = 79;
    m.KEY_OPEN_BRACKET = 219;
    m.KEY_P = 80;
    m.KEY_PAGE_DOWN = 34;
    m.KEY_PAGE_UP = 33;
    m.KEY_PAUSE = 19;
    m.KEY_PERIOD = 190;
    m.KEY_PRINT_SCREEN = 44;
    m.KEY_Q = 81;
    m.KEY_R = 82;
    m.KEY_RETURN = 13;
    m.KEY_RIGHT = 39;
    m.KEY_S = 83;
    m.KEY_SEMICOLON = 59;
    m.KEY_SEPARATOR = 108;
    m.KEY_SHIFT = 16;
    m.KEY_SLASH = 191;
    m.KEY_SPACE = 32;
    m.KEY_SUBTRACT = 109;
    m.KEY_T = 84;
    m.KEY_TAB = 9;
    m.KEY_U = 85;
    m.KEY_UP = 38;
    m.KEY_V = 86;
    m.KEY_W = 87;
    m.KEY_WINDOWS = 91;
    m.KEY_X = 88;
    m.KEY_Y = 89;
    m.KEY_Z = 90;
    m.Key = Ig;
    m.Keyboard = kb;
    m.KeyboardEvent = Dj;
    m.KtxParser = ij;
    m.LAYERID_DEPTH = 1;
    m.LAYERID_IMMEDIATE = 3;
    m.LAYERID_SKYBOX = 2;
    m.LAYERID_UI = 4;
    m.LAYERID_WORLD = 0;
    m.LAYER_FX = 2;
    m.LAYER_GIZMO = 1;
    m.LAYER_HUD = 0;
    m.LAYER_WORLD = 15;
    m.LIGHTFALLOFF_INVERSESQUARED = 1;
    m.LIGHTFALLOFF_LINEAR = 0;
    m.LIGHTTYPE_DIRECTIONAL = 0;
    m.LIGHTTYPE_POINT = 1;
    m.LIGHTTYPE_SPOT = 2;
    m.LINEBATCH_GIZMO = 2;
    m.LINEBATCH_OVERLAY = 1;
    m.LINEBATCH_WORLD = 0;
    m.Layer = ka;
    m.LayerComposition = xa;
    m.LayoutCalculator =
        rj;
    m.LayoutChildComponent = Ud;
    m.LayoutChildComponentSystem = Re;
    m.LayoutGroupComponent = kd;
    m.LayoutGroupComponentSystem = Fe;
    m.LegacyDdsParser = jj;
    m.Light = Va;
    m.LightComponent = ld;
    m.LightComponentSystem = Ge;
    m.Lightmapper = ni;
    m.LocalizedAsset = Ha;
    m.MASK_BAKED = 2;
    m.MASK_DYNAMIC = 1;
    m.MASK_LIGHTMAP = 4;
    m.MOUSEBUTTON_LEFT = 0;
    m.MOUSEBUTTON_MIDDLE = 1;
    m.MOUSEBUTTON_NONE = -1;
    m.MOUSEBUTTON_RIGHT = 2;
    m.Mat3 = rb;
    m.Mat4 = J;
    m.Material = la;
    m.MaterialHandler = Pi;
    m.Mesh = sb;
    m.MeshInstance = va;
    m.Model = tb;
    m.ModelComponent = Ga;
    m.ModelComponentSystem =
        He;
    m.ModelHandler = Qi;
    m.Morph = Db;
    m.MorphInstance = uf;
    m.MorphTarget = vf;
    m.Mouse = Kb;
    m.MouseEvent = rd;
    m.Node = Jg;
    m.ORIENTATION_HORIZONTAL = 0;
    m.ORIENTATION_VERTICAL = 1;
    m.OrientedBox = gi;
    m.PAD_1 = 0;
    m.PAD_2 = 1;
    m.PAD_3 = 2;
    m.PAD_4 = 3;
    m.PAD_DOWN = 13;
    m.PAD_FACE_1 = 0;
    m.PAD_FACE_2 = 1;
    m.PAD_FACE_3 = 2;
    m.PAD_FACE_4 = 3;
    m.PAD_LEFT = 14;
    m.PAD_L_SHOULDER_1 = 4;
    m.PAD_L_SHOULDER_2 = 6;
    m.PAD_L_STICK_BUTTON = 10;
    m.PAD_L_STICK_X = 0;
    m.PAD_L_STICK_Y = 1;
    m.PAD_RIGHT = 15;
    m.PAD_R_SHOULDER_1 = 5;
    m.PAD_R_SHOULDER_2 = 7;
    m.PAD_R_STICK_BUTTON = 11;
    m.PAD_R_STICK_X =
        2;
    m.PAD_R_STICK_Y = 3;
    m.PAD_SELECT = 8;
    m.PAD_START = 9;
    m.PAD_UP = 12;
    m.PAD_VENDOR = 16;
    m.PARTICLEMODE_CPU = 1;
    m.PARTICLEMODE_GPU = 0;
    m.PARTICLEORIENTATION_EMITTER = 2;
    m.PARTICLEORIENTATION_SCREEN = 0;
    m.PARTICLEORIENTATION_WORLD = 1;
    m.PARTICLESORT_DISTANCE = 1;
    m.PARTICLESORT_NEWER_FIRST = 2;
    m.PARTICLESORT_NONE = 0;
    m.PARTICLESORT_OLDER_FIRST = 3;
    m.PIXELFORMAT_111110F = 18;
    m.PIXELFORMAT_A8 = 0;
    m.PIXELFORMAT_ASTC_4x4 = 28;
    m.PIXELFORMAT_ATC_RGB = 29;
    m.PIXELFORMAT_ATC_RGBA = 30;
    m.PIXELFORMAT_DEPTH = 16;
    m.PIXELFORMAT_DEPTHSTENCIL = 17;
    m.PIXELFORMAT_DXT1 =
        8;
    m.PIXELFORMAT_DXT3 = 9;
    m.PIXELFORMAT_DXT5 = 10;
    m.PIXELFORMAT_ETC1 = 21;
    m.PIXELFORMAT_ETC2_RGB = 22;
    m.PIXELFORMAT_ETC2_RGBA = 23;
    m.PIXELFORMAT_L8 = 1;
    m.PIXELFORMAT_L8_A8 = 2;
    m.PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
    m.PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
    m.PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
    m.PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
    m.PIXELFORMAT_R32F = 15;
    m.PIXELFORMAT_R4_G4_B4_A4 = 5;
    m.PIXELFORMAT_R5_G5_B5_A1 = 4;
    m.PIXELFORMAT_R5_G6_B5 = 3;
    m.PIXELFORMAT_R8_G8_B8 = 6;
    m.PIXELFORMAT_R8_G8_B8_A8 = 7;
    m.PIXELFORMAT_RGB16F = 11;
    m.PIXELFORMAT_RGB32F = 13;
    m.PIXELFORMAT_RGBA16F = 12;
    m.PIXELFORMAT_RGBA32F = 14;
    m.PIXELFORMAT_SRGB = 19;
    m.PIXELFORMAT_SRGBA = 20;
    m.PRIMITIVE_LINELOOP = 2;
    m.PRIMITIVE_LINES = 1;
    m.PRIMITIVE_LINESTRIP = 3;
    m.PRIMITIVE_POINTS = 0;
    m.PRIMITIVE_TRIANGLES = 4;
    m.PRIMITIVE_TRIFAN = 6;
    m.PRIMITIVE_TRISTRIP = 5;
    m.PROJECTION_ORTHOGRAPHIC = 1;
    m.PROJECTION_PERSPECTIVE = 0;
    m.ParticleEmitter = $b;
    m.ParticleSystemComponent = md;
    m.ParticleSystemComponentSystem = Ie;
    m.PhongMaterial = jq;
    m.Picker = qd;
    m.Plane = hi;
    m.PostEffect = Cj;
    m.PostEffectPass = Vl;
    m.PostEffectQueue = Yg;
    m.ProgramLibrary =
        Jb;
    m.Quat = Y;
    m.RENDERSTYLE_POINTS = 2;
    m.RENDERSTYLE_SOLID = 0;
    m.RENDERSTYLE_WIREFRAME = 1;
    m.RESOLUTION_AUTO = "AUTO";
    m.RESOLUTION_FIXED = zj;
    m.RIGIDBODY_ACTIVE_TAG = 1;
    m.RIGIDBODY_CF_KINEMATIC_OBJECT = 2;
    m.RIGIDBODY_CF_NORESPONSE_OBJECT = 4;
    m.RIGIDBODY_CF_STATIC_OBJECT = 1;
    m.RIGIDBODY_DISABLE_DEACTIVATION = 4;
    m.RIGIDBODY_DISABLE_SIMULATION = 5;
    m.RIGIDBODY_ISLAND_SLEEPING = 2;
    m.RIGIDBODY_TYPE_DYNAMIC = "dynamic";
    m.RIGIDBODY_TYPE_KINEMATIC = "kinematic";
    m.RIGIDBODY_TYPE_STATIC = oq;
    m.RIGIDBODY_WANTS_DEACTIVATION = 3;
    m.Ray = cd;
    m.RaycastResult =
        xj;
    m.RenderTarget = sa;
    m.ResourceHandler = Ql;
    m.ResourceLoader = Ri;
    m.RigidBodyComponent = hc;
    m.RigidBodyComponentSystem = Wd;
    m.SCALEMODE_BLEND = "blend";
    m.SCALEMODE_NONE = Xd;
    m.SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
    m.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;
    m.SCROLL_MODE_BOUNCE = 1;
    m.SCROLL_MODE_CLAMP = 0;
    m.SCROLL_MODE_INFINITE = 2;
    m.SEMANTIC_ATTR = "ATTR";
    m.SEMANTIC_ATTR0 = "ATTR0";
    m.SEMANTIC_ATTR1 = "ATTR1";
    m.SEMANTIC_ATTR10 = "ATTR10";
    m.SEMANTIC_ATTR11 = "ATTR11";
    m.SEMANTIC_ATTR12 = "ATTR12";
    m.SEMANTIC_ATTR13 = "ATTR13";
    m.SEMANTIC_ATTR14 =
        "ATTR14";
    m.SEMANTIC_ATTR15 = "ATTR15";
    m.SEMANTIC_ATTR2 = "ATTR2";
    m.SEMANTIC_ATTR3 = "ATTR3";
    m.SEMANTIC_ATTR4 = "ATTR4";
    m.SEMANTIC_ATTR5 = "ATTR5";
    m.SEMANTIC_ATTR6 = "ATTR6";
    m.SEMANTIC_ATTR7 = "ATTR7";
    m.SEMANTIC_ATTR8 = "ATTR8";
    m.SEMANTIC_ATTR9 = "ATTR9";
    m.SEMANTIC_BLENDINDICES = "BLENDINDICES";
    m.SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
    m.SEMANTIC_COLOR = "COLOR";
    m.SEMANTIC_NORMAL = "NORMAL";
    m.SEMANTIC_POSITION = "POSITION";
    m.SEMANTIC_TANGENT = "TANGENT";
    m.SEMANTIC_TEXCOORD = "TEXCOORD";
    m.SEMANTIC_TEXCOORD0 = "TEXCOORD0";
    m.SEMANTIC_TEXCOORD1 =
        "TEXCOORD1";
    m.SEMANTIC_TEXCOORD2 = "TEXCOORD2";
    m.SEMANTIC_TEXCOORD3 = "TEXCOORD3";
    m.SEMANTIC_TEXCOORD4 = "TEXCOORD4";
    m.SEMANTIC_TEXCOORD5 = "TEXCOORD5";
    m.SEMANTIC_TEXCOORD6 = "TEXCOORD6";
    m.SEMANTIC_TEXCOORD7 = "TEXCOORD7";
    m.SHADERDEF_DIRLM = 128;
    m.SHADERDEF_INSTANCING = 32;
    m.SHADERDEF_LM = 64;
    m.SHADERDEF_MORPH_NORMAL = 2048;
    m.SHADERDEF_MORPH_POSITION = 1024;
    m.SHADERDEF_MORPH_TEXTURE_BASED = 4096;
    m.SHADERDEF_NOSHADOW = 1;
    m.SHADERDEF_SCREENSPACE = 256;
    m.SHADERDEF_SKIN = 2;
    m.SHADERDEF_TANGENTS = 512;
    m.SHADERDEF_UV0 = 4;
    m.SHADERDEF_UV1 =
        8;
    m.SHADERDEF_VCOLOR = 16;
    m.SHADERTAG_MATERIAL = 1;
    m.SHADER_DEPTH = 2;
    m.SHADER_FORWARD = 0;
    m.SHADER_FORWARDHDR = 1;
    m.SHADER_PICK = 18;
    m.SHADER_SHADOW = 3;
    m.SHADOWUPDATE_NONE = 0;
    m.SHADOWUPDATE_REALTIME = 2;
    m.SHADOWUPDATE_THISFRAME = 1;
    m.SHADOW_DEPTH = 0;
    m.SHADOW_PCF3 = 0;
    m.SHADOW_PCF5 = 4;
    m.SHADOW_VSM16 = 2;
    m.SHADOW_VSM32 = 3;
    m.SHADOW_VSM8 = 1;
    m.SORTKEY_DEPTH = 1;
    m.SORTKEY_FORWARD = 0;
    m.SORTMODE_BACK2FRONT = 3;
    m.SORTMODE_CUSTOM = 5;
    m.SORTMODE_FRONT2BACK = 4;
    m.SORTMODE_MANUAL = 1;
    m.SORTMODE_MATERIALMESH = 2;
    m.SORTMODE_NONE = 0;
    m.SPECOCC_AO = 1;
    m.SPECOCC_GLOSSDEPENDENT =
        2;
    m.SPECOCC_NONE = 0;
    m.SPECULAR_BLINN = 1;
    m.SPECULAR_PHONG = 0;
    m.SPRITETYPE_ANIMATED = "animated";
    m.SPRITETYPE_SIMPLE = "simple";
    m.SPRITE_RENDERMODE_SIMPLE = 0;
    m.SPRITE_RENDERMODE_SLICED = 1;
    m.SPRITE_RENDERMODE_TILED = 2;
    m.STENCILOP_DECREMENT = 5;
    m.STENCILOP_DECREMENTWRAP = 6;
    m.STENCILOP_INCREMENT = 3;
    m.STENCILOP_INCREMENTWRAP = 4;
    m.STENCILOP_INVERT = 7;
    m.STENCILOP_KEEP = 0;
    m.STENCILOP_REPLACE = 2;
    m.STENCILOP_ZERO = 1;
    m.Scene = ra;
    m.SceneHandler = Si;
    m.SceneRegistry = kc;
    m.SceneRegistryItem = Jl;
    m.SceneSettingsHandler = Ti;
    m.ScopeId = ch;
    m.ScopeSpace =
        dh;
    m.ScreenComponent = Hb;
    m.ScreenComponentSystem = Ke;
    m.ScriptAttributes = Yd;
    m.ScriptComponent = Xa;
    m.ScriptComponentSystem = Le;
    m.ScriptHandler = ub;
    m.ScriptLegacyComponent = Zd;
    m.ScriptLegacyComponentSystem = Pe;
    m.ScriptRegistry = fc;
    m.ScriptType = db;
    m.ScrollViewComponent = nd;
    m.ScrollViewComponentSystem = Qe;
    m.ScrollbarComponent = $d;
    m.ScrollbarComponentSystem = Me;
    m.Shader = te;
    m.ShaderHandler = Ui;
    m.SingleContactResult = Bl;
    m.Skeleton = Ta;
    m.Skin = Kg;
    m.SkinInstance = Ic;
    m.SortedLoopArray = ic;
    m.Sound = Ng;
    m.SoundComponent = jc;
    m.SoundComponentSystem =
        pd;
    m.SoundManager = ec;
    m.SoundSlot = Qa;
    m.Sprite = Sa;
    m.SpriteAnimationClip = wb;
    m.SpriteComponent = Ba;
    m.SpriteComponentSystem = ae;
    m.SpriteHandler = Vi;
    m.StandardMaterial = ma;
    m.StencilParameters = Td;
    m.TEXHINT_ASSET = 2;
    m.TEXHINT_LIGHTMAP = 3;
    m.TEXHINT_NONE = 0;
    m.TEXHINT_SHADOWMAP = 1;
    m.TEXTURELOCK_READ = 1;
    m.TEXTURELOCK_WRITE = 2;
    m.TEXTURETYPE_DEFAULT = "default";
    m.TEXTURETYPE_RGBE = "rgbe";
    m.TEXTURETYPE_RGBM = "rgbm";
    m.TEXTURETYPE_SWIZZLEGGGR = "swizzleGGGR";
    m.TONEMAP_ACES = 3;
    m.TONEMAP_ACES2 = 4;
    m.TONEMAP_FILMIC = 1;
    m.TONEMAP_HEJL = 2;
    m.TONEMAP_LINEAR = 0;
    m.TYPE_FLOAT32 = 6;
    m.TYPE_INT16 = 2;
    m.TYPE_INT32 = 4;
    m.TYPE_INT8 = 0;
    m.TYPE_UINT16 = 3;
    m.TYPE_UINT32 = 5;
    m.TYPE_UINT8 = 1;
    m.Tags = bd;
    m.Template = Rg;
    m.TemplateHandler = Yi;
    m.TemplateUtils = Zc;
    m.TextElement = na;
    m.TextHandler = Zi;
    m.Texture = V;
    m.TextureAtlas = xc;
    m.TextureAtlasHandler = $i;
    m.TextureHandler = Sg;
    m.TextureParser = hl;
    m.Timer = ei;
    m.Touch = kh;
    m.TouchDevice = Ue;
    m.TouchEvent = ce;
    m.TransformFeedback = Nf;
    m.UNIFORMTYPE_BOOL = 0;
    m.UNIFORMTYPE_BVEC2 = 9;
    m.UNIFORMTYPE_BVEC3 = 10;
    m.UNIFORMTYPE_BVEC4 = 11;
    m.UNIFORMTYPE_FLOAT =
        2;
    m.UNIFORMTYPE_FLOATARRAY = 17;
    m.UNIFORMTYPE_INT = 1;
    m.UNIFORMTYPE_IVEC2 = 6;
    m.UNIFORMTYPE_IVEC3 = 7;
    m.UNIFORMTYPE_IVEC4 = 8;
    m.UNIFORMTYPE_MAT2 = 12;
    m.UNIFORMTYPE_MAT3 = 13;
    m.UNIFORMTYPE_MAT4 = 14;
    m.UNIFORMTYPE_TEXTURE2D = 15;
    m.UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
    m.UNIFORMTYPE_TEXTURE3D = 20;
    m.UNIFORMTYPE_TEXTURECUBE = 16;
    m.UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
    m.UNIFORMTYPE_VEC2 = 3;
    m.UNIFORMTYPE_VEC2ARRAY = 21;
    m.UNIFORMTYPE_VEC3 = 4;
    m.UNIFORMTYPE_VEC3ARRAY = 22;
    m.UNIFORMTYPE_VEC4 = 5;
    m.UNIFORMTYPE_VEC4ARRAY = 23;
    m.URI = tg;
    m.UnsupportedBrowserError =
        Mj;
    m.VIEW_CENTER = 0;
    m.VIEW_LEFT = 1;
    m.VIEW_RIGHT = 2;
    m.Vec2 = P;
    m.Vec3 = z;
    m.Vec4 = X;
    m.VertexBuffer = ab;
    m.VertexFormat = Na;
    m.VertexIterator = Pb;
    m.VrDisplay = Od;
    m.VrManager = hd;
    m.XRHAND_LEFT = "left";
    m.XRHAND_NONE = "none";
    m.XRHAND_RIGHT = "right";
    m.XRSPACE_BOUNDEDFLOOR = "bounded-floor";
    m.XRSPACE_LOCAL = "local";
    m.XRSPACE_LOCALFLOOR = "local-floor";
    m.XRSPACE_UNBOUNDED = "unbounded";
    m.XRSPACE_VIEWER = "viewer";
    m.XRTARGETRAY_GAZE = "gaze";
    m.XRTARGETRAY_POINTER = "tracked-pointer";
    m.XRTARGETRAY_SCREEN = "screen";
    m.XRTRACKABLE_MESH = "mesh";
    m.XRTRACKABLE_PLANE = "plane";
    m.XRTRACKABLE_POINT = "point";
    m.XRTYPE_AR = Pd;
    m.XRTYPE_INLINE = jl;
    m.XRTYPE_VR = lj;
    m.XrHitTest = Sb;
    m.XrHitTestSource = Kc;
    m.XrInput = Fb;
    m.XrInputSource = ta;
    m.XrLightEstimation = ib;
    m.XrManager = Pa;
    m.ZoneComponent = od;
    m.ZoneComponentSystem = Se;
    m.anim = lq;
    m.apps = {};
    m.asset = {
        ASSET_ANIMATION: "animation",
        ASSET_AUDIO: "audio",
        ASSET_IMAGE: "image",
        ASSET_JSON: "json",
        ASSET_MODEL: "model",
        ASSET_MATERIAL: "material",
        ASSET_TEXT: "text",
        ASSET_TEXTURE: "texture",
        ASSET_CUBEMAP: "cubemap",
        ASSET_SCRIPT: "script"
    };
    m.audio = mq;
    m.basisDownload = ej;
    m.basisDownloadFromConfig = fl;
    m.basisInitialize = cj;
    m.basisSetDownloadConfig = function(a, b, c) {
        Hf = {
            glueUrl: a,
            wasmUrl: b,
            fallbackUrl: c
        }
    };
    m.basisTargetFormat = aj;
    m.basisTranscode = gl;
    m.calculateNormals = Tk;
    m.calculateTangents = Uk;
    m.common = {};
    m.config = {};
    m.createBox = Hg;
    m.createCapsule = si;
    m.createCone = ti;
    m.createCylinder = ri;
    m.createMesh = Qb;
    m.createPlane = vi;
    m.createScript = Ib;
    m.createSphere = ui;
    m.createStyle = function(a) {
        var b = document.createElement("style");
        b.type = "text/css";
        b.styleSheet ?
            b.styleSheet.cssText = a : b.appendChild(document.createTextNode(a));
        return b
    };
    m.createTorus = Vk;
    m.createURI = function(a) {
        var b = "";
        if ((a.authority || a.scheme) && (a.host || a.hostpath)) throw Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
        if (a.host && a.hostpath) throw Error("Can't have 'host' and 'hostpath' option");
        if (a.path && a.hostpath) throw Error("Can't have 'path' and 'hostpath' option");
        a.scheme && (b += a.scheme + ":");
        a.authority && (b += "//" + a.authority);
        a.host && (b += a.host);
        a.path &&
            (b += a.path);
        a.hostpath && (b += a.hostpath);
        a.query && (b += "?" + a.query);
        a.fragment && (b += "#" + a.fragment);
        return b
    };
    m.data = {};
    m.debug = ep;
    m.drawFullscreenQuad = Pl;
    m.drawQuadWithShader = La;
    m.drawTexture = function(a, b, c, d, e, f, g) {
        d = d || a.getCopyShader();
        a.constantTexSource.setValue(b);
        La(a, c, d, e, f, g)
    };
    m.events = Rf;
    m.extend = Hc;
    m.fw = pq;
    m.getTouchTargetCoords = Ij;
    m.gfx = hq;
    m.guid = Xl;
    m.http = wa;
    m.inherits = function(a, b) {
        var c = function() {},
            d = function(e, f, g, k, h, l, n, p) {
                b.call(this, e, f, g, k, h, l, n, p);
                a.call(this, e, f, g, k, h, l, n,
                    p)
            };
        d._super = b.prototype;
        c.prototype = b.prototype;
        d.prototype = new c;
        return d
    };
    m.input = nq;
    m.isDefined = bi;
    m.log = ai;
    m.makeArray = function(a) {
        return Array.prototype.slice.call(a)
    };
    m.math = N;
    m.now = Lb;
    m.path = ca;
    m.platform = Da;
    m.posteffect = iq;
    m.prefilterCubemap = function(a) {
        var b = a.device,
            c = a.sourceCubemap,
            d = a.method,
            e = a.samples,
            f = a.cpuSync;
        if (f && !c._levels[0]) console.error("ERROR: prefilter: cubemap must have _levels");
        else {
            var g = c.type,
                k = "rgbm" === g,
                h = Wa(b, F.fullscreenQuadVS, F.rgbmPS + F.prefilterCubemapPS.replace(/\$METHOD/g,
                    0 === d ? "cos" : "phong").replace(/\$NUMSAMPLES/g, e).replace(/\$textureCube/g, k ? "textureCubeRGBM" : "textureCube"), "prefilter" + d + e + k),
                l = Wa(b, F.fullscreenQuadVS, F.outputCubemapPS, "outputCubemap"),
                n = b.scope.resolve("source"),
                p = b.scope.resolve("params"),
                q = new X,
                r = c.width;
            e = c.format;
            var t = [
                    [], a.filteredFixed, a.filteredRgbm, a.filteredFixedRgbm
                ],
                u = 0 === d ? [.9, .85, .7, .4, .25, .15, .1] : [512, 128, 32, 8, 2, 1, 1],
                x = [64, 32, 16, 8, 4, 2, 1],
                v;
            var w = !1;
            f && (w = c._levels[0][0] instanceof HTMLImageElement);
            if ((6 === e || w) && f) {
                e = 7;
                var y = new V(b, {
                    cubemap: !0,
                    type: g,
                    format: e,
                    width: r,
                    height: r,
                    mipmaps: !1
                });
                y.name = "prefiltered-cube";
                for (v = 0; 6 > v; v++) {
                    var A = new sa(b, y, {
                        face: v,
                        depth: !1
                    });
                    q.x = v;
                    q.y = 0;
                    n.setValue(c);
                    p.setValue(q.data);
                    La(b, A, l);
                    eh(b, A, v)
                }
                c = y
            }
            if (128 < r) {
                var B = Math.round(Math.log2(r)) - Math.round(Math.log2(128));
                for (w = 0; w < B; w++) {
                    r = .5 * c.width;
                    var E = 0 === d ? 1 : Math.pow(2, Math.round(Math.log2(u[0]) + 2 * (B - w)));
                    y = new V(b, {
                        cubemap: !0,
                        type: g,
                        format: e,
                        width: r,
                        height: r,
                        mipmaps: !1
                    });
                    y.name = "prefiltered-cube";
                    for (v = 0; 6 > v; v++) A = new sa(b, y, {
                            face: v,
                            depth: !1
                        }),
                        q.x = v, q.y = E, q.z = r, q.w = k ? 3 : 0, n.setValue(c), p.setValue(q.data), La(b, A, l), w === B - 1 && f && eh(b, A, v);
                    c = y
                }
            }
            a.sourceCubemap = c;
            y = null;
            if (!k && a.filteredFixedRgbm)
                for (y = new V(b, {
                        cubemap: !0,
                        type: "rgbm",
                        format: 7,
                        width: r,
                        height: r,
                        mipmaps: !1
                    }), y.name = "prefiltered-cube", v = 0; 6 > v; v++) A = new sa(b, y, {
                    face: v,
                    depth: !1
                }), q.x = v, q.w = 2, n.setValue(c), p.setValue(q.data), La(b, A, l), eh(b, A, v);
            r = 0 === d ? 1 : 2048;
            A = 0 === d ? 0 : -1;
            t[A] = [];
            for (w = 0; 7 > w; w++)
                for (l = A; l < t.length; l++) null != t[l] && (t[l][w] = new V(b, {
                    cubemap: !0,
                    type: 2 > l ? g : "rgbm",
                    format: 2 >
                        l ? e : 7,
                    fixCubemapSeams: 1 === l || 3 === l,
                    width: x[w],
                    height: x[w],
                    mipmaps: !1
                }), t[l][w].name = "prefiltered-cube");
            for (l = A; l < t.length; l++)
                if (null != t[l])
                    if (1 < l && k) t[l] = t[l - 2];
                    else
                        for (w = 0; 7 > w; w++)
                            for (v = 0; 6 > v; v++) A = new sa(b, t[l][w], {
                                face: v,
                                depth: !1
                            }), q.x = v, q.y = 0 > l ? r : u[w], q.z = x[w], q.w = k ? 3 : l, n.setValue(0 === w ? c : 0 === d ? t[0][w - 1] : t[-1][w - 1]), p.setValue(q.data), La(b, A, h), f && eh(b, A, v);
            a.filtered = t[0];
            if (f && a.singleFilteredFixed) {
                c = [c].concat(a.filteredFixed);
                g = new V(b, {
                    cubemap: !0,
                    type: g,
                    fixCubemapSeams: !0,
                    format: e,
                    width: 128,
                    height: 128,
                    addressU: 1,
                    addressV: 1
                });
                g.name = "prefiltered-cube";
                for (w = 0; w < c.length; w++) g._levels[w] = c[w]._levels[0];
                g.upload();
                g._prefilteredMips = !0;
                a.singleFilteredFixed = g
            }
            if (f && a.singleFilteredFixedRgbm && a.filteredFixedRgbm) {
                c = [y].concat(a.filteredFixedRgbm);
                g = new V(b, {
                    cubemap: !0,
                    type: "rgbm",
                    fixCubemapSeams: !0,
                    format: 7,
                    width: 128,
                    height: 128,
                    addressU: 1,
                    addressV: 1
                });
                g.name = "prefiltered-cube";
                for (w = 0; w < c.length; w++) g._levels[w] = c[w]._levels[0];
                g.upload();
                g._prefilteredMips = !0;
                a.singleFilteredFixedRgbm =
                    g
            }
        }
    };
    m.programlib = qh;
    m.registerScript = Gl;
    m.reprojectTexture = function(a, b, c, d, e) {
        var f = void 0 !== d ? "prefilter" : "reproject",
            g = "decode" + on(b),
            k = "encode" + on(c),
            h = b.cubemap ? "sampleCubemap" : "sampleEquirect",
            l = c.cubemap ? "getDirectionCubemap" : "getDirectionEquirect";
        e = Wa(a, F.fullscreenQuadVS, "#define PROCESS_FUNC " + f + "\n#define DECODE_FUNC " + g + "\n#define ENCODE_FUNC " + k + "\n#define SOURCE_FUNC " + h + "\n#define TARGET_FUNC " + l + "\n#define NUM_SAMPLES " + (e || 1024) + "\n\n" + F.reprojectPS, f + g + k + h + l, null, a.webgl2 ? "" : "#extension GL_OES_standard_derivatives: enable\n");
        a.scope.resolve(b.cubemap ? "sourceCube" : "sourceTex").setValue(b);
        f = a.scope.resolve("params");
        g = new X;
        g.y = void 0 !== d ? d : 1;
        g.z = 1 - (b.fixCubemapSeams ? 1 / b.width : 0);
        g.w = 1 - (c.fixCubemapSeams ? 1 / c.width : 0);
        for (b = 0; b < (c.cubemap ? 6 : 1); b++) d = new sa(a, c, {
            face: b,
            depth: !1
        }), g.x = b, f.setValue(g.data), La(a, d, e)
    };
    m.revision = "ef8e593";
    m.scene = kq;
    m.script = vb;
    m.semanticToLocation = Pj;
    m.shFromCubemap = Nl;
    m.shaderChunks = F;
    m.shape = gq;
    m.string = vc;
    m.time = fq;
    m.type = $c;
    m.typedArrayIndexFormats = am;
    m.typedArrayIndexFormatsByteSize = [1, 2, 4];
    m.typedArrayToType = {
        Int8Array: 0,
        Uint8Array: 1,
        Int16Array: 2,
        Uint16Array: 3,
        Int32Array: 4,
        Uint32Array: 5,
        Float32Array: 6
    };
    m.typedArrayTypes = Fd;
    m.typedArrayTypesByteSize = sf;
    m.version = "1.37.0";
    Object.defineProperty(m, "__esModule", {
        value: !0
    })
});